// Code generated from MySQLParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // MySQLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

/*
 * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2.0,
 * as published by the Free Software Foundation.
 *
 * This program is also distributed with certain software (including
 * but not limited to OpenSSL) that is licensed under separate terms, as
 * designated in a particular file or component or in included license
 * documentation. The authors of MySQL hereby grant you an additional
 * permission to link the program and your derivative works with the
 * separately licensed software that they have included with MySQL.
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
 * the GNU General Public License, version 2.0, for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type MySQLParser struct {
	MySQLBaseRecognizer
}

var MySQLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func mysqlparserParserInit() {
	staticData := &MySQLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "'='", "':='", "'<=>'", "'>='", "'>'", "'<='", "'<'", "'!='",
		"'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "'~'", "'<<'", "'>>'", "'&&'",
		"'&'", "'^'", "'||'", "'|'", "'.'", "','", "';'", "':'", "'('", "')'",
		"'{'", "'}'", "'_'", "'->'", "'->>'", "'@'", "", "'@@'", "'\\N'", "'?'",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "'<>'",
	}
	staticData.SymbolicNames = []string{
		"", "ACCESSIBLE_SYMBOL", "ACCOUNT_SYMBOL", "ACTION_SYMBOL", "ADD_SYMBOL",
		"ADDDATE_SYMBOL", "AFTER_SYMBOL", "AGAINST_SYMBOL", "AGGREGATE_SYMBOL",
		"ALGORITHM_SYMBOL", "ALL_SYMBOL", "ALTER_SYMBOL", "ALWAYS_SYMBOL", "ANALYSE_SYMBOL",
		"ANALYZE_SYMBOL", "AND_SYMBOL", "ANY_SYMBOL", "AS_SYMBOL", "ASC_SYMBOL",
		"ASCII_SYMBOL", "ASENSITIVE_SYMBOL", "AT_SYMBOL", "AUTHORS_SYMBOL",
		"AUTOEXTEND_SIZE_SYMBOL", "AUTO_INCREMENT_SYMBOL", "AVG_ROW_LENGTH_SYMBOL",
		"AVG_SYMBOL", "BACKUP_SYMBOL", "BEFORE_SYMBOL", "BEGIN_SYMBOL", "BETWEEN_SYMBOL",
		"BIGINT_SYMBOL", "BINARY_SYMBOL", "BINLOG_SYMBOL", "BIN_NUM_SYMBOL",
		"BIT_AND_SYMBOL", "BIT_OR_SYMBOL", "BIT_SYMBOL", "BIT_XOR_SYMBOL", "BLOB_SYMBOL",
		"BLOCK_SYMBOL", "BOOLEAN_SYMBOL", "BOOL_SYMBOL", "BOTH_SYMBOL", "BTREE_SYMBOL",
		"BY_SYMBOL", "BYTE_SYMBOL", "CACHE_SYMBOL", "CALL_SYMBOL", "CASCADE_SYMBOL",
		"CASCADED_SYMBOL", "CASE_SYMBOL", "CAST_SYMBOL", "CATALOG_NAME_SYMBOL",
		"CHAIN_SYMBOL", "CHANGE_SYMBOL", "CHANGED_SYMBOL", "CHANNEL_SYMBOL",
		"CHARSET_SYMBOL", "CHARACTER_SYMBOL", "CHAR_SYMBOL", "CHECKSUM_SYMBOL",
		"CHECK_SYMBOL", "CIPHER_SYMBOL", "CLASS_ORIGIN_SYMBOL", "CLIENT_SYMBOL",
		"CLOSE_SYMBOL", "COALESCE_SYMBOL", "CODE_SYMBOL", "COLLATE_SYMBOL",
		"COLLATION_SYMBOL", "COLUMNS_SYMBOL", "COLUMN_SYMBOL", "COLUMN_NAME_SYMBOL",
		"COLUMN_FORMAT_SYMBOL", "COMMENT_SYMBOL", "COMMITTED_SYMBOL", "COMMIT_SYMBOL",
		"COMPACT_SYMBOL", "COMPLETION_SYMBOL", "COMPRESSED_SYMBOL", "COMPRESSION_SYMBOL",
		"CONCURRENT_SYMBOL", "CONDITION_SYMBOL", "CONNECTION_SYMBOL", "CONSISTENT_SYMBOL",
		"CONSTRAINT_SYMBOL", "CONSTRAINT_CATALOG_SYMBOL", "CONSTRAINT_NAME_SYMBOL",
		"CONSTRAINT_SCHEMA_SYMBOL", "CONTAINS_SYMBOL", "CONTEXT_SYMBOL", "CONTINUE_SYMBOL",
		"CONTRIBUTORS_SYMBOL", "CONVERT_SYMBOL", "COUNT_SYMBOL", "CPU_SYMBOL",
		"CREATE_SYMBOL", "CROSS_SYMBOL", "CUBE_SYMBOL", "CURDATE_SYMBOL", "CURRENT_SYMBOL",
		"CURRENT_DATE_SYMBOL", "CURRENT_TIME_SYMBOL", "CURRENT_TIMESTAMP_SYMBOL",
		"CURRENT_USER_SYMBOL", "CURSOR_SYMBOL", "CURSOR_NAME_SYMBOL", "CURTIME_SYMBOL",
		"DATABASE_SYMBOL", "DATABASES_SYMBOL", "DATAFILE_SYMBOL", "DATA_SYMBOL",
		"DATETIME_SYMBOL", "DATE_ADD_SYMBOL", "DATE_SUB_SYMBOL", "DATE_SYMBOL",
		"DAYOFMONTH_SYMBOL", "DAY_HOUR_SYMBOL", "DAY_MICROSECOND_SYMBOL", "DAY_MINUTE_SYMBOL",
		"DAY_SECOND_SYMBOL", "DAY_SYMBOL", "DEALLOCATE_SYMBOL", "DEC_SYMBOL",
		"DECIMAL_NUM_SYMBOL", "DECIMAL_SYMBOL", "DECLARE_SYMBOL", "DEFAULT_SYMBOL",
		"DEFAULT_AUTH_SYMBOL", "DEFINER_SYMBOL", "DELAYED_SYMBOL", "DELAY_KEY_WRITE_SYMBOL",
		"DELETE_SYMBOL", "DESC_SYMBOL", "DESCRIBE_SYMBOL", "DES_KEY_FILE_SYMBOL",
		"DETERMINISTIC_SYMBOL", "DIAGNOSTICS_SYMBOL", "DIRECTORY_SYMBOL", "DISABLE_SYMBOL",
		"DISCARD_SYMBOL", "DISK_SYMBOL", "DISTINCT_SYMBOL", "DISTINCTROW_SYMBOL",
		"DIV_SYMBOL", "DOUBLE_SYMBOL", "DO_SYMBOL", "DROP_SYMBOL", "DUAL_SYMBOL",
		"DUMPFILE_SYMBOL", "DUPLICATE_SYMBOL", "DYNAMIC_SYMBOL", "EACH_SYMBOL",
		"ELSE_SYMBOL", "ELSEIF_SYMBOL", "ENABLE_SYMBOL", "ENCLOSED_SYMBOL",
		"ENCRYPTION_SYMBOL", "END_SYMBOL", "ENDS_SYMBOL", "END_OF_INPUT_SYMBOL",
		"ENGINES_SYMBOL", "ENGINE_SYMBOL", "ENUM_SYMBOL", "ERROR_SYMBOL", "ERRORS_SYMBOL",
		"ESCAPED_SYMBOL", "ESCAPE_SYMBOL", "EVENTS_SYMBOL", "EVENT_SYMBOL",
		"EVERY_SYMBOL", "EXCHANGE_SYMBOL", "EXECUTE_SYMBOL", "EXISTS_SYMBOL",
		"EXIT_SYMBOL", "EXPANSION_SYMBOL", "EXPIRE_SYMBOL", "EXPLAIN_SYMBOL",
		"EXPORT_SYMBOL", "EXTENDED_SYMBOL", "EXTENT_SIZE_SYMBOL", "EXTRACT_SYMBOL",
		"FALSE_SYMBOL", "FAST_SYMBOL", "FAULTS_SYMBOL", "FETCH_SYMBOL", "FIELDS_SYMBOL",
		"FILE_SYMBOL", "FILE_BLOCK_SIZE_SYMBOL", "FILTER_SYMBOL", "FIRST_SYMBOL",
		"FIXED_SYMBOL", "FLOAT4_SYMBOL", "FLOAT8_SYMBOL", "FLOAT_SYMBOL", "FLUSH_SYMBOL",
		"FOLLOWS_SYMBOL", "FORCE_SYMBOL", "FOREIGN_SYMBOL", "FOR_SYMBOL", "FORMAT_SYMBOL",
		"FOUND_SYMBOL", "FROM_SYMBOL", "FULL_SYMBOL", "FULLTEXT_SYMBOL", "FUNCTION_SYMBOL",
		"GET_SYMBOL", "GENERAL_SYMBOL", "GENERATED_SYMBOL", "GROUP_REPLICATION_SYMBOL",
		"GEOMETRYCOLLECTION_SYMBOL", "GEOMETRY_SYMBOL", "GET_FORMAT_SYMBOL",
		"GLOBAL_SYMBOL", "GRANT_SYMBOL", "GRANTS_SYMBOL", "GROUP_SYMBOL", "GROUP_CONCAT_SYMBOL",
		"HANDLER_SYMBOL", "HASH_SYMBOL", "HAVING_SYMBOL", "HELP_SYMBOL", "HIGH_PRIORITY_SYMBOL",
		"HOST_SYMBOL", "HOSTS_SYMBOL", "HOUR_MICROSECOND_SYMBOL", "HOUR_MINUTE_SYMBOL",
		"HOUR_SECOND_SYMBOL", "HOUR_SYMBOL", "IDENTIFIED_SYMBOL", "IF_SYMBOL",
		"IGNORE_SYMBOL", "IGNORE_SERVER_IDS_SYMBOL", "IMPORT_SYMBOL", "INDEXES_SYMBOL",
		"INDEX_SYMBOL", "INFILE_SYMBOL", "INITIAL_SIZE_SYMBOL", "INNER_SYMBOL",
		"INOUT_SYMBOL", "INSENSITIVE_SYMBOL", "INSERT_SYMBOL", "INSERT_METHOD_SYMBOL",
		"INSTANCE_SYMBOL", "INSTALL_SYMBOL", "INTEGER_SYMBOL", "INTERVAL_SYMBOL",
		"INTO_SYMBOL", "INT_SYMBOL", "INVOKER_SYMBOL", "IN_SYMBOL", "IO_AFTER_GTIDS_SYMBOL",
		"IO_BEFORE_GTIDS_SYMBOL", "IO_THREAD_SYMBOL", "IO_SYMBOL", "IPC_SYMBOL",
		"IS_SYMBOL", "ISOLATION_SYMBOL", "ISSUER_SYMBOL", "ITERATE_SYMBOL",
		"JOIN_SYMBOL", "JSON_SYMBOL", "KEYS_SYMBOL", "KEY_BLOCK_SIZE_SYMBOL",
		"KEY_SYMBOL", "KILL_SYMBOL", "LANGUAGE_SYMBOL", "LAST_SYMBOL", "LEADING_SYMBOL",
		"LEAVES_SYMBOL", "LEAVE_SYMBOL", "LEFT_SYMBOL", "LESS_SYMBOL", "LEVEL_SYMBOL",
		"LIKE_SYMBOL", "LIMIT_SYMBOL", "LINEAR_SYMBOL", "LINES_SYMBOL", "LINESTRING_SYMBOL",
		"LIST_SYMBOL", "LOAD_SYMBOL", "LOCALTIME_SYMBOL", "LOCALTIMESTAMP_SYMBOL",
		"LOCAL_SYMBOL", "LOCATOR_SYMBOL", "LOCKS_SYMBOL", "LOCK_SYMBOL", "LOGFILE_SYMBOL",
		"LOGS_SYMBOL", "LONGBLOB_SYMBOL", "LONGTEXT_SYMBOL", "LONG_NUM_SYMBOL",
		"LONG_SYMBOL", "LOOP_SYMBOL", "LOW_PRIORITY_SYMBOL", "MASTER_AUTO_POSITION_SYMBOL",
		"MASTER_BIND_SYMBOL", "MASTER_CONNECT_RETRY_SYMBOL", "MASTER_DELAY_SYMBOL",
		"MASTER_HOST_SYMBOL", "MASTER_LOG_FILE_SYMBOL", "MASTER_LOG_POS_SYMBOL",
		"MASTER_PASSWORD_SYMBOL", "MASTER_PORT_SYMBOL", "MASTER_RETRY_COUNT_SYMBOL",
		"MASTER_SERVER_ID_SYMBOL", "MASTER_SSL_CAPATH_SYMBOL", "MASTER_SSL_CA_SYMBOL",
		"MASTER_SSL_CERT_SYMBOL", "MASTER_SSL_CIPHER_SYMBOL", "MASTER_SSL_CRL_SYMBOL",
		"MASTER_SSL_CRLPATH_SYMBOL", "MASTER_SSL_KEY_SYMBOL", "MASTER_SSL_SYMBOL",
		"MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL", "MASTER_SYMBOL", "MASTER_TLS_VERSION_SYMBOL",
		"MASTER_USER_SYMBOL", "MASTER_HEARTBEAT_PERIOD_SYMBOL", "MATCH_SYMBOL",
		"MAX_CONNECTIONS_PER_HOUR_SYMBOL", "MAX_QUERIES_PER_HOUR_SYMBOL", "MAX_ROWS_SYMBOL",
		"MAX_SIZE_SYMBOL", "MAX_STATEMENT_TIME_SYMBOL", "MAX_SYMBOL", "MAX_UPDATES_PER_HOUR_SYMBOL",
		"MAX_USER_CONNECTIONS_SYMBOL", "MAXVALUE_SYMBOL", "MEDIUMBLOB_SYMBOL",
		"MEDIUMINT_SYMBOL", "MEDIUMTEXT_SYMBOL", "MEDIUM_SYMBOL", "MEMORY_SYMBOL",
		"MERGE_SYMBOL", "MESSAGE_TEXT_SYMBOL", "MICROSECOND_SYMBOL", "MID_SYMBOL",
		"MIDDLEINT_SYMBOL", "MIGRATE_SYMBOL", "MINUTE_MICROSECOND_SYMBOL", "MINUTE_SECOND_SYMBOL",
		"MINUTE_SYMBOL", "MIN_ROWS_SYMBOL", "MIN_SYMBOL", "MODE_SYMBOL", "MODIFIES_SYMBOL",
		"MODIFY_SYMBOL", "MOD_SYMBOL", "MONTH_SYMBOL", "MULTILINESTRING_SYMBOL",
		"MULTIPOINT_SYMBOL", "MULTIPOLYGON_SYMBOL", "MUTEX_SYMBOL", "MYSQL_ERRNO_SYMBOL",
		"NAMES_SYMBOL", "NAME_SYMBOL", "NATIONAL_SYMBOL", "NATURAL_SYMBOL",
		"NCHAR_STRING_SYMBOL", "NCHAR_SYMBOL", "NDB_SYMBOL", "NDBCLUSTER_SYMBOL",
		"NEG_SYMBOL", "NEVER_SYMBOL", "NEW_SYMBOL", "NEXT_SYMBOL", "NODEGROUP_SYMBOL",
		"NONE_SYMBOL", "NONBLOCKING_SYMBOL", "NOT_SYMBOL", "NOW_SYMBOL", "NO_SYMBOL",
		"NO_WAIT_SYMBOL", "NO_WRITE_TO_BINLOG_SYMBOL", "NULL_SYMBOL", "NUMBER_SYMBOL",
		"NUMERIC_SYMBOL", "NVARCHAR_SYMBOL", "OFFLINE_SYMBOL", "OFFSET_SYMBOL",
		"OLD_PASSWORD_SYMBOL", "ON_SYMBOL", "ONE_SYMBOL", "ONLINE_SYMBOL", "ONLY_SYMBOL",
		"OPEN_SYMBOL", "OPTIMIZE_SYMBOL", "OPTIMIZER_COSTS_SYMBOL", "OPTIONS_SYMBOL",
		"OPTION_SYMBOL", "OPTIONALLY_SYMBOL", "ORDER_SYMBOL", "OR_SYMBOL", "OUTER_SYMBOL",
		"OUTFILE_SYMBOL", "OUT_SYMBOL", "OWNER_SYMBOL", "PACK_KEYS_SYMBOL",
		"PAGE_SYMBOL", "PARSER_SYMBOL", "PARTIAL_SYMBOL", "PARTITIONING_SYMBOL",
		"PARTITIONS_SYMBOL", "PARTITION_SYMBOL", "PASSWORD_SYMBOL", "PHASE_SYMBOL",
		"PLUGINS_SYMBOL", "PLUGIN_DIR_SYMBOL", "PLUGIN_SYMBOL", "POINT_SYMBOL",
		"POLYGON_SYMBOL", "PORT_SYMBOL", "POSITION_SYMBOL", "PRECEDES_SYMBOL",
		"PRECISION_SYMBOL", "PREPARE_SYMBOL", "PRESERVE_SYMBOL", "PREV_SYMBOL",
		"PRIMARY_SYMBOL", "PRIVILEGES_SYMBOL", "PROCEDURE_SYMBOL", "PROCESS_SYMBOL",
		"PROCESSLIST_SYMBOL", "PROFILE_SYMBOL", "PROFILES_SYMBOL", "PROXY_SYMBOL",
		"PURGE_SYMBOL", "QUARTER_SYMBOL", "QUERY_SYMBOL", "QUICK_SYMBOL", "RANGE_SYMBOL",
		"READS_SYMBOL", "READ_ONLY_SYMBOL", "READ_SYMBOL", "READ_WRITE_SYMBOL",
		"REAL_SYMBOL", "REBUILD_SYMBOL", "RECOVER_SYMBOL", "REDOFILE_SYMBOL",
		"REDO_BUFFER_SIZE_SYMBOL", "REDUNDANT_SYMBOL", "REFERENCES_SYMBOL",
		"REGEXP_SYMBOL", "RELAY_SYMBOL", "RELAYLOG_SYMBOL", "RELAY_LOG_FILE_SYMBOL",
		"RELAY_LOG_POS_SYMBOL", "RELAY_THREAD_SYMBOL", "RELEASE_SYMBOL", "RELOAD_SYMBOL",
		"REMOVE_SYMBOL", "RENAME_SYMBOL", "REORGANIZE_SYMBOL", "REPAIR_SYMBOL",
		"REPEATABLE_SYMBOL", "REPEAT_SYMBOL", "REPLACE_SYMBOL", "REPLICATION_SYMBOL",
		"REPLICATE_DO_DB_SYMBOL", "REPLICATE_IGNORE_DB_SYMBOL", "REPLICATE_DO_TABLE_SYMBOL",
		"REPLICATE_IGNORE_TABLE_SYMBOL", "REPLICATE_WILD_DO_TABLE_SYMBOL", "REPLICATE_WILD_IGNORE_TABLE_SYMBOL",
		"REPLICATE_REWRITE_DB_SYMBOL", "REQUIRE_SYMBOL", "RESET_SYMBOL", "RESIGNAL_SYMBOL",
		"RESTORE_SYMBOL", "RESTRICT_SYMBOL", "RESUME_SYMBOL", "RETURNED_SQLSTATE_SYMBOL",
		"RETURNS_SYMBOL", "RETURN_SYMBOL", "REVERSE_SYMBOL", "REVOKE_SYMBOL",
		"RIGHT_SYMBOL", "RLIKE_SYMBOL", "ROLLBACK_SYMBOL", "ROLLUP_SYMBOL",
		"ROTATE_SYMBOL", "ROUTINE_SYMBOL", "ROWS_SYMBOL", "ROW_COUNT_SYMBOL",
		"ROW_FORMAT_SYMBOL", "ROW_SYMBOL", "RTREE_SYMBOL", "SAVEPOINT_SYMBOL",
		"SCHEDULE_SYMBOL", "SCHEMA_SYMBOL", "SCHEMA_NAME_SYMBOL", "SCHEMAS_SYMBOL",
		"SECOND_MICROSECOND_SYMBOL", "SECOND_SYMBOL", "SECURITY_SYMBOL", "SELECT_SYMBOL",
		"SENSITIVE_SYMBOL", "SEPARATOR_SYMBOL", "SERIALIZABLE_SYMBOL", "SERIAL_SYMBOL",
		"SESSION_SYMBOL", "SERVER_SYMBOL", "SERVER_OPTIONS_SYMBOL", "SESSION_USER_SYMBOL",
		"SET_SYMBOL", "SET_VAR_SYMBOL", "SHARE_SYMBOL", "SHOW_SYMBOL", "SHUTDOWN_SYMBOL",
		"SIGNAL_SYMBOL", "SIGNED_SYMBOL", "SIMPLE_SYMBOL", "SLAVE_SYMBOL", "SLOW_SYMBOL",
		"SMALLINT_SYMBOL", "SNAPSHOT_SYMBOL", "SOME_SYMBOL", "SOCKET_SYMBOL",
		"SONAME_SYMBOL", "SOUNDS_SYMBOL", "SOURCE_SYMBOL", "SPATIAL_SYMBOL",
		"SPECIFIC_SYMBOL", "SQLEXCEPTION_SYMBOL", "SQLSTATE_SYMBOL", "SQLWARNING_SYMBOL",
		"SQL_AFTER_GTIDS_SYMBOL", "SQL_AFTER_MTS_GAPS_SYMBOL", "SQL_BEFORE_GTIDS_SYMBOL",
		"SQL_BIG_RESULT_SYMBOL", "SQL_BUFFER_RESULT_SYMBOL", "SQL_CACHE_SYMBOL",
		"SQL_CALC_FOUND_ROWS_SYMBOL", "SQL_NO_CACHE_SYMBOL", "SQL_SMALL_RESULT_SYMBOL",
		"SQL_SYMBOL", "SQL_THREAD_SYMBOL", "SSL_SYMBOL", "STACKED_SYMBOL", "STARTING_SYMBOL",
		"STARTS_SYMBOL", "START_SYMBOL", "STATS_AUTO_RECALC_SYMBOL", "STATS_PERSISTENT_SYMBOL",
		"STATS_SAMPLE_PAGES_SYMBOL", "STATUS_SYMBOL", "STDDEV_SAMP_SYMBOL",
		"STDDEV_SYMBOL", "STDDEV_POP_SYMBOL", "STD_SYMBOL", "STOP_SYMBOL", "STORAGE_SYMBOL",
		"STORED_SYMBOL", "STRAIGHT_JOIN_SYMBOL", "STRING_SYMBOL", "SUBCLASS_ORIGIN_SYMBOL",
		"SUBDATE_SYMBOL", "SUBJECT_SYMBOL", "SUBPARTITIONS_SYMBOL", "SUBPARTITION_SYMBOL",
		"SUBSTR_SYMBOL", "SUBSTRING_SYMBOL", "SUM_SYMBOL", "SUPER_SYMBOL", "SUSPEND_SYMBOL",
		"SWAPS_SYMBOL", "SWITCHES_SYMBOL", "SYSDATE_SYMBOL", "SYSTEM_USER_SYMBOL",
		"TABLES_SYMBOL", "TABLESPACE_SYMBOL", "TABLE_REF_PRIORITY_SYMBOL", "TABLE_SYMBOL",
		"TABLE_CHECKSUM_SYMBOL", "TABLE_NAME_SYMBOL", "TEMPORARY_SYMBOL", "TEMPTABLE_SYMBOL",
		"TERMINATED_SYMBOL", "TEXT_SYMBOL", "THAN_SYMBOL", "THEN_SYMBOL", "TIMESTAMP_SYMBOL",
		"TIMESTAMP_ADD_SYMBOL", "TIMESTAMP_DIFF_SYMBOL", "TIME_SYMBOL", "TINYBLOB_SYMBOL",
		"TINYINT_SYMBOL", "TINYTEXT_SYMBOL", "TO_SYMBOL", "TRAILING_SYMBOL",
		"TRANSACTION_SYMBOL", "TRIGGERS_SYMBOL", "TRIGGER_SYMBOL", "TRIM_SYMBOL",
		"TRUE_SYMBOL", "TRUNCATE_SYMBOL", "TYPES_SYMBOL", "TYPE_SYMBOL", "UDF_RETURNS_SYMBOL",
		"UNCOMMITTED_SYMBOL", "UNDEFINED_SYMBOL", "UNDOFILE_SYMBOL", "UNDO_BUFFER_SIZE_SYMBOL",
		"UNDO_SYMBOL", "UNICODE_SYMBOL", "UNINSTALL_SYMBOL", "UNION_SYMBOL",
		"UNIQUE_SYMBOL", "UNKNOWN_SYMBOL", "UNLOCK_SYMBOL", "UNSIGNED_SYMBOL",
		"UNTIL_SYMBOL", "UPDATE_SYMBOL", "UPGRADE_SYMBOL", "USAGE_SYMBOL", "USER_RESOURCES_SYMBOL",
		"USER_SYMBOL", "USE_FRM_SYMBOL", "USE_SYMBOL", "USING_SYMBOL", "UTC_DATE_SYMBOL",
		"UTC_TIMESTAMP_SYMBOL", "UTC_TIME_SYMBOL", "VALIDATION_SYMBOL", "VALUES_SYMBOL",
		"VALUE_SYMBOL", "VARBINARY_SYMBOL", "VARCHAR_SYMBOL", "VARCHARACTER_SYMBOL",
		"VARIABLES_SYMBOL", "VARIANCE_SYMBOL", "VARYING_SYMBOL", "VAR_POP_SYMBOL",
		"VAR_SAMP_SYMBOL", "VIEW_SYMBOL", "VIRTUAL_SYMBOL", "WAIT_SYMBOL", "WARNINGS_SYMBOL",
		"WEEK_SYMBOL", "WEIGHT_STRING_SYMBOL", "WHEN_SYMBOL", "WHERE_SYMBOL",
		"WHILE_SYMBOL", "WITH_SYMBOL", "WITHOUT_SYMBOL", "WORK_SYMBOL", "WRAPPER_SYMBOL",
		"WRITE_SYMBOL", "X509_SYMBOL", "XA_SYMBOL", "XID_SYMBOL", "XML_SYMBOL",
		"XOR_SYMBOL", "YEAR_MONTH_SYMBOL", "YEAR_SYMBOL", "ZEROFILL_SYMBOL",
		"PERSIST_SYMBOL", "ROLE_SYMBOL", "ADMIN_SYMBOL", "INVISIBLE_SYMBOL",
		"VISIBLE_SYMBOL", "EXCEPT_SYMBOL", "COMPONENT_SYMBOL", "RECURSIVE_SYMBOL",
		"JSON_OBJECTAGG_SYMBOL", "JSON_ARRAYAGG_SYMBOL", "OF_SYMBOL", "SKIP_SYMBOL",
		"LOCKED_SYMBOL", "NOWAIT_SYMBOL", "GROUPING_SYMBOL", "PERSIST_ONLY_SYMBOL",
		"HISTOGRAM_SYMBOL", "BUCKETS_SYMBOL", "REMOTE_SYMBOL", "CLONE_SYMBOL",
		"CUME_DIST_SYMBOL", "DENSE_RANK_SYMBOL", "EXCLUDE_SYMBOL", "FIRST_VALUE_SYMBOL",
		"FOLLOWING_SYMBOL", "GROUPS_SYMBOL", "LAG_SYMBOL", "LAST_VALUE_SYMBOL",
		"LEAD_SYMBOL", "NTH_VALUE_SYMBOL", "NTILE_SYMBOL", "NULLS_SYMBOL", "OTHERS_SYMBOL",
		"OVER_SYMBOL", "PERCENT_RANK_SYMBOL", "PRECEDING_SYMBOL", "RANK_SYMBOL",
		"RESPECT_SYMBOL", "ROW_NUMBER_SYMBOL", "TIES_SYMBOL", "UNBOUNDED_SYMBOL",
		"WINDOW_SYMBOL", "EMPTY_SYMBOL", "JSON_TABLE_SYMBOL", "NESTED_SYMBOL",
		"ORDINALITY_SYMBOL", "PATH_SYMBOL", "HISTORY_SYMBOL", "REUSE_SYMBOL",
		"SRID_SYMBOL", "THREAD_PRIORITY_SYMBOL", "RESOURCE_SYMBOL", "SYSTEM_SYMBOL",
		"VCPU_SYMBOL", "MASTER_PUBLIC_KEY_PATH_SYMBOL", "GET_MASTER_PUBLIC_KEY_SYMBOL",
		"RESTART_SYMBOL", "DEFINITION_SYMBOL", "DESCRIPTION_SYMBOL", "ORGANIZATION_SYMBOL",
		"REFERENCE_SYMBOL", "OPTIONAL_SYMBOL", "SECONDARY_SYMBOL", "SECONDARY_ENGINE_SYMBOL",
		"SECONDARY_LOAD_SYMBOL", "SECONDARY_UNLOAD_SYMBOL", "ACTIVE_SYMBOL",
		"INACTIVE_SYMBOL", "LATERAL_SYMBOL", "RETAIN_SYMBOL", "OLD_SYMBOL",
		"NETWORK_NAMESPACE_SYMBOL", "ENFORCED_SYMBOL", "ARRAY_SYMBOL", "OJ_SYMBOL",
		"MEMBER_SYMBOL", "RANDOM_SYMBOL", "MASTER_COMPRESSION_ALGORITHM_SYMBOL",
		"MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL", "PRIVILEGE_CHECKS_USER_SYMBOL",
		"MASTER_TLS_CIPHERSUITES_SYMBOL", "REQUIRE_ROW_FORMAT_SYMBOL", "PASSWORD_LOCK_TIME_SYMBOL",
		"FAILED_LOGIN_ATTEMPTS_SYMBOL", "REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL",
		"STREAM_SYMBOL", "OFF_SYMBOL", "NOT2_SYMBOL", "CONCAT_PIPES_SYMBOL",
		"INT_NUMBER", "LONG_NUMBER", "ULONGLONG_NUMBER", "EQUAL_OPERATOR", "ASSIGN_OPERATOR",
		"NULL_SAFE_EQUAL_OPERATOR", "GREATER_OR_EQUAL_OPERATOR", "GREATER_THAN_OPERATOR",
		"LESS_OR_EQUAL_OPERATOR", "LESS_THAN_OPERATOR", "NOT_EQUAL_OPERATOR",
		"PLUS_OPERATOR", "MINUS_OPERATOR", "MULT_OPERATOR", "DIV_OPERATOR",
		"MOD_OPERATOR", "LOGICAL_NOT_OPERATOR", "BITWISE_NOT_OPERATOR", "SHIFT_LEFT_OPERATOR",
		"SHIFT_RIGHT_OPERATOR", "LOGICAL_AND_OPERATOR", "BITWISE_AND_OPERATOR",
		"BITWISE_XOR_OPERATOR", "LOGICAL_OR_OPERATOR", "BITWISE_OR_OPERATOR",
		"DOT_SYMBOL", "COMMA_SYMBOL", "SEMICOLON_SYMBOL", "COLON_SYMBOL", "OPEN_PAR_SYMBOL",
		"CLOSE_PAR_SYMBOL", "OPEN_CURLY_SYMBOL", "CLOSE_CURLY_SYMBOL", "UNDERLINE_SYMBOL",
		"JSON_SEPARATOR_SYMBOL", "JSON_UNQUOTED_SEPARATOR_SYMBOL", "AT_SIGN_SYMBOL",
		"AT_TEXT_SUFFIX", "AT_AT_SIGN_SYMBOL", "NULL2_SYMBOL", "PARAM_MARKER",
		"HEX_NUMBER", "BIN_NUMBER", "DECIMAL_NUMBER", "FLOAT_NUMBER", "WHITESPACE",
		"INVALID_INPUT", "UNDERSCORE_CHARSET", "IDENTIFIER", "NCHAR_TEXT", "BACK_TICK_QUOTED_ID",
		"DOUBLE_QUOTED_TEXT", "SINGLE_QUOTED_TEXT", "VERSION_COMMENT_START",
		"MYSQL_COMMENT_START", "VERSION_COMMENT_END", "BLOCK_COMMENT", "POUND_COMMENT",
		"DASHDASH_COMMENT", "NOT_EQUAL2_OPERATOR",
	}
	staticData.RuleNames = []string{
		"query", "simpleStatement", "alterStatement", "alterDatabase", "alterEvent",
		"alterLogfileGroup", "alterLogfileGroupOptions", "alterLogfileGroupOption",
		"alterServer", "alterTable", "alterTableActions", "alterCommandList",
		"alterCommandsModifierList", "standaloneAlterCommands", "alterPartition",
		"alterList", "alterCommandsModifier", "alterListItem", "place", "restrict",
		"alterOrderList", "alterAlgorithmOption", "alterLockOption", "indexLockAndAlgorithm",
		"withValidation", "removePartitioning", "allOrPartitionNameList", "alterTablespace",
		"alterUndoTablespace", "undoTableSpaceOptions", "undoTableSpaceOption",
		"alterTablespaceOptions", "alterTablespaceOption", "changeTablespaceOption",
		"alterView", "viewTail", "viewSelect", "viewCheckOption", "createStatement",
		"createDatabase", "createDatabaseOption", "createTable", "tableElementList",
		"tableElement", "duplicateAsQueryExpression", "queryExpressionOrParens",
		"createRoutine", "createProcedure", "createFunction", "createUdf", "routineCreateOption",
		"routineAlterOptions", "routineOption", "createIndex", "indexNameAndType",
		"createIndexTarget", "createLogfileGroup", "logfileGroupOptions", "logfileGroupOption",
		"createServer", "serverOptions", "serverOption", "createTablespace",
		"createUndoTablespace", "tsDataFileName", "tsDataFile", "tablespaceOptions",
		"tablespaceOption", "tsOptionInitialSize", "tsOptionUndoRedoBufferSize",
		"tsOptionAutoextendSize", "tsOptionMaxSize", "tsOptionExtentSize", "tsOptionNodegroup",
		"tsOptionEngine", "tsOptionWait", "tsOptionComment", "tsOptionFileblockSize",
		"tsOptionEncryption", "createView", "viewReplaceOrAlgorithm", "viewAlgorithm",
		"viewSuid", "createTrigger", "triggerFollowsPrecedesClause", "createEvent",
		"createRole", "createSpatialReference", "srsAttribute", "dropStatement",
		"dropDatabase", "dropEvent", "dropFunction", "dropProcedure", "dropIndex",
		"dropLogfileGroup", "dropLogfileGroupOption", "dropServer", "dropTable",
		"dropTableSpace", "dropTrigger", "dropView", "dropRole", "dropSpatialReference",
		"dropUndoTablespace", "renameTableStatement", "renamePair", "truncateTableStatement",
		"importStatement", "callStatement", "deleteStatement", "partitionDelete",
		"deleteStatementOption", "doStatement", "handlerStatement", "handlerReadOrScan",
		"insertStatement", "insertLockOption", "insertFromConstructor", "fields",
		"insertValues", "insertQueryExpression", "valueList", "values", "valuesReference",
		"insertUpdateList", "loadStatement", "dataOrXml", "xmlRowsIdentifiedBy",
		"loadDataFileTail", "loadDataFileTargetList", "fieldOrVariableList",
		"replaceStatement", "selectStatement", "selectStatementWithInto", "queryExpression",
		"queryExpressionBody", "queryExpressionParens", "queryPrimary", "querySpecification",
		"subquery", "querySpecOption", "limitClause", "simpleLimitClause", "limitOptions",
		"limitOption", "intoClause", "procedureAnalyseClause", "havingClause",
		"windowClause", "windowDefinition", "windowSpec", "windowSpecDetails",
		"windowFrameClause", "windowFrameUnits", "windowFrameExtent", "windowFrameStart",
		"windowFrameBetween", "windowFrameBound", "windowFrameExclusion", "withClause",
		"commonTableExpression", "groupByClause", "olapOption", "orderClause",
		"direction", "fromClause", "tableReferenceList", "tableValueConstructor",
		"explicitTable", "rowValueExplicit", "selectOption", "lockingClauseList",
		"lockingClause", "lockStrengh", "lockedRowAction", "selectItemList",
		"selectItem", "selectAlias", "whereClause", "tableReference", "escapedTableReference",
		"joinedTable", "naturalJoinType", "innerJoinType", "outerJoinType",
		"tableFactor", "singleTable", "singleTableParens", "derivedTable", "tableReferenceListParens",
		"tableFunction", "columnsClause", "jtColumn", "onEmptyOrError", "onEmpty",
		"onError", "jtOnResponse", "unionOption", "tableAlias", "indexHintList",
		"indexHint", "indexHintType", "keyOrIndex", "constraintKeyType", "indexHintClause",
		"indexList", "indexListElement", "updateStatement", "transactionOrLockingStatement",
		"transactionStatement", "beginWork", "transactionCharacteristic", "savepointStatement",
		"lockStatement", "lockItem", "lockOption", "xaStatement", "xaConvert",
		"xid", "replicationStatement", "resetOption", "masterResetOptions",
		"replicationLoad", "changeMaster", "changeMasterOptions", "masterOption",
		"privilegeCheckDef", "tablePrimaryKeyCheckDef", "masterTlsCiphersuitesDef",
		"masterFileDef", "serverIdList", "changeReplication", "filterDefinition",
		"filterDbList", "filterTableList", "filterStringList", "filterWildDbTableString",
		"filterDbPairList", "slave", "slaveUntilOptions", "slaveConnectionOptions",
		"slaveThreadOptions", "slaveThreadOption", "groupReplication", "preparedStatement",
		"executeStatement", "executeVarList", "cloneStatement", "dataDirSSL",
		"ssl", "accountManagementStatement", "alterUser", "alterUserTail", "userFunction",
		"createUser", "createUserTail", "defaultRoleClause", "requireClause",
		"connectOptions", "accountLockPasswordExpireOptions", "dropUser", "grant",
		"grantTargetList", "grantOptions", "exceptRoleList", "withRoles", "grantAs",
		"versionedRequireClause", "renameUser", "revoke", "onTypeTo", "aclType",
		"roleOrPrivilegesList", "roleOrPrivilege", "grantIdentifier", "requireList",
		"requireListElement", "grantOption", "setRole", "roleList", "role",
		"tableAdministrationStatement", "histogram", "checkOption", "repairType",
		"installUninstallStatment", "setStatement", "startOptionValueList",
		"transactionCharacteristics", "transactionAccessMode", "isolationLevel",
		"optionValueListContinued", "optionValueNoOptionType", "optionValue",
		"setSystemVariable", "startOptionValueListFollowingOptionType", "optionValueFollowingOptionType",
		"setExprOrDefault", "showStatement", "showCommandType", "nonBlocking",
		"fromOrIn", "inDb", "profileType", "otherAdministrativeStatement", "keyCacheListOrParts",
		"keyCacheList", "assignToKeycache", "assignToKeycachePartition", "cacheKeyList",
		"keyUsageElement", "keyUsageList", "flushOption", "logType", "flushTables",
		"flushTablesOptions", "preloadTail", "preloadList", "preloadKeys", "adminPartition",
		"resourceGroupManagement", "createResourceGroup", "resourceGroupVcpuList",
		"vcpuNumOrRange", "resourceGroupPriority", "resourceGroupEnableDisable",
		"alterResourceGroup", "setResourceGroup", "threadIdList", "dropResourceGroup",
		"utilityStatement", "describeStatement", "explainStatement", "explainableStatement",
		"helpCommand", "useCommand", "restartServer", "expr", "boolPri", "compOp",
		"predicate", "predicateOperations", "bitExpr", "simpleExpr", "arrayCast",
		"jsonOperator", "sumExpr", "groupingOperation", "windowFunctionCall",
		"windowingClause", "leadLagInfo", "nullTreatment", "jsonFunction", "inSumExpr",
		"identListArg", "identList", "fulltextOptions", "runtimeFunctionCall",
		"geometryFunction", "timeFunctionParameters", "fractionalPrecision",
		"weightStringLevels", "weightStringLevelListItem", "dateTimeTtype",
		"trimFunction", "substringFunction", "functionCall", "udfExprList",
		"udfExpr", "variable", "userVariable", "systemVariable", "internalVariableName",
		"whenExpression", "thenExpression", "elseExpression", "castType", "exprList",
		"charset", "notRule", "not2Rule", "interval", "intervalTimeStamp", "exprListWithParentheses",
		"exprWithParentheses", "simpleExprWithParentheses", "orderList", "orderExpression",
		"groupList", "groupingExpression", "channel", "compoundStatement", "returnStatement",
		"ifStatement", "ifBody", "thenStatement", "compoundStatementList", "caseStatement",
		"elseStatement", "labeledBlock", "unlabeledBlock", "label", "beginEndBlock",
		"labeledControl", "unlabeledControl", "loopBlock", "whileDoBlock", "repeatUntilBlock",
		"spDeclarations", "spDeclaration", "variableDeclaration", "conditionDeclaration",
		"spCondition", "sqlstate", "handlerDeclaration", "handlerCondition",
		"cursorDeclaration", "iterateStatement", "leaveStatement", "getDiagnostics",
		"signalAllowedExpr", "statementInformationItem", "conditionInformationItem",
		"signalInformationItemName", "signalStatement", "resignalStatement",
		"signalInformationItem", "cursorOpen", "cursorClose", "cursorFetch",
		"schedule", "columnDefinition", "checkOrReferences", "checkConstraint",
		"constraintEnforcement", "tableConstraintDef", "constraintName", "fieldDefinition",
		"columnAttribute", "columnFormat", "storageMedia", "gcolAttribute",
		"references", "deleteOption", "keyList", "keyPart", "keyListWithExpression",
		"keyPartOrExpression", "keyListVariants", "indexType", "indexOption",
		"commonIndexOption", "visibility", "indexTypeClause", "fulltextIndexOption",
		"spatialIndexOption", "dataTypeDefinition", "dataType", "nchar", "realType",
		"fieldLength", "fieldOptions", "charsetWithOptBinary", "ascii", "unicode",
		"wsNumCodepoints", "typeDatetimePrecision", "charsetName", "collationName",
		"createTableOptions", "createTableOptionsSpaceSeparated", "createTableOption",
		"ternaryOption", "defaultCollation", "defaultEncryption", "defaultCharset",
		"partitionClause", "partitionTypeDef", "subPartitions", "partitionKeyAlgorithm",
		"partitionDefinitions", "partitionDefinition", "partitionValuesIn",
		"partitionOption", "subpartitionDefinition", "partitionValueItemListParen",
		"partitionValueItem", "definerClause", "ifExists", "ifNotExists", "procedureParameter",
		"functionParameter", "collate", "typeWithOptCollate", "schemaIdentifierPair",
		"viewRefList", "updateList", "updateElement", "charsetClause", "fieldsClause",
		"fieldTerm", "linesClause", "lineTerm", "userList", "createUserList",
		"alterUserList", "createUserEntry", "alterUserEntry", "retainCurrentPassword",
		"discardOldPassword", "replacePassword", "userIdentifierOrText", "user",
		"likeClause", "likeOrWhere", "onlineOption", "noWriteToBinLog", "usePartition",
		"fieldIdentifier", "columnName", "columnInternalRef", "columnInternalRefList",
		"columnRef", "insertIdentifier", "indexName", "indexRef", "tableWild",
		"schemaName", "schemaRef", "procedureName", "procedureRef", "functionName",
		"functionRef", "triggerName", "triggerRef", "viewName", "viewRef", "tablespaceName",
		"tablespaceRef", "logfileGroupName", "logfileGroupRef", "eventName",
		"eventRef", "udfName", "serverName", "serverRef", "engineRef", "tableName",
		"filterTableRef", "tableRefWithWildcard", "tableRef", "tableRefList",
		"tableAliasRefList", "parameterName", "labelIdentifier", "labelRef",
		"roleIdentifier", "roleRef", "pluginRef", "componentRef", "resourceGroupRef",
		"windowName", "pureIdentifier", "identifier", "identifierList", "identifierListWithParentheses",
		"qualifiedIdentifier", "simpleIdentifier", "dotIdentifier", "ulong_number",
		"real_ulong_number", "ulonglong_number", "real_ulonglong_number", "literal",
		"signedLiteral", "stringList", "textStringLiteral", "textString", "textStringHash",
		"textLiteral", "textStringNoLinebreak", "textStringLiteralList", "numLiteral",
		"boolLiteral", "nullLiteral", "temporalLiteral", "floatOptions", "standardFloatOptions",
		"precision", "textOrIdentifier", "lValueIdentifier", "roleIdentifierOrText",
		"sizeNumber", "parentheses", "equal", "optionType", "varIdentType",
		"setVarIdentType", "identifierKeyword", "identifierKeywordsAmbiguous1RolesAndLabels",
		"identifierKeywordsAmbiguous2Labels", "labelKeyword", "identifierKeywordsAmbiguous3Roles",
		"identifierKeywordsUnambiguous", "roleKeyword", "lValueKeyword", "identifierKeywordsAmbiguous4SystemVariables",
		"roleOrIdentifierKeyword", "roleOrLabelKeyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 806, 8417, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 2, 520, 7, 520, 2, 521, 7, 521, 2, 522, 7,
		522, 2, 523, 7, 523, 2, 524, 7, 524, 2, 525, 7, 525, 2, 526, 7, 526, 2,
		527, 7, 527, 2, 528, 7, 528, 2, 529, 7, 529, 2, 530, 7, 530, 2, 531, 7,
		531, 2, 532, 7, 532, 2, 533, 7, 533, 2, 534, 7, 534, 2, 535, 7, 535, 2,
		536, 7, 536, 2, 537, 7, 537, 2, 538, 7, 538, 2, 539, 7, 539, 2, 540, 7,
		540, 2, 541, 7, 541, 2, 542, 7, 542, 2, 543, 7, 543, 2, 544, 7, 544, 2,
		545, 7, 545, 2, 546, 7, 546, 2, 547, 7, 547, 2, 548, 7, 548, 2, 549, 7,
		549, 2, 550, 7, 550, 2, 551, 7, 551, 2, 552, 7, 552, 2, 553, 7, 553, 2,
		554, 7, 554, 2, 555, 7, 555, 2, 556, 7, 556, 2, 557, 7, 557, 2, 558, 7,
		558, 2, 559, 7, 559, 2, 560, 7, 560, 2, 561, 7, 561, 2, 562, 7, 562, 2,
		563, 7, 563, 2, 564, 7, 564, 2, 565, 7, 565, 2, 566, 7, 566, 2, 567, 7,
		567, 2, 568, 7, 568, 2, 569, 7, 569, 2, 570, 7, 570, 2, 571, 7, 571, 2,
		572, 7, 572, 2, 573, 7, 573, 2, 574, 7, 574, 2, 575, 7, 575, 2, 576, 7,
		576, 2, 577, 7, 577, 2, 578, 7, 578, 2, 579, 7, 579, 2, 580, 7, 580, 2,
		581, 7, 581, 2, 582, 7, 582, 2, 583, 7, 583, 2, 584, 7, 584, 2, 585, 7,
		585, 2, 586, 7, 586, 2, 587, 7, 587, 2, 588, 7, 588, 2, 589, 7, 589, 2,
		590, 7, 590, 2, 591, 7, 591, 2, 592, 7, 592, 2, 593, 7, 593, 2, 594, 7,
		594, 2, 595, 7, 595, 2, 596, 7, 596, 2, 597, 7, 597, 2, 598, 7, 598, 2,
		599, 7, 599, 2, 600, 7, 600, 2, 601, 7, 601, 2, 602, 7, 602, 2, 603, 7,
		603, 2, 604, 7, 604, 2, 605, 7, 605, 2, 606, 7, 606, 2, 607, 7, 607, 2,
		608, 7, 608, 2, 609, 7, 609, 1, 0, 1, 0, 1, 0, 3, 0, 1224, 8, 0, 1, 0,
		1, 0, 3, 0, 1228, 8, 0, 1, 0, 3, 0, 1231, 8, 0, 3, 0, 1233, 8, 0, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1269, 8, 1,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 1277, 8, 2, 1, 2, 1, 2, 1, 2,
		3, 2, 1282, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 1298, 8, 2, 1, 3, 1, 3, 1, 3, 4, 3,
		1303, 8, 3, 11, 3, 12, 3, 1304, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3, 3, 1312,
		8, 3, 1, 4, 3, 4, 1315, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 1322,
		8, 4, 1, 4, 1, 4, 1, 4, 3, 4, 1327, 8, 4, 1, 4, 3, 4, 1330, 8, 4, 1, 4,
		1, 4, 1, 4, 3, 4, 1335, 8, 4, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 1341, 8, 4,
		3, 4, 1343, 8, 4, 1, 4, 1, 4, 3, 4, 1347, 8, 4, 1, 4, 1, 4, 3, 4, 1351,
		8, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 1360, 8, 5, 1, 6,
		1, 6, 3, 6, 1364, 8, 6, 1, 6, 5, 6, 1367, 8, 6, 10, 6, 12, 6, 1370, 9,
		6, 1, 7, 1, 7, 1, 7, 3, 7, 1375, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 3,
		9, 1382, 8, 9, 1, 9, 1, 9, 3, 9, 1386, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1391,
		8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 1396, 8, 10, 1, 10, 1, 10, 1, 10, 1,
		10, 1, 10, 3, 10, 1403, 8, 10, 1, 10, 3, 10, 1406, 8, 10, 1, 11, 1, 11,
		1, 11, 1, 11, 3, 11, 1412, 8, 11, 1, 11, 3, 11, 1415, 8, 11, 1, 12, 1,
		12, 1, 12, 5, 12, 1420, 8, 12, 10, 12, 12, 12, 1423, 9, 12, 1, 13, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 1432, 8, 13, 1, 14, 1, 14, 1,
		14, 3, 14, 1437, 8, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1442, 8, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1450, 8, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 1456, 8, 14, 1, 14, 1, 14, 3, 14, 1460, 8, 14, 1, 14,
		1, 14, 1, 14, 3, 14, 1465, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 5,
		14, 1472, 8, 14, 10, 14, 12, 14, 1475, 9, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		1480, 8, 14, 1, 14, 1, 14, 5, 14, 1484, 8, 14, 10, 14, 12, 14, 1487, 9,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 1492, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 1501, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 1507, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14,
		1516, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 3, 14, 1530, 8, 14, 1, 15, 1, 15, 3, 15, 1534,
		8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1540, 8, 15, 5, 15, 1542, 8,
		15, 10, 15, 12, 15, 1545, 9, 15, 1, 16, 1, 16, 1, 16, 3, 16, 1550, 8, 16,
		1, 17, 1, 17, 3, 17, 1554, 8, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1559, 8,
		17, 1, 17, 3, 17, 1562, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1568,
		8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1574, 8, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 3, 17, 1580, 8, 17, 1, 17, 1, 17, 3, 17, 1584, 8, 17, 1, 17,
		1, 17, 1, 17, 3, 17, 1589, 8, 17, 1, 17, 1, 17, 3, 17, 1593, 8, 17, 1,
		17, 1, 17, 3, 17, 1597, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		3, 17, 1605, 8, 17, 3, 17, 1607, 8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1620, 8, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1628, 8, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 3, 17, 1636, 8, 17, 1, 17, 1, 17, 3, 17, 1640,
		8, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1669, 8, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 1685, 8, 17, 1, 17, 3, 17, 1688, 8, 17, 1,
		17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1697, 8, 17, 1, 18,
		1, 18, 1, 18, 3, 18, 1702, 8, 18, 1, 19, 1, 19, 1, 20, 1, 20, 3, 20, 1708,
		8, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1713, 8, 20, 5, 20, 1715, 8, 20, 10,
		20, 12, 20, 1718, 9, 20, 1, 21, 1, 21, 3, 21, 1722, 8, 21, 1, 21, 1, 21,
		3, 21, 1726, 8, 21, 1, 22, 1, 22, 3, 22, 1730, 8, 22, 1, 22, 1, 22, 3,
		22, 1734, 8, 22, 1, 23, 1, 23, 3, 23, 1738, 8, 23, 1, 23, 1, 23, 3, 23,
		1742, 8, 23, 3, 23, 1744, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1,
		25, 1, 25, 1, 26, 1, 26, 3, 26, 1755, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27,
		1, 27, 1, 27, 3, 27, 1763, 8, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 27, 3, 27, 1772, 8, 27, 1, 27, 5, 27, 1775, 8, 27, 10, 27, 12, 27,
		1778, 9, 27, 3, 27, 1780, 8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 1785, 8, 27,
		1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 1792, 8, 27, 1, 28, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 3, 28, 1800, 8, 28, 1, 29, 1, 29, 3, 29, 1804,
		8, 29, 1, 29, 5, 29, 1807, 8, 29, 10, 29, 12, 29, 1810, 9, 29, 1, 30, 1,
		30, 1, 31, 1, 31, 3, 31, 1816, 8, 31, 1, 31, 5, 31, 1819, 8, 31, 10, 31,
		12, 31, 1822, 9, 31, 1, 32, 1, 32, 3, 32, 1826, 8, 32, 1, 32, 1, 32, 1,
		32, 1, 32, 1, 32, 1, 32, 3, 32, 1834, 8, 32, 1, 33, 1, 33, 3, 33, 1838,
		8, 33, 1, 33, 1, 33, 1, 33, 3, 33, 1843, 8, 33, 1, 34, 3, 34, 1846, 8,
		34, 1, 34, 3, 34, 1849, 8, 34, 1, 34, 3, 34, 1852, 8, 34, 1, 34, 1, 34,
		1, 34, 1, 34, 1, 35, 3, 35, 1859, 8, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1,
		36, 3, 36, 1866, 8, 36, 1, 37, 1, 37, 3, 37, 1870, 8, 37, 1, 37, 1, 37,
		1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38,
		1894, 8, 38, 1, 39, 1, 39, 3, 39, 1898, 8, 39, 1, 39, 1, 39, 5, 39, 1902,
		8, 39, 10, 39, 12, 39, 1905, 9, 39, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40,
		1911, 8, 40, 1, 41, 3, 41, 1914, 8, 41, 1, 41, 1, 41, 3, 41, 1918, 8, 41,
		1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1925, 8, 41, 1, 41, 3, 41, 1928,
		8, 41, 1, 41, 3, 41, 1931, 8, 41, 1, 41, 3, 41, 1934, 8, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 1943, 8, 41, 1, 42, 1, 42,
		1, 42, 5, 42, 1948, 8, 42, 10, 42, 12, 42, 1951, 9, 42, 1, 43, 1, 43, 3,
		43, 1955, 8, 43, 1, 44, 3, 44, 1958, 8, 44, 1, 44, 3, 44, 1961, 8, 44,
		1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 1967, 8, 45, 1, 46, 1, 46, 1, 46, 1,
		46, 3, 46, 1973, 8, 46, 1, 46, 3, 46, 1976, 8, 46, 1, 46, 1, 46, 1, 47,
		3, 47, 1981, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 1989,
		8, 47, 10, 47, 12, 47, 1992, 9, 47, 3, 47, 1994, 8, 47, 1, 47, 1, 47, 5,
		47, 1998, 8, 47, 10, 47, 12, 47, 2001, 9, 47, 1, 47, 1, 47, 1, 48, 3, 48,
		2006, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 2014, 8,
		48, 10, 48, 12, 48, 2017, 9, 48, 3, 48, 2019, 8, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 5, 48, 2025, 8, 48, 10, 48, 12, 48, 2028, 9, 48, 1, 48, 1, 48, 1,
		49, 3, 49, 2033, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		1, 50, 1, 50, 3, 50, 2044, 8, 50, 1, 50, 3, 50, 2047, 8, 50, 1, 51, 4,
		51, 2050, 8, 51, 11, 51, 12, 51, 2051, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52,
		1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1,
		52, 1, 52, 3, 52, 2071, 8, 52, 1, 53, 3, 53, 2074, 8, 53, 1, 53, 3, 53,
		2077, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 2083, 8, 53, 1, 53, 3,
		53, 2086, 8, 53, 3, 53, 2088, 8, 53, 1, 53, 1, 53, 5, 53, 2092, 8, 53,
		10, 53, 12, 53, 2095, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 5, 53,
		2102, 8, 53, 10, 53, 12, 53, 2105, 9, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1,
		53, 5, 53, 2112, 8, 53, 10, 53, 12, 53, 2115, 9, 53, 3, 53, 2117, 8, 53,
		1, 53, 3, 53, 2120, 8, 53, 1, 54, 1, 54, 1, 54, 3, 54, 2125, 8, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 3, 54, 2131, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55,
		1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 2144, 8, 56, 1,
		57, 1, 57, 3, 57, 2148, 8, 57, 1, 57, 5, 57, 2151, 8, 57, 10, 57, 12, 57,
		2154, 9, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 2162, 8,
		58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 5, 60, 2177, 8, 60, 10, 60, 12, 60, 2180, 9, 60, 1,
		60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 2198, 8, 61, 1, 62, 1, 62, 1,
		62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 2207, 8, 62, 1, 62, 3, 62, 2210,
		8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2218, 8, 63, 1,
		64, 1, 64, 1, 64, 3, 64, 2223, 8, 64, 1, 64, 1, 64, 3, 64, 2227, 8, 64,
		1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 3, 66, 2234, 8, 66, 1, 66, 5, 66, 2237,
		8, 66, 10, 66, 12, 66, 2240, 9, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67,
		1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2254, 8, 67, 1,
		68, 1, 68, 3, 68, 2258, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 3, 69, 2264,
		8, 69, 1, 69, 1, 69, 1, 70, 1, 70, 3, 70, 2270, 8, 70, 1, 70, 1, 70, 1,
		71, 1, 71, 3, 71, 2276, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 3, 72, 2282,
		8, 72, 1, 72, 1, 72, 1, 73, 1, 73, 3, 73, 2288, 8, 73, 1, 73, 1, 73, 1,
		74, 3, 74, 2293, 8, 74, 1, 74, 1, 74, 3, 74, 2297, 8, 74, 1, 74, 1, 74,
		1, 75, 1, 75, 1, 76, 1, 76, 3, 76, 2305, 8, 76, 1, 76, 1, 76, 1, 77, 1,
		77, 3, 77, 2311, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 2317, 8, 78,
		1, 78, 1, 78, 1, 79, 3, 79, 2322, 8, 79, 1, 79, 3, 79, 2325, 8, 79, 1,
		79, 3, 79, 2328, 8, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
		3, 80, 2337, 8, 80, 1, 80, 3, 80, 2340, 8, 80, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 3, 83, 2351, 8, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 2363, 8,
		83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 3, 85, 2372, 8, 85,
		1, 85, 1, 85, 3, 85, 2376, 8, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1,
		85, 1, 85, 3, 85, 2385, 8, 85, 1, 85, 3, 85, 2388, 8, 85, 1, 85, 1, 85,
		1, 85, 1, 85, 3, 85, 2394, 8, 85, 3, 85, 2396, 8, 85, 1, 85, 1, 85, 3,
		85, 2400, 8, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 2407, 8, 86,
		1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 2418,
		8, 87, 10, 87, 12, 87, 2421, 9, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87,
		2427, 8, 87, 1, 87, 1, 87, 5, 87, 2431, 8, 87, 10, 87, 12, 87, 2434, 9,
		87, 3, 87, 2436, 8, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88,
		1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 2453, 8,
		88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 2473, 8,
		89, 1, 90, 1, 90, 3, 90, 2477, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 3, 91,
		2483, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 3, 92, 2489, 8, 92, 1, 92, 1,
		92, 1, 93, 1, 93, 3, 93, 2495, 8, 93, 1, 93, 1, 93, 1, 94, 3, 94, 2500,
		8, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2507, 8, 94, 1, 95, 1,
		95, 1, 95, 1, 95, 1, 95, 3, 95, 2514, 8, 95, 1, 95, 5, 95, 2517, 8, 95,
		10, 95, 12, 95, 2520, 9, 95, 3, 95, 2522, 8, 95, 1, 96, 1, 96, 3, 96, 2526,
		8, 96, 1, 97, 1, 97, 3, 97, 2530, 8, 97, 1, 97, 1, 97, 1, 98, 3, 98, 2535,
		8, 98, 1, 98, 1, 98, 3, 98, 2539, 8, 98, 1, 98, 1, 98, 3, 98, 2543, 8,
		98, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2549, 8, 99, 1, 99, 5, 99, 2552,
		8, 99, 10, 99, 12, 99, 2555, 9, 99, 3, 99, 2557, 8, 99, 1, 100, 1, 100,
		3, 100, 2561, 8, 100, 1, 100, 1, 100, 1, 101, 1, 101, 3, 101, 2567, 8,
		101, 1, 101, 1, 101, 3, 101, 2571, 8, 101, 1, 102, 1, 102, 3, 102, 2575,
		8, 102, 1, 102, 1, 102, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 2583, 8,
		103, 1, 103, 1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 2591, 8, 104,
		1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 5, 105, 2598, 8, 105, 10, 105,
		12, 105, 2601, 9, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107,
		3, 107, 2609, 8, 107, 1, 107, 1, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 2622, 8, 109, 1, 109, 3, 109,
		2625, 8, 109, 1, 110, 1, 110, 3, 110, 2629, 8, 110, 1, 110, 1, 110, 5,
		110, 2633, 8, 110, 10, 110, 12, 110, 2636, 9, 110, 1, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 3, 110, 2643, 8, 110, 1, 110, 1, 110, 1, 110, 3, 110, 2648,
		8, 110, 1, 110, 3, 110, 2651, 8, 110, 1, 110, 3, 110, 2654, 8, 110, 1,
		110, 3, 110, 2657, 8, 110, 1, 110, 3, 110, 2660, 8, 110, 3, 110, 2662,
		8, 110, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 2668, 8, 110, 3, 110, 2670,
		8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112,
		1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 3, 113, 2685, 8, 113, 1, 114, 1,
		114, 1, 114, 1, 114, 3, 114, 2691, 8, 114, 1, 114, 1, 114, 1, 114, 1, 114,
		1, 114, 3, 114, 2698, 8, 114, 1, 114, 3, 114, 2701, 8, 114, 3, 114, 2703,
		8, 114, 3, 114, 2705, 8, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 115, 1, 115, 3, 115, 2715, 8, 115, 3, 115, 2717, 8, 115, 1, 116,
		1, 116, 3, 116, 2721, 8, 116, 1, 116, 3, 116, 2724, 8, 116, 1, 116, 3,
		116, 2727, 8, 116, 1, 116, 1, 116, 3, 116, 2731, 8, 116, 1, 116, 1, 116,
		1, 116, 3, 116, 2736, 8, 116, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 2742,
		8, 116, 1, 116, 3, 116, 2745, 8, 116, 1, 116, 3, 116, 2748, 8, 116, 1,
		117, 1, 117, 1, 118, 1, 118, 3, 118, 2754, 8, 118, 1, 118, 3, 118, 2757,
		8, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 5, 119, 2764, 8, 119, 10,
		119, 12, 119, 2767, 9, 119, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1,
		121, 3, 121, 2775, 8, 121, 1, 121, 1, 121, 3, 121, 2779, 8, 121, 1, 122,
		1, 122, 3, 122, 2783, 8, 122, 1, 122, 1, 122, 1, 122, 1, 122, 3, 122, 2789,
		8, 122, 1, 122, 5, 122, 2792, 8, 122, 10, 122, 12, 122, 2795, 9, 122, 1,
		123, 1, 123, 3, 123, 2799, 8, 123, 1, 123, 1, 123, 1, 123, 3, 123, 2804,
		8, 123, 5, 123, 2806, 8, 123, 10, 123, 12, 123, 2809, 9, 123, 1, 124, 1,
		124, 1, 124, 3, 124, 2814, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125,
		1, 125, 1, 126, 1, 126, 1, 126, 3, 126, 2825, 8, 126, 1, 126, 3, 126, 2828,
		8, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2833, 8, 126, 1, 126, 1, 126, 1,
		126, 1, 126, 3, 126, 2839, 8, 126, 1, 126, 3, 126, 2842, 8, 126, 1, 126,
		3, 126, 2845, 8, 126, 1, 126, 3, 126, 2848, 8, 126, 1, 126, 3, 126, 2851,
		8, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128,
		1, 128, 1, 129, 1, 129, 1, 129, 3, 129, 2865, 8, 129, 1, 129, 3, 129, 2868,
		8, 129, 1, 129, 1, 129, 3, 129, 2872, 8, 129, 1, 130, 1, 130, 3, 130, 2876,
		8, 130, 1, 130, 1, 130, 1, 131, 1, 131, 3, 131, 2882, 8, 131, 1, 131, 1,
		131, 1, 131, 3, 131, 2887, 8, 131, 5, 131, 2889, 8, 131, 10, 131, 12, 131,
		2892, 9, 131, 1, 132, 1, 132, 3, 132, 2896, 8, 132, 1, 132, 3, 132, 2899,
		8, 132, 1, 132, 1, 132, 3, 132, 2903, 8, 132, 1, 132, 1, 132, 1, 132, 1,
		132, 3, 132, 2909, 8, 132, 1, 133, 1, 133, 3, 133, 2913, 8, 133, 1, 133,
		1, 133, 3, 133, 2917, 8, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 1, 134, 3, 134, 2926, 8, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2931,
		8, 134, 1, 135, 1, 135, 3, 135, 2935, 8, 135, 1, 135, 1, 135, 3, 135, 2939,
		8, 135, 1, 135, 3, 135, 2942, 8, 135, 1, 135, 1, 135, 3, 135, 2946, 8,
		135, 1, 135, 3, 135, 2949, 8, 135, 3, 135, 2951, 8, 135, 1, 135, 1, 135,
		3, 135, 2955, 8, 135, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 2961, 8,
		136, 1, 136, 1, 136, 3, 136, 2965, 8, 136, 3, 136, 2967, 8, 136, 1, 136,
		1, 136, 3, 136, 2971, 8, 136, 1, 136, 1, 136, 3, 136, 2975, 8, 136, 5,
		136, 2977, 8, 136, 10, 136, 12, 136, 2980, 9, 136, 1, 137, 1, 137, 1, 137,
		1, 137, 3, 137, 2986, 8, 137, 3, 137, 2988, 8, 137, 1, 137, 1, 137, 1,
		138, 1, 138, 1, 138, 1, 138, 1, 138, 3, 138, 2997, 8, 138, 1, 139, 1, 139,
		5, 139, 3001, 8, 139, 10, 139, 12, 139, 3004, 9, 139, 1, 139, 1, 139, 3,
		139, 3008, 8, 139, 1, 139, 3, 139, 3011, 8, 139, 1, 139, 3, 139, 3014,
		8, 139, 1, 139, 3, 139, 3017, 8, 139, 1, 139, 3, 139, 3020, 8, 139, 1,
		139, 1, 139, 3, 139, 3024, 8, 139, 1, 140, 1, 140, 1, 141, 1, 141, 1, 142,
		1, 142, 1, 142, 1, 143, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 3, 144,
		3039, 8, 144, 1, 145, 1, 145, 3, 145, 3043, 8, 145, 1, 146, 1, 146, 1,
		146, 1, 146, 3, 146, 3049, 8, 146, 1, 146, 3, 146, 3052, 8, 146, 1, 146,
		3, 146, 3055, 8, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 3061, 8,
		146, 1, 146, 1, 146, 1, 146, 3, 146, 3066, 8, 146, 5, 146, 3068, 8, 146,
		10, 146, 12, 146, 3071, 9, 146, 3, 146, 3073, 8, 146, 1, 147, 1, 147, 1,
		147, 1, 147, 1, 147, 1, 147, 3, 147, 3081, 8, 147, 3, 147, 3083, 8, 147,
		1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 1, 149, 1, 149,
		5, 149, 3094, 8, 149, 10, 149, 12, 149, 3097, 9, 149, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 151, 1, 151, 1, 151, 1, 151, 1, 152, 3, 152, 3108, 8, 152,
		1, 152, 1, 152, 1, 152, 3, 152, 3113, 8, 152, 1, 152, 3, 152, 3116, 8,
		152, 1, 152, 3, 152, 3119, 8, 152, 1, 153, 1, 153, 1, 153, 3, 153, 3124,
		8, 153, 1, 154, 1, 154, 1, 155, 1, 155, 3, 155, 3130, 8, 155, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1,
		156, 1, 156, 1, 156, 1, 156, 3, 156, 3146, 8, 156, 1, 157, 1, 157, 1, 157,
		1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158,
		1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 3166, 8, 158, 1,
		159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 1, 159, 3, 159, 3175, 8, 159,
		1, 160, 1, 160, 3, 160, 3179, 8, 160, 1, 160, 1, 160, 1, 160, 5, 160, 3184,
		8, 160, 10, 160, 12, 160, 3187, 9, 160, 1, 161, 1, 161, 3, 161, 3191, 8,
		161, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 1, 162, 1, 162, 3, 162, 3200,
		8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 3207, 8, 163, 1,
		164, 1, 164, 1, 164, 1, 164, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 3,
		166, 3218, 8, 166, 1, 167, 1, 167, 1, 167, 5, 167, 3223, 8, 167, 10, 167,
		12, 167, 3226, 9, 167, 1, 168, 1, 168, 1, 168, 1, 168, 5, 168, 3232, 8,
		168, 10, 168, 12, 168, 3235, 9, 168, 1, 169, 1, 169, 1, 169, 1, 170, 1,
		170, 1, 170, 3, 170, 3243, 8, 170, 1, 170, 1, 170, 1, 171, 1, 171, 1, 171,
		1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 3255, 8, 171, 1, 172, 4,
		172, 3258, 8, 172, 11, 172, 12, 172, 3259, 1, 173, 1, 173, 1, 173, 1, 173,
		1, 173, 3, 173, 3267, 8, 173, 1, 173, 1, 173, 3, 173, 3271, 8, 173, 1,
		173, 1, 173, 1, 173, 1, 173, 3, 173, 3277, 8, 173, 1, 174, 1, 174, 1, 174,
		3, 174, 3282, 8, 174, 1, 175, 1, 175, 1, 175, 3, 175, 3287, 8, 175, 1,
		176, 1, 176, 3, 176, 3291, 8, 176, 1, 176, 1, 176, 5, 176, 3295, 8, 176,
		10, 176, 12, 176, 3298, 9, 176, 1, 177, 1, 177, 1, 177, 3, 177, 3303, 8,
		177, 3, 177, 3305, 8, 177, 1, 178, 3, 178, 3308, 8, 178, 1, 178, 1, 178,
		3, 178, 3312, 8, 178, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 1,
		180, 1, 180, 3, 180, 3322, 8, 180, 1, 180, 1, 180, 1, 180, 3, 180, 3327,
		8, 180, 1, 180, 5, 180, 3330, 8, 180, 10, 180, 12, 180, 3333, 9, 180, 1,
		181, 1, 181, 5, 181, 3337, 8, 181, 10, 181, 12, 181, 3340, 9, 181, 1, 182,
		1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 3348, 8, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 3356, 8, 182, 1, 182, 1, 182,
		1, 182, 3, 182, 3361, 8, 182, 1, 183, 1, 183, 3, 183, 3365, 8, 183, 1,
		183, 1, 183, 1, 183, 1, 183, 3, 183, 3371, 8, 183, 1, 183, 3, 183, 3374,
		8, 183, 1, 184, 3, 184, 3377, 8, 184, 1, 184, 1, 184, 3, 184, 3381, 8,
		184, 1, 185, 1, 185, 3, 185, 3385, 8, 185, 1, 185, 1, 185, 1, 186, 1, 186,
		1, 186, 1, 186, 1, 186, 1, 186, 3, 186, 3395, 8, 186, 1, 187, 1, 187, 3,
		187, 3399, 8, 187, 1, 187, 3, 187, 3402, 8, 187, 1, 187, 3, 187, 3405,
		8, 187, 1, 188, 1, 188, 1, 188, 3, 188, 3410, 8, 188, 1, 188, 1, 188, 1,
		189, 1, 189, 3, 189, 3416, 8, 189, 1, 189, 1, 189, 3, 189, 3420, 8, 189,
		1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 3426, 8, 189, 1, 189, 3, 189, 3429,
		8, 189, 3, 189, 3431, 8, 189, 1, 190, 1, 190, 1, 190, 3, 190, 3436, 8,
		190, 1, 190, 1, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1,
		191, 1, 191, 3, 191, 3448, 8, 191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192,
		5, 192, 3455, 8, 192, 10, 192, 12, 192, 3458, 9, 192, 1, 192, 1, 192, 1,
		193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 3470,
		8, 193, 1, 193, 3, 193, 3473, 8, 193, 1, 193, 1, 193, 1, 193, 3, 193, 3478,
		8, 193, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 3485, 8, 193, 1,
		194, 1, 194, 3, 194, 3489, 8, 194, 1, 194, 1, 194, 3, 194, 3493, 8, 194,
		3, 194, 3495, 8, 194, 1, 195, 1, 195, 1, 195, 1, 195, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 197, 1, 197, 1, 197, 1, 197, 3, 197, 3509, 8, 197, 1, 198,
		1, 198, 1, 199, 1, 199, 1, 199, 3, 199, 3516, 8, 199, 1, 199, 1, 199, 1,
		200, 1, 200, 1, 200, 5, 200, 3523, 8, 200, 10, 200, 12, 200, 3526, 9, 200,
		1, 201, 1, 201, 1, 201, 3, 201, 3531, 8, 201, 1, 201, 1, 201, 1, 201, 1,
		201, 1, 201, 1, 201, 1, 201, 3, 201, 3540, 8, 201, 1, 201, 1, 201, 3, 201,
		3544, 8, 201, 1, 201, 1, 201, 3, 201, 3548, 8, 201, 1, 202, 1, 202, 1,
		203, 1, 203, 1, 204, 1, 204, 1, 204, 1, 204, 3, 204, 3558, 8, 204, 3, 204,
		3560, 8, 204, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 3568,
		8, 205, 1, 206, 1, 206, 1, 206, 5, 206, 3573, 8, 206, 10, 206, 12, 206,
		3576, 9, 206, 1, 207, 1, 207, 3, 207, 3580, 8, 207, 1, 208, 1, 208, 3,
		208, 3584, 8, 208, 1, 208, 1, 208, 3, 208, 3588, 8, 208, 1, 208, 3, 208,
		3591, 8, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 3597, 8, 208, 1,
		208, 3, 208, 3600, 8, 208, 1, 208, 3, 208, 3603, 8, 208, 1, 209, 1, 209,
		1, 209, 1, 209, 3, 209, 3609, 8, 209, 1, 210, 1, 210, 1, 210, 5, 210, 3614,
		8, 210, 10, 210, 12, 210, 3617, 9, 210, 1, 210, 1, 210, 3, 210, 3621, 8,
		210, 1, 210, 1, 210, 3, 210, 3625, 8, 210, 1, 210, 3, 210, 3628, 8, 210,
		1, 210, 3, 210, 3631, 8, 210, 1, 210, 3, 210, 3634, 8, 210, 3, 210, 3636,
		8, 210, 1, 211, 1, 211, 3, 211, 3640, 8, 211, 1, 212, 1, 212, 1, 212, 1,
		212, 1, 212, 1, 212, 3, 212, 3648, 8, 212, 1, 213, 1, 213, 1, 213, 1, 213,
		3, 213, 3654, 8, 213, 1, 213, 1, 213, 3, 213, 3658, 8, 213, 1, 213, 1,
		213, 1, 213, 3, 213, 3663, 8, 213, 1, 213, 3, 213, 3666, 8, 213, 1, 213,
		3, 213, 3669, 8, 213, 1, 213, 3, 213, 3672, 8, 213, 3, 213, 3674, 8, 213,
		1, 213, 1, 213, 1, 213, 3, 213, 3679, 8, 213, 1, 214, 1, 214, 1, 214, 1,
		214, 1, 214, 5, 214, 3686, 8, 214, 10, 214, 12, 214, 3689, 9, 214, 1, 214,
		1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214,
		3, 214, 3701, 8, 214, 3, 214, 3703, 8, 214, 1, 215, 1, 215, 3, 215, 3707,
		8, 215, 1, 215, 1, 215, 1, 216, 1, 216, 3, 216, 3713, 8, 216, 1, 216, 3,
		216, 3716, 8, 216, 1, 216, 3, 216, 3719, 8, 216, 1, 217, 1, 217, 1, 217,
		1, 217, 3, 217, 3725, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3,
		217, 3732, 8, 217, 3, 217, 3734, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217,
		1, 217, 1, 217, 3, 217, 3742, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3,
		217, 3748, 8, 217, 1, 218, 1, 218, 1, 218, 3, 218, 3753, 8, 218, 1, 218,
		3, 218, 3756, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 3, 219, 3763,
		8, 219, 3, 219, 3765, 8, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1,
		220, 1, 220, 3, 220, 3774, 8, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220,
		5, 220, 3781, 8, 220, 10, 220, 12, 220, 3784, 9, 220, 1, 220, 1, 220, 1,
		220, 1, 220, 1, 220, 1, 220, 3, 220, 3792, 8, 220, 1, 220, 1, 220, 1, 220,
		1, 220, 1, 220, 1, 220, 3, 220, 3800, 8, 220, 1, 221, 1, 221, 3, 221, 3804,
		8, 221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 221, 3, 221, 3811, 8, 221, 1,
		221, 3, 221, 3814, 8, 221, 3, 221, 3816, 8, 221, 1, 222, 1, 222, 1, 222,
		1, 222, 1, 222, 1, 222, 3, 222, 3824, 8, 222, 1, 223, 1, 223, 1, 223, 1,
		223, 3, 223, 3830, 8, 223, 1, 223, 1, 223, 1, 223, 1, 224, 1, 224, 1, 224,
		1, 224, 1, 224, 3, 224, 3840, 8, 224, 1, 225, 1, 225, 1, 225, 5, 225, 3845,
		8, 225, 10, 225, 12, 225, 3848, 9, 225, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226,
		1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 3, 226, 3941, 8, 226, 1,
		227, 1, 227, 3, 227, 3945, 8, 227, 1, 228, 1, 228, 1, 229, 1, 229, 3, 229,
		3951, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1, 230, 1,
		230, 1, 230, 1, 230, 1, 230, 1, 230, 3, 230, 3965, 8, 230, 1, 231, 1, 231,
		1, 231, 1, 231, 5, 231, 3971, 8, 231, 10, 231, 12, 231, 3974, 9, 231, 3,
		231, 3976, 8, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1, 232, 1, 232,
		1, 232, 5, 232, 3986, 8, 232, 10, 232, 12, 232, 3989, 9, 232, 1, 232, 1,
		232, 3, 232, 3993, 8, 232, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 3999,
		8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4006, 8, 233, 1,
		233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4013, 8, 233, 1, 233, 1, 233,
		1, 233, 1, 233, 1, 233, 3, 233, 4020, 8, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 1, 233, 3, 233, 4027, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233,
		3, 233, 4034, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4041,
		8, 233, 1, 233, 3, 233, 4044, 8, 233, 1, 234, 1, 234, 1, 234, 5, 234, 4049,
		8, 234, 10, 234, 12, 234, 4052, 9, 234, 1, 235, 1, 235, 1, 235, 5, 235,
		4057, 8, 235, 10, 235, 12, 235, 4060, 9, 235, 1, 236, 1, 236, 1, 236, 5,
		236, 4065, 8, 236, 10, 236, 12, 236, 4068, 9, 236, 1, 237, 1, 237, 1, 238,
		1, 238, 1, 238, 5, 238, 4075, 8, 238, 10, 238, 12, 238, 4078, 9, 238, 1,
		239, 1, 239, 1, 239, 3, 239, 4083, 8, 239, 1, 239, 1, 239, 3, 239, 4087,
		8, 239, 1, 239, 1, 239, 3, 239, 4091, 8, 239, 1, 239, 1, 239, 1, 239, 3,
		239, 4096, 8, 239, 1, 239, 3, 239, 4099, 8, 239, 3, 239, 4101, 8, 239,
		1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 3, 240, 4110, 8,
		240, 1, 240, 1, 240, 5, 240, 4114, 8, 240, 10, 240, 12, 240, 4117, 9, 240,
		1, 241, 1, 241, 1, 241, 1, 241, 3, 241, 4123, 8, 241, 1, 241, 1, 241, 1,
		241, 3, 241, 4128, 8, 241, 1, 241, 1, 241, 1, 241, 3, 241, 4133, 8, 241,
		1, 241, 1, 241, 1, 241, 3, 241, 4138, 8, 241, 1, 241, 3, 241, 4141, 8,
		241, 1, 242, 1, 242, 1, 242, 5, 242, 4146, 8, 242, 10, 242, 12, 242, 4149,
		9, 242, 1, 243, 1, 243, 1, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 3, 245, 4161, 8, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3,
		245, 4167, 8, 245, 1, 246, 1, 246, 1, 246, 1, 246, 3, 246, 4173, 8, 246,
		1, 247, 1, 247, 1, 247, 5, 247, 4178, 8, 247, 10, 247, 12, 247, 4181, 9,
		247, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248, 4188, 8, 248, 1, 248,
		1, 248, 1, 248, 1, 248, 3, 248, 4194, 8, 248, 1, 248, 1, 248, 1, 248, 1,
		248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248, 4206, 8, 248,
		3, 248, 4208, 8, 248, 1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 4214, 8,
		249, 1, 249, 1, 249, 3, 249, 4218, 8, 249, 3, 249, 4220, 8, 249, 1, 250,
		1, 250, 3, 250, 4224, 8, 250, 1, 250, 1, 250, 1, 251, 1, 251, 1, 251, 1,
		251, 1, 251, 1, 251, 1, 251, 1, 251, 1, 251, 3, 251, 4237, 8, 251, 1, 252,
		1, 252, 1, 252, 1, 252, 3, 252, 4243, 8, 252, 1, 252, 1, 252, 1, 253, 1,
		253, 1, 253, 1, 253, 3, 253, 4251, 8, 253, 1, 253, 1, 253, 1, 253, 1, 253,
		1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 3, 253, 4262, 8, 253, 1, 253, 1,
		253, 3, 253, 4266, 8, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253,
		1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 3, 253, 4279, 8, 253, 1, 253, 1,
		253, 1, 253, 1, 253, 1, 253, 3, 253, 4286, 8, 253, 1, 253, 1, 253, 1, 253,
		1, 253, 3, 253, 4292, 8, 253, 1, 253, 1, 253, 1, 253, 1, 253, 1, 253, 3,
		253, 4299, 8, 253, 3, 253, 4301, 8, 253, 1, 254, 1, 254, 1, 254, 1, 255,
		1, 255, 1, 255, 1, 255, 1, 255, 3, 255, 4311, 8, 255, 1, 255, 1, 255, 1,
		255, 1, 255, 1, 256, 1, 256, 3, 256, 4319, 8, 256, 1, 256, 3, 256, 4322,
		8, 256, 1, 256, 5, 256, 4325, 8, 256, 10, 256, 12, 256, 4328, 9, 256, 1,
		256, 3, 256, 4331, 8, 256, 1, 257, 1, 257, 1, 257, 1, 257, 3, 257, 4337,
		8, 257, 1, 257, 3, 257, 4340, 8, 257, 1, 258, 1, 258, 1, 258, 3, 258, 4345,
		8, 258, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259,
		1, 259, 4, 259, 4356, 8, 259, 11, 259, 12, 259, 4357, 1, 260, 1, 260, 1,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4370,
		8, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4375, 8, 260, 1, 260, 1, 260, 1,
		260, 1, 260, 1, 260, 1, 260, 3, 260, 4383, 8, 260, 1, 260, 1, 260, 1, 260,
		1, 260, 3, 260, 4389, 8, 260, 3, 260, 4391, 8, 260, 3, 260, 4393, 8, 260,
		1, 261, 1, 261, 1, 261, 1, 261, 3, 261, 4399, 8, 261, 1, 261, 1, 261, 1,
		262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 3, 262, 4411,
		8, 262, 1, 262, 1, 262, 1, 262, 3, 262, 4416, 8, 262, 3, 262, 4418, 8,
		262, 1, 262, 1, 262, 3, 262, 4422, 8, 262, 1, 262, 1, 262, 1, 262, 1, 262,
		3, 262, 4428, 8, 262, 1, 262, 3, 262, 4431, 8, 262, 1, 262, 3, 262, 4434,
		8, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262,
		3, 262, 4444, 8, 262, 3, 262, 4446, 8, 262, 1, 263, 1, 263, 1, 263, 1,
		263, 3, 263, 4452, 8, 263, 1, 264, 1, 264, 1, 264, 4, 264, 4457, 8, 264,
		11, 264, 12, 264, 4458, 1, 264, 1, 264, 1, 264, 1, 264, 3, 264, 4465, 8,
		264, 1, 265, 1, 265, 1, 265, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 3,
		266, 4475, 8, 266, 1, 266, 1, 266, 3, 266, 4479, 8, 266, 1, 267, 1, 267,
		1, 267, 3, 267, 4484, 8, 267, 1, 268, 1, 268, 1, 268, 1, 269, 1, 269, 1,
		269, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 5, 269, 4499,
		8, 269, 10, 269, 12, 269, 4502, 9, 269, 1, 270, 1, 270, 1, 270, 1, 270,
		1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270,
		3, 270, 4517, 8, 270, 1, 270, 1, 270, 1, 270, 3, 270, 4522, 8, 270, 1,
		270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 4530, 8, 270, 1, 270,
		1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 4538, 8, 270, 1, 271, 1,
		271, 1, 271, 3, 271, 4543, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271, 3, 271,
		4549, 8, 271, 1, 271, 3, 271, 4552, 8, 271, 3, 271, 4554, 8, 271, 1, 272,
		1, 272, 1, 273, 1, 273, 1, 273, 5, 273, 4561, 8, 273, 10, 273, 12, 273,
		4564, 9, 273, 1, 274, 1, 274, 1, 274, 3, 274, 4569, 8, 274, 1, 274, 1,
		274, 1, 274, 1, 274, 3, 274, 4575, 8, 274, 3, 274, 4577, 8, 274, 1, 274,
		1, 274, 3, 274, 4581, 8, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 1,
		274, 1, 274, 1, 274, 1, 274, 3, 274, 4592, 8, 274, 1, 274, 1, 274, 1, 274,
		1, 274, 1, 274, 1, 274, 1, 274, 1, 274, 3, 274, 4602, 8, 274, 1, 274, 1,
		274, 1, 274, 3, 274, 4607, 8, 274, 1, 275, 1, 275, 1, 275, 3, 275, 4612,
		8, 275, 1, 275, 1, 275, 1, 275, 3, 275, 4617, 8, 275, 1, 275, 1, 275, 1,
		275, 1, 275, 1, 275, 1, 275, 3, 275, 4625, 8, 275, 1, 276, 1, 276, 3, 276,
		4629, 8, 276, 1, 276, 5, 276, 4632, 8, 276, 10, 276, 12, 276, 4635, 9,
		276, 1, 277, 1, 277, 1, 277, 1, 277, 1, 277, 1, 277, 3, 277, 4643, 8, 277,
		1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278, 1, 278,
		1, 278, 3, 278, 4655, 8, 278, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1,
		279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4669, 8, 279,
		1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1, 279, 3, 279, 4678, 8,
		279, 3, 279, 4680, 8, 279, 1, 280, 1, 280, 1, 280, 5, 280, 4685, 8, 280,
		10, 280, 12, 280, 4688, 9, 280, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281,
		4694, 8, 281, 1, 282, 1, 282, 3, 282, 4698, 8, 282, 1, 282, 1, 282, 1,
		282, 1, 282, 3, 282, 4704, 8, 282, 1, 282, 1, 282, 1, 282, 1, 282, 5, 282,
		4710, 8, 282, 10, 282, 12, 282, 4713, 9, 282, 1, 282, 1, 282, 1, 282, 1,
		282, 3, 282, 4719, 8, 282, 1, 282, 1, 282, 3, 282, 4723, 8, 282, 1, 282,
		1, 282, 1, 282, 1, 282, 3, 282, 4729, 8, 282, 1, 282, 1, 282, 1, 282, 5,
		282, 4734, 8, 282, 10, 282, 12, 282, 4737, 9, 282, 3, 282, 4739, 8, 282,
		1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4748, 8,
		283, 1, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4754, 8, 283, 1, 284, 1, 284,
		1, 284, 3, 284, 4759, 8, 284, 1, 285, 1, 285, 1, 286, 1, 286, 1, 286, 1,
		286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1,
		286, 1, 286, 1, 286, 1, 286, 1, 286, 5, 286, 4780, 8, 286, 10, 286, 12,
		286, 4783, 9, 286, 3, 286, 4785, 8, 286, 1, 287, 1, 287, 1, 287, 1, 288,
		1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288,
		1, 288, 3, 288, 4801, 8, 288, 1, 288, 1, 288, 1, 288, 3, 288, 4806, 8,
		288, 1, 288, 3, 288, 4809, 8, 288, 1, 288, 1, 288, 3, 288, 4813, 8, 288,
		1, 288, 3, 288, 4816, 8, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1,
		288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 3, 288, 4830, 8, 288,
		1, 288, 1, 288, 1, 288, 1, 288, 3, 288, 4836, 8, 288, 1, 288, 1, 288, 1,
		288, 3, 288, 4841, 8, 288, 1, 288, 3, 288, 4844, 8, 288, 3, 288, 4846,
		8, 288, 1, 289, 1, 289, 3, 289, 4850, 8, 289, 1, 289, 1, 289, 1, 289, 3,
		289, 4855, 8, 289, 3, 289, 4857, 8, 289, 1, 290, 1, 290, 1, 290, 1, 291,
		1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 1, 291, 3, 291, 4869, 8, 291, 1,
		292, 1, 292, 5, 292, 4873, 8, 292, 10, 292, 12, 292, 4876, 9, 292, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293,
		3, 293, 4897, 8, 293, 1, 293, 1, 293, 3, 293, 4901, 8, 293, 3, 293, 4903,
		8, 293, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 3, 294, 4911, 8,
		294, 1, 295, 1, 295, 3, 295, 4915, 8, 295, 1, 295, 1, 295, 1, 296, 1, 296,
		1, 296, 1, 296, 1, 296, 3, 296, 4924, 8, 296, 1, 297, 1, 297, 1, 297, 1,
		297, 1, 298, 1, 298, 1, 298, 1, 298, 3, 298, 4934, 8, 298, 1, 299, 1, 299,
		1, 299, 1, 299, 1, 299, 3, 299, 4941, 8, 299, 1, 299, 3, 299, 4944, 8,
		299, 1, 299, 1, 299, 3, 299, 4948, 8, 299, 1, 299, 3, 299, 4951, 8, 299,
		1, 299, 3, 299, 4954, 8, 299, 1, 299, 1, 299, 3, 299, 4958, 8, 299, 1,
		299, 3, 299, 4961, 8, 299, 1, 299, 1, 299, 3, 299, 4965, 8, 299, 1, 299,
		3, 299, 4968, 8, 299, 1, 299, 1, 299, 1, 299, 3, 299, 4973, 8, 299, 1,
		299, 3, 299, 4976, 8, 299, 1, 299, 1, 299, 1, 299, 3, 299, 4981, 8, 299,
		1, 299, 3, 299, 4984, 8, 299, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299, 4990,
		8, 299, 1, 299, 1, 299, 3, 299, 4994, 8, 299, 1, 299, 1, 299, 1, 299, 1,
		299, 3, 299, 5000, 8, 299, 1, 299, 3, 299, 5003, 8, 299, 1, 299, 1, 299,
		1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299, 5012, 8, 299, 3, 299, 5014,
		8, 299, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299, 5020, 8, 299, 1, 299, 1,
		299, 3, 299, 5024, 8, 299, 1, 299, 3, 299, 5027, 8, 299, 1, 299, 3, 299,
		5030, 8, 299, 1, 299, 1, 299, 3, 299, 5034, 8, 299, 1, 299, 1, 299, 1,
		299, 1, 299, 3, 299, 5040, 8, 299, 1, 299, 3, 299, 5043, 8, 299, 1, 299,
		3, 299, 5046, 8, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1,
		299, 1, 299, 3, 299, 5056, 8, 299, 1, 299, 1, 299, 3, 299, 5060, 8, 299,
		1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 5, 299, 5067, 8, 299, 10, 299,
		12, 299, 5070, 9, 299, 3, 299, 5072, 8, 299, 1, 299, 1, 299, 1, 299, 3,
		299, 5077, 8, 299, 1, 299, 3, 299, 5080, 8, 299, 1, 299, 3, 299, 5083,
		8, 299, 1, 299, 1, 299, 3, 299, 5087, 8, 299, 1, 299, 3, 299, 5090, 8,
		299, 1, 299, 1, 299, 1, 299, 3, 299, 5095, 8, 299, 1, 299, 1, 299, 3, 299,
		5099, 8, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299, 5107,
		8, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299,
		1, 299, 1, 299, 1, 299, 3, 299, 5120, 8, 299, 1, 299, 1, 299, 1, 299, 1,
		299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 1,
		299, 1, 299, 1, 299, 1, 299, 3, 299, 5138, 8, 299, 1, 299, 1, 299, 1, 299,
		3, 299, 5143, 8, 299, 1, 299, 1, 299, 1, 299, 3, 299, 5148, 8, 299, 1,
		299, 1, 299, 1, 299, 1, 299, 1, 299, 1, 299, 3, 299, 5156, 8, 299, 1, 300,
		1, 300, 1, 300, 1, 300, 3, 300, 5162, 8, 300, 3, 300, 5164, 8, 300, 1,
		301, 1, 301, 3, 301, 5168, 8, 301, 1, 301, 3, 301, 5171, 8, 301, 1, 302,
		1, 302, 1, 303, 1, 303, 1, 303, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304,
		1, 304, 1, 304, 3, 304, 5185, 8, 304, 1, 305, 1, 305, 1, 305, 1, 305, 1,
		305, 1, 305, 1, 305, 1, 305, 3, 305, 5195, 8, 305, 1, 305, 1, 305, 3, 305,
		5199, 8, 305, 1, 305, 1, 305, 1, 305, 1, 305, 5, 305, 5205, 8, 305, 10,
		305, 12, 305, 5208, 9, 305, 3, 305, 5210, 8, 305, 1, 305, 1, 305, 3, 305,
		5214, 8, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1,
		305, 3, 305, 5224, 8, 305, 1, 306, 1, 306, 3, 306, 5228, 8, 306, 1, 307,
		1, 307, 1, 307, 5, 307, 5233, 8, 307, 10, 307, 12, 307, 5236, 9, 307, 1,
		308, 1, 308, 3, 308, 5240, 8, 308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 3, 309, 5248, 8, 309, 1, 310, 1, 310, 1, 310, 3, 310, 5253, 8,
		310, 1, 310, 1, 310, 1, 311, 1, 311, 3, 311, 5259, 8, 311, 1, 312, 1, 312,
		1, 312, 5, 312, 5264, 8, 312, 10, 312, 12, 312, 5267, 9, 312, 1, 313, 1,
		313, 3, 313, 5271, 8, 313, 1, 313, 1, 313, 1, 313, 1, 313, 3, 313, 5277,
		8, 313, 1, 313, 1, 313, 1, 313, 1, 313, 1, 313, 3, 313, 5284, 8, 313, 1,
		314, 1, 314, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315, 3, 315, 5294,
		8, 315, 3, 315, 5296, 8, 315, 1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 1,
		316, 3, 316, 5304, 8, 316, 1, 317, 1, 317, 1, 317, 3, 317, 5309, 8, 317,
		1, 317, 1, 317, 3, 317, 5313, 8, 317, 1, 317, 3, 317, 5316, 8, 317, 1,
		318, 1, 318, 1, 318, 5, 318, 5321, 8, 318, 10, 318, 12, 318, 5324, 9, 318,
		1, 319, 1, 319, 3, 319, 5328, 8, 319, 1, 319, 1, 319, 3, 319, 5332, 8,
		319, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 321, 1, 321, 1, 321, 1,
		321, 3, 321, 5343, 8, 321, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322, 1, 322,
		3, 322, 5351, 8, 322, 1, 322, 1, 322, 3, 322, 5355, 8, 322, 1, 322, 3,
		322, 5358, 8, 322, 1, 322, 3, 322, 5361, 8, 322, 1, 323, 1, 323, 3, 323,
		5365, 8, 323, 1, 323, 1, 323, 3, 323, 5369, 8, 323, 1, 323, 5, 323, 5372,
		8, 323, 10, 323, 12, 323, 5375, 9, 323, 1, 324, 1, 324, 1, 324, 3, 324,
		5380, 8, 324, 1, 325, 1, 325, 3, 325, 5384, 8, 325, 1, 325, 1, 325, 1,
		326, 1, 326, 1, 327, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5395, 8, 327,
		1, 327, 3, 327, 5398, 8, 327, 1, 327, 3, 327, 5401, 8, 327, 1, 327, 3,
		327, 5404, 8, 327, 1, 328, 1, 328, 1, 328, 1, 328, 1, 328, 1, 328, 3, 328,
		5412, 8, 328, 1, 329, 1, 329, 3, 329, 5416, 8, 329, 1, 329, 5, 329, 5419,
		8, 329, 10, 329, 12, 329, 5422, 9, 329, 1, 330, 1, 330, 1, 330, 1, 330,
		1, 330, 3, 330, 5429, 8, 330, 1, 331, 1, 331, 1, 331, 1, 331, 1, 331, 1,
		331, 3, 331, 5437, 8, 331, 1, 332, 1, 332, 1, 332, 1, 332, 3, 332, 5443,
		8, 332, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333,
		1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 1, 333, 3, 333,
		5461, 8, 333, 1, 333, 1, 333, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1,
		334, 3, 334, 5471, 8, 334, 1, 334, 1, 334, 1, 334, 1, 334, 3, 334, 5477,
		8, 334, 1, 335, 1, 335, 1, 335, 1, 336, 1, 336, 1, 336, 1, 337, 1, 337,
		1, 338, 1, 338, 1, 338, 1, 338, 3, 338, 5491, 8, 338, 1, 338, 3, 338, 5494,
		8, 338, 1, 338, 1, 338, 3, 338, 5498, 8, 338, 1, 338, 1, 338, 1, 338, 1,
		338, 1, 338, 1, 338, 1, 338, 1, 338, 1, 338, 5, 338, 5509, 8, 338, 10,
		338, 12, 338, 5512, 9, 338, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1,
		339, 3, 339, 5520, 8, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339,
		1, 339, 1, 339, 1, 339, 1, 339, 5, 339, 5532, 8, 339, 10, 339, 12, 339,
		5535, 9, 339, 1, 340, 1, 340, 1, 341, 1, 341, 3, 341, 5541, 8, 341, 1,
		341, 1, 341, 1, 341, 1, 341, 3, 341, 5547, 8, 341, 1, 341, 1, 341, 1, 341,
		1, 341, 3, 341, 5553, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1,
		342, 3, 342, 5561, 8, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342,
		1, 342, 1, 342, 1, 342, 3, 342, 5572, 8, 342, 1, 342, 1, 342, 3, 342, 5576,
		8, 342, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343,
		1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343,
		1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343, 1, 343,
		1, 343, 5, 343, 5605, 8, 343, 10, 343, 12, 343, 5608, 9, 343, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 3, 344, 5615, 8, 344, 1, 344, 1, 344, 3, 344,
		5619, 8, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 5636,
		8, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 5643, 8, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1,
		344, 1, 344, 1, 344, 3, 344, 5657, 8, 344, 1, 344, 1, 344, 1, 344, 1, 344,
		1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 5669, 8, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 3, 344, 5675, 8, 344, 1, 344, 1, 344, 1, 344,
		4, 344, 5680, 8, 344, 11, 344, 12, 344, 5681, 1, 344, 3, 344, 5685, 8,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 1,
		344, 1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 3, 344, 5719, 8, 344, 1, 344,
		1, 344, 1, 344, 1, 344, 1, 344, 1, 344, 5, 344, 5727, 8, 344, 10, 344,
		12, 344, 5730, 9, 344, 1, 345, 1, 345, 1, 345, 1, 346, 1, 346, 1, 346,
		1, 346, 1, 346, 1, 346, 3, 346, 5741, 8, 346, 1, 347, 1, 347, 1, 347, 3,
		347, 5746, 8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5752, 8, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5760, 8, 347, 1,
		347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5767, 8, 347, 1, 347, 1, 347,
		1, 347, 1, 347, 3, 347, 5773, 8, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5778,
		8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5784, 8, 347, 1, 347, 1,
		347, 1, 347, 3, 347, 5789, 8, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5794,
		8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5800, 8, 347, 1, 347, 1,
		347, 1, 347, 3, 347, 5805, 8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347,
		5811, 8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5819,
		8, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5827, 8,
		347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5835, 8, 347,
		1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5843, 8, 347, 1,
		347, 1, 347, 1, 347, 3, 347, 5848, 8, 347, 1, 347, 1, 347, 1, 347, 1, 347,
		3, 347, 5854, 8, 347, 1, 347, 1, 347, 1, 347, 3, 347, 5859, 8, 347, 1,
		347, 1, 347, 3, 347, 5863, 8, 347, 1, 347, 1, 347, 3, 347, 5867, 8, 347,
		1, 347, 1, 347, 1, 347, 3, 347, 5872, 8, 347, 3, 347, 5874, 8, 347, 1,
		348, 1, 348, 1, 348, 1, 348, 1, 348, 1, 349, 1, 349, 1, 349, 1, 349, 1,
		349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 5893,
		8, 349, 1, 349, 1, 349, 3, 349, 5897, 8, 349, 1, 349, 1, 349, 1, 349, 1,
		349, 1, 349, 3, 349, 5904, 8, 349, 1, 349, 1, 349, 1, 349, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 1, 349, 3, 349, 5916, 8, 349, 1, 349, 3,
		349, 5919, 8, 349, 1, 349, 1, 349, 3, 349, 5923, 8, 349, 1, 350, 1, 350,
		1, 350, 3, 350, 5928, 8, 350, 1, 351, 1, 351, 1, 351, 3, 351, 5933, 8,
		351, 1, 351, 1, 351, 3, 351, 5937, 8, 351, 1, 352, 1, 352, 1, 352, 1, 353,
		1, 353, 1, 353, 1, 353, 1, 353, 3, 353, 5947, 8, 353, 1, 353, 1, 353, 1,
		353, 1, 353, 1, 353, 1, 353, 1, 353, 3, 353, 5956, 8, 353, 3, 353, 5958,
		8, 353, 1, 354, 3, 354, 5961, 8, 354, 1, 354, 1, 354, 1, 355, 1, 355, 1,
		355, 1, 355, 1, 355, 3, 355, 5970, 8, 355, 1, 356, 1, 356, 1, 356, 5, 356,
		5975, 8, 356, 10, 356, 12, 356, 5978, 9, 356, 1, 357, 1, 357, 1, 357, 1,
		357, 1, 357, 1, 357, 1, 357, 1, 357, 1, 357, 1, 357, 3, 357, 5990, 8, 357,
		1, 357, 1, 357, 1, 357, 3, 357, 5995, 8, 357, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 3, 358, 6002, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358,
		6008, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 4, 358, 6032, 8, 358, 11,
		358, 12, 358, 6033, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6065, 8, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6085, 8,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6091, 8, 358, 1, 358, 1, 358,
		3, 358, 6095, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 3, 358, 6122, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6134, 8, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 3,
		358, 6147, 8, 358, 1, 358, 1, 358, 3, 358, 6151, 8, 358, 1, 358, 1, 358,
		3, 358, 6155, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 3, 358, 6183, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358,
		1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6239, 8, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6249, 8, 358, 1, 358,
		1, 358, 3, 358, 6253, 8, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 6265, 8, 358, 1, 358, 1, 358,
		1, 358, 3, 358, 6270, 8, 358, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1,
		359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 3, 359, 6283, 8, 359, 1, 359,
		1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359,
		1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 1, 359, 3, 359,
		6303, 8, 359, 1, 360, 1, 360, 3, 360, 6307, 8, 360, 1, 360, 1, 360, 1,
		361, 1, 361, 1, 361, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1, 362, 1,
		362, 1, 362, 5, 362, 6322, 8, 362, 10, 362, 12, 362, 6325, 9, 362, 3, 362,
		6327, 8, 362, 1, 363, 1, 363, 1, 363, 3, 363, 6332, 8, 363, 1, 363, 3,
		363, 6335, 8, 363, 1, 364, 1, 364, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365,
		3, 365, 6344, 8, 365, 1, 365, 1, 365, 3, 365, 6348, 8, 365, 1, 365, 1,
		365, 1, 365, 1, 365, 3, 365, 6354, 8, 365, 1, 365, 1, 365, 1, 365, 1, 365,
		3, 365, 6360, 8, 365, 1, 365, 1, 365, 3, 365, 6364, 8, 365, 1, 365, 1,
		365, 1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 1, 366, 3, 366, 6375,
		8, 366, 1, 366, 1, 366, 1, 366, 1, 366, 3, 366, 6381, 8, 366, 3, 366, 6383,
		8, 366, 1, 366, 1, 366, 1, 367, 1, 367, 1, 367, 3, 367, 6390, 8, 367, 1,
		367, 1, 367, 1, 367, 1, 367, 1, 367, 3, 367, 6397, 8, 367, 1, 367, 1, 367,
		3, 367, 6401, 8, 367, 1, 368, 1, 368, 1, 368, 5, 368, 6406, 8, 368, 10,
		368, 12, 368, 6409, 9, 368, 1, 369, 1, 369, 3, 369, 6413, 8, 369, 1, 370,
		1, 370, 3, 370, 6417, 8, 370, 1, 371, 1, 371, 1, 371, 3, 371, 6422, 8,
		371, 1, 372, 1, 372, 3, 372, 6426, 8, 372, 1, 372, 1, 372, 3, 372, 6430,
		8, 372, 1, 373, 1, 373, 1, 373, 3, 373, 6435, 8, 373, 1, 373, 1, 373, 1,
		373, 3, 373, 6440, 8, 373, 3, 373, 6442, 8, 373, 1, 373, 1, 373, 3, 373,
		6446, 8, 373, 1, 374, 1, 374, 1, 374, 1, 375, 1, 375, 1, 375, 1, 376, 1,
		376, 1, 376, 1, 377, 1, 377, 3, 377, 6459, 8, 377, 1, 377, 1, 377, 3, 377,
		6463, 8, 377, 1, 377, 3, 377, 6466, 8, 377, 1, 377, 1, 377, 3, 377, 6470,
		8, 377, 1, 377, 1, 377, 3, 377, 6474, 8, 377, 1, 377, 1, 377, 3, 377, 6478,
		8, 377, 1, 377, 1, 377, 1, 377, 3, 377, 6483, 8, 377, 1, 377, 1, 377, 3,
		377, 6487, 8, 377, 1, 377, 1, 377, 3, 377, 6491, 8, 377, 1, 377, 1, 377,
		1, 377, 1, 377, 1, 377, 1, 377, 1, 377, 3, 377, 6500, 8, 377, 3, 377, 6502,
		8, 377, 1, 378, 1, 378, 1, 378, 5, 378, 6507, 8, 378, 10, 378, 12, 378,
		6510, 9, 378, 1, 379, 1, 379, 1, 379, 3, 379, 6515, 8, 379, 1, 380, 1,
		380, 1, 381, 1, 381, 1, 382, 1, 382, 3, 382, 6523, 8, 382, 1, 383, 1, 383,
		1, 384, 1, 384, 1, 384, 1, 384, 1, 385, 1, 385, 1, 385, 1, 385, 1, 386,
		1, 386, 1, 386, 1, 386, 1, 387, 1, 387, 1, 387, 5, 387, 6542, 8, 387, 10,
		387, 12, 387, 6545, 9, 387, 1, 388, 1, 388, 3, 388, 6549, 8, 388, 1, 389,
		1, 389, 1, 389, 5, 389, 6554, 8, 389, 10, 389, 12, 389, 6557, 9, 389, 1,
		390, 1, 390, 1, 391, 1, 391, 1, 391, 1, 391, 1, 391, 1, 392, 1, 392, 1,
		392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1, 392, 1,
		392, 1, 392, 3, 392, 6579, 8, 392, 1, 393, 1, 393, 1, 393, 1, 394, 1, 394,
		1, 394, 1, 394, 1, 394, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395, 1, 395,
		3, 395, 6595, 8, 395, 1, 396, 1, 396, 1, 396, 1, 397, 1, 397, 1, 397, 4,
		397, 6603, 8, 397, 11, 397, 12, 397, 6604, 1, 398, 1, 398, 3, 398, 6609,
		8, 398, 1, 398, 1, 398, 1, 398, 4, 398, 6614, 8, 398, 11, 398, 12, 398,
		6615, 1, 398, 3, 398, 6619, 8, 398, 1, 398, 1, 398, 1, 398, 1, 399, 1,
		399, 1, 399, 1, 400, 1, 400, 1, 400, 3, 400, 6630, 8, 400, 1, 401, 1, 401,
		1, 402, 1, 402, 1, 402, 1, 403, 1, 403, 3, 403, 6639, 8, 403, 1, 403, 3,
		403, 6642, 8, 403, 1, 403, 1, 403, 1, 404, 1, 404, 1, 404, 3, 404, 6649,
		8, 404, 1, 405, 1, 405, 1, 405, 3, 405, 6654, 8, 405, 1, 406, 1, 406, 1,
		406, 1, 406, 1, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1,
		407, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 408, 1, 409, 1,
		409, 1, 409, 4, 409, 6678, 8, 409, 11, 409, 12, 409, 6679, 1, 410, 1, 410,
		1, 410, 1, 410, 3, 410, 6686, 8, 410, 1, 411, 1, 411, 1, 411, 1, 411, 3,
		411, 6692, 8, 411, 1, 411, 1, 411, 3, 411, 6696, 8, 411, 1, 412, 1, 412,
		1, 412, 1, 412, 1, 412, 1, 412, 1, 413, 1, 413, 3, 413, 6706, 8, 413, 1,
		414, 1, 414, 3, 414, 6710, 8, 414, 1, 414, 1, 414, 1, 415, 1, 415, 1, 415,
		1, 415, 1, 415, 1, 415, 1, 415, 5, 415, 6721, 8, 415, 10, 415, 12, 415,
		6724, 9, 415, 1, 415, 1, 415, 1, 416, 1, 416, 1, 416, 1, 416, 1, 416, 1,
		416, 1, 416, 3, 416, 6735, 8, 416, 1, 417, 1, 417, 1, 417, 1, 417, 1, 417,
		1, 417, 1, 418, 1, 418, 1, 418, 1, 419, 1, 419, 1, 419, 1, 420, 1, 420,
		1, 420, 1, 420, 3, 420, 6753, 8, 420, 1, 420, 1, 420, 1, 420, 1, 420, 5,
		420, 6759, 8, 420, 10, 420, 12, 420, 6762, 9, 420, 1, 420, 1, 420, 1, 420,
		1, 420, 1, 420, 5, 420, 6769, 8, 420, 10, 420, 12, 420, 6772, 9, 420, 3,
		420, 6774, 8, 420, 1, 421, 1, 421, 1, 421, 3, 421, 6779, 8, 421, 1, 422,
		1, 422, 3, 422, 6783, 8, 422, 1, 422, 1, 422, 1, 422, 1, 423, 1, 423, 3,
		423, 6790, 8, 423, 1, 423, 1, 423, 1, 423, 3, 423, 6795, 8, 423, 1, 424,
		1, 424, 1, 425, 1, 425, 1, 425, 3, 425, 6802, 8, 425, 1, 425, 1, 425, 1,
		425, 1, 425, 5, 425, 6808, 8, 425, 10, 425, 12, 425, 6811, 9, 425, 3, 425,
		6813, 8, 425, 1, 426, 1, 426, 1, 426, 3, 426, 6818, 8, 426, 1, 426, 1,
		426, 1, 426, 1, 426, 5, 426, 6824, 8, 426, 10, 426, 12, 426, 6827, 9, 426,
		3, 426, 6829, 8, 426, 1, 427, 1, 427, 1, 427, 1, 427, 1, 428, 1, 428, 1,
		428, 1, 429, 1, 429, 1, 429, 1, 430, 1, 430, 3, 430, 6843, 8, 430, 1, 430,
		3, 430, 6846, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 6859, 8, 431, 1, 431, 1, 431,
		3, 431, 6863, 8, 431, 3, 431, 6865, 8, 431, 1, 432, 1, 432, 1, 432, 3,
		432, 6870, 8, 432, 1, 433, 1, 433, 1, 433, 3, 433, 6875, 8, 433, 1, 434,
		1, 434, 1, 434, 1, 435, 3, 435, 6881, 8, 435, 1, 435, 1, 435, 1, 436, 1,
		436, 3, 436, 6887, 8, 436, 1, 436, 1, 436, 5, 436, 6891, 8, 436, 10, 436,
		12, 436, 6894, 9, 436, 1, 436, 1, 436, 3, 436, 6898, 8, 436, 1, 436, 3,
		436, 6901, 8, 436, 1, 436, 1, 436, 5, 436, 6905, 8, 436, 10, 436, 12, 436,
		6908, 9, 436, 1, 436, 1, 436, 3, 436, 6912, 8, 436, 1, 436, 3, 436, 6915,
		8, 436, 1, 436, 1, 436, 5, 436, 6919, 8, 436, 10, 436, 12, 436, 6922, 9,
		436, 1, 436, 3, 436, 6925, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 3, 436,
		6931, 8, 436, 3, 436, 6933, 8, 436, 1, 436, 3, 436, 6936, 8, 436, 1, 436,
		1, 436, 5, 436, 6940, 8, 436, 10, 436, 12, 436, 6943, 9, 436, 1, 436, 1,
		436, 1, 436, 3, 436, 6948, 8, 436, 1, 436, 1, 436, 1, 436, 1, 436, 1, 436,
		1, 436, 3, 436, 6956, 8, 436, 3, 436, 6958, 8, 436, 3, 436, 6960, 8, 436,
		1, 437, 1, 437, 3, 437, 6964, 8, 437, 1, 438, 1, 438, 5, 438, 6968, 8,
		438, 10, 438, 12, 438, 6971, 9, 438, 1, 438, 1, 438, 3, 438, 6975, 8, 438,
		1, 438, 1, 438, 3, 438, 6979, 8, 438, 1, 438, 1, 438, 1, 438, 3, 438, 6984,
		8, 438, 1, 438, 1, 438, 5, 438, 6988, 8, 438, 10, 438, 12, 438, 6991, 9,
		438, 1, 438, 1, 438, 5, 438, 6995, 8, 438, 10, 438, 12, 438, 6998, 9, 438,
		3, 438, 7000, 8, 438, 3, 438, 7002, 8, 438, 1, 439, 3, 439, 7005, 8, 439,
		1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 3, 439,
		7015, 8, 439, 1, 439, 1, 439, 3, 439, 7019, 8, 439, 1, 439, 1, 439, 1,
		439, 1, 439, 3, 439, 7025, 8, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439,
		3, 439, 7032, 8, 439, 1, 439, 1, 439, 1, 439, 3, 439, 7037, 8, 439, 1,
		439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1,
		439, 1, 439, 1, 439, 3, 439, 7051, 8, 439, 1, 439, 1, 439, 1, 439, 3, 439,
		7056, 8, 439, 1, 440, 1, 440, 1, 441, 1, 441, 1, 442, 1, 442, 3, 442, 7064,
		8, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7069, 8, 442, 1, 442, 1, 442, 3,
		442, 7073, 8, 442, 1, 442, 3, 442, 7076, 8, 442, 1, 443, 1, 443, 1, 443,
		3, 443, 7081, 8, 443, 1, 443, 1, 443, 3, 443, 7085, 8, 443, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7093, 8, 443, 1, 443, 1, 443,
		1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7101, 8, 443, 3, 443, 7103, 8,
		443, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 3, 444, 7110, 8, 444, 1, 445,
		1, 445, 1, 445, 1, 445, 5, 445, 7116, 8, 445, 10, 445, 12, 445, 7119, 9,
		445, 1, 445, 1, 445, 1, 446, 1, 446, 3, 446, 7125, 8, 446, 1, 446, 3, 446,
		7128, 8, 446, 1, 447, 1, 447, 1, 447, 1, 447, 5, 447, 7134, 8, 447, 10,
		447, 12, 447, 7137, 9, 447, 1, 447, 1, 447, 1, 448, 1, 448, 1, 448, 3,
		448, 7144, 8, 448, 3, 448, 7146, 8, 448, 1, 449, 1, 449, 1, 449, 1, 449,
		3, 449, 7152, 8, 449, 1, 450, 1, 450, 1, 451, 1, 451, 3, 451, 7158, 8,
		451, 1, 452, 1, 452, 3, 452, 7162, 8, 452, 1, 452, 1, 452, 1, 452, 1, 452,
		1, 452, 3, 452, 7169, 8, 452, 1, 453, 1, 453, 1, 454, 1, 454, 1, 454, 1,
		455, 1, 455, 1, 455, 1, 455, 3, 455, 7180, 8, 455, 1, 456, 1, 456, 1, 457,
		1, 457, 1, 457, 1, 458, 1, 458, 3, 458, 7189, 8, 458, 1, 458, 3, 458, 7192,
		8, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7197, 8, 458, 3, 458, 7199, 8,
		458, 1, 458, 3, 458, 7202, 8, 458, 1, 458, 3, 458, 7205, 8, 458, 1, 458,
		1, 458, 3, 458, 7209, 8, 458, 1, 458, 3, 458, 7212, 8, 458, 1, 458, 1,
		458, 3, 458, 7216, 8, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7221, 8, 458,
		1, 458, 3, 458, 7224, 8, 458, 1, 458, 1, 458, 3, 458, 7228, 8, 458, 1,
		458, 3, 458, 7231, 8, 458, 1, 458, 1, 458, 3, 458, 7235, 8, 458, 1, 458,
		1, 458, 1, 458, 3, 458, 7240, 8, 458, 1, 458, 1, 458, 3, 458, 7244, 8,
		458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1,
		458, 1, 458, 3, 458, 7256, 8, 458, 1, 458, 1, 458, 3, 458, 7260, 8, 458,
		1, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7266, 8, 458, 1, 458, 3, 458, 7269,
		8, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7274, 8, 458, 1, 458, 1, 458, 3,
		458, 7278, 8, 458, 1, 458, 1, 458, 3, 458, 7282, 8, 458, 1, 458, 1, 458,
		1, 458, 3, 458, 7287, 8, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1, 458, 1,
		458, 1, 458, 3, 458, 7296, 8, 458, 1, 458, 3, 458, 7299, 8, 458, 1, 458,
		1, 458, 3, 458, 7303, 8, 458, 1, 458, 1, 458, 3, 458, 7307, 8, 458, 1,
		458, 3, 458, 7310, 8, 458, 1, 458, 1, 458, 3, 458, 7314, 8, 458, 1, 458,
		1, 458, 3, 458, 7318, 8, 458, 1, 458, 1, 458, 1, 458, 3, 458, 7323, 8,
		458, 1, 458, 1, 458, 1, 458, 3, 458, 7328, 8, 458, 1, 458, 1, 458, 1, 458,
		1, 458, 3, 458, 7334, 8, 458, 1, 459, 1, 459, 1, 459, 3, 459, 7339, 8,
		459, 1, 460, 1, 460, 1, 460, 3, 460, 7344, 8, 460, 3, 460, 7346, 8, 460,
		1, 461, 1, 461, 1, 461, 3, 461, 7351, 8, 461, 1, 461, 1, 461, 1, 462, 4,
		462, 7356, 8, 462, 11, 462, 12, 462, 7357, 1, 463, 1, 463, 1, 463, 1, 463,
		1, 463, 1, 463, 3, 463, 7366, 8, 463, 1, 463, 1, 463, 1, 463, 1, 463, 3,
		463, 7372, 8, 463, 3, 463, 7374, 8, 463, 1, 464, 1, 464, 3, 464, 7378,
		8, 464, 1, 464, 1, 464, 3, 464, 7382, 8, 464, 1, 465, 1, 465, 3, 465, 7386,
		8, 465, 1, 465, 1, 465, 3, 465, 7390, 8, 465, 1, 466, 1, 466, 1, 466, 1,
		466, 1, 467, 1, 467, 1, 467, 1, 467, 1, 468, 1, 468, 1, 468, 1, 468, 3,
		468, 7404, 8, 468, 1, 469, 1, 469, 1, 469, 1, 469, 1, 469, 3, 469, 7411,
		8, 469, 1, 470, 1, 470, 3, 470, 7415, 8, 470, 1, 470, 5, 470, 7418, 8,
		470, 10, 470, 12, 470, 7421, 9, 470, 1, 471, 4, 471, 7424, 8, 471, 11,
		471, 12, 471, 7425, 1, 472, 1, 472, 3, 472, 7430, 8, 472, 1, 472, 1, 472,
		1, 472, 1, 472, 3, 472, 7436, 8, 472, 1, 472, 1, 472, 3, 472, 7440, 8,
		472, 1, 472, 1, 472, 3, 472, 7444, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472,
		7449, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7454, 8, 472, 1, 472, 1,
		472, 1, 472, 3, 472, 7459, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7464,
		8, 472, 1, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7470, 8, 472, 1, 472, 1,
		472, 1, 472, 1, 472, 3, 472, 7476, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472,
		7481, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7486, 8, 472, 1, 472, 1,
		472, 1, 472, 3, 472, 7491, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7496,
		8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7501, 8, 472, 1, 472, 1, 472, 1,
		472, 3, 472, 7506, 8, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7511, 8, 472,
		1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 3, 472,
		7521, 8, 472, 1, 472, 1, 472, 1, 472, 1, 472, 3, 472, 7527, 8, 472, 1,
		472, 1, 472, 1, 472, 1, 472, 3, 472, 7533, 8, 472, 1, 472, 1, 472, 1, 472,
		1, 472, 3, 472, 7539, 8, 472, 1, 472, 3, 472, 7542, 8, 472, 1, 472, 1,
		472, 1, 472, 1, 472, 1, 472, 3, 472, 7549, 8, 472, 1, 472, 1, 472, 1, 472,
		3, 472, 7554, 8, 472, 1, 472, 3, 472, 7557, 8, 472, 1, 473, 1, 473, 3,
		473, 7561, 8, 473, 1, 474, 3, 474, 7564, 8, 474, 1, 474, 1, 474, 3, 474,
		7568, 8, 474, 1, 474, 1, 474, 1, 475, 3, 475, 7573, 8, 475, 1, 475, 1,
		475, 3, 475, 7577, 8, 475, 1, 475, 1, 475, 1, 476, 3, 476, 7582, 8, 476,
		1, 476, 1, 476, 3, 476, 7586, 8, 476, 1, 476, 1, 476, 1, 477, 1, 477, 1,
		477, 1, 477, 1, 477, 3, 477, 7595, 8, 477, 1, 477, 3, 477, 7598, 8, 477,
		1, 477, 3, 477, 7601, 8, 477, 1, 478, 3, 478, 7604, 8, 478, 1, 478, 1,
		478, 3, 478, 7608, 8, 478, 1, 478, 1, 478, 3, 478, 7612, 8, 478, 1, 478,
		1, 478, 3, 478, 7616, 8, 478, 1, 478, 1, 478, 1, 478, 1, 478, 1, 478, 1,
		478, 1, 478, 1, 478, 1, 478, 1, 478, 1, 478, 1, 478, 1, 478, 3, 478, 7631,
		8, 478, 1, 478, 3, 478, 7634, 8, 478, 3, 478, 7636, 8, 478, 1, 479, 1,
		479, 1, 479, 3, 479, 7641, 8, 479, 1, 479, 1, 479, 1, 479, 1, 479, 1, 479,
		1, 479, 1, 479, 3, 479, 7650, 8, 479, 1, 479, 3, 479, 7653, 8, 479, 1,
		479, 1, 479, 3, 479, 7657, 8, 479, 1, 480, 1, 480, 1, 480, 1, 480, 1, 480,
		1, 481, 1, 481, 1, 481, 1, 481, 5, 481, 7668, 8, 481, 10, 481, 12, 481,
		7671, 9, 481, 1, 481, 1, 481, 1, 482, 1, 482, 1, 482, 1, 482, 1, 482, 1,
		482, 1, 482, 3, 482, 7682, 8, 482, 1, 482, 1, 482, 1, 482, 3, 482, 7687,
		8, 482, 1, 482, 5, 482, 7690, 8, 482, 10, 482, 12, 482, 7693, 9, 482, 1,
		482, 1, 482, 1, 482, 1, 482, 5, 482, 7699, 8, 482, 10, 482, 12, 482, 7702,
		9, 482, 1, 482, 1, 482, 3, 482, 7706, 8, 482, 1, 483, 1, 483, 1, 483, 1,
		483, 1, 483, 5, 483, 7713, 8, 483, 10, 483, 12, 483, 7716, 9, 483, 1, 483,
		1, 483, 3, 483, 7720, 8, 483, 1, 484, 1, 484, 3, 484, 7724, 8, 484, 1,
		484, 1, 484, 3, 484, 7728, 8, 484, 1, 484, 1, 484, 3, 484, 7732, 8, 484,
		1, 484, 1, 484, 1, 484, 3, 484, 7737, 8, 484, 1, 484, 1, 484, 1, 484, 3,
		484, 7742, 8, 484, 1, 484, 1, 484, 1, 484, 1, 484, 3, 484, 7748, 8, 484,
		1, 484, 1, 484, 1, 484, 3, 484, 7753, 8, 484, 1, 484, 3, 484, 7756, 8,
		484, 1, 485, 1, 485, 1, 485, 5, 485, 7761, 8, 485, 10, 485, 12, 485, 7764,
		9, 485, 1, 486, 1, 486, 1, 486, 1, 486, 5, 486, 7770, 8, 486, 10, 486,
		12, 486, 7773, 9, 486, 1, 486, 1, 486, 1, 487, 1, 487, 3, 487, 7779, 8,
		487, 1, 488, 1, 488, 1, 488, 1, 488, 1, 489, 1, 489, 1, 489, 1, 490, 1,
		490, 1, 490, 1, 490, 1, 491, 3, 491, 7793, 8, 491, 1, 491, 1, 491, 1, 492,
		1, 492, 1, 492, 1, 493, 1, 493, 1, 493, 1, 494, 1, 494, 3, 494, 7805, 8,
		494, 1, 495, 1, 495, 1, 495, 1, 495, 1, 495, 1, 495, 1, 496, 1, 496, 1,
		496, 5, 496, 7816, 8, 496, 10, 496, 12, 496, 7819, 9, 496, 1, 497, 1, 497,
		1, 497, 5, 497, 7824, 8, 497, 10, 497, 12, 497, 7827, 9, 497, 1, 498, 1,
		498, 1, 498, 1, 498, 3, 498, 7833, 8, 498, 1, 499, 1, 499, 1, 499, 1, 500,
		1, 500, 4, 500, 7840, 8, 500, 11, 500, 12, 500, 7841, 1, 501, 1, 501, 1,
		501, 1, 501, 3, 501, 7848, 8, 501, 1, 501, 1, 501, 1, 501, 1, 501, 1, 501,
		1, 501, 3, 501, 7856, 8, 501, 1, 502, 1, 502, 4, 502, 7860, 8, 502, 11,
		502, 12, 502, 7861, 1, 503, 1, 503, 1, 503, 1, 503, 1, 504, 1, 504, 1,
		504, 5, 504, 7871, 8, 504, 10, 504, 12, 504, 7874, 9, 504, 1, 505, 1, 505,
		1, 505, 5, 505, 7879, 8, 505, 10, 505, 12, 505, 7882, 9, 505, 1, 506, 1,
		506, 1, 506, 5, 506, 7887, 8, 506, 10, 506, 12, 506, 7890, 9, 506, 1, 507,
		1, 507, 1, 507, 1, 507, 1, 507, 3, 507, 7897, 8, 507, 1, 507, 1, 507, 1,
		507, 1, 507, 1, 507, 1, 507, 1, 507, 1, 507, 3, 507, 7907, 8, 507, 1, 507,
		1, 507, 1, 507, 3, 507, 7912, 8, 507, 1, 507, 1, 507, 1, 507, 3, 507, 7917,
		8, 507, 3, 507, 7919, 8, 507, 1, 508, 1, 508, 1, 508, 1, 508, 3, 508, 7925,
		8, 508, 1, 508, 1, 508, 1, 508, 1, 508, 3, 508, 7931, 8, 508, 1, 508, 3,
		508, 7934, 8, 508, 1, 508, 1, 508, 1, 508, 1, 508, 1, 508, 3, 508, 7941,
		8, 508, 3, 508, 7943, 8, 508, 3, 508, 7945, 8, 508, 1, 508, 3, 508, 7948,
		8, 508, 3, 508, 7950, 8, 508, 1, 509, 1, 509, 1, 509, 1, 509, 1, 510, 1,
		510, 1, 510, 1, 510, 1, 511, 1, 511, 1, 511, 1, 512, 1, 512, 1, 512, 1,
		512, 3, 512, 7967, 8, 512, 1, 513, 1, 513, 1, 513, 3, 513, 7972, 8, 513,
		3, 513, 7974, 8, 513, 1, 514, 1, 514, 1, 514, 1, 515, 1, 515, 3, 515, 7981,
		8, 515, 1, 516, 1, 516, 1, 517, 1, 517, 1, 518, 1, 518, 1, 518, 1, 518,
		1, 519, 1, 519, 1, 519, 3, 519, 7994, 8, 519, 3, 519, 7996, 8, 519, 1,
		520, 1, 520, 1, 520, 1, 520, 3, 520, 8002, 8, 520, 1, 521, 1, 521, 1, 522,
		1, 522, 1, 522, 1, 522, 5, 522, 8010, 8, 522, 10, 522, 12, 522, 8013, 9,
		522, 1, 522, 1, 522, 1, 523, 1, 523, 1, 524, 1, 524, 3, 524, 8021, 8, 524,
		1, 525, 1, 525, 1, 526, 1, 526, 1, 527, 1, 527, 1, 527, 1, 527, 1, 527,
		3, 527, 8032, 8, 527, 1, 527, 1, 527, 1, 528, 1, 528, 1, 529, 1, 529, 1,
		530, 1, 530, 1, 531, 1, 531, 1, 532, 1, 532, 1, 533, 1, 533, 1, 534, 1,
		534, 1, 535, 1, 535, 1, 536, 1, 536, 3, 536, 8054, 8, 536, 1, 537, 1, 537,
		3, 537, 8058, 8, 537, 1, 538, 1, 538, 1, 539, 1, 539, 1, 540, 1, 540, 1,
		541, 1, 541, 1, 542, 1, 542, 1, 543, 1, 543, 1, 544, 1, 544, 1, 545, 1,
		545, 1, 546, 1, 546, 1, 547, 1, 547, 1, 548, 1, 548, 3, 548, 8082, 8, 548,
		1, 549, 1, 549, 1, 549, 1, 550, 1, 550, 1, 550, 1, 550, 1, 550, 1, 550,
		3, 550, 8093, 8, 550, 3, 550, 8095, 8, 550, 1, 551, 1, 551, 3, 551, 8099,
		8, 551, 1, 552, 1, 552, 1, 552, 5, 552, 8104, 8, 552, 10, 552, 12, 552,
		8107, 9, 552, 1, 553, 1, 553, 1, 553, 5, 553, 8112, 8, 553, 10, 553, 12,
		553, 8115, 9, 553, 1, 554, 1, 554, 1, 555, 1, 555, 3, 555, 8121, 8, 555,
		1, 556, 1, 556, 1, 557, 1, 557, 3, 557, 8127, 8, 557, 1, 558, 1, 558, 1,
		559, 1, 559, 1, 560, 1, 560, 1, 561, 1, 561, 1, 562, 1, 562, 1, 563, 1,
		563, 1, 563, 3, 563, 8142, 8, 563, 1, 564, 1, 564, 3, 564, 8146, 8, 564,
		1, 565, 1, 565, 1, 565, 5, 565, 8151, 8, 565, 10, 565, 12, 565, 8154, 9,
		565, 1, 566, 1, 566, 1, 566, 1, 566, 1, 567, 1, 567, 3, 567, 8162, 8, 567,
		1, 568, 1, 568, 1, 568, 3, 568, 8167, 8, 568, 3, 568, 8169, 8, 568, 1,
		568, 1, 568, 1, 568, 1, 568, 3, 568, 8175, 8, 568, 1, 569, 1, 569, 1, 569,
		1, 570, 1, 570, 1, 571, 1, 571, 1, 572, 1, 572, 1, 573, 1, 573, 1, 573,
		1, 573, 1, 573, 3, 573, 8191, 8, 573, 1, 574, 1, 574, 1, 574, 1, 574, 1,
		574, 1, 574, 3, 574, 8199, 8, 574, 1, 574, 3, 574, 8202, 8, 574, 1, 575,
		1, 575, 1, 575, 1, 575, 1, 575, 3, 575, 8209, 8, 575, 1, 576, 1, 576, 1,
		576, 1, 576, 5, 576, 8215, 8, 576, 10, 576, 12, 576, 8218, 9, 576, 1, 576,
		1, 576, 1, 577, 1, 577, 1, 577, 3, 577, 8225, 8, 577, 1, 578, 1, 578, 1,
		578, 3, 578, 8230, 8, 578, 1, 579, 1, 579, 1, 579, 3, 579, 8235, 8, 579,
		1, 580, 3, 580, 8238, 8, 580, 1, 580, 1, 580, 3, 580, 8242, 8, 580, 1,
		580, 5, 580, 8245, 8, 580, 10, 580, 12, 580, 8248, 9, 580, 1, 581, 1, 581,
		1, 582, 1, 582, 1, 582, 5, 582, 8255, 8, 582, 10, 582, 12, 582, 8258, 9,
		582, 1, 583, 1, 583, 1, 584, 1, 584, 1, 585, 1, 585, 1, 586, 1, 586, 1,
		586, 1, 586, 1, 586, 1, 586, 3, 586, 8272, 8, 586, 1, 587, 1, 587, 3, 587,
		8276, 8, 587, 1, 588, 1, 588, 1, 589, 1, 589, 1, 589, 1, 589, 1, 589, 1,
		589, 1, 590, 1, 590, 3, 590, 8288, 8, 590, 1, 591, 1, 591, 3, 591, 8292,
		8, 591, 1, 592, 1, 592, 3, 592, 8296, 8, 592, 1, 593, 1, 593, 3, 593, 8300,
		8, 593, 1, 594, 1, 594, 1, 594, 1, 595, 1, 595, 1, 596, 1, 596, 1, 597,
		1, 597, 1, 597, 1, 597, 1, 597, 1, 597, 3, 597, 8315, 8, 597, 1, 598, 1,
		598, 1, 598, 1, 598, 1, 598, 1, 598, 1, 598, 1, 598, 1, 598, 1, 598, 3,
		598, 8327, 8, 598, 1, 599, 1, 599, 1, 599, 1, 599, 1, 599, 1, 599, 1, 599,
		1, 599, 3, 599, 8337, 8, 599, 1, 599, 1, 599, 1, 599, 1, 599, 1, 599, 3,
		599, 8344, 8, 599, 3, 599, 8346, 8, 599, 1, 600, 1, 600, 1, 601, 1, 601,
		1, 602, 1, 602, 1, 602, 1, 602, 1, 602, 1, 602, 1, 602, 1, 602, 1, 602,
		1, 602, 1, 602, 3, 602, 8363, 8, 602, 1, 602, 1, 602, 1, 602, 3, 602, 8368,
		8, 602, 3, 602, 8370, 8, 602, 1, 603, 1, 603, 1, 604, 1, 604, 1, 604, 3,
		604, 8377, 8, 604, 1, 605, 1, 605, 1, 605, 3, 605, 8382, 8, 605, 1, 605,
		1, 605, 1, 605, 3, 605, 8387, 8, 605, 3, 605, 8389, 8, 605, 1, 606, 1,
		606, 1, 606, 1, 606, 3, 606, 8395, 8, 606, 1, 607, 1, 607, 1, 608, 1, 608,
		1, 608, 1, 608, 1, 608, 3, 608, 8404, 8, 608, 1, 609, 1, 609, 1, 609, 1,
		609, 1, 609, 1, 609, 1, 609, 1, 609, 1, 609, 3, 609, 8415, 8, 609, 1, 609,
		0, 4, 676, 678, 686, 688, 610, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
		24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
		60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
		96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
		126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
		156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
		186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214,
		216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244,
		246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274,
		276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304,
		306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334,
		336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364,
		366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394,
		396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424,
		426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454,
		456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484,
		486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514,
		516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544,
		546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574,
		576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604,
		606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634,
		636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664,
		666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694,
		696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724,
		726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754,
		756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784,
		786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814,
		816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842, 844,
		846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872, 874,
		876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902, 904,
		906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932, 934,
		936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962, 964,
		966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 992, 994,
		996, 998, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020,
		1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044,
		1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062, 1064, 1066, 1068,
		1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 1092,
		1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114, 1116,
		1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140,
		1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158, 1160, 1162, 1164,
		1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188,
		1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212,
		1214, 1216, 1218, 0, 146, 1, 0, 722, 723, 2, 0, 17, 17, 590, 590, 2, 0,
		49, 49, 471, 471, 1, 0, 645, 646, 2, 0, 4, 4, 148, 148, 2, 0, 434, 434,
		436, 436, 1, 0, 724, 725, 2, 0, 50, 50, 284, 284, 2, 0, 232, 232, 458,
		458, 4, 0, 126, 126, 249, 249, 437, 437, 556, 556, 2, 0, 130, 130, 250,
		250, 2, 0, 440, 440, 603, 603, 2, 0, 441, 441, 604, 604, 2, 0, 374, 374,
		638, 638, 3, 0, 335, 335, 578, 578, 602, 602, 2, 0, 6, 6, 28, 28, 3, 0,
		133, 133, 242, 242, 614, 614, 2, 0, 197, 197, 415, 415, 2, 0, 571, 571,
		574, 574, 3, 0, 232, 232, 295, 295, 431, 431, 2, 0, 191, 191, 367, 367,
		4, 0, 191, 191, 268, 268, 367, 367, 419, 419, 2, 0, 750, 750, 753, 756,
		3, 0, 131, 131, 223, 223, 295, 295, 1, 0, 626, 627, 2, 0, 82, 82, 295,
		295, 2, 0, 112, 112, 653, 653, 2, 0, 278, 278, 484, 484, 2, 0, 131, 131,
		295, 295, 7, 0, 10, 10, 143, 143, 223, 223, 531, 532, 534, 534, 536, 536,
		555, 555, 2, 0, 381, 381, 773, 773, 2, 0, 747, 749, 787, 787, 3, 0, 432,
		432, 484, 484, 683, 683, 2, 0, 18, 18, 134, 134, 2, 0, 272, 272, 478, 478,
		2, 0, 98, 98, 239, 239, 2, 0, 10, 10, 143, 143, 2, 0, 198, 198, 232, 232,
		2, 0, 236, 236, 265, 265, 2, 0, 386, 386, 649, 649, 2, 0, 29, 29, 543,
		543, 2, 0, 261, 261, 472, 472, 2, 0, 32, 32, 316, 316, 2, 0, 383, 383,
		743, 744, 2, 0, 528, 528, 530, 530, 2, 0, 449, 449, 538, 538, 2, 0, 543,
		543, 552, 552, 2, 0, 123, 123, 148, 148, 3, 0, 369, 369, 539, 539, 650,
		650, 2, 0, 287, 287, 611, 611, 2, 0, 128, 128, 719, 719, 3, 0, 206, 206,
		422, 422, 574, 574, 4, 0, 242, 242, 443, 443, 497, 497, 614, 614, 13, 0,
		133, 133, 148, 148, 170, 170, 173, 173, 188, 188, 236, 236, 423, 423, 427,
		427, 451, 451, 510, 510, 565, 565, 594, 594, 616, 616, 4, 0, 483, 483,
		572, 572, 618, 618, 636, 636, 2, 0, 65, 65, 514, 514, 2, 0, 97, 97, 148,
		148, 2, 0, 128, 128, 369, 369, 2, 0, 180, 180, 431, 431, 5, 0, 56, 56,
		180, 180, 184, 184, 333, 333, 431, 431, 3, 0, 180, 180, 431, 431, 619,
		619, 2, 0, 76, 76, 601, 601, 4, 0, 10, 10, 32, 32, 128, 128, 383, 383,
		2, 0, 487, 487, 710, 710, 3, 0, 289, 289, 354, 354, 547, 547, 2, 0, 203,
		203, 251, 251, 2, 0, 33, 33, 446, 446, 2, 0, 235, 236, 263, 263, 2, 0,
		166, 166, 639, 639, 2, 0, 547, 547, 631, 631, 6, 0, 10, 10, 96, 96, 256,
		256, 334, 334, 522, 522, 567, 567, 2, 0, 84, 84, 430, 430, 5, 0, 136, 136,
		225, 225, 421, 421, 547, 547, 617, 617, 5, 0, 32, 32, 163, 163, 165, 165,
		208, 208, 515, 515, 2, 0, 618, 618, 710, 710, 2, 0, 140, 140, 156, 156,
		2, 0, 134, 135, 178, 178, 3, 0, 183, 183, 596, 596, 610, 610, 2, 0, 15,
		15, 767, 767, 2, 0, 394, 394, 770, 770, 2, 0, 10, 10, 16, 16, 2, 0, 750,
		750, 752, 757, 3, 0, 145, 145, 349, 349, 760, 762, 1, 0, 758, 759, 1, 0,
		765, 766, 2, 0, 758, 759, 764, 764, 2, 0, 35, 36, 38, 38, 4, 0, 678, 679,
		692, 692, 694, 694, 696, 696, 2, 0, 684, 684, 686, 686, 2, 0, 681, 681,
		685, 685, 2, 0, 191, 191, 268, 268, 2, 0, 232, 232, 695, 695, 2, 0, 5,
		5, 558, 558, 1, 0, 114, 115, 1, 0, 584, 585, 4, 0, 113, 113, 116, 116,
		583, 583, 586, 586, 2, 0, 371, 371, 745, 745, 2, 0, 745, 745, 763, 763,
		5, 0, 118, 121, 226, 228, 341, 342, 494, 494, 655, 655, 9, 0, 122, 122,
		229, 229, 337, 337, 343, 343, 350, 350, 429, 429, 495, 495, 640, 640, 656,
		656, 3, 0, 92, 92, 175, 175, 605, 605, 2, 0, 377, 377, 485, 485, 10, 0,
		53, 53, 64, 64, 73, 73, 87, 89, 107, 107, 336, 336, 355, 355, 492, 492,
		557, 557, 576, 576, 2, 0, 554, 554, 637, 637, 3, 0, 128, 128, 152, 152,
		192, 192, 3, 0, 128, 128, 142, 142, 334, 334, 3, 0, 204, 204, 402, 402,
		513, 513, 3, 0, 44, 44, 220, 220, 488, 488, 1, 0, 661, 662, 2, 0, 599,
		599, 621, 621, 5, 0, 31, 31, 249, 249, 331, 331, 516, 516, 588, 588, 4,
		0, 126, 126, 192, 192, 195, 195, 378, 378, 1, 0, 41, 42, 2, 0, 290, 290,
		330, 330, 4, 0, 211, 212, 279, 279, 351, 353, 411, 412, 3, 0, 512, 512,
		612, 612, 657, 657, 1, 0, 544, 546, 2, 0, 61, 61, 575, 575, 6, 0, 78, 78,
		80, 80, 128, 128, 152, 152, 192, 192, 442, 442, 3, 0, 191, 191, 268, 268,
		373, 373, 2, 0, 142, 142, 334, 334, 2, 0, 280, 280, 432, 432, 2, 0, 323,
		323, 344, 344, 2, 0, 112, 112, 236, 236, 3, 0, 240, 240, 251, 251, 397,
		397, 2, 0, 541, 541, 579, 579, 2, 0, 380, 380, 385, 385, 2, 0, 284, 284,
		375, 375, 2, 0, 795, 795, 797, 797, 3, 0, 747, 749, 788, 788, 790, 791,
		2, 0, 747, 749, 788, 788, 2, 0, 747, 749, 790, 791, 1, 0, 788, 789, 2,
		0, 183, 183, 596, 596, 2, 0, 376, 376, 786, 786, 1, 0, 750, 751, 5, 0,
		214, 214, 284, 284, 502, 502, 658, 658, 673, 673, 3, 0, 173, 173, 510,
		510, 714, 714, 32, 0, 19, 19, 29, 29, 46, 47, 58, 58, 61, 61, 75, 75, 77,
		77, 90, 90, 123, 123, 147, 147, 159, 159, 196, 197, 219, 219, 222, 222,
		234, 234, 245, 245, 267, 267, 373, 373, 415, 415, 417, 417, 455, 455, 468,
		468, 480, 480, 489, 489, 512, 512, 514, 514, 543, 543, 552, 552, 597, 597,
		606, 607, 651, 651, 677, 677, 9, 0, 170, 170, 188, 188, 369, 369, 423,
		423, 427, 427, 451, 451, 459, 459, 565, 565, 709, 709, 161, 0, 2, 3, 5,
		9, 12, 12, 16, 16, 21, 21, 23, 27, 33, 33, 37, 37, 40, 42, 44, 44, 50,
		50, 53, 54, 56, 57, 63, 68, 70, 71, 73, 74, 76, 76, 78, 82, 84, 85, 87,
		89, 91, 91, 96, 96, 101, 101, 107, 107, 111, 113, 116, 116, 122, 122, 129,
		130, 132, 132, 138, 142, 150, 152, 156, 156, 158, 158, 160, 160, 162, 166,
		168, 169, 171, 172, 176, 177, 179, 181, 184, 185, 189, 192, 201, 202, 204,
		204, 208, 208, 210, 213, 216, 216, 220, 220, 224, 225, 229, 230, 233, 233,
		235, 235, 238, 238, 243, 244, 250, 250, 255, 256, 258, 259, 262, 262, 264,
		264, 268, 268, 270, 270, 273, 274, 279, 280, 286, 286, 288, 289, 296, 296,
		298, 314, 316, 319, 321, 324, 327, 328, 333, 337, 340, 340, 343, 344, 346,
		346, 348, 348, 350, 358, 361, 361, 363, 363, 365, 368, 374, 374, 377, 377,
		379, 379, 381, 381, 384, 384, 386, 387, 390, 390, 398, 404, 406, 413, 418,
		419, 421, 421, 424, 426, 429, 431, 434, 434, 438, 439, 441, 442, 445, 449,
		452, 452, 454, 454, 456, 456, 460, 466, 470, 470, 472, 474, 476, 476, 481,
		483, 485, 486, 488, 488, 490, 490, 492, 492, 495, 496, 500, 501, 503, 503,
		508, 508, 513, 513, 515, 515, 517, 517, 519, 522, 528, 530, 532, 532, 535,
		535, 538, 538, 540, 540, 542, 542, 544, 547, 553, 553, 556, 561, 566, 568,
		571, 572, 575, 578, 580, 581, 583, 586, 592, 593, 598, 599, 601, 604, 610,
		610, 613, 613, 615, 615, 617, 619, 625, 625, 627, 627, 631, 631, 636, 636,
		638, 641, 646, 648, 650, 650, 652, 653, 656, 656, 659, 662, 664, 664, 669,
		671, 674, 675, 680, 680, 682, 682, 689, 690, 693, 693, 695, 695, 697, 698,
		702, 708, 711, 713, 715, 725, 727, 730, 732, 732, 735, 738, 4, 0, 583,
		583, 586, 586, 731, 731, 733, 744, 54, 0, 2, 2, 12, 12, 19, 19, 27, 27,
		29, 29, 46, 47, 58, 58, 61, 61, 66, 66, 75, 75, 77, 77, 90, 90, 123, 123,
		147, 147, 159, 159, 196, 197, 201, 201, 210, 210, 219, 219, 222, 222, 224,
		224, 245, 245, 267, 267, 373, 373, 387, 387, 390, 390, 398, 398, 401, 401,
		405, 405, 413, 413, 415, 415, 417, 417, 452, 452, 455, 455, 468, 468, 470,
		470, 480, 480, 489, 489, 496, 496, 503, 503, 512, 512, 514, 514, 519, 520,
		543, 543, 552, 552, 597, 597, 606, 607, 615, 615, 648, 648, 651, 651, 659,
		659, 661, 662, 677, 677, 720, 723, 155, 0, 3, 3, 5, 9, 13, 13, 16, 16,
		21, 26, 33, 33, 37, 37, 40, 42, 44, 44, 50, 50, 53, 54, 56, 57, 63, 65,
		67, 68, 70, 71, 73, 74, 76, 76, 78, 82, 84, 85, 87, 89, 91, 91, 93, 93,
		96, 96, 101, 101, 107, 107, 111, 113, 116, 116, 122, 122, 129, 130, 132,
		132, 136, 136, 138, 142, 150, 152, 156, 156, 158, 158, 160, 160, 162, 166,
		168, 169, 171, 171, 176, 176, 179, 181, 184, 185, 189, 192, 202, 202, 204,
		204, 208, 208, 211, 214, 216, 216, 220, 220, 225, 225, 229, 230, 233, 233,
		235, 235, 238, 238, 243, 244, 250, 250, 255, 256, 258, 259, 262, 262, 264,
		264, 268, 268, 270, 270, 273, 274, 279, 280, 284, 284, 286, 286, 288, 289,
		296, 296, 298, 314, 316, 319, 321, 325, 327, 328, 333, 337, 340, 340, 343,
		344, 346, 346, 348, 348, 350, 358, 361, 361, 363, 363, 365, 368, 374, 374,
		377, 377, 379, 379, 381, 382, 384, 384, 399, 400, 402, 404, 406, 412, 418,
		419, 421, 421, 424, 426, 429, 431, 434, 434, 438, 442, 445, 449, 454, 454,
		456, 456, 460, 466, 472, 474, 476, 476, 481, 483, 485, 486, 488, 488, 490,
		490, 492, 492, 495, 495, 500, 502, 508, 508, 513, 513, 515, 515, 517, 517,
		521, 522, 528, 530, 532, 533, 535, 535, 538, 538, 540, 540, 542, 542, 544,
		547, 553, 553, 556, 561, 565, 568, 571, 572, 575, 578, 580, 581, 583, 586,
		592, 593, 598, 604, 610, 610, 613, 613, 617, 619, 627, 627, 631, 631, 636,
		636, 638, 641, 647, 647, 650, 650, 652, 653, 656, 656, 664, 664, 669, 671,
		674, 676, 680, 680, 682, 682, 689, 690, 693, 693, 695, 695, 697, 698, 702,
		708, 711, 712, 716, 717, 719, 719, 724, 725, 727, 728, 5, 0, 99, 99, 206,
		206, 234, 234, 484, 484, 487, 487, 6, 0, 172, 172, 177, 177, 386, 386,
		565, 565, 625, 625, 646, 646, 9536, 0, 1232, 1, 0, 0, 0, 2, 1268, 1, 0,
		0, 0, 4, 1270, 1, 0, 0, 0, 6, 1299, 1, 0, 0, 0, 8, 1314, 1, 0, 0, 0, 10,
		1352, 1, 0, 0, 0, 12, 1361, 1, 0, 0, 0, 14, 1374, 1, 0, 0, 0, 16, 1376,
		1, 0, 0, 0, 18, 1381, 1, 0, 0, 0, 20, 1405, 1, 0, 0, 0, 22, 1414, 1, 0,
		0, 0, 24, 1416, 1, 0, 0, 0, 26, 1431, 1, 0, 0, 0, 28, 1529, 1, 0, 0, 0,
		30, 1533, 1, 0, 0, 0, 32, 1549, 1, 0, 0, 0, 34, 1696, 1, 0, 0, 0, 36, 1701,
		1, 0, 0, 0, 38, 1703, 1, 0, 0, 0, 40, 1705, 1, 0, 0, 0, 42, 1719, 1, 0,
		0, 0, 44, 1727, 1, 0, 0, 0, 46, 1743, 1, 0, 0, 0, 48, 1745, 1, 0, 0, 0,
		50, 1749, 1, 0, 0, 0, 52, 1754, 1, 0, 0, 0, 54, 1756, 1, 0, 0, 0, 56, 1793,
		1, 0, 0, 0, 58, 1801, 1, 0, 0, 0, 60, 1811, 1, 0, 0, 0, 62, 1813, 1, 0,
		0, 0, 64, 1833, 1, 0, 0, 0, 66, 1842, 1, 0, 0, 0, 68, 1845, 1, 0, 0, 0,
		70, 1858, 1, 0, 0, 0, 72, 1863, 1, 0, 0, 0, 74, 1867, 1, 0, 0, 0, 76, 1874,
		1, 0, 0, 0, 78, 1895, 1, 0, 0, 0, 80, 1910, 1, 0, 0, 0, 82, 1913, 1, 0,
		0, 0, 84, 1944, 1, 0, 0, 0, 86, 1954, 1, 0, 0, 0, 88, 1957, 1, 0, 0, 0,
		90, 1966, 1, 0, 0, 0, 92, 1968, 1, 0, 0, 0, 94, 1980, 1, 0, 0, 0, 96, 2005,
		1, 0, 0, 0, 98, 2032, 1, 0, 0, 0, 100, 2046, 1, 0, 0, 0, 102, 2049, 1,
		0, 0, 0, 104, 2070, 1, 0, 0, 0, 106, 2073, 1, 0, 0, 0, 108, 2130, 1, 0,
		0, 0, 110, 2132, 1, 0, 0, 0, 112, 2136, 1, 0, 0, 0, 114, 2145, 1, 0, 0,
		0, 116, 2161, 1, 0, 0, 0, 118, 2163, 1, 0, 0, 0, 120, 2171, 1, 0, 0, 0,
		122, 2197, 1, 0, 0, 0, 124, 2199, 1, 0, 0, 0, 126, 2211, 1, 0, 0, 0, 128,
		2226, 1, 0, 0, 0, 130, 2228, 1, 0, 0, 0, 132, 2231, 1, 0, 0, 0, 134, 2253,
		1, 0, 0, 0, 136, 2255, 1, 0, 0, 0, 138, 2261, 1, 0, 0, 0, 140, 2267, 1,
		0, 0, 0, 142, 2273, 1, 0, 0, 0, 144, 2279, 1, 0, 0, 0, 146, 2285, 1, 0,
		0, 0, 148, 2292, 1, 0, 0, 0, 150, 2300, 1, 0, 0, 0, 152, 2302, 1, 0, 0,
		0, 154, 2308, 1, 0, 0, 0, 156, 2314, 1, 0, 0, 0, 158, 2321, 1, 0, 0, 0,
		160, 2339, 1, 0, 0, 0, 162, 2341, 1, 0, 0, 0, 164, 2345, 1, 0, 0, 0, 166,
		2350, 1, 0, 0, 0, 168, 2366, 1, 0, 0, 0, 170, 2371, 1, 0, 0, 0, 172, 2404,
		1, 0, 0, 0, 174, 2435, 1, 0, 0, 0, 176, 2452, 1, 0, 0, 0, 178, 2454, 1,
		0, 0, 0, 180, 2474, 1, 0, 0, 0, 182, 2480, 1, 0, 0, 0, 184, 2486, 1, 0,
		0, 0, 186, 2492, 1, 0, 0, 0, 188, 2499, 1, 0, 0, 0, 190, 2508, 1, 0, 0,
		0, 192, 2525, 1, 0, 0, 0, 194, 2527, 1, 0, 0, 0, 196, 2534, 1, 0, 0, 0,
		198, 2544, 1, 0, 0, 0, 200, 2558, 1, 0, 0, 0, 202, 2564, 1, 0, 0, 0, 204,
		2572, 1, 0, 0, 0, 206, 2578, 1, 0, 0, 0, 208, 2586, 1, 0, 0, 0, 210, 2592,
		1, 0, 0, 0, 212, 2602, 1, 0, 0, 0, 214, 2606, 1, 0, 0, 0, 216, 2612, 1,
		0, 0, 0, 218, 2617, 1, 0, 0, 0, 220, 2628, 1, 0, 0, 0, 222, 2671, 1, 0,
		0, 0, 224, 2677, 1, 0, 0, 0, 226, 2679, 1, 0, 0, 0, 228, 2686, 1, 0, 0,
		0, 230, 2716, 1, 0, 0, 0, 232, 2718, 1, 0, 0, 0, 234, 2749, 1, 0, 0, 0,
		236, 2756, 1, 0, 0, 0, 238, 2760, 1, 0, 0, 0, 240, 2768, 1, 0, 0, 0, 242,
		2778, 1, 0, 0, 0, 244, 2780, 1, 0, 0, 0, 246, 2798, 1, 0, 0, 0, 248, 2810,
		1, 0, 0, 0, 250, 2815, 1, 0, 0, 0, 252, 2821, 1, 0, 0, 0, 254, 2854, 1,
		0, 0, 0, 256, 2856, 1, 0, 0, 0, 258, 2864, 1, 0, 0, 0, 260, 2873, 1, 0,
		0, 0, 262, 2881, 1, 0, 0, 0, 264, 2893, 1, 0, 0, 0, 266, 2916, 1, 0, 0,
		0, 268, 2930, 1, 0, 0, 0, 270, 2934, 1, 0, 0, 0, 272, 2966, 1, 0, 0, 0,
		274, 2981, 1, 0, 0, 0, 276, 2996, 1, 0, 0, 0, 278, 2998, 1, 0, 0, 0, 280,
		3025, 1, 0, 0, 0, 282, 3027, 1, 0, 0, 0, 284, 3029, 1, 0, 0, 0, 286, 3032,
		1, 0, 0, 0, 288, 3035, 1, 0, 0, 0, 290, 3042, 1, 0, 0, 0, 292, 3044, 1,
		0, 0, 0, 294, 3074, 1, 0, 0, 0, 296, 3086, 1, 0, 0, 0, 298, 3089, 1, 0,
		0, 0, 300, 3098, 1, 0, 0, 0, 302, 3102, 1, 0, 0, 0, 304, 3107, 1, 0, 0,
		0, 306, 3120, 1, 0, 0, 0, 308, 3125, 1, 0, 0, 0, 310, 3129, 1, 0, 0, 0,
		312, 3145, 1, 0, 0, 0, 314, 3147, 1, 0, 0, 0, 316, 3165, 1, 0, 0, 0, 318,
		3167, 1, 0, 0, 0, 320, 3176, 1, 0, 0, 0, 322, 3188, 1, 0, 0, 0, 324, 3195,
		1, 0, 0, 0, 326, 3206, 1, 0, 0, 0, 328, 3208, 1, 0, 0, 0, 330, 3212, 1,
		0, 0, 0, 332, 3214, 1, 0, 0, 0, 334, 3219, 1, 0, 0, 0, 336, 3227, 1, 0,
		0, 0, 338, 3236, 1, 0, 0, 0, 340, 3239, 1, 0, 0, 0, 342, 3254, 1, 0, 0,
		0, 344, 3257, 1, 0, 0, 0, 346, 3276, 1, 0, 0, 0, 348, 3281, 1, 0, 0, 0,
		350, 3286, 1, 0, 0, 0, 352, 3290, 1, 0, 0, 0, 354, 3304, 1, 0, 0, 0, 356,
		3307, 1, 0, 0, 0, 358, 3313, 1, 0, 0, 0, 360, 3326, 1, 0, 0, 0, 362, 3334,
		1, 0, 0, 0, 364, 3360, 1, 0, 0, 0, 366, 3373, 1, 0, 0, 0, 368, 3380, 1,
		0, 0, 0, 370, 3382, 1, 0, 0, 0, 372, 3394, 1, 0, 0, 0, 374, 3396, 1, 0,
		0, 0, 376, 3406, 1, 0, 0, 0, 378, 3430, 1, 0, 0, 0, 380, 3432, 1, 0, 0,
		0, 382, 3439, 1, 0, 0, 0, 384, 3449, 1, 0, 0, 0, 386, 3484, 1, 0, 0, 0,
		388, 3494, 1, 0, 0, 0, 390, 3496, 1, 0, 0, 0, 392, 3500, 1, 0, 0, 0, 394,
		3508, 1, 0, 0, 0, 396, 3510, 1, 0, 0, 0, 398, 3515, 1, 0, 0, 0, 400, 3519,
		1, 0, 0, 0, 402, 3547, 1, 0, 0, 0, 404, 3549, 1, 0, 0, 0, 406, 3551, 1,
		0, 0, 0, 408, 3559, 1, 0, 0, 0, 410, 3561, 1, 0, 0, 0, 412, 3569, 1, 0,
		0, 0, 414, 3579, 1, 0, 0, 0, 416, 3583, 1, 0, 0, 0, 418, 3608, 1, 0, 0,
		0, 420, 3635, 1, 0, 0, 0, 422, 3637, 1, 0, 0, 0, 424, 3647, 1, 0, 0, 0,
		426, 3678, 1, 0, 0, 0, 428, 3702, 1, 0, 0, 0, 430, 3704, 1, 0, 0, 0, 432,
		3718, 1, 0, 0, 0, 434, 3720, 1, 0, 0, 0, 436, 3755, 1, 0, 0, 0, 438, 3757,
		1, 0, 0, 0, 440, 3799, 1, 0, 0, 0, 442, 3815, 1, 0, 0, 0, 444, 3817, 1,
		0, 0, 0, 446, 3825, 1, 0, 0, 0, 448, 3834, 1, 0, 0, 0, 450, 3841, 1, 0,
		0, 0, 452, 3940, 1, 0, 0, 0, 454, 3944, 1, 0, 0, 0, 456, 3946, 1, 0, 0,
		0, 458, 3950, 1, 0, 0, 0, 460, 3964, 1, 0, 0, 0, 462, 3966, 1, 0, 0, 0,
		464, 3979, 1, 0, 0, 0, 466, 4043, 1, 0, 0, 0, 468, 4045, 1, 0, 0, 0, 470,
		4053, 1, 0, 0, 0, 472, 4061, 1, 0, 0, 0, 474, 4069, 1, 0, 0, 0, 476, 4071,
		1, 0, 0, 0, 478, 4100, 1, 0, 0, 0, 480, 4109, 1, 0, 0, 0, 482, 4140, 1,
		0, 0, 0, 484, 4142, 1, 0, 0, 0, 486, 4150, 1, 0, 0, 0, 488, 4152, 1, 0,
		0, 0, 490, 4166, 1, 0, 0, 0, 492, 4168, 1, 0, 0, 0, 494, 4174, 1, 0, 0,
		0, 496, 4182, 1, 0, 0, 0, 498, 4219, 1, 0, 0, 0, 500, 4221, 1, 0, 0, 0,
		502, 4236, 1, 0, 0, 0, 504, 4238, 1, 0, 0, 0, 506, 4300, 1, 0, 0, 0, 508,
		4302, 1, 0, 0, 0, 510, 4305, 1, 0, 0, 0, 512, 4330, 1, 0, 0, 0, 514, 4339,
		1, 0, 0, 0, 516, 4341, 1, 0, 0, 0, 518, 4346, 1, 0, 0, 0, 520, 4392, 1,
		0, 0, 0, 522, 4394, 1, 0, 0, 0, 524, 4402, 1, 0, 0, 0, 526, 4451, 1, 0,
		0, 0, 528, 4464, 1, 0, 0, 0, 530, 4466, 1, 0, 0, 0, 532, 4469, 1, 0, 0,
		0, 534, 4480, 1, 0, 0, 0, 536, 4485, 1, 0, 0, 0, 538, 4488, 1, 0, 0, 0,
		540, 4503, 1, 0, 0, 0, 542, 4553, 1, 0, 0, 0, 544, 4555, 1, 0, 0, 0, 546,
		4557, 1, 0, 0, 0, 548, 4606, 1, 0, 0, 0, 550, 4624, 1, 0, 0, 0, 552, 4626,
		1, 0, 0, 0, 554, 4642, 1, 0, 0, 0, 556, 4654, 1, 0, 0, 0, 558, 4679, 1,
		0, 0, 0, 560, 4681, 1, 0, 0, 0, 562, 4689, 1, 0, 0, 0, 564, 4738, 1, 0,
		0, 0, 566, 4753, 1, 0, 0, 0, 568, 4758, 1, 0, 0, 0, 570, 4760, 1, 0, 0,
		0, 572, 4784, 1, 0, 0, 0, 574, 4786, 1, 0, 0, 0, 576, 4845, 1, 0, 0, 0,
		578, 4856, 1, 0, 0, 0, 580, 4858, 1, 0, 0, 0, 582, 4861, 1, 0, 0, 0, 584,
		4874, 1, 0, 0, 0, 586, 4902, 1, 0, 0, 0, 588, 4910, 1, 0, 0, 0, 590, 4912,
		1, 0, 0, 0, 592, 4923, 1, 0, 0, 0, 594, 4925, 1, 0, 0, 0, 596, 4933, 1,
		0, 0, 0, 598, 4935, 1, 0, 0, 0, 600, 5163, 1, 0, 0, 0, 602, 5170, 1, 0,
		0, 0, 604, 5172, 1, 0, 0, 0, 606, 5174, 1, 0, 0, 0, 608, 5184, 1, 0, 0,
		0, 610, 5223, 1, 0, 0, 0, 612, 5227, 1, 0, 0, 0, 614, 5229, 1, 0, 0, 0,
		616, 5237, 1, 0, 0, 0, 618, 5241, 1, 0, 0, 0, 620, 5249, 1, 0, 0, 0, 622,
		5258, 1, 0, 0, 0, 624, 5260, 1, 0, 0, 0, 626, 5283, 1, 0, 0, 0, 628, 5285,
		1, 0, 0, 0, 630, 5287, 1, 0, 0, 0, 632, 5303, 1, 0, 0, 0, 634, 5315, 1,
		0, 0, 0, 636, 5317, 1, 0, 0, 0, 638, 5325, 1, 0, 0, 0, 640, 5333, 1, 0,
		0, 0, 642, 5342, 1, 0, 0, 0, 644, 5344, 1, 0, 0, 0, 646, 5362, 1, 0, 0,
		0, 648, 5376, 1, 0, 0, 0, 650, 5381, 1, 0, 0, 0, 652, 5387, 1, 0, 0, 0,
		654, 5389, 1, 0, 0, 0, 656, 5405, 1, 0, 0, 0, 658, 5413, 1, 0, 0, 0, 660,
		5423, 1, 0, 0, 0, 662, 5436, 1, 0, 0, 0, 664, 5438, 1, 0, 0, 0, 666, 5444,
		1, 0, 0, 0, 668, 5476, 1, 0, 0, 0, 670, 5478, 1, 0, 0, 0, 672, 5481, 1,
		0, 0, 0, 674, 5484, 1, 0, 0, 0, 676, 5497, 1, 0, 0, 0, 678, 5513, 1, 0,
		0, 0, 680, 5536, 1, 0, 0, 0, 682, 5538, 1, 0, 0, 0, 684, 5575, 1, 0, 0,
		0, 686, 5577, 1, 0, 0, 0, 688, 5718, 1, 0, 0, 0, 690, 5731, 1, 0, 0, 0,
		692, 5740, 1, 0, 0, 0, 694, 5873, 1, 0, 0, 0, 696, 5875, 1, 0, 0, 0, 698,
		5922, 1, 0, 0, 0, 700, 5924, 1, 0, 0, 0, 702, 5929, 1, 0, 0, 0, 704, 5938,
		1, 0, 0, 0, 706, 5957, 1, 0, 0, 0, 708, 5960, 1, 0, 0, 0, 710, 5969, 1,
		0, 0, 0, 712, 5971, 1, 0, 0, 0, 714, 5994, 1, 0, 0, 0, 716, 6269, 1, 0,
		0, 0, 718, 6302, 1, 0, 0, 0, 720, 6304, 1, 0, 0, 0, 722, 6310, 1, 0, 0,
		0, 724, 6313, 1, 0, 0, 0, 726, 6328, 1, 0, 0, 0, 728, 6336, 1, 0, 0, 0,
		730, 6338, 1, 0, 0, 0, 732, 6367, 1, 0, 0, 0, 734, 6400, 1, 0, 0, 0, 736,
		6402, 1, 0, 0, 0, 738, 6410, 1, 0, 0, 0, 740, 6416, 1, 0, 0, 0, 742, 6421,
		1, 0, 0, 0, 744, 6423, 1, 0, 0, 0, 746, 6445, 1, 0, 0, 0, 748, 6447, 1,
		0, 0, 0, 750, 6450, 1, 0, 0, 0, 752, 6453, 1, 0, 0, 0, 754, 6501, 1, 0,
		0, 0, 756, 6503, 1, 0, 0, 0, 758, 6514, 1, 0, 0, 0, 760, 6516, 1, 0, 0,
		0, 762, 6518, 1, 0, 0, 0, 764, 6522, 1, 0, 0, 0, 766, 6524, 1, 0, 0, 0,
		768, 6526, 1, 0, 0, 0, 770, 6530, 1, 0, 0, 0, 772, 6534, 1, 0, 0, 0, 774,
		6538, 1, 0, 0, 0, 776, 6546, 1, 0, 0, 0, 778, 6550, 1, 0, 0, 0, 780, 6558,
		1, 0, 0, 0, 782, 6560, 1, 0, 0, 0, 784, 6578, 1, 0, 0, 0, 786, 6580, 1,
		0, 0, 0, 788, 6583, 1, 0, 0, 0, 790, 6588, 1, 0, 0, 0, 792, 6596, 1, 0,
		0, 0, 794, 6602, 1, 0, 0, 0, 796, 6606, 1, 0, 0, 0, 798, 6623, 1, 0, 0,
		0, 800, 6626, 1, 0, 0, 0, 802, 6631, 1, 0, 0, 0, 804, 6633, 1, 0, 0, 0,
		806, 6636, 1, 0, 0, 0, 808, 6645, 1, 0, 0, 0, 810, 6653, 1, 0, 0, 0, 812,
		6655, 1, 0, 0, 0, 814, 6660, 1, 0, 0, 0, 816, 6667, 1, 0, 0, 0, 818, 6677,
		1, 0, 0, 0, 820, 6685, 1, 0, 0, 0, 822, 6687, 1, 0, 0, 0, 824, 6697, 1,
		0, 0, 0, 826, 6705, 1, 0, 0, 0, 828, 6707, 1, 0, 0, 0, 830, 6713, 1, 0,
		0, 0, 832, 6734, 1, 0, 0, 0, 834, 6736, 1, 0, 0, 0, 836, 6742, 1, 0, 0,
		0, 838, 6745, 1, 0, 0, 0, 840, 6748, 1, 0, 0, 0, 842, 6778, 1, 0, 0, 0,
		844, 6782, 1, 0, 0, 0, 846, 6789, 1, 0, 0, 0, 848, 6796, 1, 0, 0, 0, 850,
		6798, 1, 0, 0, 0, 852, 6814, 1, 0, 0, 0, 854, 6830, 1, 0, 0, 0, 856, 6834,
		1, 0, 0, 0, 858, 6837, 1, 0, 0, 0, 860, 6840, 1, 0, 0, 0, 862, 6864, 1,
		0, 0, 0, 864, 6866, 1, 0, 0, 0, 866, 6874, 1, 0, 0, 0, 868, 6876, 1, 0,
		0, 0, 870, 6880, 1, 0, 0, 0, 872, 6959, 1, 0, 0, 0, 874, 6961, 1, 0, 0,
		0, 876, 6965, 1, 0, 0, 0, 878, 7055, 1, 0, 0, 0, 880, 7057, 1, 0, 0, 0,
		882, 7059, 1, 0, 0, 0, 884, 7075, 1, 0, 0, 0, 886, 7077, 1, 0, 0, 0, 888,
		7109, 1, 0, 0, 0, 890, 7111, 1, 0, 0, 0, 892, 7122, 1, 0, 0, 0, 894, 7129,
		1, 0, 0, 0, 896, 7145, 1, 0, 0, 0, 898, 7151, 1, 0, 0, 0, 900, 7153, 1,
		0, 0, 0, 902, 7157, 1, 0, 0, 0, 904, 7168, 1, 0, 0, 0, 906, 7170, 1, 0,
		0, 0, 908, 7172, 1, 0, 0, 0, 910, 7179, 1, 0, 0, 0, 912, 7181, 1, 0, 0,
		0, 914, 7183, 1, 0, 0, 0, 916, 7333, 1, 0, 0, 0, 918, 7338, 1, 0, 0, 0,
		920, 7345, 1, 0, 0, 0, 922, 7347, 1, 0, 0, 0, 924, 7355, 1, 0, 0, 0, 926,
		7373, 1, 0, 0, 0, 928, 7381, 1, 0, 0, 0, 930, 7389, 1, 0, 0, 0, 932, 7391,
		1, 0, 0, 0, 934, 7395, 1, 0, 0, 0, 936, 7403, 1, 0, 0, 0, 938, 7410, 1,
		0, 0, 0, 940, 7412, 1, 0, 0, 0, 942, 7423, 1, 0, 0, 0, 944, 7556, 1, 0,
		0, 0, 946, 7560, 1, 0, 0, 0, 948, 7563, 1, 0, 0, 0, 950, 7572, 1, 0, 0,
		0, 952, 7581, 1, 0, 0, 0, 954, 7589, 1, 0, 0, 0, 956, 7635, 1, 0, 0, 0,
		958, 7637, 1, 0, 0, 0, 960, 7658, 1, 0, 0, 0, 962, 7663, 1, 0, 0, 0, 964,
		7674, 1, 0, 0, 0, 966, 7719, 1, 0, 0, 0, 968, 7755, 1, 0, 0, 0, 970, 7757,
		1, 0, 0, 0, 972, 7765, 1, 0, 0, 0, 974, 7778, 1, 0, 0, 0, 976, 7780, 1,
		0, 0, 0, 978, 7784, 1, 0, 0, 0, 980, 7787, 1, 0, 0, 0, 982, 7792, 1, 0,
		0, 0, 984, 7796, 1, 0, 0, 0, 986, 7799, 1, 0, 0, 0, 988, 7802, 1, 0, 0,
		0, 990, 7806, 1, 0, 0, 0, 992, 7812, 1, 0, 0, 0, 994, 7820, 1, 0, 0, 0,
		996, 7828, 1, 0, 0, 0, 998, 7834, 1, 0, 0, 0, 1000, 7837, 1, 0, 0, 0, 1002,
		7855, 1, 0, 0, 0, 1004, 7857, 1, 0, 0, 0, 1006, 7863, 1, 0, 0, 0, 1008,
		7867, 1, 0, 0, 0, 1010, 7875, 1, 0, 0, 0, 1012, 7883, 1, 0, 0, 0, 1014,
		7891, 1, 0, 0, 0, 1016, 7920, 1, 0, 0, 0, 1018, 7951, 1, 0, 0, 0, 1020,
		7955, 1, 0, 0, 0, 1022, 7959, 1, 0, 0, 0, 1024, 7962, 1, 0, 0, 0, 1026,
		7973, 1, 0, 0, 0, 1028, 7975, 1, 0, 0, 0, 1030, 7980, 1, 0, 0, 0, 1032,
		7982, 1, 0, 0, 0, 1034, 7984, 1, 0, 0, 0, 1036, 7986, 1, 0, 0, 0, 1038,
		7995, 1, 0, 0, 0, 1040, 8001, 1, 0, 0, 0, 1042, 8003, 1, 0, 0, 0, 1044,
		8005, 1, 0, 0, 0, 1046, 8016, 1, 0, 0, 0, 1048, 8020, 1, 0, 0, 0, 1050,
		8022, 1, 0, 0, 0, 1052, 8024, 1, 0, 0, 0, 1054, 8026, 1, 0, 0, 0, 1056,
		8035, 1, 0, 0, 0, 1058, 8037, 1, 0, 0, 0, 1060, 8039, 1, 0, 0, 0, 1062,
		8041, 1, 0, 0, 0, 1064, 8043, 1, 0, 0, 0, 1066, 8045, 1, 0, 0, 0, 1068,
		8047, 1, 0, 0, 0, 1070, 8049, 1, 0, 0, 0, 1072, 8053, 1, 0, 0, 0, 1074,
		8057, 1, 0, 0, 0, 1076, 8059, 1, 0, 0, 0, 1078, 8061, 1, 0, 0, 0, 1080,
		8063, 1, 0, 0, 0, 1082, 8065, 1, 0, 0, 0, 1084, 8067, 1, 0, 0, 0, 1086,
		8069, 1, 0, 0, 0, 1088, 8071, 1, 0, 0, 0, 1090, 8073, 1, 0, 0, 0, 1092,
		8075, 1, 0, 0, 0, 1094, 8077, 1, 0, 0, 0, 1096, 8081, 1, 0, 0, 0, 1098,
		8083, 1, 0, 0, 0, 1100, 8086, 1, 0, 0, 0, 1102, 8098, 1, 0, 0, 0, 1104,
		8100, 1, 0, 0, 0, 1106, 8108, 1, 0, 0, 0, 1108, 8116, 1, 0, 0, 0, 1110,
		8120, 1, 0, 0, 0, 1112, 8122, 1, 0, 0, 0, 1114, 8126, 1, 0, 0, 0, 1116,
		8128, 1, 0, 0, 0, 1118, 8130, 1, 0, 0, 0, 1120, 8132, 1, 0, 0, 0, 1122,
		8134, 1, 0, 0, 0, 1124, 8136, 1, 0, 0, 0, 1126, 8141, 1, 0, 0, 0, 1128,
		8145, 1, 0, 0, 0, 1130, 8147, 1, 0, 0, 0, 1132, 8155, 1, 0, 0, 0, 1134,
		8159, 1, 0, 0, 0, 1136, 8174, 1, 0, 0, 0, 1138, 8176, 1, 0, 0, 0, 1140,
		8179, 1, 0, 0, 0, 1142, 8181, 1, 0, 0, 0, 1144, 8183, 1, 0, 0, 0, 1146,
		8190, 1, 0, 0, 0, 1148, 8201, 1, 0, 0, 0, 1150, 8208, 1, 0, 0, 0, 1152,
		8210, 1, 0, 0, 0, 1154, 8224, 1, 0, 0, 0, 1156, 8229, 1, 0, 0, 0, 1158,
		8234, 1, 0, 0, 0, 1160, 8241, 1, 0, 0, 0, 1162, 8249, 1, 0, 0, 0, 1164,
		8251, 1, 0, 0, 0, 1166, 8259, 1, 0, 0, 0, 1168, 8261, 1, 0, 0, 0, 1170,
		8263, 1, 0, 0, 0, 1172, 8271, 1, 0, 0, 0, 1174, 8275, 1, 0, 0, 0, 1176,
		8277, 1, 0, 0, 0, 1178, 8279, 1, 0, 0, 0, 1180, 8287, 1, 0, 0, 0, 1182,
		8291, 1, 0, 0, 0, 1184, 8295, 1, 0, 0, 0, 1186, 8299, 1, 0, 0, 0, 1188,
		8301, 1, 0, 0, 0, 1190, 8304, 1, 0, 0, 0, 1192, 8306, 1, 0, 0, 0, 1194,
		8314, 1, 0, 0, 0, 1196, 8326, 1, 0, 0, 0, 1198, 8345, 1, 0, 0, 0, 1200,
		8347, 1, 0, 0, 0, 1202, 8349, 1, 0, 0, 0, 1204, 8369, 1, 0, 0, 0, 1206,
		8371, 1, 0, 0, 0, 1208, 8376, 1, 0, 0, 0, 1210, 8388, 1, 0, 0, 0, 1212,
		8394, 1, 0, 0, 0, 1214, 8396, 1, 0, 0, 0, 1216, 8403, 1, 0, 0, 0, 1218,
		8414, 1, 0, 0, 0, 1220, 1233, 5, 0, 0, 1, 1221, 1224, 3, 2, 1, 0, 1222,
		1224, 3, 422, 211, 0, 1223, 1221, 1, 0, 0, 0, 1223, 1222, 1, 0, 0, 0, 1224,
		1230, 1, 0, 0, 0, 1225, 1227, 5, 774, 0, 0, 1226, 1228, 5, 0, 0, 1, 1227,
		1226, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 1231, 1, 0, 0, 0, 1229,
		1231, 5, 0, 0, 1, 1230, 1225, 1, 0, 0, 0, 1230, 1229, 1, 0, 0, 0, 1231,
		1233, 1, 0, 0, 0, 1232, 1220, 1, 0, 0, 0, 1232, 1223, 1, 0, 0, 0, 1233,
		1, 1, 0, 0, 0, 1234, 1269, 3, 4, 2, 0, 1235, 1269, 3, 76, 38, 0, 1236,
		1269, 3, 178, 89, 0, 1237, 1269, 3, 210, 105, 0, 1238, 1269, 3, 214, 107,
		0, 1239, 1240, 4, 1, 0, 0, 1240, 1269, 3, 216, 108, 0, 1241, 1269, 3, 218,
		109, 0, 1242, 1269, 3, 220, 110, 0, 1243, 1269, 3, 226, 113, 0, 1244, 1269,
		3, 228, 114, 0, 1245, 1269, 3, 232, 116, 0, 1246, 1269, 3, 252, 126, 0,
		1247, 1269, 3, 264, 132, 0, 1248, 1269, 3, 266, 133, 0, 1249, 1269, 3,
		416, 208, 0, 1250, 1269, 3, 418, 209, 0, 1251, 1269, 3, 440, 220, 0, 1252,
		1269, 3, 490, 245, 0, 1253, 1254, 4, 1, 1, 0, 1254, 1269, 3, 496, 248,
		0, 1255, 1269, 3, 502, 251, 0, 1256, 1269, 3, 564, 282, 0, 1257, 1269,
		3, 572, 286, 0, 1258, 1269, 3, 574, 287, 0, 1259, 1269, 3, 598, 299, 0,
		1260, 1261, 4, 1, 2, 0, 1261, 1269, 3, 642, 321, 0, 1262, 1269, 3, 610,
		305, 0, 1263, 1269, 3, 662, 331, 0, 1264, 1265, 4, 1, 3, 0, 1265, 1269,
		3, 840, 420, 0, 1266, 1269, 3, 850, 425, 0, 1267, 1269, 3, 852, 426, 0,
		1268, 1234, 1, 0, 0, 0, 1268, 1235, 1, 0, 0, 0, 1268, 1236, 1, 0, 0, 0,
		1268, 1237, 1, 0, 0, 0, 1268, 1238, 1, 0, 0, 0, 1268, 1239, 1, 0, 0, 0,
		1268, 1241, 1, 0, 0, 0, 1268, 1242, 1, 0, 0, 0, 1268, 1243, 1, 0, 0, 0,
		1268, 1244, 1, 0, 0, 0, 1268, 1245, 1, 0, 0, 0, 1268, 1246, 1, 0, 0, 0,
		1268, 1247, 1, 0, 0, 0, 1268, 1248, 1, 0, 0, 0, 1268, 1249, 1, 0, 0, 0,
		1268, 1250, 1, 0, 0, 0, 1268, 1251, 1, 0, 0, 0, 1268, 1252, 1, 0, 0, 0,
		1268, 1253, 1, 0, 0, 0, 1268, 1255, 1, 0, 0, 0, 1268, 1256, 1, 0, 0, 0,
		1268, 1257, 1, 0, 0, 0, 1268, 1258, 1, 0, 0, 0, 1268, 1259, 1, 0, 0, 0,
		1268, 1260, 1, 0, 0, 0, 1268, 1262, 1, 0, 0, 0, 1268, 1263, 1, 0, 0, 0,
		1268, 1264, 1, 0, 0, 0, 1268, 1266, 1, 0, 0, 0, 1268, 1267, 1, 0, 0, 0,
		1269, 3, 1, 0, 0, 0, 1270, 1297, 5, 11, 0, 0, 1271, 1298, 3, 18, 9, 0,
		1272, 1298, 3, 6, 3, 0, 1273, 1274, 5, 422, 0, 0, 1274, 1276, 3, 1062,
		531, 0, 1275, 1277, 3, 102, 51, 0, 1276, 1275, 1, 0, 0, 0, 1276, 1277,
		1, 0, 0, 0, 1277, 1298, 1, 0, 0, 0, 1278, 1279, 5, 206, 0, 0, 1279, 1281,
		3, 1066, 533, 0, 1280, 1282, 3, 102, 51, 0, 1281, 1280, 1, 0, 0, 0, 1281,
		1282, 1, 0, 0, 0, 1282, 1298, 1, 0, 0, 0, 1283, 1298, 3, 68, 34, 0, 1284,
		1298, 3, 8, 4, 0, 1285, 1298, 3, 54, 27, 0, 1286, 1287, 4, 2, 4, 0, 1287,
		1298, 3, 56, 28, 0, 1288, 1298, 3, 10, 5, 0, 1289, 1298, 3, 16, 8, 0, 1290,
		1291, 4, 2, 5, 0, 1291, 1292, 5, 244, 0, 0, 1292, 1293, 5, 482, 0, 0, 1293,
		1294, 3, 1180, 590, 0, 1294, 1295, 5, 316, 0, 0, 1295, 1296, 5, 265, 0,
		0, 1296, 1298, 1, 0, 0, 0, 1297, 1271, 1, 0, 0, 0, 1297, 1272, 1, 0, 0,
		0, 1297, 1273, 1, 0, 0, 0, 1297, 1278, 1, 0, 0, 0, 1297, 1283, 1, 0, 0,
		0, 1297, 1284, 1, 0, 0, 0, 1297, 1285, 1, 0, 0, 0, 1297, 1286, 1, 0, 0,
		0, 1297, 1288, 1, 0, 0, 0, 1297, 1289, 1, 0, 0, 0, 1297, 1290, 1, 0, 0,
		0, 1298, 5, 1, 0, 0, 0, 1299, 1300, 5, 109, 0, 0, 1300, 1311, 3, 1058,
		529, 0, 1301, 1303, 3, 80, 40, 0, 1302, 1301, 1, 0, 0, 0, 1303, 1304, 1,
		0, 0, 0, 1304, 1302, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1312, 1,
		0, 0, 0, 1306, 1307, 4, 3, 6, 0, 1307, 1308, 5, 615, 0, 0, 1308, 1309,
		5, 112, 0, 0, 1309, 1310, 5, 139, 0, 0, 1310, 1312, 5, 357, 0, 0, 1311,
		1302, 1, 0, 0, 0, 1311, 1306, 1, 0, 0, 0, 1312, 7, 1, 0, 0, 0, 1313, 1315,
		3, 976, 488, 0, 1314, 1313, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 1316,
		1, 0, 0, 0, 1316, 1317, 5, 170, 0, 0, 1317, 1321, 3, 1086, 543, 0, 1318,
		1319, 5, 383, 0, 0, 1319, 1320, 5, 490, 0, 0, 1320, 1322, 3, 862, 431,
		0, 1321, 1318, 1, 0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1329, 1, 0, 0,
		0, 1323, 1324, 5, 383, 0, 0, 1324, 1326, 5, 79, 0, 0, 1325, 1327, 5, 371,
		0, 0, 1326, 1325, 1, 0, 0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1328, 1, 0,
		0, 0, 1328, 1330, 5, 418, 0, 0, 1329, 1323, 1, 0, 0, 0, 1329, 1330, 1,
		0, 0, 0, 1330, 1334, 1, 0, 0, 0, 1331, 1332, 5, 453, 0, 0, 1332, 1333,
		5, 590, 0, 0, 1333, 1335, 3, 1128, 564, 0, 1334, 1331, 1, 0, 0, 0, 1334,
		1335, 1, 0, 0, 0, 1335, 1342, 1, 0, 0, 0, 1336, 1343, 5, 156, 0, 0, 1337,
		1340, 5, 140, 0, 0, 1338, 1339, 5, 383, 0, 0, 1339, 1341, 5, 514, 0, 0,
		1340, 1338, 1, 0, 0, 0, 1340, 1341, 1, 0, 0, 0, 1341, 1343, 1, 0, 0, 0,
		1342, 1336, 1, 0, 0, 0, 1342, 1337, 1, 0, 0, 0, 1342, 1343, 1, 0, 0, 0,
		1343, 1346, 1, 0, 0, 0, 1344, 1345, 5, 75, 0, 0, 1345, 1347, 3, 1160, 580,
		0, 1346, 1344, 1, 0, 0, 0, 1346, 1347, 1, 0, 0, 0, 1347, 1350, 1, 0, 0,
		0, 1348, 1349, 5, 147, 0, 0, 1349, 1351, 3, 784, 392, 0, 1350, 1348, 1,
		0, 0, 0, 1350, 1351, 1, 0, 0, 0, 1351, 9, 1, 0, 0, 0, 1352, 1353, 5, 288,
		0, 0, 1353, 1354, 5, 217, 0, 0, 1354, 1355, 3, 1082, 541, 0, 1355, 1356,
		5, 4, 0, 0, 1356, 1357, 5, 603, 0, 0, 1357, 1359, 3, 1160, 580, 0, 1358,
		1360, 3, 12, 6, 0, 1359, 1358, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360,
		11, 1, 0, 0, 0, 1361, 1368, 3, 14, 7, 0, 1362, 1364, 5, 773, 0, 0, 1363,
		1362, 1, 0, 0, 0, 1363, 1364, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365,
		1367, 3, 14, 7, 0, 1366, 1363, 1, 0, 0, 0, 1367, 1370, 1, 0, 0, 0, 1368,
		1366, 1, 0, 0, 0, 1368, 1369, 1, 0, 0, 0, 1369, 13, 1, 0, 0, 0, 1370, 1368,
		1, 0, 0, 0, 1371, 1375, 3, 136, 68, 0, 1372, 1375, 3, 148, 74, 0, 1373,
		1375, 3, 150, 75, 0, 1374, 1371, 1, 0, 0, 0, 1374, 1372, 1, 0, 0, 0, 1374,
		1373, 1, 0, 0, 0, 1375, 15, 1, 0, 0, 0, 1376, 1377, 5, 503, 0, 0, 1377,
		1378, 3, 1092, 546, 0, 1378, 1379, 3, 120, 60, 0, 1379, 17, 1, 0, 0, 0,
		1380, 1382, 3, 1032, 516, 0, 1381, 1380, 1, 0, 0, 0, 1381, 1382, 1, 0,
		0, 0, 1382, 1385, 1, 0, 0, 0, 1383, 1384, 4, 9, 7, 0, 1384, 1386, 5, 232,
		0, 0, 1385, 1383, 1, 0, 0, 0, 1385, 1386, 1, 0, 0, 0, 1386, 1387, 1, 0,
		0, 0, 1387, 1388, 5, 574, 0, 0, 1388, 1390, 3, 1102, 551, 0, 1389, 1391,
		3, 20, 10, 0, 1390, 1389, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 19,
		1, 0, 0, 0, 1392, 1395, 3, 22, 11, 0, 1393, 1396, 3, 954, 477, 0, 1394,
		1396, 3, 50, 25, 0, 1395, 1393, 1, 0, 0, 0, 1395, 1394, 1, 0, 0, 0, 1395,
		1396, 1, 0, 0, 0, 1396, 1406, 1, 0, 0, 0, 1397, 1406, 3, 954, 477, 0, 1398,
		1406, 3, 50, 25, 0, 1399, 1400, 3, 24, 12, 0, 1400, 1401, 5, 773, 0, 0,
		1401, 1403, 1, 0, 0, 0, 1402, 1399, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0,
		1403, 1404, 1, 0, 0, 0, 1404, 1406, 3, 26, 13, 0, 1405, 1392, 1, 0, 0,
		0, 1405, 1397, 1, 0, 0, 0, 1405, 1398, 1, 0, 0, 0, 1405, 1402, 1, 0, 0,
		0, 1406, 21, 1, 0, 0, 0, 1407, 1415, 3, 24, 12, 0, 1408, 1409, 3, 24, 12,
		0, 1409, 1410, 5, 773, 0, 0, 1410, 1412, 1, 0, 0, 0, 1411, 1408, 1, 0,
		0, 0, 1411, 1412, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 1415, 3, 30,
		15, 0, 1414, 1407, 1, 0, 0, 0, 1414, 1411, 1, 0, 0, 0, 1415, 23, 1, 0,
		0, 0, 1416, 1421, 3, 32, 16, 0, 1417, 1418, 5, 773, 0, 0, 1418, 1420, 3,
		32, 16, 0, 1419, 1417, 1, 0, 0, 0, 1420, 1423, 1, 0, 0, 0, 1421, 1419,
		1, 0, 0, 0, 1421, 1422, 1, 0, 0, 0, 1422, 25, 1, 0, 0, 0, 1423, 1421, 1,
		0, 0, 0, 1424, 1425, 5, 141, 0, 0, 1425, 1432, 5, 572, 0, 0, 1426, 1427,
		5, 234, 0, 0, 1427, 1432, 5, 572, 0, 0, 1428, 1432, 3, 28, 14, 0, 1429,
		1430, 4, 13, 8, 0, 1430, 1432, 7, 0, 0, 0, 1431, 1424, 1, 0, 0, 0, 1431,
		1426, 1, 0, 0, 0, 1431, 1428, 1, 0, 0, 0, 1431, 1429, 1, 0, 0, 0, 1432,
		27, 1, 0, 0, 0, 1433, 1434, 5, 4, 0, 0, 1434, 1436, 5, 405, 0, 0, 1435,
		1437, 3, 1034, 517, 0, 1436, 1435, 1, 0, 0, 0, 1436, 1437, 1, 0, 0, 0,
		1437, 1441, 1, 0, 0, 0, 1438, 1442, 3, 962, 481, 0, 1439, 1440, 5, 404,
		0, 0, 1440, 1442, 3, 1142, 571, 0, 1441, 1438, 1, 0, 0, 0, 1441, 1439,
		1, 0, 0, 0, 1442, 1530, 1, 0, 0, 0, 1443, 1444, 5, 148, 0, 0, 1444, 1445,
		5, 405, 0, 0, 1445, 1530, 3, 1130, 565, 0, 1446, 1447, 5, 438, 0, 0, 1447,
		1449, 5, 405, 0, 0, 1448, 1450, 3, 1034, 517, 0, 1449, 1448, 1, 0, 0, 0,
		1449, 1450, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451, 1530, 3, 52, 26,
		0, 1452, 1453, 5, 388, 0, 0, 1453, 1455, 5, 405, 0, 0, 1454, 1456, 3, 1034,
		517, 0, 1455, 1454, 1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1457, 1,
		0, 0, 0, 1457, 1459, 3, 52, 26, 0, 1458, 1460, 3, 1034, 517, 0, 1459, 1458,
		1, 0, 0, 0, 1459, 1460, 1, 0, 0, 0, 1460, 1530, 1, 0, 0, 0, 1461, 1462,
		5, 14, 0, 0, 1462, 1464, 5, 405, 0, 0, 1463, 1465, 3, 1034, 517, 0, 1464,
		1463, 1, 0, 0, 0, 1464, 1465, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466,
		1530, 3, 52, 26, 0, 1467, 1468, 5, 62, 0, 0, 1468, 1469, 5, 405, 0, 0,
		1469, 1473, 3, 52, 26, 0, 1470, 1472, 3, 568, 284, 0, 1471, 1470, 1, 0,
		0, 0, 1472, 1475, 1, 0, 0, 0, 1473, 1471, 1, 0, 0, 0, 1473, 1474, 1, 0,
		0, 0, 1474, 1530, 1, 0, 0, 0, 1475, 1473, 1, 0, 0, 0, 1476, 1477, 5, 455,
		0, 0, 1477, 1479, 5, 405, 0, 0, 1478, 1480, 3, 1034, 517, 0, 1479, 1478,
		1, 0, 0, 0, 1479, 1480, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1485,
		3, 52, 26, 0, 1482, 1484, 3, 570, 285, 0, 1483, 1482, 1, 0, 0, 0, 1484,
		1487, 1, 0, 0, 0, 1485, 1483, 1, 0, 0, 0, 1485, 1486, 1, 0, 0, 0, 1486,
		1530, 1, 0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1488, 1489, 5, 67, 0, 0, 1489,
		1491, 5, 405, 0, 0, 1490, 1492, 3, 1034, 517, 0, 1491, 1490, 1, 0, 0, 0,
		1491, 1492, 1, 0, 0, 0, 1492, 1493, 1, 0, 0, 0, 1493, 1530, 3, 1142, 571,
		0, 1494, 1495, 5, 597, 0, 0, 1495, 1496, 5, 405, 0, 0, 1496, 1530, 3, 52,
		26, 0, 1497, 1498, 5, 454, 0, 0, 1498, 1500, 5, 405, 0, 0, 1499, 1501,
		3, 1034, 517, 0, 1500, 1499, 1, 0, 0, 0, 1500, 1501, 1, 0, 0, 0, 1501,
		1506, 1, 0, 0, 0, 1502, 1503, 3, 1130, 565, 0, 1503, 1504, 5, 248, 0, 0,
		1504, 1505, 3, 962, 481, 0, 1505, 1507, 1, 0, 0, 0, 1506, 1502, 1, 0, 0,
		0, 1506, 1507, 1, 0, 0, 0, 1507, 1530, 1, 0, 0, 0, 1508, 1509, 5, 172,
		0, 0, 1509, 1510, 5, 405, 0, 0, 1510, 1511, 3, 1128, 564, 0, 1511, 1512,
		5, 645, 0, 0, 1512, 1513, 5, 574, 0, 0, 1513, 1515, 3, 1102, 551, 0, 1514,
		1516, 3, 48, 24, 0, 1515, 1514, 1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516,
		1530, 1, 0, 0, 0, 1517, 1518, 4, 14, 9, 0, 1518, 1519, 5, 141, 0, 0, 1519,
		1520, 5, 405, 0, 0, 1520, 1521, 3, 52, 26, 0, 1521, 1522, 5, 572, 0, 0,
		1522, 1530, 1, 0, 0, 0, 1523, 1524, 4, 14, 10, 0, 1524, 1525, 5, 234, 0,
		0, 1525, 1526, 5, 405, 0, 0, 1526, 1527, 3, 52, 26, 0, 1527, 1528, 5, 572,
		0, 0, 1528, 1530, 1, 0, 0, 0, 1529, 1433, 1, 0, 0, 0, 1529, 1443, 1, 0,
		0, 0, 1529, 1446, 1, 0, 0, 0, 1529, 1452, 1, 0, 0, 0, 1529, 1461, 1, 0,
		0, 0, 1529, 1467, 1, 0, 0, 0, 1529, 1476, 1, 0, 0, 0, 1529, 1488, 1, 0,
		0, 0, 1529, 1494, 1, 0, 0, 0, 1529, 1497, 1, 0, 0, 0, 1529, 1508, 1, 0,
		0, 0, 1529, 1517, 1, 0, 0, 0, 1529, 1523, 1, 0, 0, 0, 1530, 29, 1, 0, 0,
		0, 1531, 1534, 3, 34, 17, 0, 1532, 1534, 3, 942, 471, 0, 1533, 1531, 1,
		0, 0, 0, 1533, 1532, 1, 0, 0, 0, 1534, 1543, 1, 0, 0, 0, 1535, 1539, 5,
		773, 0, 0, 1536, 1540, 3, 34, 17, 0, 1537, 1540, 3, 32, 16, 0, 1538, 1540,
		3, 942, 471, 0, 1539, 1536, 1, 0, 0, 0, 1539, 1537, 1, 0, 0, 0, 1539, 1538,
		1, 0, 0, 0, 1540, 1542, 1, 0, 0, 0, 1541, 1535, 1, 0, 0, 0, 1542, 1545,
		1, 0, 0, 0, 1543, 1541, 1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 31, 1,
		0, 0, 0, 1545, 1543, 1, 0, 0, 0, 1546, 1550, 3, 42, 21, 0, 1547, 1550,
		3, 44, 22, 0, 1548, 1550, 3, 48, 24, 0, 1549, 1546, 1, 0, 0, 0, 1549, 1547,
		1, 0, 0, 0, 1549, 1548, 1, 0, 0, 0, 1550, 33, 1, 0, 0, 0, 1551, 1553, 5,
		4, 0, 0, 1552, 1554, 5, 72, 0, 0, 1553, 1552, 1, 0, 0, 0, 1553, 1554, 1,
		0, 0, 0, 1554, 1567, 1, 0, 0, 0, 1555, 1556, 3, 1128, 564, 0, 1556, 1558,
		3, 876, 438, 0, 1557, 1559, 3, 866, 433, 0, 1558, 1557, 1, 0, 0, 0, 1558,
		1559, 1, 0, 0, 0, 1559, 1561, 1, 0, 0, 0, 1560, 1562, 3, 36, 18, 0, 1561,
		1560, 1, 0, 0, 0, 1561, 1562, 1, 0, 0, 0, 1562, 1568, 1, 0, 0, 0, 1563,
		1564, 5, 776, 0, 0, 1564, 1565, 3, 84, 42, 0, 1565, 1566, 5, 777, 0, 0,
		1566, 1568, 1, 0, 0, 0, 1567, 1555, 1, 0, 0, 0, 1567, 1563, 1, 0, 0, 0,
		1568, 1697, 1, 0, 0, 0, 1569, 1570, 5, 4, 0, 0, 1570, 1697, 3, 872, 436,
		0, 1571, 1573, 5, 55, 0, 0, 1572, 1574, 5, 72, 0, 0, 1573, 1572, 1, 0,
		0, 0, 1573, 1574, 1, 0, 0, 0, 1574, 1575, 1, 0, 0, 0, 1575, 1576, 3, 1042,
		521, 0, 1576, 1577, 3, 1128, 564, 0, 1577, 1579, 3, 876, 438, 0, 1578,
		1580, 3, 36, 18, 0, 1579, 1578, 1, 0, 0, 0, 1579, 1580, 1, 0, 0, 0, 1580,
		1697, 1, 0, 0, 0, 1581, 1583, 5, 348, 0, 0, 1582, 1584, 5, 72, 0, 0, 1583,
		1582, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1585, 1, 0, 0, 0, 1585,
		1586, 3, 1042, 521, 0, 1586, 1588, 3, 876, 438, 0, 1587, 1589, 3, 36, 18,
		0, 1588, 1587, 1, 0, 0, 0, 1588, 1589, 1, 0, 0, 0, 1589, 1697, 1, 0, 0,
		0, 1590, 1619, 5, 148, 0, 0, 1591, 1593, 5, 72, 0, 0, 1592, 1591, 1, 0,
		0, 0, 1592, 1593, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1596, 3, 1042,
		521, 0, 1595, 1597, 3, 38, 19, 0, 1596, 1595, 1, 0, 0, 0, 1596, 1597, 1,
		0, 0, 0, 1597, 1620, 1, 0, 0, 0, 1598, 1599, 5, 199, 0, 0, 1599, 1606,
		5, 265, 0, 0, 1600, 1601, 4, 17, 11, 0, 1601, 1607, 3, 1042, 521, 0, 1602,
		1604, 4, 17, 12, 0, 1603, 1605, 3, 1042, 521, 0, 1604, 1603, 1, 0, 0, 0,
		1604, 1605, 1, 0, 0, 0, 1605, 1607, 1, 0, 0, 0, 1606, 1600, 1, 0, 0, 0,
		1606, 1602, 1, 0, 0, 0, 1607, 1620, 1, 0, 0, 0, 1608, 1609, 5, 420, 0,
		0, 1609, 1620, 5, 265, 0, 0, 1610, 1611, 3, 406, 203, 0, 1611, 1612, 3,
		1052, 526, 0, 1612, 1620, 1, 0, 0, 0, 1613, 1614, 4, 17, 13, 0, 1614, 1615,
		5, 62, 0, 0, 1615, 1620, 3, 1128, 564, 0, 1616, 1617, 4, 17, 14, 0, 1617,
		1618, 5, 86, 0, 0, 1618, 1620, 3, 1128, 564, 0, 1619, 1592, 1, 0, 0, 0,
		1619, 1598, 1, 0, 0, 0, 1619, 1608, 1, 0, 0, 0, 1619, 1610, 1, 0, 0, 0,
		1619, 1613, 1, 0, 0, 0, 1619, 1616, 1, 0, 0, 0, 1620, 1697, 1, 0, 0, 0,
		1621, 1622, 5, 140, 0, 0, 1622, 1697, 5, 263, 0, 0, 1623, 1624, 5, 156,
		0, 0, 1624, 1697, 5, 263, 0, 0, 1625, 1627, 5, 11, 0, 0, 1626, 1628, 5,
		72, 0, 0, 1627, 1626, 1, 0, 0, 0, 1627, 1628, 1, 0, 0, 0, 1628, 1629, 1,
		0, 0, 0, 1629, 1639, 3, 1042, 521, 0, 1630, 1631, 5, 506, 0, 0, 1631, 1635,
		5, 128, 0, 0, 1632, 1633, 4, 17, 15, 0, 1633, 1636, 3, 770, 385, 0, 1634,
		1636, 3, 1150, 575, 0, 1635, 1632, 1, 0, 0, 0, 1635, 1634, 1, 0, 0, 0,
		1636, 1640, 1, 0, 0, 0, 1637, 1638, 5, 148, 0, 0, 1638, 1640, 5, 128, 0,
		0, 1639, 1630, 1, 0, 0, 0, 1639, 1637, 1, 0, 0, 0, 1640, 1697, 1, 0, 0,
		0, 1641, 1642, 4, 17, 16, 0, 1642, 1643, 5, 11, 0, 0, 1643, 1644, 5, 236,
		0, 0, 1644, 1645, 3, 1052, 526, 0, 1645, 1646, 3, 906, 453, 0, 1646, 1697,
		1, 0, 0, 0, 1647, 1648, 4, 17, 17, 0, 1648, 1649, 5, 11, 0, 0, 1649, 1650,
		5, 62, 0, 0, 1650, 1651, 3, 1128, 564, 0, 1651, 1652, 3, 870, 435, 0, 1652,
		1697, 1, 0, 0, 0, 1653, 1654, 4, 17, 18, 0, 1654, 1655, 5, 11, 0, 0, 1655,
		1656, 5, 86, 0, 0, 1656, 1657, 3, 1128, 564, 0, 1657, 1658, 3, 870, 435,
		0, 1658, 1697, 1, 0, 0, 0, 1659, 1660, 4, 17, 19, 0, 1660, 1661, 5, 453,
		0, 0, 1661, 1662, 5, 72, 0, 0, 1662, 1663, 3, 1042, 521, 0, 1663, 1664,
		5, 590, 0, 0, 1664, 1665, 3, 1128, 564, 0, 1665, 1697, 1, 0, 0, 0, 1666,
		1668, 5, 453, 0, 0, 1667, 1669, 7, 1, 0, 0, 1668, 1667, 1, 0, 0, 0, 1668,
		1669, 1, 0, 0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1697, 3, 1096, 548, 0,
		1671, 1672, 4, 17, 20, 0, 1672, 1673, 5, 453, 0, 0, 1673, 1674, 3, 406,
		203, 0, 1674, 1675, 3, 1052, 526, 0, 1675, 1676, 5, 590, 0, 0, 1676, 1677,
		3, 1050, 525, 0, 1677, 1697, 1, 0, 0, 0, 1678, 1679, 5, 94, 0, 0, 1679,
		1680, 5, 590, 0, 0, 1680, 1684, 3, 758, 379, 0, 1681, 1682, 4, 17, 21,
		0, 1682, 1685, 5, 128, 0, 0, 1683, 1685, 3, 936, 468, 0, 1684, 1681, 1,
		0, 0, 0, 1684, 1683, 1, 0, 0, 0, 1685, 1687, 1, 0, 0, 0, 1686, 1688, 3,
		986, 493, 0, 1687, 1686, 1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1697,
		1, 0, 0, 0, 1689, 1697, 5, 198, 0, 0, 1690, 1691, 5, 393, 0, 0, 1691, 1692,
		5, 45, 0, 0, 1692, 1697, 3, 40, 20, 0, 1693, 1694, 4, 17, 22, 0, 1694,
		1695, 5, 615, 0, 0, 1695, 1697, 5, 403, 0, 0, 1696, 1551, 1, 0, 0, 0, 1696,
		1569, 1, 0, 0, 0, 1696, 1571, 1, 0, 0, 0, 1696, 1581, 1, 0, 0, 0, 1696,
		1590, 1, 0, 0, 0, 1696, 1621, 1, 0, 0, 0, 1696, 1623, 1, 0, 0, 0, 1696,
		1625, 1, 0, 0, 0, 1696, 1641, 1, 0, 0, 0, 1696, 1647, 1, 0, 0, 0, 1696,
		1653, 1, 0, 0, 0, 1696, 1659, 1, 0, 0, 0, 1696, 1666, 1, 0, 0, 0, 1696,
		1671, 1, 0, 0, 0, 1696, 1678, 1, 0, 0, 0, 1696, 1689, 1, 0, 0, 0, 1696,
		1690, 1, 0, 0, 0, 1696, 1693, 1, 0, 0, 0, 1697, 35, 1, 0, 0, 0, 1698, 1699,
		5, 6, 0, 0, 1699, 1702, 3, 1128, 564, 0, 1700, 1702, 5, 191, 0, 0, 1701,
		1698, 1, 0, 0, 0, 1701, 1700, 1, 0, 0, 0, 1702, 37, 1, 0, 0, 0, 1703, 1704,
		7, 2, 0, 0, 1704, 39, 1, 0, 0, 0, 1705, 1707, 3, 1128, 564, 0, 1706, 1708,
		3, 330, 165, 0, 1707, 1706, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0, 1708, 1716,
		1, 0, 0, 0, 1709, 1710, 5, 773, 0, 0, 1710, 1712, 3, 1128, 564, 0, 1711,
		1713, 3, 330, 165, 0, 1712, 1711, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713,
		1715, 1, 0, 0, 0, 1714, 1709, 1, 0, 0, 0, 1715, 1718, 1, 0, 0, 0, 1716,
		1714, 1, 0, 0, 0, 1716, 1717, 1, 0, 0, 0, 1717, 41, 1, 0, 0, 0, 1718, 1716,
		1, 0, 0, 0, 1719, 1721, 5, 9, 0, 0, 1720, 1722, 5, 750, 0, 0, 1721, 1720,
		1, 0, 0, 0, 1721, 1722, 1, 0, 0, 0, 1722, 1725, 1, 0, 0, 0, 1723, 1726,
		5, 128, 0, 0, 1724, 1726, 3, 1128, 564, 0, 1725, 1723, 1, 0, 0, 0, 1725,
		1724, 1, 0, 0, 0, 1726, 43, 1, 0, 0, 0, 1727, 1729, 5, 287, 0, 0, 1728,
		1730, 5, 750, 0, 0, 1729, 1728, 1, 0, 0, 0, 1729, 1730, 1, 0, 0, 0, 1730,
		1733, 1, 0, 0, 0, 1731, 1734, 5, 128, 0, 0, 1732, 1734, 3, 1128, 564, 0,
		1733, 1731, 1, 0, 0, 0, 1733, 1732, 1, 0, 0, 0, 1734, 45, 1, 0, 0, 0, 1735,
		1737, 3, 42, 21, 0, 1736, 1738, 3, 44, 22, 0, 1737, 1736, 1, 0, 0, 0, 1737,
		1738, 1, 0, 0, 0, 1738, 1744, 1, 0, 0, 0, 1739, 1741, 3, 44, 22, 0, 1740,
		1742, 3, 42, 21, 0, 1741, 1740, 1, 0, 0, 0, 1741, 1742, 1, 0, 0, 0, 1742,
		1744, 1, 0, 0, 0, 1743, 1735, 1, 0, 0, 0, 1743, 1739, 1, 0, 0, 0, 1744,
		47, 1, 0, 0, 0, 1745, 1746, 4, 24, 23, 0, 1746, 1747, 7, 3, 0, 0, 1747,
		1748, 5, 625, 0, 0, 1748, 49, 1, 0, 0, 0, 1749, 1750, 5, 452, 0, 0, 1750,
		1751, 5, 403, 0, 0, 1751, 51, 1, 0, 0, 0, 1752, 1755, 5, 10, 0, 0, 1753,
		1755, 3, 1130, 565, 0, 1754, 1752, 1, 0, 0, 0, 1754, 1753, 1, 0, 0, 0,
		1755, 53, 1, 0, 0, 0, 1756, 1757, 5, 572, 0, 0, 1757, 1791, 3, 1078, 539,
		0, 1758, 1759, 7, 4, 0, 0, 1759, 1760, 5, 111, 0, 0, 1760, 1762, 3, 1160,
		580, 0, 1761, 1763, 3, 62, 31, 0, 1762, 1761, 1, 0, 0, 0, 1762, 1763, 1,
		0, 0, 0, 1763, 1792, 1, 0, 0, 0, 1764, 1784, 4, 27, 24, 0, 1765, 1785,
		1, 0, 0, 0, 1766, 1767, 5, 55, 0, 0, 1767, 1768, 5, 111, 0, 0, 1768, 1779,
		3, 1160, 580, 0, 1769, 1776, 3, 66, 33, 0, 1770, 1772, 5, 773, 0, 0, 1771,
		1770, 1, 0, 0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 1773, 1, 0, 0, 0, 1773,
		1775, 3, 66, 33, 0, 1774, 1771, 1, 0, 0, 0, 1775, 1778, 1, 0, 0, 0, 1776,
		1774, 1, 0, 0, 0, 1776, 1777, 1, 0, 0, 0, 1777, 1780, 1, 0, 0, 0, 1778,
		1776, 1, 0, 0, 0, 1779, 1769, 1, 0, 0, 0, 1779, 1780, 1, 0, 0, 0, 1780,
		1785, 1, 0, 0, 0, 1781, 1785, 7, 5, 0, 0, 1782, 1783, 5, 371, 0, 0, 1783,
		1785, 5, 1, 0, 0, 1784, 1765, 1, 0, 0, 0, 1784, 1766, 1, 0, 0, 0, 1784,
		1781, 1, 0, 0, 0, 1784, 1782, 1, 0, 0, 0, 1785, 1792, 1, 0, 0, 0, 1786,
		1787, 5, 453, 0, 0, 1787, 1788, 5, 590, 0, 0, 1788, 1792, 3, 1128, 564,
		0, 1789, 1790, 4, 27, 25, 0, 1790, 1792, 3, 62, 31, 0, 1791, 1758, 1, 0,
		0, 0, 1791, 1764, 1, 0, 0, 0, 1791, 1786, 1, 0, 0, 0, 1791, 1789, 1, 0,
		0, 0, 1792, 55, 1, 0, 0, 0, 1793, 1794, 5, 605, 0, 0, 1794, 1795, 5, 572,
		0, 0, 1795, 1796, 3, 1078, 539, 0, 1796, 1797, 5, 506, 0, 0, 1797, 1799,
		7, 6, 0, 0, 1798, 1800, 3, 58, 29, 0, 1799, 1798, 1, 0, 0, 0, 1799, 1800,
		1, 0, 0, 0, 1800, 57, 1, 0, 0, 0, 1801, 1808, 3, 60, 30, 0, 1802, 1804,
		5, 773, 0, 0, 1803, 1802, 1, 0, 0, 0, 1803, 1804, 1, 0, 0, 0, 1804, 1805,
		1, 0, 0, 0, 1805, 1807, 3, 60, 30, 0, 1806, 1803, 1, 0, 0, 0, 1807, 1810,
		1, 0, 0, 0, 1808, 1806, 1, 0, 0, 0, 1808, 1809, 1, 0, 0, 0, 1809, 59, 1,
		0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1811, 1812, 3, 148, 74, 0, 1812, 61, 1,
		0, 0, 0, 1813, 1820, 3, 64, 32, 0, 1814, 1816, 5, 773, 0, 0, 1815, 1814,
		1, 0, 0, 0, 1815, 1816, 1, 0, 0, 0, 1816, 1817, 1, 0, 0, 0, 1817, 1819,
		3, 64, 32, 0, 1818, 1815, 1, 0, 0, 0, 1819, 1822, 1, 0, 0, 0, 1820, 1818,
		1, 0, 0, 0, 1820, 1821, 1, 0, 0, 0, 1821, 63, 1, 0, 0, 0, 1822, 1820, 1,
		0, 0, 0, 1823, 1825, 5, 238, 0, 0, 1824, 1826, 5, 750, 0, 0, 1825, 1824,
		1, 0, 0, 0, 1825, 1826, 1, 0, 0, 0, 1826, 1827, 1, 0, 0, 0, 1827, 1834,
		3, 1186, 593, 0, 1828, 1834, 3, 140, 70, 0, 1829, 1834, 3, 142, 71, 0,
		1830, 1834, 3, 148, 74, 0, 1831, 1834, 3, 150, 75, 0, 1832, 1834, 3, 156,
		78, 0, 1833, 1823, 1, 0, 0, 0, 1833, 1828, 1, 0, 0, 0, 1833, 1829, 1, 0,
		0, 0, 1833, 1830, 1, 0, 0, 0, 1833, 1831, 1, 0, 0, 0, 1833, 1832, 1, 0,
		0, 0, 1834, 65, 1, 0, 0, 0, 1835, 1837, 5, 238, 0, 0, 1836, 1838, 5, 750,
		0, 0, 1837, 1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 1839, 1, 0,
		0, 0, 1839, 1843, 3, 1186, 593, 0, 1840, 1843, 3, 140, 70, 0, 1841, 1843,
		3, 142, 71, 0, 1842, 1835, 1, 0, 0, 0, 1842, 1840, 1, 0, 0, 0, 1842, 1841,
		1, 0, 0, 0, 1843, 67, 1, 0, 0, 0, 1844, 1846, 3, 162, 81, 0, 1845, 1844,
		1, 0, 0, 0, 1845, 1846, 1, 0, 0, 0, 1846, 1848, 1, 0, 0, 0, 1847, 1849,
		3, 976, 488, 0, 1848, 1847, 1, 0, 0, 0, 1848, 1849, 1, 0, 0, 0, 1849, 1851,
		1, 0, 0, 0, 1850, 1852, 3, 164, 82, 0, 1851, 1850, 1, 0, 0, 0, 1851, 1852,
		1, 0, 0, 0, 1852, 1853, 1, 0, 0, 0, 1853, 1854, 5, 636, 0, 0, 1854, 1855,
		3, 1074, 537, 0, 1855, 1856, 3, 70, 35, 0, 1856, 69, 1, 0, 0, 0, 1857,
		1859, 3, 1044, 522, 0, 1858, 1857, 1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0,
		1859, 1860, 1, 0, 0, 0, 1860, 1861, 5, 17, 0, 0, 1861, 1862, 3, 72, 36,
		0, 1862, 71, 1, 0, 0, 0, 1863, 1865, 3, 90, 45, 0, 1864, 1866, 3, 74, 37,
		0, 1865, 1864, 1, 0, 0, 0, 1865, 1866, 1, 0, 0, 0, 1866, 73, 1, 0, 0, 0,
		1867, 1869, 5, 645, 0, 0, 1868, 1870, 7, 7, 0, 0, 1869, 1868, 1, 0, 0,
		0, 1869, 1870, 1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871, 1872, 5, 62, 0,
		0, 1872, 1873, 5, 391, 0, 0, 1873, 75, 1, 0, 0, 0, 1874, 1893, 5, 97, 0,
		0, 1875, 1894, 3, 78, 39, 0, 1876, 1894, 3, 82, 41, 0, 1877, 1894, 3, 96,
		48, 0, 1878, 1894, 3, 94, 47, 0, 1879, 1894, 3, 98, 49, 0, 1880, 1894,
		3, 112, 56, 0, 1881, 1894, 3, 158, 79, 0, 1882, 1894, 3, 166, 83, 0, 1883,
		1894, 3, 106, 53, 0, 1884, 1894, 3, 118, 59, 0, 1885, 1894, 3, 124, 62,
		0, 1886, 1894, 3, 170, 85, 0, 1887, 1888, 4, 38, 26, 0, 1888, 1894, 3,
		172, 86, 0, 1889, 1890, 4, 38, 27, 0, 1890, 1894, 3, 174, 87, 0, 1891,
		1892, 4, 38, 28, 0, 1892, 1894, 3, 126, 63, 0, 1893, 1875, 1, 0, 0, 0,
		1893, 1876, 1, 0, 0, 0, 1893, 1877, 1, 0, 0, 0, 1893, 1878, 1, 0, 0, 0,
		1893, 1879, 1, 0, 0, 0, 1893, 1880, 1, 0, 0, 0, 1893, 1881, 1, 0, 0, 0,
		1893, 1882, 1, 0, 0, 0, 1893, 1883, 1, 0, 0, 0, 1893, 1884, 1, 0, 0, 0,
		1893, 1885, 1, 0, 0, 0, 1893, 1886, 1, 0, 0, 0, 1893, 1887, 1, 0, 0, 0,
		1893, 1889, 1, 0, 0, 0, 1893, 1891, 1, 0, 0, 0, 1894, 77, 1, 0, 0, 0, 1895,
		1897, 5, 109, 0, 0, 1896, 1898, 3, 980, 490, 0, 1897, 1896, 1, 0, 0, 0,
		1897, 1898, 1, 0, 0, 0, 1898, 1899, 1, 0, 0, 0, 1899, 1903, 3, 1056, 528,
		0, 1900, 1902, 3, 80, 40, 0, 1901, 1900, 1, 0, 0, 0, 1902, 1905, 1, 0,
		0, 0, 1903, 1901, 1, 0, 0, 0, 1903, 1904, 1, 0, 0, 0, 1904, 79, 1, 0, 0,
		0, 1905, 1903, 1, 0, 0, 0, 1906, 1911, 3, 952, 476, 0, 1907, 1911, 3, 948,
		474, 0, 1908, 1909, 4, 40, 29, 0, 1909, 1911, 3, 950, 475, 0, 1910, 1906,
		1, 0, 0, 0, 1910, 1907, 1, 0, 0, 0, 1910, 1908, 1, 0, 0, 0, 1911, 81, 1,
		0, 0, 0, 1912, 1914, 5, 577, 0, 0, 1913, 1912, 1, 0, 0, 0, 1913, 1914,
		1, 0, 0, 0, 1914, 1915, 1, 0, 0, 0, 1915, 1917, 5, 574, 0, 0, 1916, 1918,
		3, 980, 490, 0, 1917, 1916, 1, 0, 0, 0, 1917, 1918, 1, 0, 0, 0, 1918, 1919,
		1, 0, 0, 0, 1919, 1942, 3, 1096, 548, 0, 1920, 1921, 5, 776, 0, 0, 1921,
		1922, 3, 84, 42, 0, 1922, 1923, 5, 777, 0, 0, 1923, 1925, 1, 0, 0, 0, 1924,
		1920, 1, 0, 0, 0, 1924, 1925, 1, 0, 0, 0, 1925, 1927, 1, 0, 0, 0, 1926,
		1928, 3, 940, 470, 0, 1927, 1926, 1, 0, 0, 0, 1927, 1928, 1, 0, 0, 0, 1928,
		1930, 1, 0, 0, 0, 1929, 1931, 3, 954, 477, 0, 1930, 1929, 1, 0, 0, 0, 1930,
		1931, 1, 0, 0, 0, 1931, 1933, 1, 0, 0, 0, 1932, 1934, 3, 88, 44, 0, 1933,
		1932, 1, 0, 0, 0, 1933, 1934, 1, 0, 0, 0, 1934, 1943, 1, 0, 0, 0, 1935,
		1936, 5, 275, 0, 0, 1936, 1943, 3, 1102, 551, 0, 1937, 1938, 5, 776, 0,
		0, 1938, 1939, 5, 275, 0, 0, 1939, 1940, 3, 1102, 551, 0, 1940, 1941, 5,
		777, 0, 0, 1941, 1943, 1, 0, 0, 0, 1942, 1924, 1, 0, 0, 0, 1942, 1935,
		1, 0, 0, 0, 1942, 1937, 1, 0, 0, 0, 1943, 83, 1, 0, 0, 0, 1944, 1949, 3,
		86, 43, 0, 1945, 1946, 5, 773, 0, 0, 1946, 1948, 3, 86, 43, 0, 1947, 1945,
		1, 0, 0, 0, 1948, 1951, 1, 0, 0, 0, 1949, 1947, 1, 0, 0, 0, 1949, 1950,
		1, 0, 0, 0, 1950, 85, 1, 0, 0, 0, 1951, 1949, 1, 0, 0, 0, 1952, 1955, 3,
		864, 432, 0, 1953, 1955, 3, 872, 436, 0, 1954, 1952, 1, 0, 0, 0, 1954,
		1953, 1, 0, 0, 0, 1955, 87, 1, 0, 0, 0, 1956, 1958, 7, 8, 0, 0, 1957, 1956,
		1, 0, 0, 0, 1957, 1958, 1, 0, 0, 0, 1958, 1960, 1, 0, 0, 0, 1959, 1961,
		5, 17, 0, 0, 1960, 1959, 1, 0, 0, 0, 1960, 1961, 1, 0, 0, 0, 1961, 1962,
		1, 0, 0, 0, 1962, 1963, 3, 90, 45, 0, 1963, 89, 1, 0, 0, 0, 1964, 1967,
		3, 270, 135, 0, 1965, 1967, 3, 274, 137, 0, 1966, 1964, 1, 0, 0, 0, 1966,
		1965, 1, 0, 0, 0, 1967, 91, 1, 0, 0, 0, 1968, 1972, 5, 97, 0, 0, 1969,
		1973, 3, 94, 47, 0, 1970, 1973, 3, 96, 48, 0, 1971, 1973, 3, 98, 49, 0,
		1972, 1969, 1, 0, 0, 0, 1972, 1970, 1, 0, 0, 0, 1972, 1971, 1, 0, 0, 0,
		1973, 1975, 1, 0, 0, 0, 1974, 1976, 5, 774, 0, 0, 1975, 1974, 1, 0, 0,
		0, 1975, 1976, 1, 0, 0, 0, 1976, 1977, 1, 0, 0, 0, 1977, 1978, 5, 0, 0,
		1, 1978, 93, 1, 0, 0, 0, 1979, 1981, 3, 976, 488, 0, 1980, 1979, 1, 0,
		0, 0, 1980, 1981, 1, 0, 0, 0, 1981, 1982, 1, 0, 0, 0, 1982, 1983, 5, 422,
		0, 0, 1983, 1984, 3, 1060, 530, 0, 1984, 1993, 5, 776, 0, 0, 1985, 1990,
		3, 982, 491, 0, 1986, 1987, 5, 773, 0, 0, 1987, 1989, 3, 982, 491, 0, 1988,
		1986, 1, 0, 0, 0, 1989, 1992, 1, 0, 0, 0, 1990, 1988, 1, 0, 0, 0, 1990,
		1991, 1, 0, 0, 0, 1991, 1994, 1, 0, 0, 0, 1992, 1990, 1, 0, 0, 0, 1993,
		1985, 1, 0, 0, 0, 1993, 1994, 1, 0, 0, 0, 1994, 1995, 1, 0, 0, 0, 1995,
		1999, 5, 777, 0, 0, 1996, 1998, 3, 100, 50, 0, 1997, 1996, 1, 0, 0, 0,
		1998, 2001, 1, 0, 0, 0, 1999, 1997, 1, 0, 0, 0, 1999, 2000, 1, 0, 0, 0,
		2000, 2002, 1, 0, 0, 0, 2001, 1999, 1, 0, 0, 0, 2002, 2003, 3, 784, 392,
		0, 2003, 95, 1, 0, 0, 0, 2004, 2006, 3, 976, 488, 0, 2005, 2004, 1, 0,
		0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2007, 1, 0, 0, 0, 2007, 2008, 5, 206,
		0, 0, 2008, 2009, 3, 1064, 532, 0, 2009, 2018, 5, 776, 0, 0, 2010, 2015,
		3, 984, 492, 0, 2011, 2012, 5, 773, 0, 0, 2012, 2014, 3, 984, 492, 0, 2013,
		2011, 1, 0, 0, 0, 2014, 2017, 1, 0, 0, 0, 2015, 2013, 1, 0, 0, 0, 2015,
		2016, 1, 0, 0, 0, 2016, 2019, 1, 0, 0, 0, 2017, 2015, 1, 0, 0, 0, 2018,
		2010, 1, 0, 0, 0, 2018, 2019, 1, 0, 0, 0, 2019, 2020, 1, 0, 0, 0, 2020,
		2021, 5, 777, 0, 0, 2021, 2022, 5, 474, 0, 0, 2022, 2026, 3, 988, 494,
		0, 2023, 2025, 3, 100, 50, 0, 2024, 2023, 1, 0, 0, 0, 2025, 2028, 1, 0,
		0, 0, 2026, 2024, 1, 0, 0, 0, 2026, 2027, 1, 0, 0, 0, 2027, 2029, 1, 0,
		0, 0, 2028, 2026, 1, 0, 0, 0, 2029, 2030, 3, 784, 392, 0, 2030, 97, 1,
		0, 0, 0, 2031, 2033, 5, 8, 0, 0, 2032, 2031, 1, 0, 0, 0, 2032, 2033, 1,
		0, 0, 0, 2033, 2034, 1, 0, 0, 0, 2034, 2035, 5, 206, 0, 0, 2035, 2036,
		3, 1088, 544, 0, 2036, 2037, 5, 474, 0, 0, 2037, 2038, 7, 9, 0, 0, 2038,
		2039, 5, 520, 0, 0, 2039, 2040, 3, 1160, 580, 0, 2040, 99, 1, 0, 0, 0,
		2041, 2047, 3, 104, 52, 0, 2042, 2044, 5, 371, 0, 0, 2043, 2042, 1, 0,
		0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2045, 1, 0, 0, 0, 2045, 2047, 5, 137,
		0, 0, 2046, 2041, 1, 0, 0, 0, 2046, 2043, 1, 0, 0, 0, 2047, 101, 1, 0,
		0, 0, 2048, 2050, 3, 100, 50, 0, 2049, 2048, 1, 0, 0, 0, 2050, 2051, 1,
		0, 0, 0, 2051, 2049, 1, 0, 0, 0, 2051, 2052, 1, 0, 0, 0, 2052, 103, 1,
		0, 0, 0, 2053, 2054, 5, 75, 0, 0, 2054, 2071, 3, 1160, 580, 0, 2055, 2056,
		5, 267, 0, 0, 2056, 2071, 5, 537, 0, 0, 2057, 2058, 5, 373, 0, 0, 2058,
		2071, 5, 537, 0, 0, 2059, 2060, 5, 90, 0, 0, 2060, 2071, 5, 537, 0, 0,
		2061, 2062, 5, 433, 0, 0, 2062, 2063, 5, 537, 0, 0, 2063, 2071, 5, 112,
		0, 0, 2064, 2065, 5, 347, 0, 0, 2065, 2066, 5, 537, 0, 0, 2066, 2071, 5,
		112, 0, 0, 2067, 2068, 5, 537, 0, 0, 2068, 2069, 5, 496, 0, 0, 2069, 2071,
		7, 10, 0, 0, 2070, 2053, 1, 0, 0, 0, 2070, 2055, 1, 0, 0, 0, 2070, 2057,
		1, 0, 0, 0, 2070, 2059, 1, 0, 0, 0, 2070, 2061, 1, 0, 0, 0, 2070, 2064,
		1, 0, 0, 0, 2070, 2067, 1, 0, 0, 0, 2071, 105, 1, 0, 0, 0, 2072, 2074,
		3, 1032, 516, 0, 2073, 2072, 1, 0, 0, 0, 2073, 2074, 1, 0, 0, 0, 2074,
		2116, 1, 0, 0, 0, 2075, 2077, 5, 609, 0, 0, 2076, 2075, 1, 0, 0, 0, 2076,
		2077, 1, 0, 0, 0, 2077, 2078, 1, 0, 0, 0, 2078, 2087, 5, 236, 0, 0, 2079,
		2080, 4, 53, 30, 0, 2080, 2082, 3, 1050, 525, 0, 2081, 2083, 3, 908, 454,
		0, 2082, 2081, 1, 0, 0, 0, 2082, 2083, 1, 0, 0, 0, 2083, 2088, 1, 0, 0,
		0, 2084, 2086, 3, 108, 54, 0, 2085, 2084, 1, 0, 0, 0, 2085, 2086, 1, 0,
		0, 0, 2086, 2088, 1, 0, 0, 0, 2087, 2079, 1, 0, 0, 0, 2087, 2085, 1, 0,
		0, 0, 2088, 2089, 1, 0, 0, 0, 2089, 2093, 3, 110, 55, 0, 2090, 2092, 3,
		902, 451, 0, 2091, 2090, 1, 0, 0, 0, 2092, 2095, 1, 0, 0, 0, 2093, 2091,
		1, 0, 0, 0, 2093, 2094, 1, 0, 0, 0, 2094, 2117, 1, 0, 0, 0, 2095, 2093,
		1, 0, 0, 0, 2096, 2097, 5, 205, 0, 0, 2097, 2098, 5, 236, 0, 0, 2098, 2099,
		3, 1050, 525, 0, 2099, 2103, 3, 110, 55, 0, 2100, 2102, 3, 910, 455, 0,
		2101, 2100, 1, 0, 0, 0, 2102, 2105, 1, 0, 0, 0, 2103, 2101, 1, 0, 0, 0,
		2103, 2104, 1, 0, 0, 0, 2104, 2117, 1, 0, 0, 0, 2105, 2103, 1, 0, 0, 0,
		2106, 2107, 5, 523, 0, 0, 2107, 2108, 5, 236, 0, 0, 2108, 2109, 3, 1050,
		525, 0, 2109, 2113, 3, 110, 55, 0, 2110, 2112, 3, 912, 456, 0, 2111, 2110,
		1, 0, 0, 0, 2112, 2115, 1, 0, 0, 0, 2113, 2111, 1, 0, 0, 0, 2113, 2114,
		1, 0, 0, 0, 2114, 2117, 1, 0, 0, 0, 2115, 2113, 1, 0, 0, 0, 2116, 2076,
		1, 0, 0, 0, 2116, 2096, 1, 0, 0, 0, 2116, 2106, 1, 0, 0, 0, 2117, 2119,
		1, 0, 0, 0, 2118, 2120, 3, 46, 23, 0, 2119, 2118, 1, 0, 0, 0, 2119, 2120,
		1, 0, 0, 0, 2120, 107, 1, 0, 0, 0, 2121, 2124, 3, 1050, 525, 0, 2122, 2123,
		5, 621, 0, 0, 2123, 2125, 3, 900, 450, 0, 2124, 2122, 1, 0, 0, 0, 2124,
		2125, 1, 0, 0, 0, 2125, 2131, 1, 0, 0, 0, 2126, 2127, 3, 1050, 525, 0,
		2127, 2128, 5, 599, 0, 0, 2128, 2129, 3, 900, 450, 0, 2129, 2131, 1, 0,
		0, 0, 2130, 2121, 1, 0, 0, 0, 2130, 2126, 1, 0, 0, 0, 2131, 109, 1, 0,
		0, 0, 2132, 2133, 5, 383, 0, 0, 2133, 2134, 3, 1102, 551, 0, 2134, 2135,
		3, 898, 449, 0, 2135, 111, 1, 0, 0, 0, 2136, 2137, 5, 288, 0, 0, 2137,
		2138, 5, 217, 0, 0, 2138, 2139, 3, 1080, 540, 0, 2139, 2140, 5, 4, 0, 0,
		2140, 2141, 7, 11, 0, 0, 2141, 2143, 3, 1160, 580, 0, 2142, 2144, 3, 114,
		57, 0, 2143, 2142, 1, 0, 0, 0, 2143, 2144, 1, 0, 0, 0, 2144, 113, 1, 0,
		0, 0, 2145, 2152, 3, 116, 58, 0, 2146, 2148, 5, 773, 0, 0, 2147, 2146,
		1, 0, 0, 0, 2147, 2148, 1, 0, 0, 0, 2148, 2149, 1, 0, 0, 0, 2149, 2151,
		3, 116, 58, 0, 2150, 2147, 1, 0, 0, 0, 2151, 2154, 1, 0, 0, 0, 2152, 2150,
		1, 0, 0, 0, 2152, 2153, 1, 0, 0, 0, 2153, 115, 1, 0, 0, 0, 2154, 2152,
		1, 0, 0, 0, 2155, 2162, 3, 136, 68, 0, 2156, 2162, 3, 138, 69, 0, 2157,
		2162, 3, 146, 73, 0, 2158, 2162, 3, 148, 74, 0, 2159, 2162, 3, 150, 75,
		0, 2160, 2162, 3, 152, 76, 0, 2161, 2155, 1, 0, 0, 0, 2161, 2156, 1, 0,
		0, 0, 2161, 2157, 1, 0, 0, 0, 2161, 2158, 1, 0, 0, 0, 2161, 2159, 1, 0,
		0, 0, 2161, 2160, 1, 0, 0, 0, 2162, 117, 1, 0, 0, 0, 2163, 2164, 5, 503,
		0, 0, 2164, 2165, 3, 1090, 545, 0, 2165, 2166, 5, 199, 0, 0, 2166, 2167,
		5, 112, 0, 0, 2167, 2168, 5, 648, 0, 0, 2168, 2169, 3, 1180, 590, 0, 2169,
		2170, 3, 120, 60, 0, 2170, 119, 1, 0, 0, 0, 2171, 2172, 5, 390, 0, 0, 2172,
		2173, 5, 776, 0, 0, 2173, 2178, 3, 122, 61, 0, 2174, 2175, 5, 773, 0, 0,
		2175, 2177, 3, 122, 61, 0, 2176, 2174, 1, 0, 0, 0, 2177, 2180, 1, 0, 0,
		0, 2178, 2176, 1, 0, 0, 0, 2178, 2179, 1, 0, 0, 0, 2179, 2181, 1, 0, 0,
		0, 2180, 2178, 1, 0, 0, 0, 2181, 2182, 5, 777, 0, 0, 2182, 121, 1, 0, 0,
		0, 2183, 2184, 5, 224, 0, 0, 2184, 2198, 3, 1160, 580, 0, 2185, 2186, 5,
		109, 0, 0, 2186, 2198, 3, 1160, 580, 0, 2187, 2188, 5, 618, 0, 0, 2188,
		2198, 3, 1160, 580, 0, 2189, 2190, 5, 406, 0, 0, 2190, 2198, 3, 1160, 580,
		0, 2191, 2192, 5, 519, 0, 0, 2192, 2198, 3, 1160, 580, 0, 2193, 2194, 5,
		398, 0, 0, 2194, 2198, 3, 1160, 580, 0, 2195, 2196, 5, 413, 0, 0, 2196,
		2198, 3, 1140, 570, 0, 2197, 2183, 1, 0, 0, 0, 2197, 2185, 1, 0, 0, 0,
		2197, 2187, 1, 0, 0, 0, 2197, 2189, 1, 0, 0, 0, 2197, 2191, 1, 0, 0, 0,
		2197, 2193, 1, 0, 0, 0, 2197, 2195, 1, 0, 0, 0, 2198, 123, 1, 0, 0, 0,
		2199, 2200, 5, 572, 0, 0, 2200, 2201, 3, 1076, 538, 0, 2201, 2206, 3, 128,
		64, 0, 2202, 2203, 5, 620, 0, 0, 2203, 2204, 5, 288, 0, 0, 2204, 2205,
		5, 217, 0, 0, 2205, 2207, 3, 1082, 541, 0, 2206, 2202, 1, 0, 0, 0, 2206,
		2207, 1, 0, 0, 0, 2207, 2209, 1, 0, 0, 0, 2208, 2210, 3, 132, 66, 0, 2209,
		2208, 1, 0, 0, 0, 2209, 2210, 1, 0, 0, 0, 2210, 125, 1, 0, 0, 0, 2211,
		2212, 5, 605, 0, 0, 2212, 2213, 5, 572, 0, 0, 2213, 2214, 3, 1076, 538,
		0, 2214, 2215, 5, 4, 0, 0, 2215, 2217, 3, 130, 65, 0, 2216, 2218, 3, 58,
		29, 0, 2217, 2216, 1, 0, 0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 127, 1, 0,
		0, 0, 2219, 2222, 4, 64, 31, 0, 2220, 2221, 5, 4, 0, 0, 2221, 2223, 3,
		130, 65, 0, 2222, 2220, 1, 0, 0, 0, 2222, 2223, 1, 0, 0, 0, 2223, 2227,
		1, 0, 0, 0, 2224, 2225, 5, 4, 0, 0, 2225, 2227, 3, 130, 65, 0, 2226, 2219,
		1, 0, 0, 0, 2226, 2224, 1, 0, 0, 0, 2227, 129, 1, 0, 0, 0, 2228, 2229,
		5, 111, 0, 0, 2229, 2230, 3, 1160, 580, 0, 2230, 131, 1, 0, 0, 0, 2231,
		2238, 3, 134, 67, 0, 2232, 2234, 5, 773, 0, 0, 2233, 2232, 1, 0, 0, 0,
		2233, 2234, 1, 0, 0, 0, 2234, 2235, 1, 0, 0, 0, 2235, 2237, 3, 134, 67,
		0, 2236, 2233, 1, 0, 0, 0, 2237, 2240, 1, 0, 0, 0, 2238, 2236, 1, 0, 0,
		0, 2238, 2239, 1, 0, 0, 0, 2239, 133, 1, 0, 0, 0, 2240, 2238, 1, 0, 0,
		0, 2241, 2254, 3, 136, 68, 0, 2242, 2254, 3, 140, 70, 0, 2243, 2254, 3,
		142, 71, 0, 2244, 2254, 3, 144, 72, 0, 2245, 2254, 3, 146, 73, 0, 2246,
		2254, 3, 148, 74, 0, 2247, 2254, 3, 150, 75, 0, 2248, 2254, 3, 152, 76,
		0, 2249, 2250, 4, 67, 32, 0, 2250, 2254, 3, 154, 77, 0, 2251, 2252, 4,
		67, 33, 0, 2252, 2254, 3, 156, 78, 0, 2253, 2241, 1, 0, 0, 0, 2253, 2242,
		1, 0, 0, 0, 2253, 2243, 1, 0, 0, 0, 2253, 2244, 1, 0, 0, 0, 2253, 2245,
		1, 0, 0, 0, 2253, 2246, 1, 0, 0, 0, 2253, 2247, 1, 0, 0, 0, 2253, 2248,
		1, 0, 0, 0, 2253, 2249, 1, 0, 0, 0, 2253, 2251, 1, 0, 0, 0, 2254, 135,
		1, 0, 0, 0, 2255, 2257, 5, 238, 0, 0, 2256, 2258, 5, 750, 0, 0, 2257, 2256,
		1, 0, 0, 0, 2257, 2258, 1, 0, 0, 0, 2258, 2259, 1, 0, 0, 0, 2259, 2260,
		3, 1186, 593, 0, 2260, 137, 1, 0, 0, 0, 2261, 2263, 7, 12, 0, 0, 2262,
		2264, 5, 750, 0, 0, 2263, 2262, 1, 0, 0, 0, 2263, 2264, 1, 0, 0, 0, 2264,
		2265, 1, 0, 0, 0, 2265, 2266, 3, 1186, 593, 0, 2266, 139, 1, 0, 0, 0, 2267,
		2269, 5, 23, 0, 0, 2268, 2270, 5, 750, 0, 0, 2269, 2268, 1, 0, 0, 0, 2269,
		2270, 1, 0, 0, 0, 2270, 2271, 1, 0, 0, 0, 2271, 2272, 3, 1186, 593, 0,
		2272, 141, 1, 0, 0, 0, 2273, 2275, 5, 324, 0, 0, 2274, 2276, 5, 750, 0,
		0, 2275, 2274, 1, 0, 0, 0, 2275, 2276, 1, 0, 0, 0, 2276, 2277, 1, 0, 0,
		0, 2277, 2278, 3, 1186, 593, 0, 2278, 143, 1, 0, 0, 0, 2279, 2281, 5, 181,
		0, 0, 2280, 2282, 5, 750, 0, 0, 2281, 2280, 1, 0, 0, 0, 2281, 2282, 1,
		0, 0, 0, 2282, 2283, 1, 0, 0, 0, 2283, 2284, 3, 1186, 593, 0, 2284, 145,
		1, 0, 0, 0, 2285, 2287, 5, 368, 0, 0, 2286, 2288, 5, 750, 0, 0, 2287, 2286,
		1, 0, 0, 0, 2287, 2288, 1, 0, 0, 0, 2288, 2289, 1, 0, 0, 0, 2289, 2290,
		3, 1142, 571, 0, 2290, 147, 1, 0, 0, 0, 2291, 2293, 5, 553, 0, 0, 2292,
		2291, 1, 0, 0, 0, 2292, 2293, 1, 0, 0, 0, 2293, 2294, 1, 0, 0, 0, 2294,
		2296, 5, 163, 0, 0, 2295, 2297, 5, 750, 0, 0, 2296, 2295, 1, 0, 0, 0, 2296,
		2297, 1, 0, 0, 0, 2297, 2298, 1, 0, 0, 0, 2298, 2299, 3, 1094, 547, 0,
		2299, 149, 1, 0, 0, 0, 2300, 2301, 7, 13, 0, 0, 2301, 151, 1, 0, 0, 0,
		2302, 2304, 5, 75, 0, 0, 2303, 2305, 5, 750, 0, 0, 2304, 2303, 1, 0, 0,
		0, 2304, 2305, 1, 0, 0, 0, 2305, 2306, 1, 0, 0, 0, 2306, 2307, 3, 1160,
		580, 0, 2307, 153, 1, 0, 0, 0, 2308, 2310, 5, 189, 0, 0, 2309, 2311, 5,
		750, 0, 0, 2310, 2309, 1, 0, 0, 0, 2310, 2311, 1, 0, 0, 0, 2311, 2312,
		1, 0, 0, 0, 2312, 2313, 3, 1186, 593, 0, 2313, 155, 1, 0, 0, 0, 2314, 2316,
		5, 158, 0, 0, 2315, 2317, 5, 750, 0, 0, 2316, 2315, 1, 0, 0, 0, 2316, 2317,
		1, 0, 0, 0, 2317, 2318, 1, 0, 0, 0, 2318, 2319, 3, 1154, 577, 0, 2319,
		157, 1, 0, 0, 0, 2320, 2322, 3, 160, 80, 0, 2321, 2320, 1, 0, 0, 0, 2321,
		2322, 1, 0, 0, 0, 2322, 2324, 1, 0, 0, 0, 2323, 2325, 3, 976, 488, 0, 2324,
		2323, 1, 0, 0, 0, 2324, 2325, 1, 0, 0, 0, 2325, 2327, 1, 0, 0, 0, 2326,
		2328, 3, 164, 82, 0, 2327, 2326, 1, 0, 0, 0, 2327, 2328, 1, 0, 0, 0, 2328,
		2329, 1, 0, 0, 0, 2329, 2330, 5, 636, 0, 0, 2330, 2331, 3, 1072, 536, 0,
		2331, 2332, 3, 70, 35, 0, 2332, 159, 1, 0, 0, 0, 2333, 2334, 5, 394, 0,
		0, 2334, 2336, 5, 458, 0, 0, 2335, 2337, 3, 162, 81, 0, 2336, 2335, 1,
		0, 0, 0, 2336, 2337, 1, 0, 0, 0, 2337, 2340, 1, 0, 0, 0, 2338, 2340, 3,
		162, 81, 0, 2339, 2333, 1, 0, 0, 0, 2339, 2338, 1, 0, 0, 0, 2340, 161,
		1, 0, 0, 0, 2341, 2342, 5, 9, 0, 0, 2342, 2343, 5, 750, 0, 0, 2343, 2344,
		7, 14, 0, 0, 2344, 163, 1, 0, 0, 0, 2345, 2346, 5, 537, 0, 0, 2346, 2347,
		5, 496, 0, 0, 2347, 2348, 7, 10, 0, 0, 2348, 165, 1, 0, 0, 0, 2349, 2351,
		3, 976, 488, 0, 2350, 2349, 1, 0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351, 2352,
		1, 0, 0, 0, 2352, 2353, 5, 594, 0, 0, 2353, 2354, 3, 1068, 534, 0, 2354,
		2355, 7, 15, 0, 0, 2355, 2356, 7, 16, 0, 0, 2356, 2357, 5, 383, 0, 0, 2357,
		2358, 3, 1102, 551, 0, 2358, 2359, 5, 200, 0, 0, 2359, 2360, 5, 153, 0,
		0, 2360, 2362, 5, 487, 0, 0, 2361, 2363, 3, 168, 84, 0, 2362, 2361, 1,
		0, 0, 0, 2362, 2363, 1, 0, 0, 0, 2363, 2364, 1, 0, 0, 0, 2364, 2365, 3,
		784, 392, 0, 2365, 167, 1, 0, 0, 0, 2366, 2367, 4, 84, 34, 0, 2367, 2368,
		7, 17, 0, 0, 2368, 2369, 3, 1180, 590, 0, 2369, 169, 1, 0, 0, 0, 2370,
		2372, 3, 976, 488, 0, 2371, 2370, 1, 0, 0, 0, 2371, 2372, 1, 0, 0, 0, 2372,
		2373, 1, 0, 0, 0, 2373, 2375, 5, 170, 0, 0, 2374, 2376, 3, 980, 490, 0,
		2375, 2374, 1, 0, 0, 0, 2375, 2376, 1, 0, 0, 0, 2376, 2377, 1, 0, 0, 0,
		2377, 2378, 3, 1084, 542, 0, 2378, 2379, 5, 383, 0, 0, 2379, 2380, 5, 490,
		0, 0, 2380, 2387, 3, 862, 431, 0, 2381, 2382, 5, 383, 0, 0, 2382, 2384,
		5, 79, 0, 0, 2383, 2385, 5, 371, 0, 0, 2384, 2383, 1, 0, 0, 0, 2384, 2385,
		1, 0, 0, 0, 2385, 2386, 1, 0, 0, 0, 2386, 2388, 5, 418, 0, 0, 2387, 2381,
		1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0, 2388, 2395, 1, 0, 0, 0, 2389, 2396,
		5, 156, 0, 0, 2390, 2393, 5, 140, 0, 0, 2391, 2392, 5, 383, 0, 0, 2392,
		2394, 5, 514, 0, 0, 2393, 2391, 1, 0, 0, 0, 2393, 2394, 1, 0, 0, 0, 2394,
		2396, 1, 0, 0, 0, 2395, 2389, 1, 0, 0, 0, 2395, 2390, 1, 0, 0, 0, 2395,
		2396, 1, 0, 0, 0, 2396, 2399, 1, 0, 0, 0, 2397, 2398, 5, 75, 0, 0, 2398,
		2400, 3, 1160, 580, 0, 2399, 2397, 1, 0, 0, 0, 2399, 2400, 1, 0, 0, 0,
		2400, 2401, 1, 0, 0, 0, 2401, 2402, 5, 147, 0, 0, 2402, 2403, 3, 784, 392,
		0, 2403, 171, 1, 0, 0, 0, 2404, 2406, 5, 659, 0, 0, 2405, 2407, 3, 980,
		490, 0, 2406, 2405, 1, 0, 0, 0, 2406, 2407, 1, 0, 0, 0, 2407, 2408, 1,
		0, 0, 0, 2408, 2409, 3, 560, 280, 0, 2409, 173, 1, 0, 0, 0, 2410, 2411,
		5, 394, 0, 0, 2411, 2412, 5, 458, 0, 0, 2412, 2413, 5, 523, 0, 0, 2413,
		2414, 5, 718, 0, 0, 2414, 2415, 5, 710, 0, 0, 2415, 2419, 3, 1146, 573,
		0, 2416, 2418, 3, 176, 88, 0, 2417, 2416, 1, 0, 0, 0, 2418, 2421, 1, 0,
		0, 0, 2419, 2417, 1, 0, 0, 0, 2419, 2420, 1, 0, 0, 0, 2420, 2436, 1, 0,
		0, 0, 2421, 2419, 1, 0, 0, 0, 2422, 2423, 5, 523, 0, 0, 2423, 2424, 5,
		718, 0, 0, 2424, 2426, 5, 710, 0, 0, 2425, 2427, 3, 980, 490, 0, 2426,
		2425, 1, 0, 0, 0, 2426, 2427, 1, 0, 0, 0, 2427, 2428, 1, 0, 0, 0, 2428,
		2432, 3, 1146, 573, 0, 2429, 2431, 3, 176, 88, 0, 2430, 2429, 1, 0, 0,
		0, 2431, 2434, 1, 0, 0, 0, 2432, 2430, 1, 0, 0, 0, 2432, 2433, 1, 0, 0,
		0, 2433, 2436, 1, 0, 0, 0, 2434, 2432, 1, 0, 0, 0, 2435, 2410, 1, 0, 0,
		0, 2435, 2422, 1, 0, 0, 0, 2436, 175, 1, 0, 0, 0, 2437, 2438, 5, 357, 0,
		0, 2438, 2439, 5, 580, 0, 0, 2439, 2453, 3, 1162, 581, 0, 2440, 2441, 5,
		715, 0, 0, 2441, 2442, 5, 580, 0, 0, 2442, 2453, 3, 1162, 581, 0, 2443,
		2444, 5, 717, 0, 0, 2444, 2445, 3, 1162, 581, 0, 2445, 2446, 5, 230, 0,
		0, 2446, 2447, 5, 45, 0, 0, 2447, 2448, 3, 1146, 573, 0, 2448, 2453, 1,
		0, 0, 0, 2449, 2450, 5, 716, 0, 0, 2450, 2451, 5, 580, 0, 0, 2451, 2453,
		3, 1162, 581, 0, 2452, 2437, 1, 0, 0, 0, 2452, 2440, 1, 0, 0, 0, 2452,
		2443, 1, 0, 0, 0, 2452, 2449, 1, 0, 0, 0, 2453, 177, 1, 0, 0, 0, 2454,
		2472, 5, 148, 0, 0, 2455, 2473, 3, 180, 90, 0, 2456, 2473, 3, 182, 91,
		0, 2457, 2473, 3, 184, 92, 0, 2458, 2473, 3, 186, 93, 0, 2459, 2473, 3,
		188, 94, 0, 2460, 2473, 3, 190, 95, 0, 2461, 2473, 3, 194, 97, 0, 2462,
		2473, 3, 196, 98, 0, 2463, 2473, 3, 198, 99, 0, 2464, 2473, 3, 200, 100,
		0, 2465, 2473, 3, 202, 101, 0, 2466, 2467, 4, 89, 35, 0, 2467, 2473, 3,
		204, 102, 0, 2468, 2469, 4, 89, 36, 0, 2469, 2473, 3, 206, 103, 0, 2470,
		2471, 4, 89, 37, 0, 2471, 2473, 3, 208, 104, 0, 2472, 2455, 1, 0, 0, 0,
		2472, 2456, 1, 0, 0, 0, 2472, 2457, 1, 0, 0, 0, 2472, 2458, 1, 0, 0, 0,
		2472, 2459, 1, 0, 0, 0, 2472, 2460, 1, 0, 0, 0, 2472, 2461, 1, 0, 0, 0,
		2472, 2462, 1, 0, 0, 0, 2472, 2463, 1, 0, 0, 0, 2472, 2464, 1, 0, 0, 0,
		2472, 2465, 1, 0, 0, 0, 2472, 2466, 1, 0, 0, 0, 2472, 2468, 1, 0, 0, 0,
		2472, 2470, 1, 0, 0, 0, 2473, 179, 1, 0, 0, 0, 2474, 2476, 5, 109, 0, 0,
		2475, 2477, 3, 978, 489, 0, 2476, 2475, 1, 0, 0, 0, 2476, 2477, 1, 0, 0,
		0, 2477, 2478, 1, 0, 0, 0, 2478, 2479, 3, 1058, 529, 0, 2479, 181, 1, 0,
		0, 0, 2480, 2482, 5, 170, 0, 0, 2481, 2483, 3, 978, 489, 0, 2482, 2481,
		1, 0, 0, 0, 2482, 2483, 1, 0, 0, 0, 2483, 2484, 1, 0, 0, 0, 2484, 2485,
		3, 1086, 543, 0, 2485, 183, 1, 0, 0, 0, 2486, 2488, 5, 206, 0, 0, 2487,
		2489, 3, 978, 489, 0, 2488, 2487, 1, 0, 0, 0, 2488, 2489, 1, 0, 0, 0, 2489,
		2490, 1, 0, 0, 0, 2490, 2491, 3, 1066, 533, 0, 2491, 185, 1, 0, 0, 0, 2492,
		2494, 5, 422, 0, 0, 2493, 2495, 3, 978, 489, 0, 2494, 2493, 1, 0, 0, 0,
		2494, 2495, 1, 0, 0, 0, 2495, 2496, 1, 0, 0, 0, 2496, 2497, 3, 1062, 531,
		0, 2497, 187, 1, 0, 0, 0, 2498, 2500, 3, 1032, 516, 0, 2499, 2498, 1, 0,
		0, 0, 2499, 2500, 1, 0, 0, 0, 2500, 2501, 1, 0, 0, 0, 2501, 2502, 5, 236,
		0, 0, 2502, 2503, 3, 1052, 526, 0, 2503, 2504, 5, 383, 0, 0, 2504, 2506,
		3, 1102, 551, 0, 2505, 2507, 3, 46, 23, 0, 2506, 2505, 1, 0, 0, 0, 2506,
		2507, 1, 0, 0, 0, 2507, 189, 1, 0, 0, 0, 2508, 2509, 5, 288, 0, 0, 2509,
		2510, 5, 217, 0, 0, 2510, 2521, 3, 1082, 541, 0, 2511, 2518, 3, 192, 96,
		0, 2512, 2514, 5, 773, 0, 0, 2513, 2512, 1, 0, 0, 0, 2513, 2514, 1, 0,
		0, 0, 2514, 2515, 1, 0, 0, 0, 2515, 2517, 3, 192, 96, 0, 2516, 2513, 1,
		0, 0, 0, 2517, 2520, 1, 0, 0, 0, 2518, 2516, 1, 0, 0, 0, 2518, 2519, 1,
		0, 0, 0, 2519, 2522, 1, 0, 0, 0, 2520, 2518, 1, 0, 0, 0, 2521, 2511, 1,
		0, 0, 0, 2521, 2522, 1, 0, 0, 0, 2522, 191, 1, 0, 0, 0, 2523, 2526, 3,
		150, 75, 0, 2524, 2526, 3, 148, 74, 0, 2525, 2523, 1, 0, 0, 0, 2525, 2524,
		1, 0, 0, 0, 2526, 193, 1, 0, 0, 0, 2527, 2529, 5, 503, 0, 0, 2528, 2530,
		3, 978, 489, 0, 2529, 2528, 1, 0, 0, 0, 2529, 2530, 1, 0, 0, 0, 2530, 2531,
		1, 0, 0, 0, 2531, 2532, 3, 1092, 546, 0, 2532, 195, 1, 0, 0, 0, 2533, 2535,
		5, 577, 0, 0, 2534, 2533, 1, 0, 0, 0, 2534, 2535, 1, 0, 0, 0, 2535, 2536,
		1, 0, 0, 0, 2536, 2538, 7, 18, 0, 0, 2537, 2539, 3, 978, 489, 0, 2538,
		2537, 1, 0, 0, 0, 2538, 2539, 1, 0, 0, 0, 2539, 2540, 1, 0, 0, 0, 2540,
		2542, 3, 1104, 552, 0, 2541, 2543, 7, 2, 0, 0, 2542, 2541, 1, 0, 0, 0,
		2542, 2543, 1, 0, 0, 0, 2543, 197, 1, 0, 0, 0, 2544, 2545, 5, 572, 0, 0,
		2545, 2556, 3, 1078, 539, 0, 2546, 2553, 3, 192, 96, 0, 2547, 2549, 5,
		773, 0, 0, 2548, 2547, 1, 0, 0, 0, 2548, 2549, 1, 0, 0, 0, 2549, 2550,
		1, 0, 0, 0, 2550, 2552, 3, 192, 96, 0, 2551, 2548, 1, 0, 0, 0, 2552, 2555,
		1, 0, 0, 0, 2553, 2551, 1, 0, 0, 0, 2553, 2554, 1, 0, 0, 0, 2554, 2557,
		1, 0, 0, 0, 2555, 2553, 1, 0, 0, 0, 2556, 2546, 1, 0, 0, 0, 2556, 2557,
		1, 0, 0, 0, 2557, 199, 1, 0, 0, 0, 2558, 2560, 5, 594, 0, 0, 2559, 2561,
		3, 978, 489, 0, 2560, 2559, 1, 0, 0, 0, 2560, 2561, 1, 0, 0, 0, 2561, 2562,
		1, 0, 0, 0, 2562, 2563, 3, 1070, 535, 0, 2563, 201, 1, 0, 0, 0, 2564, 2566,
		5, 636, 0, 0, 2565, 2567, 3, 978, 489, 0, 2566, 2565, 1, 0, 0, 0, 2566,
		2567, 1, 0, 0, 0, 2567, 2568, 1, 0, 0, 0, 2568, 2570, 3, 992, 496, 0, 2569,
		2571, 7, 2, 0, 0, 2570, 2569, 1, 0, 0, 0, 2570, 2571, 1, 0, 0, 0, 2571,
		203, 1, 0, 0, 0, 2572, 2574, 5, 659, 0, 0, 2573, 2575, 3, 978, 489, 0,
		2574, 2573, 1, 0, 0, 0, 2574, 2575, 1, 0, 0, 0, 2575, 2576, 1, 0, 0, 0,
		2576, 2577, 3, 560, 280, 0, 2577, 205, 1, 0, 0, 0, 2578, 2579, 5, 523,
		0, 0, 2579, 2580, 5, 718, 0, 0, 2580, 2582, 5, 710, 0, 0, 2581, 2583, 3,
		978, 489, 0, 2582, 2581, 1, 0, 0, 0, 2582, 2583, 1, 0, 0, 0, 2583, 2584,
		1, 0, 0, 0, 2584, 2585, 3, 1146, 573, 0, 2585, 207, 1, 0, 0, 0, 2586, 2587,
		5, 605, 0, 0, 2587, 2588, 5, 572, 0, 0, 2588, 2590, 3, 1078, 539, 0, 2589,
		2591, 3, 58, 29, 0, 2590, 2589, 1, 0, 0, 0, 2590, 2591, 1, 0, 0, 0, 2591,
		209, 1, 0, 0, 0, 2592, 2593, 5, 453, 0, 0, 2593, 2594, 7, 18, 0, 0, 2594,
		2599, 3, 212, 106, 0, 2595, 2596, 5, 773, 0, 0, 2596, 2598, 3, 212, 106,
		0, 2597, 2595, 1, 0, 0, 0, 2598, 2601, 1, 0, 0, 0, 2599, 2597, 1, 0, 0,
		0, 2599, 2600, 1, 0, 0, 0, 2600, 211, 1, 0, 0, 0, 2601, 2599, 1, 0, 0,
		0, 2602, 2603, 3, 1102, 551, 0, 2603, 2604, 5, 590, 0, 0, 2604, 2605, 3,
		1096, 548, 0, 2605, 213, 1, 0, 0, 0, 2606, 2608, 5, 597, 0, 0, 2607, 2609,
		5, 574, 0, 0, 2608, 2607, 1, 0, 0, 0, 2608, 2609, 1, 0, 0, 0, 2609, 2610,
		1, 0, 0, 0, 2610, 2611, 3, 1102, 551, 0, 2611, 215, 1, 0, 0, 0, 2612, 2613,
		5, 234, 0, 0, 2613, 2614, 5, 574, 0, 0, 2614, 2615, 5, 203, 0, 0, 2615,
		2616, 3, 1164, 582, 0, 2616, 217, 1, 0, 0, 0, 2617, 2618, 5, 48, 0, 0,
		2618, 2624, 3, 1062, 531, 0, 2619, 2621, 5, 776, 0, 0, 2620, 2622, 3, 756,
		378, 0, 2621, 2620, 1, 0, 0, 0, 2621, 2622, 1, 0, 0, 0, 2622, 2623, 1,
		0, 0, 0, 2623, 2625, 5, 777, 0, 0, 2624, 2619, 1, 0, 0, 0, 2624, 2625,
		1, 0, 0, 0, 2625, 219, 1, 0, 0, 0, 2626, 2627, 4, 110, 38, 0, 2627, 2629,
		3, 320, 160, 0, 2628, 2626, 1, 0, 0, 0, 2628, 2629, 1, 0, 0, 0, 2629, 2630,
		1, 0, 0, 0, 2630, 2634, 5, 133, 0, 0, 2631, 2633, 3, 224, 112, 0, 2632,
		2631, 1, 0, 0, 0, 2633, 2636, 1, 0, 0, 0, 2634, 2632, 1, 0, 0, 0, 2634,
		2635, 1, 0, 0, 0, 2635, 2669, 1, 0, 0, 0, 2636, 2634, 1, 0, 0, 0, 2637,
		2661, 5, 203, 0, 0, 2638, 2639, 3, 1106, 553, 0, 2639, 2640, 5, 621, 0,
		0, 2640, 2642, 3, 334, 167, 0, 2641, 2643, 3, 358, 179, 0, 2642, 2641,
		1, 0, 0, 0, 2642, 2643, 1, 0, 0, 0, 2643, 2662, 1, 0, 0, 0, 2644, 2647,
		3, 1102, 551, 0, 2645, 2646, 4, 110, 39, 0, 2646, 2648, 3, 398, 199, 0,
		2647, 2645, 1, 0, 0, 0, 2647, 2648, 1, 0, 0, 0, 2648, 2650, 1, 0, 0, 0,
		2649, 2651, 3, 222, 111, 0, 2650, 2649, 1, 0, 0, 0, 2650, 2651, 1, 0, 0,
		0, 2651, 2653, 1, 0, 0, 0, 2652, 2654, 3, 358, 179, 0, 2653, 2652, 1, 0,
		0, 0, 2653, 2654, 1, 0, 0, 0, 2654, 2656, 1, 0, 0, 0, 2655, 2657, 3, 328,
		164, 0, 2656, 2655, 1, 0, 0, 0, 2656, 2657, 1, 0, 0, 0, 2657, 2659, 1,
		0, 0, 0, 2658, 2660, 3, 286, 143, 0, 2659, 2658, 1, 0, 0, 0, 2659, 2660,
		1, 0, 0, 0, 2660, 2662, 1, 0, 0, 0, 2661, 2638, 1, 0, 0, 0, 2661, 2644,
		1, 0, 0, 0, 2662, 2670, 1, 0, 0, 0, 2663, 2664, 3, 1106, 553, 0, 2664,
		2665, 5, 203, 0, 0, 2665, 2667, 3, 334, 167, 0, 2666, 2668, 3, 358, 179,
		0, 2667, 2666, 1, 0, 0, 0, 2667, 2668, 1, 0, 0, 0, 2668, 2670, 1, 0, 0,
		0, 2669, 2637, 1, 0, 0, 0, 2669, 2663, 1, 0, 0, 0, 2670, 221, 1, 0, 0,
		0, 2671, 2672, 4, 111, 40, 0, 2672, 2673, 5, 405, 0, 0, 2673, 2674, 5,
		776, 0, 0, 2674, 2675, 3, 1130, 565, 0, 2675, 2676, 5, 777, 0, 0, 2676,
		223, 1, 0, 0, 0, 2677, 2678, 7, 19, 0, 0, 2678, 225, 1, 0, 0, 0, 2679,
		2684, 5, 147, 0, 0, 2680, 2681, 4, 113, 41, 0, 2681, 2685, 3, 756, 378,
		0, 2682, 2683, 4, 113, 42, 0, 2683, 2685, 3, 352, 176, 0, 2684, 2680, 1,
		0, 0, 0, 2684, 2682, 1, 0, 0, 0, 2685, 227, 1, 0, 0, 0, 2686, 2704, 5,
		219, 0, 0, 2687, 2688, 3, 1102, 551, 0, 2688, 2690, 5, 387, 0, 0, 2689,
		2691, 3, 398, 199, 0, 2690, 2689, 1, 0, 0, 0, 2690, 2691, 1, 0, 0, 0, 2691,
		2705, 1, 0, 0, 0, 2692, 2702, 3, 1128, 564, 0, 2693, 2703, 5, 66, 0, 0,
		2694, 2695, 5, 435, 0, 0, 2695, 2697, 3, 230, 115, 0, 2696, 2698, 3, 358,
		179, 0, 2697, 2696, 1, 0, 0, 0, 2697, 2698, 1, 0, 0, 0, 2698, 2700, 1,
		0, 0, 0, 2699, 2701, 3, 284, 142, 0, 2700, 2699, 1, 0, 0, 0, 2700, 2701,
		1, 0, 0, 0, 2701, 2703, 1, 0, 0, 0, 2702, 2693, 1, 0, 0, 0, 2702, 2694,
		1, 0, 0, 0, 2703, 2705, 1, 0, 0, 0, 2704, 2687, 1, 0, 0, 0, 2704, 2692,
		1, 0, 0, 0, 2705, 229, 1, 0, 0, 0, 2706, 2717, 7, 20, 0, 0, 2707, 2714,
		3, 1128, 564, 0, 2708, 2715, 7, 21, 0, 0, 2709, 2710, 7, 22, 0, 0, 2710,
		2711, 5, 776, 0, 0, 2711, 2712, 3, 246, 123, 0, 2712, 2713, 5, 777, 0,
		0, 2713, 2715, 1, 0, 0, 0, 2714, 2708, 1, 0, 0, 0, 2714, 2709, 1, 0, 0,
		0, 2715, 2717, 1, 0, 0, 0, 2716, 2706, 1, 0, 0, 0, 2716, 2707, 1, 0, 0,
		0, 2717, 231, 1, 0, 0, 0, 2718, 2720, 5, 242, 0, 0, 2719, 2721, 3, 234,
		117, 0, 2720, 2719, 1, 0, 0, 0, 2720, 2721, 1, 0, 0, 0, 2721, 2723, 1,
		0, 0, 0, 2722, 2724, 5, 232, 0, 0, 2723, 2722, 1, 0, 0, 0, 2723, 2724,
		1, 0, 0, 0, 2724, 2726, 1, 0, 0, 0, 2725, 2727, 5, 248, 0, 0, 2726, 2725,
		1, 0, 0, 0, 2726, 2727, 1, 0, 0, 0, 2727, 2728, 1, 0, 0, 0, 2728, 2730,
		3, 1102, 551, 0, 2729, 2731, 3, 1036, 518, 0, 2730, 2729, 1, 0, 0, 0, 2730,
		2731, 1, 0, 0, 0, 2731, 2744, 1, 0, 0, 0, 2732, 2735, 3, 236, 118, 0, 2733,
		2734, 4, 116, 43, 0, 2734, 2736, 3, 248, 124, 0, 2735, 2733, 1, 0, 0, 0,
		2735, 2736, 1, 0, 0, 0, 2736, 2745, 1, 0, 0, 0, 2737, 2738, 5, 506, 0,
		0, 2738, 2741, 3, 994, 497, 0, 2739, 2740, 4, 116, 44, 0, 2740, 2742, 3,
		248, 124, 0, 2741, 2739, 1, 0, 0, 0, 2741, 2742, 1, 0, 0, 0, 2742, 2745,
		1, 0, 0, 0, 2743, 2745, 3, 242, 121, 0, 2744, 2732, 1, 0, 0, 0, 2744, 2737,
		1, 0, 0, 0, 2744, 2743, 1, 0, 0, 0, 2745, 2747, 1, 0, 0, 0, 2746, 2748,
		3, 250, 125, 0, 2747, 2746, 1, 0, 0, 0, 2747, 2748, 1, 0, 0, 0, 2748, 233,
		1, 0, 0, 0, 2749, 2750, 7, 23, 0, 0, 2750, 235, 1, 0, 0, 0, 2751, 2753,
		5, 776, 0, 0, 2752, 2754, 3, 238, 119, 0, 2753, 2752, 1, 0, 0, 0, 2753,
		2754, 1, 0, 0, 0, 2754, 2755, 1, 0, 0, 0, 2755, 2757, 5, 777, 0, 0, 2756,
		2751, 1, 0, 0, 0, 2756, 2757, 1, 0, 0, 0, 2757, 2758, 1, 0, 0, 0, 2758,
		2759, 3, 240, 120, 0, 2759, 237, 1, 0, 0, 0, 2760, 2765, 3, 1048, 524,
		0, 2761, 2762, 5, 773, 0, 0, 2762, 2764, 3, 1048, 524, 0, 2763, 2761, 1,
		0, 0, 0, 2764, 2767, 1, 0, 0, 0, 2765, 2763, 1, 0, 0, 0, 2765, 2766, 1,
		0, 0, 0, 2766, 239, 1, 0, 0, 0, 2767, 2765, 1, 0, 0, 0, 2768, 2769, 7,
		24, 0, 0, 2769, 2770, 3, 244, 122, 0, 2770, 241, 1, 0, 0, 0, 2771, 2779,
		3, 90, 45, 0, 2772, 2774, 5, 776, 0, 0, 2773, 2775, 3, 238, 119, 0, 2774,
		2773, 1, 0, 0, 0, 2774, 2775, 1, 0, 0, 0, 2775, 2776, 1, 0, 0, 0, 2776,
		2777, 5, 777, 0, 0, 2777, 2779, 3, 90, 45, 0, 2778, 2771, 1, 0, 0, 0, 2778,
		2772, 1, 0, 0, 0, 2779, 243, 1, 0, 0, 0, 2780, 2782, 5, 776, 0, 0, 2781,
		2783, 3, 246, 123, 0, 2782, 2781, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783,
		2784, 1, 0, 0, 0, 2784, 2793, 5, 777, 0, 0, 2785, 2786, 5, 773, 0, 0, 2786,
		2788, 5, 776, 0, 0, 2787, 2789, 3, 246, 123, 0, 2788, 2787, 1, 0, 0, 0,
		2788, 2789, 1, 0, 0, 0, 2789, 2790, 1, 0, 0, 0, 2790, 2792, 5, 777, 0,
		0, 2791, 2785, 1, 0, 0, 0, 2792, 2795, 1, 0, 0, 0, 2793, 2791, 1, 0, 0,
		0, 2793, 2794, 1, 0, 0, 0, 2794, 245, 1, 0, 0, 0, 2795, 2793, 1, 0, 0,
		0, 2796, 2799, 3, 676, 338, 0, 2797, 2799, 5, 128, 0, 0, 2798, 2796, 1,
		0, 0, 0, 2798, 2797, 1, 0, 0, 0, 2799, 2807, 1, 0, 0, 0, 2800, 2803, 5,
		773, 0, 0, 2801, 2804, 3, 676, 338, 0, 2802, 2804, 5, 128, 0, 0, 2803,
		2801, 1, 0, 0, 0, 2803, 2802, 1, 0, 0, 0, 2804, 2806, 1, 0, 0, 0, 2805,
		2800, 1, 0, 0, 0, 2806, 2809, 1, 0, 0, 0, 2807, 2805, 1, 0, 0, 0, 2807,
		2808, 1, 0, 0, 0, 2808, 247, 1, 0, 0, 0, 2809, 2807, 1, 0, 0, 0, 2810,
		2811, 5, 17, 0, 0, 2811, 2813, 3, 1128, 564, 0, 2812, 2814, 3, 1044, 522,
		0, 2813, 2812, 1, 0, 0, 0, 2813, 2814, 1, 0, 0, 0, 2814, 249, 1, 0, 0,
		0, 2815, 2816, 5, 383, 0, 0, 2816, 2817, 5, 151, 0, 0, 2817, 2818, 5, 265,
		0, 0, 2818, 2819, 5, 614, 0, 0, 2819, 2820, 3, 994, 497, 0, 2820, 251,
		1, 0, 0, 0, 2821, 2822, 5, 281, 0, 0, 2822, 2824, 3, 254, 127, 0, 2823,
		2825, 7, 25, 0, 0, 2824, 2823, 1, 0, 0, 0, 2824, 2825, 1, 0, 0, 0, 2825,
		2827, 1, 0, 0, 0, 2826, 2828, 5, 284, 0, 0, 2827, 2826, 1, 0, 0, 0, 2827,
		2828, 1, 0, 0, 0, 2828, 2829, 1, 0, 0, 0, 2829, 2830, 5, 237, 0, 0, 2830,
		2832, 3, 1160, 580, 0, 2831, 2833, 7, 8, 0, 0, 2832, 2831, 1, 0, 0, 0,
		2832, 2833, 1, 0, 0, 0, 2833, 2834, 1, 0, 0, 0, 2834, 2835, 5, 248, 0,
		0, 2835, 2836, 5, 574, 0, 0, 2836, 2838, 3, 1102, 551, 0, 2837, 2839, 3,
		1036, 518, 0, 2838, 2837, 1, 0, 0, 0, 2838, 2839, 1, 0, 0, 0, 2839, 2841,
		1, 0, 0, 0, 2840, 2842, 3, 998, 499, 0, 2841, 2840, 1, 0, 0, 0, 2841, 2842,
		1, 0, 0, 0, 2842, 2844, 1, 0, 0, 0, 2843, 2845, 3, 256, 128, 0, 2844, 2843,
		1, 0, 0, 0, 2844, 2845, 1, 0, 0, 0, 2845, 2847, 1, 0, 0, 0, 2846, 2848,
		3, 1000, 500, 0, 2847, 2846, 1, 0, 0, 0, 2847, 2848, 1, 0, 0, 0, 2848,
		2850, 1, 0, 0, 0, 2849, 2851, 3, 1004, 502, 0, 2850, 2849, 1, 0, 0, 0,
		2850, 2851, 1, 0, 0, 0, 2851, 2852, 1, 0, 0, 0, 2852, 2853, 3, 258, 129,
		0, 2853, 253, 1, 0, 0, 0, 2854, 2855, 7, 26, 0, 0, 2855, 255, 1, 0, 0,
		0, 2856, 2857, 5, 484, 0, 0, 2857, 2858, 5, 230, 0, 0, 2858, 2859, 5, 45,
		0, 0, 2859, 2860, 3, 1156, 578, 0, 2860, 257, 1, 0, 0, 0, 2861, 2862, 5,
		232, 0, 0, 2862, 2863, 5, 747, 0, 0, 2863, 2865, 7, 27, 0, 0, 2864, 2861,
		1, 0, 0, 0, 2864, 2865, 1, 0, 0, 0, 2865, 2867, 1, 0, 0, 0, 2866, 2868,
		3, 260, 130, 0, 2867, 2866, 1, 0, 0, 0, 2867, 2868, 1, 0, 0, 0, 2868, 2871,
		1, 0, 0, 0, 2869, 2870, 5, 506, 0, 0, 2870, 2872, 3, 994, 497, 0, 2871,
		2869, 1, 0, 0, 0, 2871, 2872, 1, 0, 0, 0, 2872, 259, 1, 0, 0, 0, 2873,
		2875, 5, 776, 0, 0, 2874, 2876, 3, 262, 131, 0, 2875, 2874, 1, 0, 0, 0,
		2875, 2876, 1, 0, 0, 0, 2876, 2877, 1, 0, 0, 0, 2877, 2878, 5, 777, 0,
		0, 2878, 261, 1, 0, 0, 0, 2879, 2882, 3, 1046, 523, 0, 2880, 2882, 3, 742,
		371, 0, 2881, 2879, 1, 0, 0, 0, 2881, 2880, 1, 0, 0, 0, 2882, 2890, 1,
		0, 0, 0, 2883, 2886, 5, 773, 0, 0, 2884, 2887, 3, 1046, 523, 0, 2885, 2887,
		3, 742, 371, 0, 2886, 2884, 1, 0, 0, 0, 2886, 2885, 1, 0, 0, 0, 2887, 2889,
		1, 0, 0, 0, 2888, 2883, 1, 0, 0, 0, 2889, 2892, 1, 0, 0, 0, 2890, 2888,
		1, 0, 0, 0, 2890, 2891, 1, 0, 0, 0, 2891, 263, 1, 0, 0, 0, 2892, 2890,
		1, 0, 0, 0, 2893, 2895, 5, 458, 0, 0, 2894, 2896, 7, 28, 0, 0, 2895, 2894,
		1, 0, 0, 0, 2895, 2896, 1, 0, 0, 0, 2896, 2898, 1, 0, 0, 0, 2897, 2899,
		5, 248, 0, 0, 2898, 2897, 1, 0, 0, 0, 2898, 2899, 1, 0, 0, 0, 2899, 2900,
		1, 0, 0, 0, 2900, 2902, 3, 1102, 551, 0, 2901, 2903, 3, 1036, 518, 0, 2902,
		2901, 1, 0, 0, 0, 2902, 2903, 1, 0, 0, 0, 2903, 2908, 1, 0, 0, 0, 2904,
		2909, 3, 236, 118, 0, 2905, 2906, 5, 506, 0, 0, 2906, 2909, 3, 994, 497,
		0, 2907, 2909, 3, 242, 121, 0, 2908, 2904, 1, 0, 0, 0, 2908, 2905, 1, 0,
		0, 0, 2908, 2907, 1, 0, 0, 0, 2909, 265, 1, 0, 0, 0, 2910, 2912, 3, 270,
		135, 0, 2911, 2913, 3, 344, 172, 0, 2912, 2911, 1, 0, 0, 0, 2912, 2913,
		1, 0, 0, 0, 2913, 2917, 1, 0, 0, 0, 2914, 2917, 3, 274, 137, 0, 2915, 2917,
		3, 268, 134, 0, 2916, 2910, 1, 0, 0, 0, 2916, 2914, 1, 0, 0, 0, 2916, 2915,
		1, 0, 0, 0, 2917, 267, 1, 0, 0, 0, 2918, 2919, 5, 776, 0, 0, 2919, 2920,
		3, 268, 134, 0, 2920, 2921, 5, 777, 0, 0, 2921, 2931, 1, 0, 0, 0, 2922,
		2923, 3, 270, 135, 0, 2923, 2925, 3, 292, 146, 0, 2924, 2926, 3, 344, 172,
		0, 2925, 2924, 1, 0, 0, 0, 2925, 2926, 1, 0, 0, 0, 2926, 2931, 1, 0, 0,
		0, 2927, 2928, 3, 344, 172, 0, 2928, 2929, 3, 292, 146, 0, 2929, 2931,
		1, 0, 0, 0, 2930, 2918, 1, 0, 0, 0, 2930, 2922, 1, 0, 0, 0, 2930, 2927,
		1, 0, 0, 0, 2931, 269, 1, 0, 0, 0, 2932, 2933, 4, 135, 45, 0, 2933, 2935,
		3, 320, 160, 0, 2934, 2932, 1, 0, 0, 0, 2934, 2935, 1, 0, 0, 0, 2935, 2950,
		1, 0, 0, 0, 2936, 2938, 3, 272, 136, 0, 2937, 2939, 3, 328, 164, 0, 2938,
		2937, 1, 0, 0, 0, 2938, 2939, 1, 0, 0, 0, 2939, 2941, 1, 0, 0, 0, 2940,
		2942, 3, 284, 142, 0, 2941, 2940, 1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942,
		2951, 1, 0, 0, 0, 2943, 2945, 3, 274, 137, 0, 2944, 2946, 3, 328, 164,
		0, 2945, 2944, 1, 0, 0, 0, 2945, 2946, 1, 0, 0, 0, 2946, 2948, 1, 0, 0,
		0, 2947, 2949, 3, 284, 142, 0, 2948, 2947, 1, 0, 0, 0, 2948, 2949, 1, 0,
		0, 0, 2949, 2951, 1, 0, 0, 0, 2950, 2936, 1, 0, 0, 0, 2950, 2943, 1, 0,
		0, 0, 2951, 2954, 1, 0, 0, 0, 2952, 2953, 4, 135, 46, 0, 2953, 2955, 3,
		294, 147, 0, 2954, 2952, 1, 0, 0, 0, 2954, 2955, 1, 0, 0, 0, 2955, 271,
		1, 0, 0, 0, 2956, 2967, 3, 276, 138, 0, 2957, 2958, 3, 274, 137, 0, 2958,
		2960, 5, 608, 0, 0, 2959, 2961, 3, 396, 198, 0, 2960, 2959, 1, 0, 0, 0,
		2960, 2961, 1, 0, 0, 0, 2961, 2964, 1, 0, 0, 0, 2962, 2965, 3, 276, 138,
		0, 2963, 2965, 3, 274, 137, 0, 2964, 2962, 1, 0, 0, 0, 2964, 2963, 1, 0,
		0, 0, 2965, 2967, 1, 0, 0, 0, 2966, 2956, 1, 0, 0, 0, 2966, 2957, 1, 0,
		0, 0, 2967, 2978, 1, 0, 0, 0, 2968, 2970, 5, 608, 0, 0, 2969, 2971, 3,
		396, 198, 0, 2970, 2969, 1, 0, 0, 0, 2970, 2971, 1, 0, 0, 0, 2971, 2974,
		1, 0, 0, 0, 2972, 2975, 3, 276, 138, 0, 2973, 2975, 3, 274, 137, 0, 2974,
		2972, 1, 0, 0, 0, 2974, 2973, 1, 0, 0, 0, 2975, 2977, 1, 0, 0, 0, 2976,
		2968, 1, 0, 0, 0, 2977, 2980, 1, 0, 0, 0, 2978, 2976, 1, 0, 0, 0, 2978,
		2979, 1, 0, 0, 0, 2979, 273, 1, 0, 0, 0, 2980, 2978, 1, 0, 0, 0, 2981,
		2987, 5, 776, 0, 0, 2982, 2988, 3, 274, 137, 0, 2983, 2985, 3, 270, 135,
		0, 2984, 2986, 3, 344, 172, 0, 2985, 2984, 1, 0, 0, 0, 2985, 2986, 1, 0,
		0, 0, 2986, 2988, 1, 0, 0, 0, 2987, 2982, 1, 0, 0, 0, 2987, 2983, 1, 0,
		0, 0, 2988, 2989, 1, 0, 0, 0, 2989, 2990, 5, 777, 0, 0, 2990, 275, 1, 0,
		0, 0, 2991, 2997, 3, 278, 139, 0, 2992, 2993, 4, 138, 47, 0, 2993, 2997,
		3, 336, 168, 0, 2994, 2995, 4, 138, 48, 0, 2995, 2997, 3, 338, 169, 0,
		2996, 2991, 1, 0, 0, 0, 2996, 2992, 1, 0, 0, 0, 2996, 2994, 1, 0, 0, 0,
		2997, 277, 1, 0, 0, 0, 2998, 3002, 5, 497, 0, 0, 2999, 3001, 3, 342, 171,
		0, 3000, 2999, 1, 0, 0, 0, 3001, 3004, 1, 0, 0, 0, 3002, 3000, 1, 0, 0,
		0, 3002, 3003, 1, 0, 0, 0, 3003, 3005, 1, 0, 0, 0, 3004, 3002, 1, 0, 0,
		0, 3005, 3007, 3, 352, 176, 0, 3006, 3008, 3, 292, 146, 0, 3007, 3006,
		1, 0, 0, 0, 3007, 3008, 1, 0, 0, 0, 3008, 3010, 1, 0, 0, 0, 3009, 3011,
		3, 332, 166, 0, 3010, 3009, 1, 0, 0, 0, 3010, 3011, 1, 0, 0, 0, 3011, 3013,
		1, 0, 0, 0, 3012, 3014, 3, 358, 179, 0, 3013, 3012, 1, 0, 0, 0, 3013, 3014,
		1, 0, 0, 0, 3014, 3016, 1, 0, 0, 0, 3015, 3017, 3, 324, 162, 0, 3016, 3015,
		1, 0, 0, 0, 3016, 3017, 1, 0, 0, 0, 3017, 3019, 1, 0, 0, 0, 3018, 3020,
		3, 296, 148, 0, 3019, 3018, 1, 0, 0, 0, 3019, 3020, 1, 0, 0, 0, 3020, 3023,
		1, 0, 0, 0, 3021, 3022, 4, 139, 49, 0, 3022, 3024, 3, 298, 149, 0, 3023,
		3021, 1, 0, 0, 0, 3023, 3024, 1, 0, 0, 0, 3024, 279, 1, 0, 0, 0, 3025,
		3026, 3, 274, 137, 0, 3026, 281, 1, 0, 0, 0, 3027, 3028, 7, 29, 0, 0, 3028,
		283, 1, 0, 0, 0, 3029, 3030, 5, 276, 0, 0, 3030, 3031, 3, 288, 144, 0,
		3031, 285, 1, 0, 0, 0, 3032, 3033, 5, 276, 0, 0, 3033, 3034, 3, 290, 145,
		0, 3034, 287, 1, 0, 0, 0, 3035, 3038, 3, 290, 145, 0, 3036, 3037, 7, 30,
		0, 0, 3037, 3039, 3, 290, 145, 0, 3038, 3036, 1, 0, 0, 0, 3038, 3039, 1,
		0, 0, 0, 3039, 289, 1, 0, 0, 0, 3040, 3043, 3, 1128, 564, 0, 3041, 3043,
		7, 31, 0, 0, 3042, 3040, 1, 0, 0, 0, 3042, 3041, 1, 0, 0, 0, 3043, 291,
		1, 0, 0, 0, 3044, 3072, 5, 248, 0, 0, 3045, 3046, 5, 396, 0, 0, 3046, 3048,
		3, 1154, 577, 0, 3047, 3049, 3, 998, 499, 0, 3048, 3047, 1, 0, 0, 0, 3048,
		3049, 1, 0, 0, 0, 3049, 3051, 1, 0, 0, 0, 3050, 3052, 3, 1000, 500, 0,
		3051, 3050, 1, 0, 0, 0, 3051, 3052, 1, 0, 0, 0, 3052, 3054, 1, 0, 0, 0,
		3053, 3055, 3, 1004, 502, 0, 3054, 3053, 1, 0, 0, 0, 3054, 3055, 1, 0,
		0, 0, 3055, 3073, 1, 0, 0, 0, 3056, 3057, 5, 150, 0, 0, 3057, 3073, 3,
		1154, 577, 0, 3058, 3061, 3, 1180, 590, 0, 3059, 3061, 3, 742, 371, 0,
		3060, 3058, 1, 0, 0, 0, 3060, 3059, 1, 0, 0, 0, 3061, 3069, 1, 0, 0, 0,
		3062, 3065, 5, 773, 0, 0, 3063, 3066, 3, 1180, 590, 0, 3064, 3066, 3, 742,
		371, 0, 3065, 3063, 1, 0, 0, 0, 3065, 3064, 1, 0, 0, 0, 3066, 3068, 1,
		0, 0, 0, 3067, 3062, 1, 0, 0, 0, 3068, 3071, 1, 0, 0, 0, 3069, 3067, 1,
		0, 0, 0, 3069, 3070, 1, 0, 0, 0, 3070, 3073, 1, 0, 0, 0, 3071, 3069, 1,
		0, 0, 0, 3072, 3045, 1, 0, 0, 0, 3072, 3056, 1, 0, 0, 0, 3072, 3060, 1,
		0, 0, 0, 3073, 293, 1, 0, 0, 0, 3074, 3075, 5, 422, 0, 0, 3075, 3076, 5,
		13, 0, 0, 3076, 3082, 5, 776, 0, 0, 3077, 3080, 5, 747, 0, 0, 3078, 3079,
		5, 773, 0, 0, 3079, 3081, 5, 747, 0, 0, 3080, 3078, 1, 0, 0, 0, 3080, 3081,
		1, 0, 0, 0, 3081, 3083, 1, 0, 0, 0, 3082, 3077, 1, 0, 0, 0, 3082, 3083,
		1, 0, 0, 0, 3083, 3084, 1, 0, 0, 0, 3084, 3085, 5, 777, 0, 0, 3085, 295,
		1, 0, 0, 0, 3086, 3087, 5, 221, 0, 0, 3087, 3088, 3, 676, 338, 0, 3088,
		297, 1, 0, 0, 0, 3089, 3090, 5, 699, 0, 0, 3090, 3095, 3, 300, 150, 0,
		3091, 3092, 5, 773, 0, 0, 3092, 3094, 3, 300, 150, 0, 3093, 3091, 1, 0,
		0, 0, 3094, 3097, 1, 0, 0, 0, 3095, 3093, 1, 0, 0, 0, 3095, 3096, 1, 0,
		0, 0, 3096, 299, 1, 0, 0, 0, 3097, 3095, 1, 0, 0, 0, 3098, 3099, 3, 1124,
		562, 0, 3099, 3100, 5, 17, 0, 0, 3100, 3101, 3, 302, 151, 0, 3101, 301,
		1, 0, 0, 0, 3102, 3103, 5, 776, 0, 0, 3103, 3104, 3, 304, 152, 0, 3104,
		3105, 5, 777, 0, 0, 3105, 303, 1, 0, 0, 0, 3106, 3108, 3, 1124, 562, 0,
		3107, 3106, 1, 0, 0, 0, 3107, 3108, 1, 0, 0, 0, 3108, 3112, 1, 0, 0, 0,
		3109, 3110, 5, 405, 0, 0, 3110, 3111, 5, 45, 0, 0, 3111, 3113, 3, 774,
		387, 0, 3112, 3109, 1, 0, 0, 0, 3112, 3113, 1, 0, 0, 0, 3113, 3115, 1,
		0, 0, 0, 3114, 3116, 3, 328, 164, 0, 3115, 3114, 1, 0, 0, 0, 3115, 3116,
		1, 0, 0, 0, 3116, 3118, 1, 0, 0, 0, 3117, 3119, 3, 306, 153, 0, 3118, 3117,
		1, 0, 0, 0, 3118, 3119, 1, 0, 0, 0, 3119, 305, 1, 0, 0, 0, 3120, 3121,
		3, 308, 154, 0, 3121, 3123, 3, 310, 155, 0, 3122, 3124, 3, 318, 159, 0,
		3123, 3122, 1, 0, 0, 0, 3123, 3124, 1, 0, 0, 0, 3124, 307, 1, 0, 0, 0,
		3125, 3126, 7, 32, 0, 0, 3126, 309, 1, 0, 0, 0, 3127, 3130, 3, 312, 156,
		0, 3128, 3130, 3, 314, 157, 0, 3129, 3127, 1, 0, 0, 0, 3129, 3128, 1, 0,
		0, 0, 3130, 311, 1, 0, 0, 0, 3131, 3132, 5, 698, 0, 0, 3132, 3146, 5, 693,
		0, 0, 3133, 3134, 3, 1144, 572, 0, 3134, 3135, 5, 693, 0, 0, 3135, 3146,
		1, 0, 0, 0, 3136, 3137, 5, 787, 0, 0, 3137, 3146, 5, 693, 0, 0, 3138, 3139,
		5, 247, 0, 0, 3139, 3140, 3, 676, 338, 0, 3140, 3141, 3, 764, 382, 0, 3141,
		3142, 5, 693, 0, 0, 3142, 3146, 1, 0, 0, 0, 3143, 3144, 5, 101, 0, 0, 3144,
		3146, 5, 487, 0, 0, 3145, 3131, 1, 0, 0, 0, 3145, 3133, 1, 0, 0, 0, 3145,
		3136, 1, 0, 0, 0, 3145, 3138, 1, 0, 0, 0, 3145, 3143, 1, 0, 0, 0, 3146,
		313, 1, 0, 0, 0, 3147, 3148, 5, 30, 0, 0, 3148, 3149, 3, 316, 158, 0, 3149,
		3150, 5, 15, 0, 0, 3150, 3151, 3, 316, 158, 0, 3151, 315, 1, 0, 0, 0, 3152,
		3166, 3, 312, 156, 0, 3153, 3154, 5, 698, 0, 0, 3154, 3166, 5, 682, 0,
		0, 3155, 3156, 3, 1144, 572, 0, 3156, 3157, 5, 682, 0, 0, 3157, 3166, 1,
		0, 0, 0, 3158, 3159, 5, 787, 0, 0, 3159, 3166, 5, 682, 0, 0, 3160, 3161,
		5, 247, 0, 0, 3161, 3162, 3, 676, 338, 0, 3162, 3163, 3, 764, 382, 0, 3163,
		3164, 5, 682, 0, 0, 3164, 3166, 1, 0, 0, 0, 3165, 3152, 1, 0, 0, 0, 3165,
		3153, 1, 0, 0, 0, 3165, 3155, 1, 0, 0, 0, 3165, 3158, 1, 0, 0, 0, 3165,
		3160, 1, 0, 0, 0, 3166, 317, 1, 0, 0, 0, 3167, 3174, 5, 680, 0, 0, 3168,
		3169, 5, 101, 0, 0, 3169, 3175, 5, 487, 0, 0, 3170, 3175, 5, 217, 0, 0,
		3171, 3175, 5, 697, 0, 0, 3172, 3173, 5, 373, 0, 0, 3173, 3175, 5, 690,
		0, 0, 3174, 3168, 1, 0, 0, 0, 3174, 3170, 1, 0, 0, 0, 3174, 3171, 1, 0,
		0, 0, 3174, 3172, 1, 0, 0, 0, 3175, 319, 1, 0, 0, 0, 3176, 3178, 5, 645,
		0, 0, 3177, 3179, 5, 665, 0, 0, 3178, 3177, 1, 0, 0, 0, 3178, 3179, 1,
		0, 0, 0, 3179, 3180, 1, 0, 0, 0, 3180, 3185, 3, 322, 161, 0, 3181, 3182,
		5, 773, 0, 0, 3182, 3184, 3, 322, 161, 0, 3183, 3181, 1, 0, 0, 0, 3184,
		3187, 1, 0, 0, 0, 3185, 3183, 1, 0, 0, 0, 3185, 3186, 1, 0, 0, 0, 3186,
		321, 1, 0, 0, 0, 3187, 3185, 1, 0, 0, 0, 3188, 3190, 3, 1128, 564, 0, 3189,
		3191, 3, 1044, 522, 0, 3190, 3189, 1, 0, 0, 0, 3190, 3191, 1, 0, 0, 0,
		3191, 3192, 1, 0, 0, 0, 3192, 3193, 5, 17, 0, 0, 3193, 3194, 3, 280, 140,
		0, 3194, 323, 1, 0, 0, 0, 3195, 3196, 5, 217, 0, 0, 3196, 3197, 5, 45,
		0, 0, 3197, 3199, 3, 774, 387, 0, 3198, 3200, 3, 326, 163, 0, 3199, 3198,
		1, 0, 0, 0, 3199, 3200, 1, 0, 0, 0, 3200, 325, 1, 0, 0, 0, 3201, 3202,
		5, 645, 0, 0, 3202, 3207, 5, 481, 0, 0, 3203, 3204, 4, 163, 50, 0, 3204,
		3205, 5, 645, 0, 0, 3205, 3207, 5, 99, 0, 0, 3206, 3201, 1, 0, 0, 0, 3206,
		3203, 1, 0, 0, 0, 3207, 327, 1, 0, 0, 0, 3208, 3209, 5, 393, 0, 0, 3209,
		3210, 5, 45, 0, 0, 3210, 3211, 3, 774, 387, 0, 3211, 329, 1, 0, 0, 0, 3212,
		3213, 7, 33, 0, 0, 3213, 331, 1, 0, 0, 0, 3214, 3217, 5, 203, 0, 0, 3215,
		3218, 5, 149, 0, 0, 3216, 3218, 3, 334, 167, 0, 3217, 3215, 1, 0, 0, 0,
		3217, 3216, 1, 0, 0, 0, 3218, 333, 1, 0, 0, 0, 3219, 3224, 3, 360, 180,
		0, 3220, 3221, 5, 773, 0, 0, 3221, 3223, 3, 360, 180, 0, 3222, 3220, 1,
		0, 0, 0, 3223, 3226, 1, 0, 0, 0, 3224, 3222, 1, 0, 0, 0, 3224, 3225, 1,
		0, 0, 0, 3225, 335, 1, 0, 0, 0, 3226, 3224, 1, 0, 0, 0, 3227, 3228, 5,
		626, 0, 0, 3228, 3233, 3, 340, 170, 0, 3229, 3230, 5, 773, 0, 0, 3230,
		3232, 3, 340, 170, 0, 3231, 3229, 1, 0, 0, 0, 3232, 3235, 1, 0, 0, 0, 3233,
		3231, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 337, 1, 0, 0, 0, 3235,
		3233, 1, 0, 0, 0, 3236, 3237, 5, 574, 0, 0, 3237, 3238, 3, 1102, 551, 0,
		3238, 339, 1, 0, 0, 0, 3239, 3240, 5, 487, 0, 0, 3240, 3242, 5, 776, 0,
		0, 3241, 3243, 3, 246, 123, 0, 3242, 3241, 1, 0, 0, 0, 3242, 3243, 1, 0,
		0, 0, 3243, 3244, 1, 0, 0, 0, 3244, 3245, 5, 777, 0, 0, 3245, 341, 1, 0,
		0, 0, 3246, 3255, 3, 282, 141, 0, 3247, 3255, 5, 535, 0, 0, 3248, 3249,
		4, 171, 51, 0, 3249, 3255, 5, 533, 0, 0, 3250, 3251, 4, 171, 52, 0, 3251,
		3252, 5, 325, 0, 0, 3252, 3253, 5, 750, 0, 0, 3253, 3255, 3, 1142, 571,
		0, 3254, 3246, 1, 0, 0, 0, 3254, 3247, 1, 0, 0, 0, 3254, 3248, 1, 0, 0,
		0, 3254, 3250, 1, 0, 0, 0, 3255, 343, 1, 0, 0, 0, 3256, 3258, 3, 346, 173,
		0, 3257, 3256, 1, 0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3257, 1, 0, 0,
		0, 3259, 3260, 1, 0, 0, 0, 3260, 345, 1, 0, 0, 0, 3261, 3262, 5, 200, 0,
		0, 3262, 3266, 3, 348, 174, 0, 3263, 3264, 4, 173, 53, 0, 3264, 3265, 5,
		668, 0, 0, 3265, 3267, 3, 1106, 553, 0, 3266, 3263, 1, 0, 0, 0, 3266, 3267,
		1, 0, 0, 0, 3267, 3270, 1, 0, 0, 0, 3268, 3269, 4, 173, 54, 0, 3269, 3271,
		3, 350, 175, 0, 3270, 3268, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3277,
		1, 0, 0, 0, 3272, 3273, 5, 287, 0, 0, 3273, 3274, 5, 251, 0, 0, 3274, 3275,
		5, 508, 0, 0, 3275, 3277, 5, 346, 0, 0, 3276, 3261, 1, 0, 0, 0, 3276, 3272,
		1, 0, 0, 0, 3277, 347, 1, 0, 0, 0, 3278, 3282, 5, 614, 0, 0, 3279, 3280,
		4, 174, 55, 0, 3280, 3282, 5, 508, 0, 0, 3281, 3278, 1, 0, 0, 0, 3281,
		3279, 1, 0, 0, 0, 3282, 349, 1, 0, 0, 0, 3283, 3284, 5, 669, 0, 0, 3284,
		3287, 5, 670, 0, 0, 3285, 3287, 5, 671, 0, 0, 3286, 3283, 1, 0, 0, 0, 3286,
		3285, 1, 0, 0, 0, 3287, 351, 1, 0, 0, 0, 3288, 3291, 3, 354, 177, 0, 3289,
		3291, 5, 760, 0, 0, 3290, 3288, 1, 0, 0, 0, 3290, 3289, 1, 0, 0, 0, 3291,
		3296, 1, 0, 0, 0, 3292, 3293, 5, 773, 0, 0, 3293, 3295, 3, 354, 177, 0,
		3294, 3292, 1, 0, 0, 0, 3295, 3298, 1, 0, 0, 0, 3296, 3294, 1, 0, 0, 0,
		3296, 3297, 1, 0, 0, 0, 3297, 353, 1, 0, 0, 0, 3298, 3296, 1, 0, 0, 0,
		3299, 3305, 3, 1054, 527, 0, 3300, 3302, 3, 676, 338, 0, 3301, 3303, 3,
		356, 178, 0, 3302, 3301, 1, 0, 0, 0, 3302, 3303, 1, 0, 0, 0, 3303, 3305,
		1, 0, 0, 0, 3304, 3299, 1, 0, 0, 0, 3304, 3300, 1, 0, 0, 0, 3305, 355,
		1, 0, 0, 0, 3306, 3308, 5, 17, 0, 0, 3307, 3306, 1, 0, 0, 0, 3307, 3308,
		1, 0, 0, 0, 3308, 3311, 1, 0, 0, 0, 3309, 3312, 3, 1128, 564, 0, 3310,
		3312, 3, 1154, 577, 0, 3311, 3309, 1, 0, 0, 0, 3311, 3310, 1, 0, 0, 0,
		3312, 357, 1, 0, 0, 0, 3313, 3314, 5, 643, 0, 0, 3314, 3315, 3, 676, 338,
		0, 3315, 359, 1, 0, 0, 0, 3316, 3327, 3, 372, 186, 0, 3317, 3321, 5, 778,
		0, 0, 3318, 3319, 4, 180, 56, 0, 3319, 3322, 3, 1128, 564, 0, 3320, 3322,
		5, 732, 0, 0, 3321, 3318, 1, 0, 0, 0, 3321, 3320, 1, 0, 0, 0, 3322, 3323,
		1, 0, 0, 0, 3323, 3324, 3, 362, 181, 0, 3324, 3325, 5, 779, 0, 0, 3325,
		3327, 1, 0, 0, 0, 3326, 3316, 1, 0, 0, 0, 3326, 3317, 1, 0, 0, 0, 3327,
		3331, 1, 0, 0, 0, 3328, 3330, 3, 364, 182, 0, 3329, 3328, 1, 0, 0, 0, 3330,
		3333, 1, 0, 0, 0, 3331, 3329, 1, 0, 0, 0, 3331, 3332, 1, 0, 0, 0, 3332,
		361, 1, 0, 0, 0, 3333, 3331, 1, 0, 0, 0, 3334, 3338, 3, 372, 186, 0, 3335,
		3337, 3, 364, 182, 0, 3336, 3335, 1, 0, 0, 0, 3337, 3340, 1, 0, 0, 0, 3338,
		3336, 1, 0, 0, 0, 3338, 3339, 1, 0, 0, 0, 3339, 363, 1, 0, 0, 0, 3340,
		3338, 1, 0, 0, 0, 3341, 3342, 3, 368, 184, 0, 3342, 3347, 3, 360, 180,
		0, 3343, 3344, 5, 383, 0, 0, 3344, 3348, 3, 676, 338, 0, 3345, 3346, 5,
		621, 0, 0, 3346, 3348, 3, 1132, 566, 0, 3347, 3343, 1, 0, 0, 0, 3347, 3345,
		1, 0, 0, 0, 3347, 3348, 1, 0, 0, 0, 3348, 3361, 1, 0, 0, 0, 3349, 3350,
		3, 370, 185, 0, 3350, 3355, 3, 360, 180, 0, 3351, 3352, 5, 383, 0, 0, 3352,
		3356, 3, 676, 338, 0, 3353, 3354, 5, 621, 0, 0, 3354, 3356, 3, 1132, 566,
		0, 3355, 3351, 1, 0, 0, 0, 3355, 3353, 1, 0, 0, 0, 3356, 3361, 1, 0, 0,
		0, 3357, 3358, 3, 366, 183, 0, 3358, 3359, 3, 372, 186, 0, 3359, 3361,
		1, 0, 0, 0, 3360, 3341, 1, 0, 0, 0, 3360, 3349, 1, 0, 0, 0, 3360, 3357,
		1, 0, 0, 0, 3361, 365, 1, 0, 0, 0, 3362, 3364, 5, 359, 0, 0, 3363, 3365,
		5, 239, 0, 0, 3364, 3363, 1, 0, 0, 0, 3364, 3365, 1, 0, 0, 0, 3365, 3366,
		1, 0, 0, 0, 3366, 3374, 5, 261, 0, 0, 3367, 3368, 5, 359, 0, 0, 3368, 3370,
		7, 34, 0, 0, 3369, 3371, 5, 395, 0, 0, 3370, 3369, 1, 0, 0, 0, 3370, 3371,
		1, 0, 0, 0, 3371, 3372, 1, 0, 0, 0, 3372, 3374, 5, 261, 0, 0, 3373, 3362,
		1, 0, 0, 0, 3373, 3367, 1, 0, 0, 0, 3374, 367, 1, 0, 0, 0, 3375, 3377,
		7, 35, 0, 0, 3376, 3375, 1, 0, 0, 0, 3376, 3377, 1, 0, 0, 0, 3377, 3378,
		1, 0, 0, 0, 3378, 3381, 5, 261, 0, 0, 3379, 3381, 5, 555, 0, 0, 3380, 3376,
		1, 0, 0, 0, 3380, 3379, 1, 0, 0, 0, 3381, 369, 1, 0, 0, 0, 3382, 3384,
		7, 34, 0, 0, 3383, 3385, 5, 395, 0, 0, 3384, 3383, 1, 0, 0, 0, 3384, 3385,
		1, 0, 0, 0, 3385, 3386, 1, 0, 0, 0, 3386, 3387, 5, 261, 0, 0, 3387, 371,
		1, 0, 0, 0, 3388, 3395, 3, 374, 187, 0, 3389, 3395, 3, 376, 188, 0, 3390,
		3395, 3, 378, 189, 0, 3391, 3395, 3, 380, 190, 0, 3392, 3393, 4, 186, 57,
		0, 3393, 3395, 3, 382, 191, 0, 3394, 3388, 1, 0, 0, 0, 3394, 3389, 1, 0,
		0, 0, 3394, 3390, 1, 0, 0, 0, 3394, 3391, 1, 0, 0, 0, 3394, 3392, 1, 0,
		0, 0, 3395, 373, 1, 0, 0, 0, 3396, 3398, 3, 1102, 551, 0, 3397, 3399, 3,
		1036, 518, 0, 3398, 3397, 1, 0, 0, 0, 3398, 3399, 1, 0, 0, 0, 3399, 3401,
		1, 0, 0, 0, 3400, 3402, 3, 398, 199, 0, 3401, 3400, 1, 0, 0, 0, 3401, 3402,
		1, 0, 0, 0, 3402, 3404, 1, 0, 0, 0, 3403, 3405, 3, 400, 200, 0, 3404, 3403,
		1, 0, 0, 0, 3404, 3405, 1, 0, 0, 0, 3405, 375, 1, 0, 0, 0, 3406, 3409,
		5, 776, 0, 0, 3407, 3410, 3, 374, 187, 0, 3408, 3410, 3, 376, 188, 0, 3409,
		3407, 1, 0, 0, 0, 3409, 3408, 1, 0, 0, 0, 3410, 3411, 1, 0, 0, 0, 3411,
		3412, 5, 777, 0, 0, 3412, 377, 1, 0, 0, 0, 3413, 3415, 3, 280, 140, 0,
		3414, 3416, 3, 398, 199, 0, 3415, 3414, 1, 0, 0, 0, 3415, 3416, 1, 0, 0,
		0, 3416, 3419, 1, 0, 0, 0, 3417, 3418, 4, 189, 58, 0, 3418, 3420, 3, 1044,
		522, 0, 3419, 3417, 1, 0, 0, 0, 3419, 3420, 1, 0, 0, 0, 3420, 3431, 1,
		0, 0, 0, 3421, 3422, 4, 189, 59, 0, 3422, 3423, 5, 726, 0, 0, 3423, 3425,
		3, 280, 140, 0, 3424, 3426, 3, 398, 199, 0, 3425, 3424, 1, 0, 0, 0, 3425,
		3426, 1, 0, 0, 0, 3426, 3428, 1, 0, 0, 0, 3427, 3429, 3, 1044, 522, 0,
		3428, 3427, 1, 0, 0, 0, 3428, 3429, 1, 0, 0, 0, 3429, 3431, 1, 0, 0, 0,
		3430, 3413, 1, 0, 0, 0, 3430, 3421, 1, 0, 0, 0, 3431, 379, 1, 0, 0, 0,
		3432, 3435, 5, 776, 0, 0, 3433, 3436, 3, 334, 167, 0, 3434, 3436, 3, 380,
		190, 0, 3435, 3433, 1, 0, 0, 0, 3435, 3434, 1, 0, 0, 0, 3436, 3437, 1,
		0, 0, 0, 3437, 3438, 5, 777, 0, 0, 3438, 381, 1, 0, 0, 0, 3439, 3440, 5,
		701, 0, 0, 3440, 3441, 5, 776, 0, 0, 3441, 3442, 3, 676, 338, 0, 3442,
		3443, 5, 773, 0, 0, 3443, 3444, 3, 1154, 577, 0, 3444, 3445, 3, 384, 192,
		0, 3445, 3447, 5, 777, 0, 0, 3446, 3448, 3, 398, 199, 0, 3447, 3446, 1,
		0, 0, 0, 3447, 3448, 1, 0, 0, 0, 3448, 383, 1, 0, 0, 0, 3449, 3450, 5,
		71, 0, 0, 3450, 3451, 5, 776, 0, 0, 3451, 3456, 3, 386, 193, 0, 3452, 3453,
		5, 773, 0, 0, 3453, 3455, 3, 386, 193, 0, 3454, 3452, 1, 0, 0, 0, 3455,
		3458, 1, 0, 0, 0, 3456, 3454, 1, 0, 0, 0, 3456, 3457, 1, 0, 0, 0, 3457,
		3459, 1, 0, 0, 0, 3458, 3456, 1, 0, 0, 0, 3459, 3460, 5, 777, 0, 0, 3460,
		385, 1, 0, 0, 0, 3461, 3462, 3, 1128, 564, 0, 3462, 3463, 5, 200, 0, 0,
		3463, 3464, 5, 703, 0, 0, 3464, 3485, 1, 0, 0, 0, 3465, 3466, 3, 1128,
		564, 0, 3466, 3469, 3, 916, 458, 0, 3467, 3468, 4, 193, 60, 0, 3468, 3470,
		3, 986, 493, 0, 3469, 3467, 1, 0, 0, 0, 3469, 3470, 1, 0, 0, 0, 3470, 3472,
		1, 0, 0, 0, 3471, 3473, 5, 174, 0, 0, 3472, 3471, 1, 0, 0, 0, 3472, 3473,
		1, 0, 0, 0, 3473, 3474, 1, 0, 0, 0, 3474, 3475, 5, 704, 0, 0, 3475, 3477,
		3, 1154, 577, 0, 3476, 3478, 3, 388, 194, 0, 3477, 3476, 1, 0, 0, 0, 3477,
		3478, 1, 0, 0, 0, 3478, 3485, 1, 0, 0, 0, 3479, 3480, 5, 702, 0, 0, 3480,
		3481, 5, 704, 0, 0, 3481, 3482, 3, 1154, 577, 0, 3482, 3483, 3, 384, 192,
		0, 3483, 3485, 1, 0, 0, 0, 3484, 3461, 1, 0, 0, 0, 3484, 3465, 1, 0, 0,
		0, 3484, 3479, 1, 0, 0, 0, 3485, 387, 1, 0, 0, 0, 3486, 3488, 3, 390, 195,
		0, 3487, 3489, 3, 392, 196, 0, 3488, 3487, 1, 0, 0, 0, 3488, 3489, 1, 0,
		0, 0, 3489, 3495, 1, 0, 0, 0, 3490, 3492, 3, 392, 196, 0, 3491, 3493, 3,
		390, 195, 0, 3492, 3491, 1, 0, 0, 0, 3492, 3493, 1, 0, 0, 0, 3493, 3495,
		1, 0, 0, 0, 3494, 3486, 1, 0, 0, 0, 3494, 3490, 1, 0, 0, 0, 3495, 389,
		1, 0, 0, 0, 3496, 3497, 3, 394, 197, 0, 3497, 3498, 5, 383, 0, 0, 3498,
		3499, 5, 700, 0, 0, 3499, 391, 1, 0, 0, 0, 3500, 3501, 3, 394, 197, 0,
		3501, 3502, 5, 383, 0, 0, 3502, 3503, 5, 165, 0, 0, 3503, 393, 1, 0, 0,
		0, 3504, 3509, 5, 165, 0, 0, 3505, 3509, 5, 376, 0, 0, 3506, 3507, 5, 128,
		0, 0, 3507, 3509, 3, 1154, 577, 0, 3508, 3504, 1, 0, 0, 0, 3508, 3505,
		1, 0, 0, 0, 3508, 3506, 1, 0, 0, 0, 3509, 395, 1, 0, 0, 0, 3510, 3511,
		7, 36, 0, 0, 3511, 397, 1, 0, 0, 0, 3512, 3516, 5, 17, 0, 0, 3513, 3514,
		4, 199, 61, 0, 3514, 3516, 5, 750, 0, 0, 3515, 3512, 1, 0, 0, 0, 3515,
		3513, 1, 0, 0, 0, 3515, 3516, 1, 0, 0, 0, 3516, 3517, 1, 0, 0, 0, 3517,
		3518, 3, 1128, 564, 0, 3518, 399, 1, 0, 0, 0, 3519, 3524, 3, 402, 201,
		0, 3520, 3521, 5, 773, 0, 0, 3521, 3523, 3, 402, 201, 0, 3522, 3520, 1,
		0, 0, 0, 3523, 3526, 1, 0, 0, 0, 3524, 3522, 1, 0, 0, 0, 3524, 3525, 1,
		0, 0, 0, 3525, 401, 1, 0, 0, 0, 3526, 3524, 1, 0, 0, 0, 3527, 3528, 3,
		404, 202, 0, 3528, 3530, 3, 406, 203, 0, 3529, 3531, 3, 410, 205, 0, 3530,
		3529, 1, 0, 0, 0, 3530, 3531, 1, 0, 0, 0, 3531, 3532, 1, 0, 0, 0, 3532,
		3533, 5, 776, 0, 0, 3533, 3534, 3, 412, 206, 0, 3534, 3535, 5, 777, 0,
		0, 3535, 3548, 1, 0, 0, 0, 3536, 3537, 5, 620, 0, 0, 3537, 3539, 3, 406,
		203, 0, 3538, 3540, 3, 410, 205, 0, 3539, 3538, 1, 0, 0, 0, 3539, 3540,
		1, 0, 0, 0, 3540, 3541, 1, 0, 0, 0, 3541, 3543, 5, 776, 0, 0, 3542, 3544,
		3, 412, 206, 0, 3543, 3542, 1, 0, 0, 0, 3543, 3544, 1, 0, 0, 0, 3544, 3545,
		1, 0, 0, 0, 3545, 3546, 5, 777, 0, 0, 3546, 3548, 1, 0, 0, 0, 3547, 3527,
		1, 0, 0, 0, 3547, 3536, 1, 0, 0, 0, 3548, 403, 1, 0, 0, 0, 3549, 3550,
		7, 37, 0, 0, 3550, 405, 1, 0, 0, 0, 3551, 3552, 7, 38, 0, 0, 3552, 407,
		1, 0, 0, 0, 3553, 3554, 5, 420, 0, 0, 3554, 3560, 5, 265, 0, 0, 3555, 3557,
		5, 609, 0, 0, 3556, 3558, 3, 406, 203, 0, 3557, 3556, 1, 0, 0, 0, 3557,
		3558, 1, 0, 0, 0, 3558, 3560, 1, 0, 0, 0, 3559, 3553, 1, 0, 0, 0, 3559,
		3555, 1, 0, 0, 0, 3560, 409, 1, 0, 0, 0, 3561, 3567, 5, 200, 0, 0, 3562,
		3568, 5, 261, 0, 0, 3563, 3564, 5, 393, 0, 0, 3564, 3568, 5, 45, 0, 0,
		3565, 3566, 5, 217, 0, 0, 3566, 3568, 5, 45, 0, 0, 3567, 3562, 1, 0, 0,
		0, 3567, 3563, 1, 0, 0, 0, 3567, 3565, 1, 0, 0, 0, 3568, 411, 1, 0, 0,
		0, 3569, 3574, 3, 414, 207, 0, 3570, 3571, 5, 773, 0, 0, 3571, 3573, 3,
		414, 207, 0, 3572, 3570, 1, 0, 0, 0, 3573, 3576, 1, 0, 0, 0, 3574, 3572,
		1, 0, 0, 0, 3574, 3575, 1, 0, 0, 0, 3575, 413, 1, 0, 0, 0, 3576, 3574,
		1, 0, 0, 0, 3577, 3580, 3, 1128, 564, 0, 3578, 3580, 5, 420, 0, 0, 3579,
		3577, 1, 0, 0, 0, 3579, 3578, 1, 0, 0, 0, 3580, 415, 1, 0, 0, 0, 3581,
		3582, 4, 208, 62, 0, 3582, 3584, 3, 320, 160, 0, 3583, 3581, 1, 0, 0, 0,
		3583, 3584, 1, 0, 0, 0, 3584, 3585, 1, 0, 0, 0, 3585, 3587, 5, 614, 0,
		0, 3586, 3588, 5, 295, 0, 0, 3587, 3586, 1, 0, 0, 0, 3587, 3588, 1, 0,
		0, 0, 3588, 3590, 1, 0, 0, 0, 3589, 3591, 5, 232, 0, 0, 3590, 3589, 1,
		0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591, 3592, 1, 0, 0, 0, 3592, 3593, 3,
		334, 167, 0, 3593, 3594, 5, 506, 0, 0, 3594, 3596, 3, 994, 497, 0, 3595,
		3597, 3, 358, 179, 0, 3596, 3595, 1, 0, 0, 0, 3596, 3597, 1, 0, 0, 0, 3597,
		3599, 1, 0, 0, 0, 3598, 3600, 3, 328, 164, 0, 3599, 3598, 1, 0, 0, 0, 3599,
		3600, 1, 0, 0, 0, 3600, 3602, 1, 0, 0, 0, 3601, 3603, 3, 286, 143, 0, 3602,
		3601, 1, 0, 0, 0, 3602, 3603, 1, 0, 0, 0, 3603, 417, 1, 0, 0, 0, 3604,
		3609, 3, 420, 210, 0, 3605, 3609, 3, 426, 213, 0, 3606, 3609, 3, 428, 214,
		0, 3607, 3609, 3, 434, 217, 0, 3608, 3604, 1, 0, 0, 0, 3608, 3605, 1, 0,
		0, 0, 3608, 3606, 1, 0, 0, 0, 3608, 3607, 1, 0, 0, 0, 3609, 419, 1, 0,
		0, 0, 3610, 3611, 5, 543, 0, 0, 3611, 3615, 5, 592, 0, 0, 3612, 3614, 3,
		424, 212, 0, 3613, 3612, 1, 0, 0, 0, 3614, 3617, 1, 0, 0, 0, 3615, 3613,
		1, 0, 0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3636, 1, 0, 0, 0, 3617, 3615,
		1, 0, 0, 0, 3618, 3620, 5, 77, 0, 0, 3619, 3621, 5, 647, 0, 0, 3620, 3619,
		1, 0, 0, 0, 3620, 3621, 1, 0, 0, 0, 3621, 3627, 1, 0, 0, 0, 3622, 3624,
		5, 15, 0, 0, 3623, 3625, 5, 373, 0, 0, 3624, 3623, 1, 0, 0, 0, 3624, 3625,
		1, 0, 0, 0, 3625, 3626, 1, 0, 0, 0, 3626, 3628, 5, 54, 0, 0, 3627, 3622,
		1, 0, 0, 0, 3627, 3628, 1, 0, 0, 0, 3628, 3633, 1, 0, 0, 0, 3629, 3631,
		5, 373, 0, 0, 3630, 3629, 1, 0, 0, 0, 3630, 3631, 1, 0, 0, 0, 3631, 3632,
		1, 0, 0, 0, 3632, 3634, 5, 450, 0, 0, 3633, 3630, 1, 0, 0, 0, 3633, 3634,
		1, 0, 0, 0, 3634, 3636, 1, 0, 0, 0, 3635, 3610, 1, 0, 0, 0, 3635, 3618,
		1, 0, 0, 0, 3636, 421, 1, 0, 0, 0, 3637, 3639, 5, 29, 0, 0, 3638, 3640,
		5, 647, 0, 0, 3639, 3638, 1, 0, 0, 0, 3639, 3640, 1, 0, 0, 0, 3640, 423,
		1, 0, 0, 0, 3641, 3642, 5, 645, 0, 0, 3642, 3643, 5, 85, 0, 0, 3643, 3648,
		5, 517, 0, 0, 3644, 3645, 4, 212, 63, 0, 3645, 3646, 5, 435, 0, 0, 3646,
		3648, 7, 39, 0, 0, 3647, 3641, 1, 0, 0, 0, 3647, 3644, 1, 0, 0, 0, 3648,
		425, 1, 0, 0, 0, 3649, 3650, 5, 489, 0, 0, 3650, 3679, 3, 1128, 564, 0,
		3651, 3653, 5, 480, 0, 0, 3652, 3654, 5, 647, 0, 0, 3653, 3652, 1, 0, 0,
		0, 3653, 3654, 1, 0, 0, 0, 3654, 3673, 1, 0, 0, 0, 3655, 3657, 5, 590,
		0, 0, 3656, 3658, 5, 489, 0, 0, 3657, 3656, 1, 0, 0, 0, 3657, 3658, 1,
		0, 0, 0, 3658, 3659, 1, 0, 0, 0, 3659, 3674, 3, 1128, 564, 0, 3660, 3662,
		5, 15, 0, 0, 3661, 3663, 5, 373, 0, 0, 3662, 3661, 1, 0, 0, 0, 3662, 3663,
		1, 0, 0, 0, 3663, 3664, 1, 0, 0, 0, 3664, 3666, 5, 54, 0, 0, 3665, 3660,
		1, 0, 0, 0, 3665, 3666, 1, 0, 0, 0, 3666, 3671, 1, 0, 0, 0, 3667, 3669,
		5, 373, 0, 0, 3668, 3667, 1, 0, 0, 0, 3668, 3669, 1, 0, 0, 0, 3669, 3670,
		1, 0, 0, 0, 3670, 3672, 5, 450, 0, 0, 3671, 3668, 1, 0, 0, 0, 3671, 3672,
		1, 0, 0, 0, 3672, 3674, 1, 0, 0, 0, 3673, 3655, 1, 0, 0, 0, 3673, 3665,
		1, 0, 0, 0, 3674, 3679, 1, 0, 0, 0, 3675, 3676, 5, 450, 0, 0, 3676, 3677,
		5, 489, 0, 0, 3677, 3679, 3, 1128, 564, 0, 3678, 3649, 1, 0, 0, 0, 3678,
		3651, 1, 0, 0, 0, 3678, 3675, 1, 0, 0, 0, 3679, 427, 1, 0, 0, 0, 3680,
		3681, 5, 287, 0, 0, 3681, 3682, 7, 18, 0, 0, 3682, 3687, 3, 430, 215, 0,
		3683, 3684, 5, 773, 0, 0, 3684, 3686, 3, 430, 215, 0, 3685, 3683, 1, 0,
		0, 0, 3686, 3689, 1, 0, 0, 0, 3687, 3685, 1, 0, 0, 0, 3687, 3688, 1, 0,
		0, 0, 3688, 3703, 1, 0, 0, 0, 3689, 3687, 1, 0, 0, 0, 3690, 3691, 4, 214,
		64, 0, 3691, 3692, 5, 287, 0, 0, 3692, 3693, 5, 244, 0, 0, 3693, 3694,
		5, 200, 0, 0, 3694, 3703, 5, 27, 0, 0, 3695, 3700, 5, 611, 0, 0, 3696,
		3701, 5, 571, 0, 0, 3697, 3701, 5, 574, 0, 0, 3698, 3699, 4, 214, 65, 0,
		3699, 3701, 5, 244, 0, 0, 3700, 3696, 1, 0, 0, 0, 3700, 3697, 1, 0, 0,
		0, 3700, 3698, 1, 0, 0, 0, 3701, 3703, 1, 0, 0, 0, 3702, 3680, 1, 0, 0,
		0, 3702, 3690, 1, 0, 0, 0, 3702, 3695, 1, 0, 0, 0, 3703, 429, 1, 0, 0,
		0, 3704, 3706, 3, 1102, 551, 0, 3705, 3707, 3, 398, 199, 0, 3706, 3705,
		1, 0, 0, 0, 3706, 3707, 1, 0, 0, 0, 3707, 3708, 1, 0, 0, 0, 3708, 3709,
		3, 432, 216, 0, 3709, 431, 1, 0, 0, 0, 3710, 3712, 5, 435, 0, 0, 3711,
		3713, 5, 284, 0, 0, 3712, 3711, 1, 0, 0, 0, 3712, 3713, 1, 0, 0, 0, 3713,
		3719, 1, 0, 0, 0, 3714, 3716, 5, 295, 0, 0, 3715, 3714, 1, 0, 0, 0, 3715,
		3716, 1, 0, 0, 0, 3716, 3717, 1, 0, 0, 0, 3717, 3719, 5, 649, 0, 0, 3718,
		3710, 1, 0, 0, 0, 3718, 3715, 1, 0, 0, 0, 3719, 433, 1, 0, 0, 0, 3720,
		3747, 5, 651, 0, 0, 3721, 3722, 7, 40, 0, 0, 3722, 3724, 3, 438, 219, 0,
		3723, 3725, 7, 41, 0, 0, 3724, 3723, 1, 0, 0, 0, 3724, 3725, 1, 0, 0, 0,
		3725, 3748, 1, 0, 0, 0, 3726, 3727, 5, 159, 0, 0, 3727, 3733, 3, 438, 219,
		0, 3728, 3731, 5, 566, 0, 0, 3729, 3730, 5, 200, 0, 0, 3730, 3732, 5, 340,
		0, 0, 3731, 3729, 1, 0, 0, 0, 3731, 3732, 1, 0, 0, 0, 3732, 3734, 1, 0,
		0, 0, 3733, 3728, 1, 0, 0, 0, 3733, 3734, 1, 0, 0, 0, 3734, 3748, 1, 0,
		0, 0, 3735, 3736, 5, 417, 0, 0, 3736, 3748, 3, 438, 219, 0, 3737, 3738,
		5, 77, 0, 0, 3738, 3741, 3, 438, 219, 0, 3739, 3740, 5, 384, 0, 0, 3740,
		3742, 5, 407, 0, 0, 3741, 3739, 1, 0, 0, 0, 3741, 3742, 1, 0, 0, 0, 3742,
		3748, 1, 0, 0, 0, 3743, 3744, 5, 480, 0, 0, 3744, 3748, 3, 438, 219, 0,
		3745, 3746, 5, 439, 0, 0, 3746, 3748, 3, 436, 218, 0, 3747, 3721, 1, 0,
		0, 0, 3747, 3726, 1, 0, 0, 0, 3747, 3735, 1, 0, 0, 0, 3747, 3737, 1, 0,
		0, 0, 3747, 3743, 1, 0, 0, 0, 3747, 3745, 1, 0, 0, 0, 3748, 435, 1, 0,
		0, 0, 3749, 3752, 4, 218, 66, 0, 3750, 3751, 5, 94, 0, 0, 3751, 3753, 5,
		652, 0, 0, 3752, 3750, 1, 0, 0, 0, 3752, 3753, 1, 0, 0, 0, 3753, 3756,
		1, 0, 0, 0, 3754, 3756, 1, 0, 0, 0, 3755, 3749, 1, 0, 0, 0, 3755, 3754,
		1, 0, 0, 0, 3756, 437, 1, 0, 0, 0, 3757, 3764, 3, 1156, 578, 0, 3758, 3759,
		5, 773, 0, 0, 3759, 3762, 3, 1156, 578, 0, 3760, 3761, 5, 773, 0, 0, 3761,
		3763, 3, 1140, 570, 0, 3762, 3760, 1, 0, 0, 0, 3762, 3763, 1, 0, 0, 0,
		3763, 3765, 1, 0, 0, 0, 3764, 3758, 1, 0, 0, 0, 3764, 3765, 1, 0, 0, 0,
		3765, 439, 1, 0, 0, 0, 3766, 3767, 5, 428, 0, 0, 3767, 3768, 7, 42, 0,
		0, 3768, 3773, 5, 289, 0, 0, 3769, 3770, 5, 590, 0, 0, 3770, 3774, 3, 1160,
		580, 0, 3771, 3772, 5, 28, 0, 0, 3772, 3774, 3, 676, 338, 0, 3773, 3769,
		1, 0, 0, 0, 3773, 3771, 1, 0, 0, 0, 3774, 3800, 1, 0, 0, 0, 3775, 3800,
		3, 448, 224, 0, 3776, 3777, 5, 468, 0, 0, 3777, 3782, 3, 442, 221, 0, 3778,
		3779, 5, 773, 0, 0, 3779, 3781, 3, 442, 221, 0, 3780, 3778, 1, 0, 0, 0,
		3781, 3784, 1, 0, 0, 0, 3782, 3780, 1, 0, 0, 0, 3782, 3783, 1, 0, 0, 0,
		3783, 3800, 1, 0, 0, 0, 3784, 3782, 1, 0, 0, 0, 3785, 3786, 4, 220, 67,
		0, 3786, 3787, 5, 468, 0, 0, 3787, 3791, 5, 658, 0, 0, 3788, 3789, 3, 978,
		489, 0, 3789, 3790, 3, 1128, 564, 0, 3790, 3792, 1, 0, 0, 0, 3791, 3788,
		1, 0, 0, 0, 3791, 3792, 1, 0, 0, 0, 3792, 3800, 1, 0, 0, 0, 3793, 3800,
		3, 478, 239, 0, 3794, 3795, 4, 220, 68, 0, 3795, 3800, 3, 464, 232, 0,
		3796, 3800, 3, 446, 223, 0, 3797, 3798, 4, 220, 69, 0, 3798, 3800, 3, 488,
		244, 0, 3799, 3766, 1, 0, 0, 0, 3799, 3775, 1, 0, 0, 0, 3799, 3776, 1,
		0, 0, 0, 3799, 3785, 1, 0, 0, 0, 3799, 3793, 1, 0, 0, 0, 3799, 3794, 1,
		0, 0, 0, 3799, 3796, 1, 0, 0, 0, 3799, 3797, 1, 0, 0, 0, 3800, 441, 1,
		0, 0, 0, 3801, 3803, 5, 316, 0, 0, 3802, 3804, 3, 444, 222, 0, 3803, 3802,
		1, 0, 0, 0, 3803, 3804, 1, 0, 0, 0, 3804, 3816, 1, 0, 0, 0, 3805, 3806,
		4, 221, 70, 0, 3806, 3807, 5, 430, 0, 0, 3807, 3816, 5, 47, 0, 0, 3808,
		3810, 5, 514, 0, 0, 3809, 3811, 5, 10, 0, 0, 3810, 3809, 1, 0, 0, 0, 3810,
		3811, 1, 0, 0, 0, 3811, 3813, 1, 0, 0, 0, 3812, 3814, 3, 782, 391, 0, 3813,
		3812, 1, 0, 0, 0, 3813, 3814, 1, 0, 0, 0, 3814, 3816, 1, 0, 0, 0, 3815,
		3801, 1, 0, 0, 0, 3815, 3805, 1, 0, 0, 0, 3815, 3808, 1, 0, 0, 0, 3816,
		443, 1, 0, 0, 0, 3817, 3818, 4, 222, 71, 0, 3818, 3823, 5, 590, 0, 0, 3819,
		3820, 4, 222, 72, 0, 3820, 3824, 3, 1142, 571, 0, 3821, 3822, 4, 222, 73,
		0, 3822, 3824, 3, 1146, 573, 0, 3823, 3819, 1, 0, 0, 0, 3823, 3821, 1,
		0, 0, 0, 3824, 445, 1, 0, 0, 0, 3825, 3829, 5, 281, 0, 0, 3826, 3830, 5,
		112, 0, 0, 3827, 3828, 5, 574, 0, 0, 3828, 3830, 3, 1102, 551, 0, 3829,
		3826, 1, 0, 0, 0, 3829, 3827, 1, 0, 0, 0, 3830, 3831, 1, 0, 0, 0, 3831,
		3832, 5, 203, 0, 0, 3832, 3833, 5, 316, 0, 0, 3833, 447, 1, 0, 0, 0, 3834,
		3835, 5, 55, 0, 0, 3835, 3836, 5, 316, 0, 0, 3836, 3837, 5, 590, 0, 0,
		3837, 3839, 3, 450, 225, 0, 3838, 3840, 3, 782, 391, 0, 3839, 3838, 1,
		0, 0, 0, 3839, 3840, 1, 0, 0, 0, 3840, 449, 1, 0, 0, 0, 3841, 3846, 3,
		452, 226, 0, 3842, 3843, 5, 773, 0, 0, 3843, 3845, 3, 452, 226, 0, 3844,
		3842, 1, 0, 0, 0, 3845, 3848, 1, 0, 0, 0, 3846, 3844, 1, 0, 0, 0, 3846,
		3847, 1, 0, 0, 0, 3847, 451, 1, 0, 0, 0, 3848, 3846, 1, 0, 0, 0, 3849,
		3850, 5, 300, 0, 0, 3850, 3851, 5, 750, 0, 0, 3851, 3941, 3, 1162, 581,
		0, 3852, 3853, 5, 729, 0, 0, 3853, 3854, 5, 750, 0, 0, 3854, 3941, 3, 1162,
		581, 0, 3855, 3856, 5, 297, 0, 0, 3856, 3857, 5, 750, 0, 0, 3857, 3941,
		3, 1162, 581, 0, 3858, 3859, 5, 318, 0, 0, 3859, 3860, 5, 750, 0, 0, 3860,
		3941, 3, 1162, 581, 0, 3861, 3862, 5, 303, 0, 0, 3862, 3863, 5, 750, 0,
		0, 3863, 3941, 3, 1162, 581, 0, 3864, 3865, 5, 304, 0, 0, 3865, 3866, 5,
		750, 0, 0, 3866, 3941, 3, 1140, 570, 0, 3867, 3868, 5, 298, 0, 0, 3868,
		3869, 5, 750, 0, 0, 3869, 3941, 3, 1140, 570, 0, 3870, 3871, 5, 305, 0,
		0, 3871, 3872, 5, 750, 0, 0, 3872, 3941, 3, 1140, 570, 0, 3873, 3874, 5,
		299, 0, 0, 3874, 3875, 5, 750, 0, 0, 3875, 3941, 3, 1140, 570, 0, 3876,
		3877, 5, 314, 0, 0, 3877, 3878, 5, 750, 0, 0, 3878, 3941, 3, 1140, 570,
		0, 3879, 3880, 5, 308, 0, 0, 3880, 3881, 5, 750, 0, 0, 3881, 3941, 3, 1162,
		581, 0, 3882, 3883, 5, 307, 0, 0, 3883, 3884, 5, 750, 0, 0, 3884, 3941,
		3, 1162, 581, 0, 3885, 3886, 5, 317, 0, 0, 3886, 3887, 5, 750, 0, 0, 3887,
		3941, 3, 1162, 581, 0, 3888, 3889, 5, 309, 0, 0, 3889, 3890, 5, 750, 0,
		0, 3890, 3941, 3, 1162, 581, 0, 3891, 3892, 5, 738, 0, 0, 3892, 3893, 5,
		750, 0, 0, 3893, 3941, 3, 458, 229, 0, 3894, 3895, 5, 310, 0, 0, 3895,
		3896, 5, 750, 0, 0, 3896, 3941, 3, 1162, 581, 0, 3897, 3898, 5, 313, 0,
		0, 3898, 3899, 5, 750, 0, 0, 3899, 3941, 3, 1162, 581, 0, 3900, 3901, 5,
		315, 0, 0, 3901, 3902, 5, 750, 0, 0, 3902, 3941, 3, 1140, 570, 0, 3903,
		3904, 5, 311, 0, 0, 3904, 3905, 5, 750, 0, 0, 3905, 3941, 3, 1160, 580,
		0, 3906, 3907, 5, 312, 0, 0, 3907, 3908, 5, 750, 0, 0, 3908, 3941, 3, 1162,
		581, 0, 3909, 3910, 5, 712, 0, 0, 3910, 3911, 5, 750, 0, 0, 3911, 3941,
		3, 1162, 581, 0, 3912, 3913, 5, 713, 0, 0, 3913, 3914, 5, 750, 0, 0, 3914,
		3941, 3, 1140, 570, 0, 3915, 3916, 5, 319, 0, 0, 3916, 3917, 5, 750, 0,
		0, 3917, 3941, 3, 1140, 570, 0, 3918, 3919, 5, 233, 0, 0, 3919, 3920, 5,
		750, 0, 0, 3920, 3941, 3, 462, 231, 0, 3921, 3922, 5, 735, 0, 0, 3922,
		3923, 5, 750, 0, 0, 3923, 3941, 3, 1154, 577, 0, 3924, 3925, 5, 736, 0,
		0, 3925, 3926, 5, 750, 0, 0, 3926, 3941, 3, 1140, 570, 0, 3927, 3928, 5,
		296, 0, 0, 3928, 3929, 5, 750, 0, 0, 3929, 3941, 3, 1140, 570, 0, 3930,
		3931, 5, 737, 0, 0, 3931, 3932, 5, 750, 0, 0, 3932, 3941, 3, 454, 227,
		0, 3933, 3934, 5, 739, 0, 0, 3934, 3935, 5, 750, 0, 0, 3935, 3941, 3, 1140,
		570, 0, 3936, 3937, 5, 742, 0, 0, 3937, 3938, 5, 750, 0, 0, 3938, 3941,
		3, 456, 228, 0, 3939, 3941, 3, 460, 230, 0, 3940, 3849, 1, 0, 0, 0, 3940,
		3852, 1, 0, 0, 0, 3940, 3855, 1, 0, 0, 0, 3940, 3858, 1, 0, 0, 0, 3940,
		3861, 1, 0, 0, 0, 3940, 3864, 1, 0, 0, 0, 3940, 3867, 1, 0, 0, 0, 3940,
		3870, 1, 0, 0, 0, 3940, 3873, 1, 0, 0, 0, 3940, 3876, 1, 0, 0, 0, 3940,
		3879, 1, 0, 0, 0, 3940, 3882, 1, 0, 0, 0, 3940, 3885, 1, 0, 0, 0, 3940,
		3888, 1, 0, 0, 0, 3940, 3891, 1, 0, 0, 0, 3940, 3894, 1, 0, 0, 0, 3940,
		3897, 1, 0, 0, 0, 3940, 3900, 1, 0, 0, 0, 3940, 3903, 1, 0, 0, 0, 3940,
		3906, 1, 0, 0, 0, 3940, 3909, 1, 0, 0, 0, 3940, 3912, 1, 0, 0, 0, 3940,
		3915, 1, 0, 0, 0, 3940, 3918, 1, 0, 0, 0, 3940, 3921, 1, 0, 0, 0, 3940,
		3924, 1, 0, 0, 0, 3940, 3927, 1, 0, 0, 0, 3940, 3930, 1, 0, 0, 0, 3940,
		3933, 1, 0, 0, 0, 3940, 3936, 1, 0, 0, 0, 3940, 3939, 1, 0, 0, 0, 3941,
		453, 1, 0, 0, 0, 3942, 3945, 3, 1024, 512, 0, 3943, 3945, 5, 376, 0, 0,
		3944, 3942, 1, 0, 0, 0, 3944, 3943, 1, 0, 0, 0, 3945, 455, 1, 0, 0, 0,
		3946, 3947, 7, 43, 0, 0, 3947, 457, 1, 0, 0, 0, 3948, 3951, 3, 1162, 581,
		0, 3949, 3951, 5, 376, 0, 0, 3950, 3948, 1, 0, 0, 0, 3950, 3949, 1, 0,
		0, 0, 3951, 459, 1, 0, 0, 0, 3952, 3953, 5, 301, 0, 0, 3953, 3954, 5, 750,
		0, 0, 3954, 3965, 3, 1162, 581, 0, 3955, 3956, 5, 302, 0, 0, 3956, 3957,
		5, 750, 0, 0, 3957, 3965, 3, 1144, 572, 0, 3958, 3959, 5, 447, 0, 0, 3959,
		3960, 5, 750, 0, 0, 3960, 3965, 3, 1162, 581, 0, 3961, 3962, 5, 448, 0,
		0, 3962, 3963, 5, 750, 0, 0, 3963, 3965, 3, 1140, 570, 0, 3964, 3952, 1,
		0, 0, 0, 3964, 3955, 1, 0, 0, 0, 3964, 3958, 1, 0, 0, 0, 3964, 3961, 1,
		0, 0, 0, 3965, 461, 1, 0, 0, 0, 3966, 3975, 5, 776, 0, 0, 3967, 3972, 3,
		1140, 570, 0, 3968, 3969, 5, 773, 0, 0, 3969, 3971, 3, 1140, 570, 0, 3970,
		3968, 1, 0, 0, 0, 3971, 3974, 1, 0, 0, 0, 3972, 3970, 1, 0, 0, 0, 3972,
		3973, 1, 0, 0, 0, 3973, 3976, 1, 0, 0, 0, 3974, 3972, 1, 0, 0, 0, 3975,
		3967, 1, 0, 0, 0, 3975, 3976, 1, 0, 0, 0, 3976, 3977, 1, 0, 0, 0, 3977,
		3978, 5, 777, 0, 0, 3978, 463, 1, 0, 0, 0, 3979, 3980, 5, 55, 0, 0, 3980,
		3981, 5, 459, 0, 0, 3981, 3982, 5, 190, 0, 0, 3982, 3987, 3, 466, 233,
		0, 3983, 3984, 5, 773, 0, 0, 3984, 3986, 3, 466, 233, 0, 3985, 3983, 1,
		0, 0, 0, 3986, 3989, 1, 0, 0, 0, 3987, 3985, 1, 0, 0, 0, 3987, 3988, 1,
		0, 0, 0, 3988, 3992, 1, 0, 0, 0, 3989, 3987, 1, 0, 0, 0, 3990, 3991, 4,
		232, 74, 0, 3991, 3993, 3, 782, 391, 0, 3992, 3990, 1, 0, 0, 0, 3992, 3993,
		1, 0, 0, 0, 3993, 465, 1, 0, 0, 0, 3994, 3995, 5, 460, 0, 0, 3995, 3996,
		5, 750, 0, 0, 3996, 3998, 5, 776, 0, 0, 3997, 3999, 3, 468, 234, 0, 3998,
		3997, 1, 0, 0, 0, 3998, 3999, 1, 0, 0, 0, 3999, 4000, 1, 0, 0, 0, 4000,
		4044, 5, 777, 0, 0, 4001, 4002, 5, 461, 0, 0, 4002, 4003, 5, 750, 0, 0,
		4003, 4005, 5, 776, 0, 0, 4004, 4006, 3, 468, 234, 0, 4005, 4004, 1, 0,
		0, 0, 4005, 4006, 1, 0, 0, 0, 4006, 4007, 1, 0, 0, 0, 4007, 4044, 5, 777,
		0, 0, 4008, 4009, 5, 462, 0, 0, 4009, 4010, 5, 750, 0, 0, 4010, 4012, 5,
		776, 0, 0, 4011, 4013, 3, 470, 235, 0, 4012, 4011, 1, 0, 0, 0, 4012, 4013,
		1, 0, 0, 0, 4013, 4014, 1, 0, 0, 0, 4014, 4044, 5, 777, 0, 0, 4015, 4016,
		5, 463, 0, 0, 4016, 4017, 5, 750, 0, 0, 4017, 4019, 5, 776, 0, 0, 4018,
		4020, 3, 470, 235, 0, 4019, 4018, 1, 0, 0, 0, 4019, 4020, 1, 0, 0, 0, 4020,
		4021, 1, 0, 0, 0, 4021, 4044, 5, 777, 0, 0, 4022, 4023, 5, 464, 0, 0, 4023,
		4024, 5, 750, 0, 0, 4024, 4026, 5, 776, 0, 0, 4025, 4027, 3, 472, 236,
		0, 4026, 4025, 1, 0, 0, 0, 4026, 4027, 1, 0, 0, 0, 4027, 4028, 1, 0, 0,
		0, 4028, 4044, 5, 777, 0, 0, 4029, 4030, 5, 465, 0, 0, 4030, 4031, 5, 750,
		0, 0, 4031, 4033, 5, 776, 0, 0, 4032, 4034, 3, 472, 236, 0, 4033, 4032,
		1, 0, 0, 0, 4033, 4034, 1, 0, 0, 0, 4034, 4035, 1, 0, 0, 0, 4035, 4044,
		5, 777, 0, 0, 4036, 4037, 5, 466, 0, 0, 4037, 4038, 5, 750, 0, 0, 4038,
		4040, 5, 776, 0, 0, 4039, 4041, 3, 476, 238, 0, 4040, 4039, 1, 0, 0, 0,
		4040, 4041, 1, 0, 0, 0, 4041, 4042, 1, 0, 0, 0, 4042, 4044, 5, 777, 0,
		0, 4043, 3994, 1, 0, 0, 0, 4043, 4001, 1, 0, 0, 0, 4043, 4008, 1, 0, 0,
		0, 4043, 4015, 1, 0, 0, 0, 4043, 4022, 1, 0, 0, 0, 4043, 4029, 1, 0, 0,
		0, 4043, 4036, 1, 0, 0, 0, 4044, 467, 1, 0, 0, 0, 4045, 4050, 3, 1058,
		529, 0, 4046, 4047, 5, 773, 0, 0, 4047, 4049, 3, 1058, 529, 0, 4048, 4046,
		1, 0, 0, 0, 4049, 4052, 1, 0, 0, 0, 4050, 4048, 1, 0, 0, 0, 4050, 4051,
		1, 0, 0, 0, 4051, 469, 1, 0, 0, 0, 4052, 4050, 1, 0, 0, 0, 4053, 4058,
		3, 1098, 549, 0, 4054, 4055, 5, 773, 0, 0, 4055, 4057, 3, 1098, 549, 0,
		4056, 4054, 1, 0, 0, 0, 4057, 4060, 1, 0, 0, 0, 4058, 4056, 1, 0, 0, 0,
		4058, 4059, 1, 0, 0, 0, 4059, 471, 1, 0, 0, 0, 4060, 4058, 1, 0, 0, 0,
		4061, 4066, 3, 474, 237, 0, 4062, 4063, 5, 773, 0, 0, 4063, 4065, 3, 474,
		237, 0, 4064, 4062, 1, 0, 0, 0, 4065, 4068, 1, 0, 0, 0, 4066, 4064, 1,
		0, 0, 0, 4066, 4067, 1, 0, 0, 0, 4067, 473, 1, 0, 0, 0, 4068, 4066, 1,
		0, 0, 0, 4069, 4070, 3, 1162, 581, 0, 4070, 475, 1, 0, 0, 0, 4071, 4076,
		3, 990, 495, 0, 4072, 4073, 5, 773, 0, 0, 4073, 4075, 3, 990, 495, 0, 4074,
		4072, 1, 0, 0, 0, 4075, 4078, 1, 0, 0, 0, 4076, 4074, 1, 0, 0, 0, 4076,
		4077, 1, 0, 0, 0, 4077, 477, 1, 0, 0, 0, 4078, 4076, 1, 0, 0, 0, 4079,
		4080, 5, 543, 0, 0, 4080, 4082, 5, 514, 0, 0, 4081, 4083, 3, 484, 242,
		0, 4082, 4081, 1, 0, 0, 0, 4082, 4083, 1, 0, 0, 0, 4083, 4086, 1, 0, 0,
		0, 4084, 4085, 5, 613, 0, 0, 4085, 4087, 3, 480, 240, 0, 4086, 4084, 1,
		0, 0, 0, 4086, 4087, 1, 0, 0, 0, 4087, 4088, 1, 0, 0, 0, 4088, 4090, 3,
		482, 241, 0, 4089, 4091, 3, 782, 391, 0, 4090, 4089, 1, 0, 0, 0, 4090,
		4091, 1, 0, 0, 0, 4091, 4101, 1, 0, 0, 0, 4092, 4093, 5, 552, 0, 0, 4093,
		4095, 5, 514, 0, 0, 4094, 4096, 3, 484, 242, 0, 4095, 4094, 1, 0, 0, 0,
		4095, 4096, 1, 0, 0, 0, 4096, 4098, 1, 0, 0, 0, 4097, 4099, 3, 782, 391,
		0, 4098, 4097, 1, 0, 0, 0, 4098, 4099, 1, 0, 0, 0, 4099, 4101, 1, 0, 0,
		0, 4100, 4079, 1, 0, 0, 0, 4100, 4092, 1, 0, 0, 0, 4101, 479, 1, 0, 0,
		0, 4102, 4110, 3, 460, 230, 0, 4103, 4104, 4, 240, 75, 0, 4104, 4105, 7,
		44, 0, 0, 4105, 4106, 5, 750, 0, 0, 4106, 4110, 3, 1156, 578, 0, 4107,
		4108, 4, 240, 76, 0, 4108, 4110, 5, 529, 0, 0, 4109, 4102, 1, 0, 0, 0,
		4109, 4103, 1, 0, 0, 0, 4109, 4107, 1, 0, 0, 0, 4110, 4115, 1, 0, 0, 0,
		4111, 4112, 5, 773, 0, 0, 4112, 4114, 3, 460, 230, 0, 4113, 4111, 1, 0,
		0, 0, 4114, 4117, 1, 0, 0, 0, 4115, 4113, 1, 0, 0, 0, 4115, 4116, 1, 0,
		0, 0, 4116, 481, 1, 0, 0, 0, 4117, 4115, 1, 0, 0, 0, 4118, 4122, 4, 241,
		77, 0, 4119, 4120, 5, 618, 0, 0, 4120, 4121, 5, 750, 0, 0, 4121, 4123,
		3, 1156, 578, 0, 4122, 4119, 1, 0, 0, 0, 4122, 4123, 1, 0, 0, 0, 4123,
		4127, 1, 0, 0, 0, 4124, 4125, 5, 406, 0, 0, 4125, 4126, 5, 750, 0, 0, 4126,
		4128, 3, 1156, 578, 0, 4127, 4124, 1, 0, 0, 0, 4127, 4128, 1, 0, 0, 0,
		4128, 4132, 1, 0, 0, 0, 4129, 4130, 5, 129, 0, 0, 4130, 4131, 5, 750, 0,
		0, 4131, 4133, 3, 1156, 578, 0, 4132, 4129, 1, 0, 0, 0, 4132, 4133, 1,
		0, 0, 0, 4133, 4137, 1, 0, 0, 0, 4134, 4135, 5, 409, 0, 0, 4135, 4136,
		5, 750, 0, 0, 4136, 4138, 3, 1156, 578, 0, 4137, 4134, 1, 0, 0, 0, 4137,
		4138, 1, 0, 0, 0, 4138, 4141, 1, 0, 0, 0, 4139, 4141, 1, 0, 0, 0, 4140,
		4118, 1, 0, 0, 0, 4140, 4139, 1, 0, 0, 0, 4141, 483, 1, 0, 0, 0, 4142,
		4147, 3, 486, 243, 0, 4143, 4144, 5, 773, 0, 0, 4144, 4146, 3, 486, 243,
		0, 4145, 4143, 1, 0, 0, 0, 4146, 4149, 1, 0, 0, 0, 4147, 4145, 1, 0, 0,
		0, 4147, 4148, 1, 0, 0, 0, 4148, 485, 1, 0, 0, 0, 4149, 4147, 1, 0, 0,
		0, 4150, 4151, 7, 45, 0, 0, 4151, 487, 1, 0, 0, 0, 4152, 4153, 7, 46, 0,
		0, 4153, 4154, 5, 210, 0, 0, 4154, 489, 1, 0, 0, 0, 4155, 4156, 5, 417,
		0, 0, 4156, 4157, 3, 1128, 564, 0, 4157, 4160, 5, 203, 0, 0, 4158, 4161,
		3, 1160, 580, 0, 4159, 4161, 3, 742, 371, 0, 4160, 4158, 1, 0, 0, 0, 4160,
		4159, 1, 0, 0, 0, 4161, 4167, 1, 0, 0, 0, 4162, 4167, 3, 492, 246, 0, 4163,
		4164, 7, 47, 0, 0, 4164, 4165, 5, 417, 0, 0, 4165, 4167, 3, 1128, 564,
		0, 4166, 4155, 1, 0, 0, 0, 4166, 4162, 1, 0, 0, 0, 4166, 4163, 1, 0, 0,
		0, 4167, 491, 1, 0, 0, 0, 4168, 4169, 5, 173, 0, 0, 4169, 4172, 3, 1128,
		564, 0, 4170, 4171, 5, 621, 0, 0, 4171, 4173, 3, 494, 247, 0, 4172, 4170,
		1, 0, 0, 0, 4172, 4173, 1, 0, 0, 0, 4173, 493, 1, 0, 0, 0, 4174, 4179,
		3, 742, 371, 0, 4175, 4176, 5, 773, 0, 0, 4176, 4178, 3, 742, 371, 0, 4177,
		4175, 1, 0, 0, 0, 4178, 4181, 1, 0, 0, 0, 4179, 4177, 1, 0, 0, 0, 4179,
		4180, 1, 0, 0, 0, 4180, 495, 1, 0, 0, 0, 4181, 4179, 1, 0, 0, 0, 4182,
		4207, 5, 677, 0, 0, 4183, 4184, 5, 284, 0, 0, 4184, 4185, 5, 112, 0, 0,
		4185, 4187, 5, 139, 0, 0, 4186, 4188, 3, 1190, 595, 0, 4187, 4186, 1, 0,
		0, 0, 4187, 4188, 1, 0, 0, 0, 4188, 4189, 1, 0, 0, 0, 4189, 4208, 3, 1154,
		577, 0, 4190, 4193, 5, 676, 0, 0, 4191, 4192, 5, 200, 0, 0, 4192, 4194,
		5, 459, 0, 0, 4193, 4191, 1, 0, 0, 0, 4193, 4194, 1, 0, 0, 0, 4194, 4208,
		1, 0, 0, 0, 4195, 4196, 4, 248, 78, 0, 4196, 4197, 5, 244, 0, 0, 4197,
		4198, 5, 203, 0, 0, 4198, 4199, 3, 1026, 513, 0, 4199, 4200, 5, 775, 0,
		0, 4200, 4201, 3, 1140, 570, 0, 4201, 4202, 5, 230, 0, 0, 4202, 4203, 5,
		45, 0, 0, 4203, 4205, 3, 1154, 577, 0, 4204, 4206, 3, 498, 249, 0, 4205,
		4204, 1, 0, 0, 0, 4205, 4206, 1, 0, 0, 0, 4206, 4208, 1, 0, 0, 0, 4207,
		4183, 1, 0, 0, 0, 4207, 4190, 1, 0, 0, 0, 4207, 4195, 1, 0, 0, 0, 4208,
		497, 1, 0, 0, 0, 4209, 4220, 3, 500, 250, 0, 4210, 4211, 5, 112, 0, 0,
		4211, 4213, 5, 139, 0, 0, 4212, 4214, 3, 1190, 595, 0, 4213, 4212, 1, 0,
		0, 0, 4213, 4214, 1, 0, 0, 0, 4214, 4215, 1, 0, 0, 0, 4215, 4217, 3, 1154,
		577, 0, 4216, 4218, 3, 500, 250, 0, 4217, 4216, 1, 0, 0, 0, 4217, 4218,
		1, 0, 0, 0, 4218, 4220, 1, 0, 0, 0, 4219, 4209, 1, 0, 0, 0, 4219, 4210,
		1, 0, 0, 0, 4220, 499, 1, 0, 0, 0, 4221, 4223, 5, 467, 0, 0, 4222, 4224,
		5, 373, 0, 0, 4223, 4222, 1, 0, 0, 0, 4223, 4224, 1, 0, 0, 0, 4224, 4225,
		1, 0, 0, 0, 4225, 4226, 5, 539, 0, 0, 4226, 501, 1, 0, 0, 0, 4227, 4228,
		4, 251, 79, 0, 4228, 4237, 3, 504, 252, 0, 4229, 4237, 3, 510, 255, 0,
		4230, 4237, 3, 522, 261, 0, 4231, 4237, 3, 524, 262, 0, 4232, 4237, 3,
		538, 269, 0, 4233, 4237, 3, 540, 270, 0, 4234, 4235, 4, 251, 80, 0, 4235,
		4237, 3, 558, 279, 0, 4236, 4227, 1, 0, 0, 0, 4236, 4229, 1, 0, 0, 0, 4236,
		4230, 1, 0, 0, 0, 4236, 4231, 1, 0, 0, 0, 4236, 4232, 1, 0, 0, 0, 4236,
		4233, 1, 0, 0, 0, 4236, 4234, 1, 0, 0, 0, 4237, 503, 1, 0, 0, 0, 4238,
		4239, 5, 11, 0, 0, 4239, 4242, 5, 618, 0, 0, 4240, 4241, 4, 252, 81, 0,
		4241, 4243, 3, 978, 489, 0, 4242, 4240, 1, 0, 0, 0, 4242, 4243, 1, 0, 0,
		0, 4243, 4244, 1, 0, 0, 0, 4244, 4245, 3, 506, 253, 0, 4245, 505, 1, 0,
		0, 0, 4246, 4247, 4, 253, 82, 0, 4247, 4251, 3, 1010, 505, 0, 4248, 4249,
		4, 253, 83, 0, 4249, 4251, 3, 1012, 506, 0, 4250, 4246, 1, 0, 0, 0, 4250,
		4248, 1, 0, 0, 0, 4251, 4252, 1, 0, 0, 0, 4252, 4253, 3, 512, 256, 0, 4253,
		4301, 1, 0, 0, 0, 4254, 4255, 4, 253, 84, 0, 4255, 4256, 3, 1026, 513,
		0, 4256, 4257, 5, 230, 0, 0, 4257, 4258, 5, 45, 0, 0, 4258, 4261, 3, 1156,
		578, 0, 4259, 4260, 4, 253, 85, 0, 4260, 4262, 3, 1022, 511, 0, 4261, 4259,
		1, 0, 0, 0, 4261, 4262, 1, 0, 0, 0, 4262, 4265, 1, 0, 0, 0, 4263, 4264,
		4, 253, 86, 0, 4264, 4266, 3, 1018, 509, 0, 4265, 4263, 1, 0, 0, 0, 4265,
		4266, 1, 0, 0, 0, 4266, 4301, 1, 0, 0, 0, 4267, 4268, 4, 253, 87, 0, 4268,
		4269, 3, 1026, 513, 0, 4269, 4270, 3, 1020, 510, 0, 4270, 4301, 1, 0, 0,
		0, 4271, 4272, 4, 253, 88, 0, 4272, 4273, 3, 1026, 513, 0, 4273, 4274,
		5, 128, 0, 0, 4274, 4278, 5, 659, 0, 0, 4275, 4279, 5, 10, 0, 0, 4276,
		4279, 5, 369, 0, 0, 4277, 4279, 3, 560, 280, 0, 4278, 4275, 1, 0, 0, 0,
		4278, 4276, 1, 0, 0, 0, 4278, 4277, 1, 0, 0, 0, 4279, 4301, 1, 0, 0, 0,
		4280, 4281, 4, 253, 89, 0, 4281, 4282, 3, 1026, 513, 0, 4282, 4285, 5,
		230, 0, 0, 4283, 4284, 5, 645, 0, 0, 4284, 4286, 3, 1180, 590, 0, 4285,
		4283, 1, 0, 0, 0, 4285, 4286, 1, 0, 0, 0, 4286, 4287, 1, 0, 0, 0, 4287,
		4288, 5, 45, 0, 0, 4288, 4289, 5, 734, 0, 0, 4289, 4291, 5, 406, 0, 0,
		4290, 4292, 3, 1018, 509, 0, 4291, 4290, 1, 0, 0, 0, 4291, 4292, 1, 0,
		0, 0, 4292, 4301, 1, 0, 0, 0, 4293, 4294, 5, 741, 0, 0, 4294, 4301, 3,
		1142, 571, 0, 4295, 4298, 5, 740, 0, 0, 4296, 4299, 3, 1142, 571, 0, 4297,
		4299, 5, 698, 0, 0, 4298, 4296, 1, 0, 0, 0, 4298, 4297, 1, 0, 0, 0, 4299,
		4301, 1, 0, 0, 0, 4300, 4250, 1, 0, 0, 0, 4300, 4254, 1, 0, 0, 0, 4300,
		4267, 1, 0, 0, 0, 4300, 4271, 1, 0, 0, 0, 4300, 4280, 1, 0, 0, 0, 4300,
		4293, 1, 0, 0, 0, 4300, 4295, 1, 0, 0, 0, 4301, 507, 1, 0, 0, 0, 4302,
		4303, 5, 618, 0, 0, 4303, 4304, 3, 1188, 594, 0, 4304, 509, 1, 0, 0, 0,
		4305, 4306, 5, 97, 0, 0, 4306, 4310, 5, 618, 0, 0, 4307, 4308, 4, 255,
		90, 0, 4308, 4311, 3, 980, 490, 0, 4309, 4311, 1, 0, 0, 0, 4310, 4307,
		1, 0, 0, 0, 4310, 4309, 1, 0, 0, 0, 4311, 4312, 1, 0, 0, 0, 4312, 4313,
		3, 1010, 505, 0, 4313, 4314, 3, 514, 257, 0, 4314, 4315, 3, 512, 256, 0,
		4315, 511, 1, 0, 0, 0, 4316, 4318, 4, 256, 91, 0, 4317, 4319, 3, 516, 258,
		0, 4318, 4317, 1, 0, 0, 0, 4318, 4319, 1, 0, 0, 0, 4319, 4321, 1, 0, 0,
		0, 4320, 4322, 3, 518, 259, 0, 4321, 4320, 1, 0, 0, 0, 4321, 4322, 1, 0,
		0, 0, 4322, 4326, 1, 0, 0, 0, 4323, 4325, 3, 520, 260, 0, 4324, 4323, 1,
		0, 0, 0, 4325, 4328, 1, 0, 0, 0, 4326, 4324, 1, 0, 0, 0, 4326, 4327, 1,
		0, 0, 0, 4327, 4331, 1, 0, 0, 0, 4328, 4326, 1, 0, 0, 0, 4329, 4331, 1,
		0, 0, 0, 4330, 4316, 1, 0, 0, 0, 4330, 4329, 1, 0, 0, 0, 4331, 513, 1,
		0, 0, 0, 4332, 4336, 4, 257, 92, 0, 4333, 4334, 5, 128, 0, 0, 4334, 4335,
		5, 659, 0, 0, 4335, 4337, 3, 560, 280, 0, 4336, 4333, 1, 0, 0, 0, 4336,
		4337, 1, 0, 0, 0, 4337, 4340, 1, 0, 0, 0, 4338, 4340, 1, 0, 0, 0, 4339,
		4332, 1, 0, 0, 0, 4339, 4338, 1, 0, 0, 0, 4340, 515, 1, 0, 0, 0, 4341,
		4344, 5, 467, 0, 0, 4342, 4345, 3, 552, 276, 0, 4343, 4345, 7, 48, 0, 0,
		4344, 4342, 1, 0, 0, 0, 4344, 4343, 1, 0, 0, 0, 4345, 517, 1, 0, 0, 0,
		4346, 4355, 5, 645, 0, 0, 4347, 4348, 5, 322, 0, 0, 4348, 4356, 3, 1140,
		570, 0, 4349, 4350, 5, 327, 0, 0, 4350, 4356, 3, 1140, 570, 0, 4351, 4352,
		5, 321, 0, 0, 4352, 4356, 3, 1140, 570, 0, 4353, 4354, 5, 328, 0, 0, 4354,
		4356, 3, 1140, 570, 0, 4355, 4347, 1, 0, 0, 0, 4355, 4349, 1, 0, 0, 0,
		4355, 4351, 1, 0, 0, 0, 4355, 4353, 1, 0, 0, 0, 4356, 4357, 1, 0, 0, 0,
		4357, 4355, 1, 0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 519, 1, 0, 0, 0,
		4359, 4360, 5, 2, 0, 0, 4360, 4393, 7, 49, 0, 0, 4361, 4390, 5, 406, 0,
		0, 4362, 4369, 5, 177, 0, 0, 4363, 4364, 5, 247, 0, 0, 4364, 4365, 3, 1142,
		571, 0, 4365, 4366, 5, 122, 0, 0, 4366, 4370, 1, 0, 0, 0, 4367, 4370, 5,
		365, 0, 0, 4368, 4370, 5, 128, 0, 0, 4369, 4363, 1, 0, 0, 0, 4369, 4367,
		1, 0, 0, 0, 4369, 4368, 1, 0, 0, 0, 4369, 4370, 1, 0, 0, 0, 4370, 4391,
		1, 0, 0, 0, 4371, 4374, 5, 705, 0, 0, 4372, 4375, 3, 1142, 571, 0, 4373,
		4375, 5, 128, 0, 0, 4374, 4372, 1, 0, 0, 0, 4374, 4373, 1, 0, 0, 0, 4375,
		4391, 1, 0, 0, 0, 4376, 4377, 5, 706, 0, 0, 4377, 4382, 5, 247, 0, 0, 4378,
		4379, 3, 1142, 571, 0, 4379, 4380, 5, 122, 0, 0, 4380, 4383, 1, 0, 0, 0,
		4381, 4383, 5, 128, 0, 0, 4382, 4378, 1, 0, 0, 0, 4382, 4381, 1, 0, 0,
		0, 4383, 4391, 1, 0, 0, 0, 4384, 4385, 4, 260, 93, 0, 4385, 4386, 5, 467,
		0, 0, 4386, 4388, 5, 101, 0, 0, 4387, 4389, 7, 50, 0, 0, 4388, 4387, 1,
		0, 0, 0, 4388, 4389, 1, 0, 0, 0, 4389, 4391, 1, 0, 0, 0, 4390, 4362, 1,
		0, 0, 0, 4390, 4371, 1, 0, 0, 0, 4390, 4376, 1, 0, 0, 0, 4390, 4384, 1,
		0, 0, 0, 4391, 4393, 1, 0, 0, 0, 4392, 4359, 1, 0, 0, 0, 4392, 4361, 1,
		0, 0, 0, 4393, 521, 1, 0, 0, 0, 4394, 4395, 5, 148, 0, 0, 4395, 4398, 5,
		618, 0, 0, 4396, 4397, 4, 261, 94, 0, 4397, 4399, 3, 978, 489, 0, 4398,
		4396, 1, 0, 0, 0, 4398, 4399, 1, 0, 0, 0, 4399, 4400, 1, 0, 0, 0, 4400,
		4401, 3, 1008, 504, 0, 4401, 523, 1, 0, 0, 0, 4402, 4445, 5, 215, 0, 0,
		4403, 4404, 4, 262, 95, 0, 4404, 4405, 3, 546, 273, 0, 4405, 4406, 5, 590,
		0, 0, 4406, 4410, 3, 1008, 504, 0, 4407, 4408, 5, 645, 0, 0, 4408, 4409,
		5, 660, 0, 0, 4409, 4411, 5, 391, 0, 0, 4410, 4407, 1, 0, 0, 0, 4410, 4411,
		1, 0, 0, 0, 4411, 4446, 1, 0, 0, 0, 4412, 4418, 3, 546, 273, 0, 4413, 4415,
		5, 10, 0, 0, 4414, 4416, 5, 421, 0, 0, 4415, 4414, 1, 0, 0, 0, 4415, 4416,
		1, 0, 0, 0, 4416, 4418, 1, 0, 0, 0, 4417, 4412, 1, 0, 0, 0, 4417, 4413,
		1, 0, 0, 0, 4418, 4419, 1, 0, 0, 0, 4419, 4421, 5, 383, 0, 0, 4420, 4422,
		3, 544, 272, 0, 4421, 4420, 1, 0, 0, 0, 4421, 4422, 1, 0, 0, 0, 4422, 4423,
		1, 0, 0, 0, 4423, 4424, 3, 550, 275, 0, 4424, 4425, 5, 590, 0, 0, 4425,
		4427, 3, 526, 263, 0, 4426, 4428, 3, 536, 268, 0, 4427, 4426, 1, 0, 0,
		0, 4427, 4428, 1, 0, 0, 0, 4428, 4430, 1, 0, 0, 0, 4429, 4431, 3, 528,
		264, 0, 4430, 4429, 1, 0, 0, 0, 4430, 4431, 1, 0, 0, 0, 4431, 4433, 1,
		0, 0, 0, 4432, 4434, 3, 534, 267, 0, 4433, 4432, 1, 0, 0, 0, 4433, 4434,
		1, 0, 0, 0, 4434, 4446, 1, 0, 0, 0, 4435, 4436, 5, 427, 0, 0, 4436, 4437,
		5, 383, 0, 0, 4437, 4438, 3, 1026, 513, 0, 4438, 4439, 5, 590, 0, 0, 4439,
		4443, 3, 526, 263, 0, 4440, 4441, 5, 645, 0, 0, 4441, 4442, 5, 215, 0,
		0, 4442, 4444, 5, 391, 0, 0, 4443, 4440, 1, 0, 0, 0, 4443, 4444, 1, 0,
		0, 0, 4444, 4446, 1, 0, 0, 0, 4445, 4403, 1, 0, 0, 0, 4445, 4417, 1, 0,
		0, 0, 4445, 4435, 1, 0, 0, 0, 4446, 525, 1, 0, 0, 0, 4447, 4448, 4, 263,
		96, 0, 4448, 4452, 3, 1010, 505, 0, 4449, 4450, 4, 263, 97, 0, 4450, 4452,
		3, 1008, 504, 0, 4451, 4447, 1, 0, 0, 0, 4451, 4449, 1, 0, 0, 0, 4452,
		527, 1, 0, 0, 0, 4453, 4454, 4, 264, 98, 0, 4454, 4456, 5, 645, 0, 0, 4455,
		4457, 3, 556, 278, 0, 4456, 4455, 1, 0, 0, 0, 4457, 4458, 1, 0, 0, 0, 4458,
		4456, 1, 0, 0, 0, 4458, 4459, 1, 0, 0, 0, 4459, 4465, 1, 0, 0, 0, 4460,
		4461, 4, 264, 99, 0, 4461, 4462, 5, 645, 0, 0, 4462, 4463, 5, 215, 0, 0,
		4463, 4465, 5, 391, 0, 0, 4464, 4453, 1, 0, 0, 0, 4464, 4460, 1, 0, 0,
		0, 4465, 529, 1, 0, 0, 0, 4466, 4467, 5, 663, 0, 0, 4467, 4468, 3, 560,
		280, 0, 4468, 531, 1, 0, 0, 0, 4469, 4470, 5, 645, 0, 0, 4470, 4478, 5,
		659, 0, 0, 4471, 4479, 3, 560, 280, 0, 4472, 4474, 5, 10, 0, 0, 4473, 4475,
		3, 530, 265, 0, 4474, 4473, 1, 0, 0, 0, 4474, 4475, 1, 0, 0, 0, 4475, 4479,
		1, 0, 0, 0, 4476, 4479, 5, 369, 0, 0, 4477, 4479, 5, 128, 0, 0, 4478, 4471,
		1, 0, 0, 0, 4478, 4472, 1, 0, 0, 0, 4478, 4476, 1, 0, 0, 0, 4478, 4477,
		1, 0, 0, 0, 4479, 533, 1, 0, 0, 0, 4480, 4481, 5, 17, 0, 0, 4481, 4483,
		5, 618, 0, 0, 4482, 4484, 3, 532, 266, 0, 4483, 4482, 1, 0, 0, 0, 4483,
		4484, 1, 0, 0, 0, 4484, 535, 1, 0, 0, 0, 4485, 4486, 4, 268, 100, 0, 4486,
		4487, 3, 516, 258, 0, 4487, 537, 1, 0, 0, 0, 4488, 4489, 5, 453, 0, 0,
		4489, 4490, 5, 618, 0, 0, 4490, 4491, 3, 1026, 513, 0, 4491, 4492, 5, 590,
		0, 0, 4492, 4500, 3, 1026, 513, 0, 4493, 4494, 5, 773, 0, 0, 4494, 4495,
		3, 1026, 513, 0, 4495, 4496, 5, 590, 0, 0, 4496, 4497, 3, 1026, 513, 0,
		4497, 4499, 1, 0, 0, 0, 4498, 4493, 1, 0, 0, 0, 4499, 4502, 1, 0, 0, 0,
		4500, 4498, 1, 0, 0, 0, 4500, 4501, 1, 0, 0, 0, 4501, 539, 1, 0, 0, 0,
		4502, 4500, 1, 0, 0, 0, 4503, 4537, 5, 477, 0, 0, 4504, 4505, 4, 270, 101,
		0, 4505, 4506, 3, 546, 273, 0, 4506, 4507, 5, 203, 0, 0, 4507, 4508, 3,
		1008, 504, 0, 4508, 4538, 1, 0, 0, 0, 4509, 4510, 3, 546, 273, 0, 4510,
		4511, 3, 542, 271, 0, 4511, 4512, 5, 203, 0, 0, 4512, 4513, 3, 1008, 504,
		0, 4513, 4538, 1, 0, 0, 0, 4514, 4516, 5, 10, 0, 0, 4515, 4517, 5, 421,
		0, 0, 4516, 4515, 1, 0, 0, 0, 4516, 4517, 1, 0, 0, 0, 4517, 4529, 1, 0,
		0, 0, 4518, 4519, 4, 270, 102, 0, 4519, 4521, 5, 383, 0, 0, 4520, 4522,
		3, 544, 272, 0, 4521, 4520, 1, 0, 0, 0, 4521, 4522, 1, 0, 0, 0, 4522, 4523,
		1, 0, 0, 0, 4523, 4530, 3, 550, 275, 0, 4524, 4525, 5, 773, 0, 0, 4525,
		4526, 5, 215, 0, 0, 4526, 4527, 5, 391, 0, 0, 4527, 4528, 5, 203, 0, 0,
		4528, 4530, 3, 1008, 504, 0, 4529, 4518, 1, 0, 0, 0, 4529, 4524, 1, 0,
		0, 0, 4530, 4538, 1, 0, 0, 0, 4531, 4532, 5, 427, 0, 0, 4532, 4533, 5,
		383, 0, 0, 4533, 4534, 3, 1026, 513, 0, 4534, 4535, 5, 203, 0, 0, 4535,
		4536, 3, 1008, 504, 0, 4536, 4538, 1, 0, 0, 0, 4537, 4504, 1, 0, 0, 0,
		4537, 4509, 1, 0, 0, 0, 4537, 4514, 1, 0, 0, 0, 4537, 4531, 1, 0, 0, 0,
		4538, 541, 1, 0, 0, 0, 4539, 4540, 4, 271, 103, 0, 4540, 4542, 5, 383,
		0, 0, 4541, 4543, 3, 544, 272, 0, 4542, 4541, 1, 0, 0, 0, 4542, 4543, 1,
		0, 0, 0, 4543, 4544, 1, 0, 0, 0, 4544, 4554, 3, 550, 275, 0, 4545, 4551,
		4, 271, 104, 0, 4546, 4548, 5, 383, 0, 0, 4547, 4549, 3, 544, 272, 0, 4548,
		4547, 1, 0, 0, 0, 4548, 4549, 1, 0, 0, 0, 4549, 4550, 1, 0, 0, 0, 4550,
		4552, 3, 550, 275, 0, 4551, 4546, 1, 0, 0, 0, 4551, 4552, 1, 0, 0, 0, 4552,
		4554, 1, 0, 0, 0, 4553, 4539, 1, 0, 0, 0, 4553, 4545, 1, 0, 0, 0, 4554,
		543, 1, 0, 0, 0, 4555, 4556, 7, 51, 0, 0, 4556, 545, 1, 0, 0, 0, 4557,
		4562, 3, 548, 274, 0, 4558, 4559, 5, 773, 0, 0, 4559, 4561, 3, 548, 274,
		0, 4560, 4558, 1, 0, 0, 0, 4561, 4564, 1, 0, 0, 0, 4562, 4560, 1, 0, 0,
		0, 4562, 4563, 1, 0, 0, 0, 4563, 547, 1, 0, 0, 0, 4564, 4562, 1, 0, 0,
		0, 4565, 4576, 4, 274, 105, 0, 4566, 4568, 3, 1184, 592, 0, 4567, 4569,
		3, 1044, 522, 0, 4568, 4567, 1, 0, 0, 0, 4568, 4569, 1, 0, 0, 0, 4569,
		4577, 1, 0, 0, 0, 4570, 4574, 3, 1184, 592, 0, 4571, 4575, 5, 784, 0, 0,
		4572, 4573, 5, 783, 0, 0, 4573, 4575, 3, 1180, 590, 0, 4574, 4571, 1, 0,
		0, 0, 4574, 4572, 1, 0, 0, 0, 4575, 4577, 1, 0, 0, 0, 4576, 4566, 1, 0,
		0, 0, 4576, 4570, 1, 0, 0, 0, 4577, 4607, 1, 0, 0, 0, 4578, 4580, 7, 52,
		0, 0, 4579, 4581, 3, 1044, 522, 0, 4580, 4579, 1, 0, 0, 0, 4580, 4581,
		1, 0, 0, 0, 4581, 4607, 1, 0, 0, 0, 4582, 4607, 7, 53, 0, 0, 4583, 4584,
		5, 215, 0, 0, 4584, 4607, 5, 391, 0, 0, 4585, 4586, 5, 509, 0, 0, 4586,
		4607, 5, 110, 0, 0, 4587, 4591, 5, 97, 0, 0, 4588, 4589, 5, 577, 0, 0,
		4589, 4592, 5, 571, 0, 0, 4590, 4592, 7, 54, 0, 0, 4591, 4588, 1, 0, 0,
		0, 4591, 4590, 1, 0, 0, 0, 4591, 4592, 1, 0, 0, 0, 4592, 4607, 1, 0, 0,
		0, 4593, 4594, 5, 287, 0, 0, 4594, 4607, 5, 571, 0, 0, 4595, 4596, 5, 459,
		0, 0, 4596, 4607, 7, 55, 0, 0, 4597, 4598, 5, 509, 0, 0, 4598, 4607, 5,
		636, 0, 0, 4599, 4601, 5, 11, 0, 0, 4600, 4602, 5, 483, 0, 0, 4601, 4600,
		1, 0, 0, 0, 4601, 4602, 1, 0, 0, 0, 4602, 4607, 1, 0, 0, 0, 4603, 4604,
		4, 274, 106, 0, 4604, 4605, 7, 56, 0, 0, 4605, 4607, 5, 659, 0, 0, 4606,
		4565, 1, 0, 0, 0, 4606, 4578, 1, 0, 0, 0, 4606, 4582, 1, 0, 0, 0, 4606,
		4583, 1, 0, 0, 0, 4606, 4585, 1, 0, 0, 0, 4606, 4587, 1, 0, 0, 0, 4606,
		4593, 1, 0, 0, 0, 4606, 4595, 1, 0, 0, 0, 4606, 4597, 1, 0, 0, 0, 4606,
		4599, 1, 0, 0, 0, 4606, 4603, 1, 0, 0, 0, 4607, 549, 1, 0, 0, 0, 4608,
		4611, 5, 760, 0, 0, 4609, 4610, 5, 772, 0, 0, 4610, 4612, 5, 760, 0, 0,
		4611, 4609, 1, 0, 0, 0, 4611, 4612, 1, 0, 0, 0, 4612, 4625, 1, 0, 0, 0,
		4613, 4616, 3, 1058, 529, 0, 4614, 4615, 5, 772, 0, 0, 4615, 4617, 5, 760,
		0, 0, 4616, 4614, 1, 0, 0, 0, 4616, 4617, 1, 0, 0, 0, 4617, 4625, 1, 0,
		0, 0, 4618, 4625, 3, 1102, 551, 0, 4619, 4620, 4, 275, 107, 0, 4620, 4621,
		3, 1058, 529, 0, 4621, 4622, 5, 772, 0, 0, 4622, 4623, 3, 1102, 551, 0,
		4623, 4625, 1, 0, 0, 0, 4624, 4608, 1, 0, 0, 0, 4624, 4613, 1, 0, 0, 0,
		4624, 4618, 1, 0, 0, 0, 4624, 4619, 1, 0, 0, 0, 4625, 551, 1, 0, 0, 0,
		4626, 4633, 3, 554, 277, 0, 4627, 4629, 5, 15, 0, 0, 4628, 4627, 1, 0,
		0, 0, 4628, 4629, 1, 0, 0, 0, 4629, 4630, 1, 0, 0, 0, 4630, 4632, 3, 554,
		277, 0, 4631, 4628, 1, 0, 0, 0, 4632, 4635, 1, 0, 0, 0, 4633, 4631, 1,
		0, 0, 0, 4633, 4634, 1, 0, 0, 0, 4634, 553, 1, 0, 0, 0, 4635, 4633, 1,
		0, 0, 0, 4636, 4637, 5, 63, 0, 0, 4637, 4643, 3, 1156, 578, 0, 4638, 4639,
		5, 259, 0, 0, 4639, 4643, 3, 1156, 578, 0, 4640, 4641, 5, 559, 0, 0, 4641,
		4643, 3, 1156, 578, 0, 4642, 4636, 1, 0, 0, 0, 4642, 4638, 1, 0, 0, 0,
		4642, 4640, 1, 0, 0, 0, 4643, 555, 1, 0, 0, 0, 4644, 4645, 5, 215, 0, 0,
		4645, 4655, 5, 391, 0, 0, 4646, 4647, 5, 322, 0, 0, 4647, 4655, 3, 1140,
		570, 0, 4648, 4649, 5, 327, 0, 0, 4649, 4655, 3, 1140, 570, 0, 4650, 4651,
		5, 321, 0, 0, 4651, 4655, 3, 1140, 570, 0, 4652, 4653, 5, 328, 0, 0, 4653,
		4655, 3, 1140, 570, 0, 4654, 4644, 1, 0, 0, 0, 4654, 4646, 1, 0, 0, 0,
		4654, 4648, 1, 0, 0, 0, 4654, 4650, 1, 0, 0, 0, 4654, 4652, 1, 0, 0, 0,
		4655, 557, 1, 0, 0, 0, 4656, 4657, 5, 506, 0, 0, 4657, 4658, 5, 659, 0,
		0, 4658, 4680, 3, 560, 280, 0, 4659, 4660, 5, 506, 0, 0, 4660, 4661, 5,
		659, 0, 0, 4661, 4680, 7, 57, 0, 0, 4662, 4663, 5, 506, 0, 0, 4663, 4664,
		5, 128, 0, 0, 4664, 4668, 5, 659, 0, 0, 4665, 4669, 3, 560, 280, 0, 4666,
		4669, 5, 369, 0, 0, 4667, 4669, 5, 10, 0, 0, 4668, 4665, 1, 0, 0, 0, 4668,
		4666, 1, 0, 0, 0, 4668, 4667, 1, 0, 0, 0, 4669, 4670, 1, 0, 0, 0, 4670,
		4671, 5, 590, 0, 0, 4671, 4680, 3, 560, 280, 0, 4672, 4673, 5, 506, 0,
		0, 4673, 4674, 5, 659, 0, 0, 4674, 4677, 5, 10, 0, 0, 4675, 4676, 5, 663,
		0, 0, 4676, 4678, 3, 560, 280, 0, 4677, 4675, 1, 0, 0, 0, 4677, 4678, 1,
		0, 0, 0, 4678, 4680, 1, 0, 0, 0, 4679, 4656, 1, 0, 0, 0, 4679, 4659, 1,
		0, 0, 0, 4679, 4662, 1, 0, 0, 0, 4679, 4672, 1, 0, 0, 0, 4680, 559, 1,
		0, 0, 0, 4681, 4686, 3, 562, 281, 0, 4682, 4683, 5, 773, 0, 0, 4683, 4685,
		3, 562, 281, 0, 4684, 4682, 1, 0, 0, 0, 4685, 4688, 1, 0, 0, 0, 4686, 4684,
		1, 0, 0, 0, 4686, 4687, 1, 0, 0, 0, 4687, 561, 1, 0, 0, 0, 4688, 4686,
		1, 0, 0, 0, 4689, 4693, 3, 1184, 592, 0, 4690, 4691, 5, 783, 0, 0, 4691,
		4694, 3, 1180, 590, 0, 4692, 4694, 5, 784, 0, 0, 4693, 4690, 1, 0, 0, 0,
		4693, 4692, 1, 0, 0, 0, 4693, 4694, 1, 0, 0, 0, 4694, 563, 1, 0, 0, 0,
		4695, 4697, 5, 14, 0, 0, 4696, 4698, 3, 1034, 517, 0, 4697, 4696, 1, 0,
		0, 0, 4697, 4698, 1, 0, 0, 0, 4698, 4699, 1, 0, 0, 0, 4699, 4700, 5, 574,
		0, 0, 4700, 4703, 3, 1104, 552, 0, 4701, 4702, 4, 282, 108, 0, 4702, 4704,
		3, 566, 283, 0, 4703, 4701, 1, 0, 0, 0, 4703, 4704, 1, 0, 0, 0, 4704, 4739,
		1, 0, 0, 0, 4705, 4706, 5, 62, 0, 0, 4706, 4707, 5, 574, 0, 0, 4707, 4711,
		3, 1104, 552, 0, 4708, 4710, 3, 568, 284, 0, 4709, 4708, 1, 0, 0, 0, 4710,
		4713, 1, 0, 0, 0, 4711, 4709, 1, 0, 0, 0, 4711, 4712, 1, 0, 0, 0, 4712,
		4739, 1, 0, 0, 0, 4713, 4711, 1, 0, 0, 0, 4714, 4715, 5, 61, 0, 0, 4715,
		4716, 5, 574, 0, 0, 4716, 4718, 3, 1104, 552, 0, 4717, 4719, 7, 58, 0,
		0, 4718, 4717, 1, 0, 0, 0, 4718, 4719, 1, 0, 0, 0, 4719, 4739, 1, 0, 0,
		0, 4720, 4722, 5, 388, 0, 0, 4721, 4723, 3, 1034, 517, 0, 4722, 4721, 1,
		0, 0, 0, 4722, 4723, 1, 0, 0, 0, 4723, 4724, 1, 0, 0, 0, 4724, 4725, 5,
		574, 0, 0, 4725, 4739, 3, 1104, 552, 0, 4726, 4728, 5, 455, 0, 0, 4727,
		4729, 3, 1034, 517, 0, 4728, 4727, 1, 0, 0, 0, 4728, 4729, 1, 0, 0, 0,
		4729, 4730, 1, 0, 0, 0, 4730, 4731, 5, 574, 0, 0, 4731, 4735, 3, 1104,
		552, 0, 4732, 4734, 3, 570, 285, 0, 4733, 4732, 1, 0, 0, 0, 4734, 4737,
		1, 0, 0, 0, 4735, 4733, 1, 0, 0, 0, 4735, 4736, 1, 0, 0, 0, 4736, 4739,
		1, 0, 0, 0, 4737, 4735, 1, 0, 0, 0, 4738, 4695, 1, 0, 0, 0, 4738, 4705,
		1, 0, 0, 0, 4738, 4714, 1, 0, 0, 0, 4738, 4720, 1, 0, 0, 0, 4738, 4726,
		1, 0, 0, 0, 4739, 565, 1, 0, 0, 0, 4740, 4741, 5, 614, 0, 0, 4741, 4742,
		5, 674, 0, 0, 4742, 4743, 5, 383, 0, 0, 4743, 4747, 3, 1130, 565, 0, 4744,
		4745, 5, 645, 0, 0, 4745, 4746, 5, 747, 0, 0, 4746, 4748, 5, 675, 0, 0,
		4747, 4744, 1, 0, 0, 0, 4747, 4748, 1, 0, 0, 0, 4748, 4754, 1, 0, 0, 0,
		4749, 4750, 5, 148, 0, 0, 4750, 4751, 5, 674, 0, 0, 4751, 4752, 5, 383,
		0, 0, 4752, 4754, 3, 1130, 565, 0, 4753, 4740, 1, 0, 0, 0, 4753, 4749,
		1, 0, 0, 0, 4754, 567, 1, 0, 0, 0, 4755, 4756, 5, 200, 0, 0, 4756, 4759,
		5, 615, 0, 0, 4757, 4759, 7, 59, 0, 0, 4758, 4755, 1, 0, 0, 0, 4758, 4757,
		1, 0, 0, 0, 4759, 569, 1, 0, 0, 0, 4760, 4761, 7, 60, 0, 0, 4761, 571,
		1, 0, 0, 0, 4762, 4763, 5, 245, 0, 0, 4763, 4764, 5, 410, 0, 0, 4764, 4765,
		3, 1128, 564, 0, 4765, 4766, 5, 520, 0, 0, 4766, 4767, 3, 1154, 577, 0,
		4767, 4785, 1, 0, 0, 0, 4768, 4769, 5, 245, 0, 0, 4769, 4770, 5, 664, 0,
		0, 4770, 4785, 3, 1164, 582, 0, 4771, 4772, 5, 607, 0, 0, 4772, 4773, 5,
		410, 0, 0, 4773, 4785, 3, 1118, 559, 0, 4774, 4775, 5, 607, 0, 0, 4775,
		4776, 5, 664, 0, 0, 4776, 4781, 3, 1120, 560, 0, 4777, 4778, 5, 773, 0,
		0, 4778, 4780, 3, 1120, 560, 0, 4779, 4777, 1, 0, 0, 0, 4780, 4783, 1,
		0, 0, 0, 4781, 4779, 1, 0, 0, 0, 4781, 4782, 1, 0, 0, 0, 4782, 4785, 1,
		0, 0, 0, 4783, 4781, 1, 0, 0, 0, 4784, 4762, 1, 0, 0, 0, 4784, 4768, 1,
		0, 0, 0, 4784, 4771, 1, 0, 0, 0, 4784, 4774, 1, 0, 0, 0, 4785, 573, 1,
		0, 0, 0, 4786, 4787, 5, 506, 0, 0, 4787, 4788, 3, 576, 288, 0, 4788, 575,
		1, 0, 0, 0, 4789, 4790, 3, 586, 293, 0, 4790, 4791, 3, 584, 292, 0, 4791,
		4846, 1, 0, 0, 0, 4792, 4793, 5, 592, 0, 0, 4793, 4846, 3, 578, 289, 0,
		4794, 4795, 3, 1192, 596, 0, 4795, 4796, 3, 592, 296, 0, 4796, 4846, 1,
		0, 0, 0, 4797, 4800, 5, 406, 0, 0, 4798, 4799, 5, 200, 0, 0, 4799, 4801,
		3, 1026, 513, 0, 4800, 4798, 1, 0, 0, 0, 4800, 4801, 1, 0, 0, 0, 4801,
		4802, 1, 0, 0, 0, 4802, 4829, 3, 1190, 595, 0, 4803, 4805, 3, 1156, 578,
		0, 4804, 4806, 3, 1022, 511, 0, 4805, 4804, 1, 0, 0, 0, 4805, 4806, 1,
		0, 0, 0, 4806, 4808, 1, 0, 0, 0, 4807, 4809, 3, 1018, 509, 0, 4808, 4807,
		1, 0, 0, 0, 4808, 4809, 1, 0, 0, 0, 4809, 4830, 1, 0, 0, 0, 4810, 4812,
		3, 1156, 578, 0, 4811, 4813, 3, 1022, 511, 0, 4812, 4811, 1, 0, 0, 0, 4812,
		4813, 1, 0, 0, 0, 4813, 4815, 1, 0, 0, 0, 4814, 4816, 3, 1018, 509, 0,
		4815, 4814, 1, 0, 0, 0, 4815, 4816, 1, 0, 0, 0, 4816, 4830, 1, 0, 0, 0,
		4817, 4818, 4, 288, 109, 0, 4818, 4819, 5, 382, 0, 0, 4819, 4820, 5, 776,
		0, 0, 4820, 4821, 3, 1156, 578, 0, 4821, 4822, 5, 777, 0, 0, 4822, 4830,
		1, 0, 0, 0, 4823, 4824, 4, 288, 110, 0, 4824, 4825, 5, 406, 0, 0, 4825,
		4826, 5, 776, 0, 0, 4826, 4827, 3, 1156, 578, 0, 4827, 4828, 5, 777, 0,
		0, 4828, 4830, 1, 0, 0, 0, 4829, 4803, 1, 0, 0, 0, 4829, 4810, 1, 0, 0,
		0, 4829, 4817, 1, 0, 0, 0, 4829, 4823, 1, 0, 0, 0, 4830, 4846, 1, 0, 0,
		0, 4831, 4832, 4, 288, 111, 0, 4832, 4835, 5, 406, 0, 0, 4833, 4834, 5,
		200, 0, 0, 4834, 4836, 3, 1026, 513, 0, 4835, 4833, 1, 0, 0, 0, 4835, 4836,
		1, 0, 0, 0, 4836, 4837, 1, 0, 0, 0, 4837, 4838, 5, 590, 0, 0, 4838, 4840,
		5, 734, 0, 0, 4839, 4841, 3, 1022, 511, 0, 4840, 4839, 1, 0, 0, 0, 4840,
		4841, 1, 0, 0, 0, 4841, 4843, 1, 0, 0, 0, 4842, 4844, 3, 1018, 509, 0,
		4843, 4842, 1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4846, 1, 0, 0, 0,
		4845, 4789, 1, 0, 0, 0, 4845, 4792, 1, 0, 0, 0, 4845, 4794, 1, 0, 0, 0,
		4845, 4797, 1, 0, 0, 0, 4845, 4831, 1, 0, 0, 0, 4846, 577, 1, 0, 0, 0,
		4847, 4849, 3, 580, 290, 0, 4848, 4850, 3, 582, 291, 0, 4849, 4848, 1,
		0, 0, 0, 4849, 4850, 1, 0, 0, 0, 4850, 4857, 1, 0, 0, 0, 4851, 4854, 3,
		582, 291, 0, 4852, 4853, 5, 773, 0, 0, 4853, 4855, 3, 580, 290, 0, 4854,
		4852, 1, 0, 0, 0, 4854, 4855, 1, 0, 0, 0, 4855, 4857, 1, 0, 0, 0, 4856,
		4847, 1, 0, 0, 0, 4856, 4851, 1, 0, 0, 0, 4857, 579, 1, 0, 0, 0, 4858,
		4859, 5, 435, 0, 0, 4859, 4860, 7, 39, 0, 0, 4860, 581, 1, 0, 0, 0, 4861,
		4862, 5, 258, 0, 0, 4862, 4868, 5, 274, 0, 0, 4863, 4864, 5, 456, 0, 0,
		4864, 4869, 5, 435, 0, 0, 4865, 4866, 5, 435, 0, 0, 4866, 4869, 7, 61,
		0, 0, 4867, 4869, 5, 500, 0, 0, 4868, 4863, 1, 0, 0, 0, 4868, 4865, 1,
		0, 0, 0, 4868, 4867, 1, 0, 0, 0, 4869, 583, 1, 0, 0, 0, 4870, 4871, 5,
		773, 0, 0, 4871, 4873, 3, 588, 294, 0, 4872, 4870, 1, 0, 0, 0, 4873, 4876,
		1, 0, 0, 0, 4874, 4872, 1, 0, 0, 0, 4874, 4875, 1, 0, 0, 0, 4875, 585,
		1, 0, 0, 0, 4876, 4874, 1, 0, 0, 0, 4877, 4878, 3, 746, 373, 0, 4878, 4879,
		3, 1190, 595, 0, 4879, 4880, 3, 596, 298, 0, 4880, 4903, 1, 0, 0, 0, 4881,
		4903, 3, 998, 499, 0, 4882, 4883, 3, 742, 371, 0, 4883, 4884, 3, 1190,
		595, 0, 4884, 4885, 3, 676, 338, 0, 4885, 4903, 1, 0, 0, 0, 4886, 4887,
		3, 590, 295, 0, 4887, 4888, 3, 1190, 595, 0, 4888, 4889, 3, 596, 298, 0,
		4889, 4903, 1, 0, 0, 0, 4890, 4900, 5, 356, 0, 0, 4891, 4892, 3, 1190,
		595, 0, 4892, 4893, 3, 676, 338, 0, 4893, 4901, 1, 0, 0, 0, 4894, 4896,
		3, 936, 468, 0, 4895, 4897, 3, 986, 493, 0, 4896, 4895, 1, 0, 0, 0, 4896,
		4897, 1, 0, 0, 0, 4897, 4901, 1, 0, 0, 0, 4898, 4899, 4, 293, 112, 0, 4899,
		4901, 5, 128, 0, 0, 4900, 4891, 1, 0, 0, 0, 4900, 4894, 1, 0, 0, 0, 4900,
		4898, 1, 0, 0, 0, 4901, 4903, 1, 0, 0, 0, 4902, 4877, 1, 0, 0, 0, 4902,
		4881, 1, 0, 0, 0, 4902, 4882, 1, 0, 0, 0, 4902, 4886, 1, 0, 0, 0, 4902,
		4890, 1, 0, 0, 0, 4903, 587, 1, 0, 0, 0, 4904, 4905, 3, 1192, 596, 0, 4905,
		4906, 3, 746, 373, 0, 4906, 4907, 3, 1190, 595, 0, 4907, 4908, 3, 596,
		298, 0, 4908, 4911, 1, 0, 0, 0, 4909, 4911, 3, 586, 293, 0, 4910, 4904,
		1, 0, 0, 0, 4910, 4909, 1, 0, 0, 0, 4911, 589, 1, 0, 0, 0, 4912, 4914,
		5, 785, 0, 0, 4913, 4915, 3, 1196, 598, 0, 4914, 4913, 1, 0, 0, 0, 4914,
		4915, 1, 0, 0, 0, 4915, 4916, 1, 0, 0, 0, 4916, 4917, 3, 746, 373, 0, 4917,
		591, 1, 0, 0, 0, 4918, 4919, 3, 594, 297, 0, 4919, 4920, 3, 584, 292, 0,
		4920, 4924, 1, 0, 0, 0, 4921, 4922, 5, 592, 0, 0, 4922, 4924, 3, 578, 289,
		0, 4923, 4918, 1, 0, 0, 0, 4923, 4921, 1, 0, 0, 0, 4924, 593, 1, 0, 0,
		0, 4925, 4926, 3, 746, 373, 0, 4926, 4927, 3, 1190, 595, 0, 4927, 4928,
		3, 596, 298, 0, 4928, 595, 1, 0, 0, 0, 4929, 4934, 3, 676, 338, 0, 4930,
		4934, 7, 62, 0, 0, 4931, 4932, 4, 298, 113, 0, 4932, 4934, 7, 63, 0, 0,
		4933, 4929, 1, 0, 0, 0, 4933, 4930, 1, 0, 0, 0, 4933, 4931, 1, 0, 0, 0,
		4934, 597, 1, 0, 0, 0, 4935, 5155, 5, 509, 0, 0, 4936, 4937, 4, 299, 114,
		0, 4937, 5156, 5, 22, 0, 0, 4938, 4940, 5, 110, 0, 0, 4939, 4941, 3, 1030,
		515, 0, 4940, 4939, 1, 0, 0, 0, 4940, 4941, 1, 0, 0, 0, 4941, 5156, 1,
		0, 0, 0, 4942, 4944, 3, 600, 300, 0, 4943, 4942, 1, 0, 0, 0, 4943, 4944,
		1, 0, 0, 0, 4944, 4945, 1, 0, 0, 0, 4945, 4947, 5, 571, 0, 0, 4946, 4948,
		3, 606, 303, 0, 4947, 4946, 1, 0, 0, 0, 4947, 4948, 1, 0, 0, 0, 4948, 4950,
		1, 0, 0, 0, 4949, 4951, 3, 1030, 515, 0, 4950, 4949, 1, 0, 0, 0, 4950,
		4951, 1, 0, 0, 0, 4951, 5156, 1, 0, 0, 0, 4952, 4954, 5, 204, 0, 0, 4953,
		4952, 1, 0, 0, 0, 4953, 4954, 1, 0, 0, 0, 4954, 4955, 1, 0, 0, 0, 4955,
		4957, 5, 593, 0, 0, 4956, 4958, 3, 606, 303, 0, 4957, 4956, 1, 0, 0, 0,
		4957, 4958, 1, 0, 0, 0, 4958, 4960, 1, 0, 0, 0, 4959, 4961, 3, 1030, 515,
		0, 4960, 4959, 1, 0, 0, 0, 4960, 4961, 1, 0, 0, 0, 4961, 5156, 1, 0, 0,
		0, 4962, 4964, 5, 169, 0, 0, 4963, 4965, 3, 606, 303, 0, 4964, 4963, 1,
		0, 0, 0, 4964, 4965, 1, 0, 0, 0, 4965, 4967, 1, 0, 0, 0, 4966, 4968, 3,
		1030, 515, 0, 4967, 4966, 1, 0, 0, 0, 4967, 4968, 1, 0, 0, 0, 4968, 5156,
		1, 0, 0, 0, 4969, 4970, 5, 574, 0, 0, 4970, 4972, 5, 547, 0, 0, 4971, 4973,
		3, 606, 303, 0, 4972, 4971, 1, 0, 0, 0, 4972, 4973, 1, 0, 0, 0, 4973, 4975,
		1, 0, 0, 0, 4974, 4976, 3, 1030, 515, 0, 4975, 4974, 1, 0, 0, 0, 4975,
		4976, 1, 0, 0, 0, 4976, 5156, 1, 0, 0, 0, 4977, 4978, 5, 387, 0, 0, 4978,
		4980, 5, 571, 0, 0, 4979, 4981, 3, 606, 303, 0, 4980, 4979, 1, 0, 0, 0,
		4980, 4981, 1, 0, 0, 0, 4981, 4983, 1, 0, 0, 0, 4982, 4984, 3, 1030, 515,
		0, 4983, 4982, 1, 0, 0, 0, 4983, 4984, 1, 0, 0, 0, 4984, 5156, 1, 0, 0,
		0, 4985, 5156, 5, 408, 0, 0, 4986, 4989, 5, 163, 0, 0, 4987, 4990, 3, 1094,
		547, 0, 4988, 4990, 5, 10, 0, 0, 4989, 4987, 1, 0, 0, 0, 4989, 4988, 1,
		0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 5156, 7, 64, 0, 0, 4992, 4994, 3,
		600, 300, 0, 4993, 4992, 1, 0, 0, 0, 4993, 4994, 1, 0, 0, 0, 4994, 4995,
		1, 0, 0, 0, 4995, 4996, 5, 71, 0, 0, 4996, 4997, 7, 65, 0, 0, 4997, 4999,
		3, 1102, 551, 0, 4998, 5000, 3, 606, 303, 0, 4999, 4998, 1, 0, 0, 0, 4999,
		5000, 1, 0, 0, 0, 5000, 5002, 1, 0, 0, 0, 5001, 5003, 3, 1030, 515, 0,
		5002, 5001, 1, 0, 0, 0, 5002, 5003, 1, 0, 0, 0, 5003, 5156, 1, 0, 0, 0,
		5004, 5005, 7, 42, 0, 0, 5005, 5156, 5, 289, 0, 0, 5006, 5013, 5, 514,
		0, 0, 5007, 5014, 5, 225, 0, 0, 5008, 5009, 5, 547, 0, 0, 5009, 5011, 3,
		602, 301, 0, 5010, 5012, 3, 782, 391, 0, 5011, 5010, 1, 0, 0, 0, 5011,
		5012, 1, 0, 0, 0, 5012, 5014, 1, 0, 0, 0, 5013, 5007, 1, 0, 0, 0, 5013,
		5008, 1, 0, 0, 0, 5014, 5156, 1, 0, 0, 0, 5015, 5016, 7, 66, 0, 0, 5016,
		5019, 5, 169, 0, 0, 5017, 5018, 5, 251, 0, 0, 5018, 5020, 3, 1156, 578,
		0, 5019, 5017, 1, 0, 0, 0, 5019, 5020, 1, 0, 0, 0, 5020, 5023, 1, 0, 0,
		0, 5021, 5022, 5, 203, 0, 0, 5022, 5024, 3, 1144, 572, 0, 5023, 5021, 1,
		0, 0, 0, 5023, 5024, 1, 0, 0, 0, 5024, 5026, 1, 0, 0, 0, 5025, 5027, 3,
		284, 142, 0, 5026, 5025, 1, 0, 0, 0, 5026, 5027, 1, 0, 0, 0, 5027, 5029,
		1, 0, 0, 0, 5028, 5030, 3, 782, 391, 0, 5029, 5028, 1, 0, 0, 0, 5029, 5030,
		1, 0, 0, 0, 5030, 5156, 1, 0, 0, 0, 5031, 5032, 4, 299, 115, 0, 5032, 5034,
		5, 180, 0, 0, 5033, 5031, 1, 0, 0, 0, 5033, 5034, 1, 0, 0, 0, 5034, 5035,
		1, 0, 0, 0, 5035, 5036, 7, 67, 0, 0, 5036, 5037, 3, 604, 302, 0, 5037,
		5039, 3, 1102, 551, 0, 5038, 5040, 3, 606, 303, 0, 5039, 5038, 1, 0, 0,
		0, 5039, 5040, 1, 0, 0, 0, 5040, 5042, 1, 0, 0, 0, 5041, 5043, 3, 358,
		179, 0, 5042, 5041, 1, 0, 0, 0, 5042, 5043, 1, 0, 0, 0, 5043, 5156, 1,
		0, 0, 0, 5044, 5046, 5, 553, 0, 0, 5045, 5044, 1, 0, 0, 0, 5045, 5046,
		1, 0, 0, 0, 5046, 5047, 1, 0, 0, 0, 5047, 5156, 5, 162, 0, 0, 5048, 5049,
		5, 95, 0, 0, 5049, 5050, 5, 776, 0, 0, 5050, 5051, 5, 760, 0, 0, 5051,
		5052, 5, 777, 0, 0, 5052, 5156, 7, 68, 0, 0, 5053, 5055, 5, 639, 0, 0,
		5054, 5056, 3, 284, 142, 0, 5055, 5054, 1, 0, 0, 0, 5055, 5056, 1, 0, 0,
		0, 5056, 5156, 1, 0, 0, 0, 5057, 5059, 5, 166, 0, 0, 5058, 5060, 3, 284,
		142, 0, 5059, 5058, 1, 0, 0, 0, 5059, 5060, 1, 0, 0, 0, 5060, 5156, 1,
		0, 0, 0, 5061, 5156, 5, 426, 0, 0, 5062, 5071, 5, 425, 0, 0, 5063, 5068,
		3, 608, 304, 0, 5064, 5065, 5, 773, 0, 0, 5065, 5067, 3, 608, 304, 0, 5066,
		5064, 1, 0, 0, 0, 5067, 5070, 1, 0, 0, 0, 5068, 5066, 1, 0, 0, 0, 5068,
		5069, 1, 0, 0, 0, 5069, 5072, 1, 0, 0, 0, 5070, 5068, 1, 0, 0, 0, 5071,
		5063, 1, 0, 0, 0, 5071, 5072, 1, 0, 0, 0, 5072, 5076, 1, 0, 0, 0, 5073,
		5074, 5, 200, 0, 0, 5074, 5075, 5, 430, 0, 0, 5075, 5077, 5, 747, 0, 0,
		5076, 5073, 1, 0, 0, 0, 5076, 5077, 1, 0, 0, 0, 5077, 5079, 1, 0, 0, 0,
		5078, 5080, 3, 284, 142, 0, 5079, 5078, 1, 0, 0, 0, 5079, 5080, 1, 0, 0,
		0, 5080, 5156, 1, 0, 0, 0, 5081, 5083, 3, 1192, 596, 0, 5082, 5081, 1,
		0, 0, 0, 5082, 5083, 1, 0, 0, 0, 5083, 5084, 1, 0, 0, 0, 5084, 5086, 7,
		69, 0, 0, 5085, 5087, 3, 1030, 515, 0, 5086, 5085, 1, 0, 0, 0, 5086, 5087,
		1, 0, 0, 0, 5087, 5156, 1, 0, 0, 0, 5088, 5090, 5, 204, 0, 0, 5089, 5088,
		1, 0, 0, 0, 5089, 5090, 1, 0, 0, 0, 5090, 5091, 1, 0, 0, 0, 5091, 5156,
		5, 424, 0, 0, 5092, 5094, 3, 758, 379, 0, 5093, 5095, 3, 1030, 515, 0,
		5094, 5093, 1, 0, 0, 0, 5094, 5095, 1, 0, 0, 0, 5095, 5156, 1, 0, 0, 0,
		5096, 5098, 5, 70, 0, 0, 5097, 5099, 3, 1030, 515, 0, 5098, 5097, 1, 0,
		0, 0, 5098, 5099, 1, 0, 0, 0, 5099, 5156, 1, 0, 0, 0, 5100, 5101, 4, 299,
		116, 0, 5101, 5156, 5, 93, 0, 0, 5102, 5156, 5, 421, 0, 0, 5103, 5106,
		5, 216, 0, 0, 5104, 5105, 5, 200, 0, 0, 5105, 5107, 3, 1026, 513, 0, 5106,
		5104, 1, 0, 0, 0, 5106, 5107, 1, 0, 0, 0, 5107, 5156, 1, 0, 0, 0, 5108,
		5109, 5, 216, 0, 0, 5109, 5110, 5, 200, 0, 0, 5110, 5111, 3, 1026, 513,
		0, 5111, 5112, 5, 621, 0, 0, 5112, 5113, 3, 1008, 504, 0, 5113, 5156, 1,
		0, 0, 0, 5114, 5115, 5, 316, 0, 0, 5115, 5156, 5, 547, 0, 0, 5116, 5137,
		5, 97, 0, 0, 5117, 5119, 5, 109, 0, 0, 5118, 5120, 3, 980, 490, 0, 5119,
		5118, 1, 0, 0, 0, 5119, 5120, 1, 0, 0, 0, 5120, 5121, 1, 0, 0, 0, 5121,
		5138, 3, 1058, 529, 0, 5122, 5123, 5, 170, 0, 0, 5123, 5138, 3, 1086, 543,
		0, 5124, 5125, 5, 206, 0, 0, 5125, 5138, 3, 1066, 533, 0, 5126, 5127, 5,
		422, 0, 0, 5127, 5138, 3, 1062, 531, 0, 5128, 5129, 5, 574, 0, 0, 5129,
		5138, 3, 1102, 551, 0, 5130, 5131, 5, 594, 0, 0, 5131, 5138, 3, 1070, 535,
		0, 5132, 5133, 5, 636, 0, 0, 5133, 5138, 3, 1074, 537, 0, 5134, 5135, 4,
		299, 117, 0, 5135, 5136, 5, 618, 0, 0, 5136, 5138, 3, 1026, 513, 0, 5137,
		5117, 1, 0, 0, 0, 5137, 5122, 1, 0, 0, 0, 5137, 5124, 1, 0, 0, 0, 5137,
		5126, 1, 0, 0, 0, 5137, 5128, 1, 0, 0, 0, 5137, 5130, 1, 0, 0, 0, 5137,
		5132, 1, 0, 0, 0, 5137, 5134, 1, 0, 0, 0, 5138, 5156, 1, 0, 0, 0, 5139,
		5140, 5, 422, 0, 0, 5140, 5142, 5, 547, 0, 0, 5141, 5143, 3, 1030, 515,
		0, 5142, 5141, 1, 0, 0, 0, 5142, 5143, 1, 0, 0, 0, 5143, 5156, 1, 0, 0,
		0, 5144, 5145, 5, 206, 0, 0, 5145, 5147, 5, 547, 0, 0, 5146, 5148, 3, 1030,
		515, 0, 5147, 5146, 1, 0, 0, 0, 5147, 5148, 1, 0, 0, 0, 5148, 5156, 1,
		0, 0, 0, 5149, 5150, 5, 422, 0, 0, 5150, 5151, 5, 68, 0, 0, 5151, 5156,
		3, 1062, 531, 0, 5152, 5153, 5, 206, 0, 0, 5153, 5154, 5, 68, 0, 0, 5154,
		5156, 3, 1066, 533, 0, 5155, 4936, 1, 0, 0, 0, 5155, 4938, 1, 0, 0, 0,
		5155, 4943, 1, 0, 0, 0, 5155, 4953, 1, 0, 0, 0, 5155, 4962, 1, 0, 0, 0,
		5155, 4969, 1, 0, 0, 0, 5155, 4977, 1, 0, 0, 0, 5155, 4985, 1, 0, 0, 0,
		5155, 4986, 1, 0, 0, 0, 5155, 4993, 1, 0, 0, 0, 5155, 5004, 1, 0, 0, 0,
		5155, 5006, 1, 0, 0, 0, 5155, 5015, 1, 0, 0, 0, 5155, 5033, 1, 0, 0, 0,
		5155, 5045, 1, 0, 0, 0, 5155, 5048, 1, 0, 0, 0, 5155, 5053, 1, 0, 0, 0,
		5155, 5057, 1, 0, 0, 0, 5155, 5061, 1, 0, 0, 0, 5155, 5062, 1, 0, 0, 0,
		5155, 5082, 1, 0, 0, 0, 5155, 5089, 1, 0, 0, 0, 5155, 5092, 1, 0, 0, 0,
		5155, 5096, 1, 0, 0, 0, 5155, 5100, 1, 0, 0, 0, 5155, 5102, 1, 0, 0, 0,
		5155, 5103, 1, 0, 0, 0, 5155, 5108, 1, 0, 0, 0, 5155, 5114, 1, 0, 0, 0,
		5155, 5116, 1, 0, 0, 0, 5155, 5139, 1, 0, 0, 0, 5155, 5144, 1, 0, 0, 0,
		5155, 5149, 1, 0, 0, 0, 5155, 5152, 1, 0, 0, 0, 5156, 599, 1, 0, 0, 0,
		5157, 5164, 5, 204, 0, 0, 5158, 5159, 4, 300, 118, 0, 5159, 5161, 5, 180,
		0, 0, 5160, 5162, 5, 204, 0, 0, 5161, 5160, 1, 0, 0, 0, 5161, 5162, 1,
		0, 0, 0, 5162, 5164, 1, 0, 0, 0, 5163, 5157, 1, 0, 0, 0, 5163, 5158, 1,
		0, 0, 0, 5164, 601, 1, 0, 0, 0, 5165, 5167, 4, 301, 119, 0, 5166, 5168,
		5, 370, 0, 0, 5167, 5166, 1, 0, 0, 0, 5167, 5168, 1, 0, 0, 0, 5168, 5171,
		1, 0, 0, 0, 5169, 5171, 1, 0, 0, 0, 5170, 5165, 1, 0, 0, 0, 5170, 5169,
		1, 0, 0, 0, 5171, 603, 1, 0, 0, 0, 5172, 5173, 7, 65, 0, 0, 5173, 605,
		1, 0, 0, 0, 5174, 5175, 3, 604, 302, 0, 5175, 5176, 3, 1128, 564, 0, 5176,
		607, 1, 0, 0, 0, 5177, 5178, 5, 40, 0, 0, 5178, 5185, 5, 255, 0, 0, 5179,
		5180, 5, 91, 0, 0, 5180, 5185, 5, 568, 0, 0, 5181, 5182, 5, 400, 0, 0,
		5182, 5185, 5, 185, 0, 0, 5183, 5185, 7, 70, 0, 0, 5184, 5177, 1, 0, 0,
		0, 5184, 5179, 1, 0, 0, 0, 5184, 5181, 1, 0, 0, 0, 5184, 5183, 1, 0, 0,
		0, 5185, 609, 1, 0, 0, 0, 5186, 5187, 5, 33, 0, 0, 5187, 5224, 3, 1160,
		580, 0, 5188, 5189, 5, 47, 0, 0, 5189, 5190, 5, 236, 0, 0, 5190, 5191,
		3, 612, 306, 0, 5191, 5194, 5, 251, 0, 0, 5192, 5195, 3, 1128, 564, 0,
		5193, 5195, 5, 128, 0, 0, 5194, 5192, 1, 0, 0, 0, 5194, 5193, 1, 0, 0,
		0, 5195, 5224, 1, 0, 0, 0, 5196, 5198, 5, 196, 0, 0, 5197, 5199, 3, 1034,
		517, 0, 5198, 5197, 1, 0, 0, 0, 5198, 5199, 1, 0, 0, 0, 5199, 5209, 1,
		0, 0, 0, 5200, 5210, 3, 630, 315, 0, 5201, 5206, 3, 626, 313, 0, 5202,
		5203, 5, 773, 0, 0, 5203, 5205, 3, 626, 313, 0, 5204, 5202, 1, 0, 0, 0,
		5205, 5208, 1, 0, 0, 0, 5206, 5204, 1, 0, 0, 0, 5206, 5207, 1, 0, 0, 0,
		5207, 5210, 1, 0, 0, 0, 5208, 5206, 1, 0, 0, 0, 5209, 5200, 1, 0, 0, 0,
		5209, 5201, 1, 0, 0, 0, 5210, 5224, 1, 0, 0, 0, 5211, 5213, 5, 266, 0,
		0, 5212, 5214, 7, 71, 0, 0, 5213, 5212, 1, 0, 0, 0, 5213, 5214, 1, 0, 0,
		0, 5214, 5215, 1, 0, 0, 0, 5215, 5224, 3, 676, 338, 0, 5216, 5217, 5, 281,
		0, 0, 5217, 5218, 5, 236, 0, 0, 5218, 5219, 5, 248, 0, 0, 5219, 5220, 5,
		47, 0, 0, 5220, 5224, 3, 634, 317, 0, 5221, 5222, 4, 305, 120, 0, 5222,
		5224, 5, 510, 0, 0, 5223, 5186, 1, 0, 0, 0, 5223, 5188, 1, 0, 0, 0, 5223,
		5196, 1, 0, 0, 0, 5223, 5211, 1, 0, 0, 0, 5223, 5216, 1, 0, 0, 0, 5223,
		5221, 1, 0, 0, 0, 5224, 611, 1, 0, 0, 0, 5225, 5228, 3, 614, 307, 0, 5226,
		5228, 3, 618, 309, 0, 5227, 5225, 1, 0, 0, 0, 5227, 5226, 1, 0, 0, 0, 5228,
		613, 1, 0, 0, 0, 5229, 5234, 3, 616, 308, 0, 5230, 5231, 5, 773, 0, 0,
		5231, 5233, 3, 616, 308, 0, 5232, 5230, 1, 0, 0, 0, 5233, 5236, 1, 0, 0,
		0, 5234, 5232, 1, 0, 0, 0, 5234, 5235, 1, 0, 0, 0, 5235, 615, 1, 0, 0,
		0, 5236, 5234, 1, 0, 0, 0, 5237, 5239, 3, 1102, 551, 0, 5238, 5240, 3,
		620, 310, 0, 5239, 5238, 1, 0, 0, 0, 5239, 5240, 1, 0, 0, 0, 5240, 617,
		1, 0, 0, 0, 5241, 5242, 3, 1102, 551, 0, 5242, 5243, 5, 405, 0, 0, 5243,
		5244, 5, 776, 0, 0, 5244, 5245, 3, 52, 26, 0, 5245, 5247, 5, 777, 0, 0,
		5246, 5248, 3, 620, 310, 0, 5247, 5246, 1, 0, 0, 0, 5247, 5248, 1, 0, 0,
		0, 5248, 619, 1, 0, 0, 0, 5249, 5250, 3, 406, 203, 0, 5250, 5252, 5, 776,
		0, 0, 5251, 5253, 3, 624, 312, 0, 5252, 5251, 1, 0, 0, 0, 5252, 5253, 1,
		0, 0, 0, 5253, 5254, 1, 0, 0, 0, 5254, 5255, 5, 777, 0, 0, 5255, 621, 1,
		0, 0, 0, 5256, 5259, 3, 1128, 564, 0, 5257, 5259, 5, 420, 0, 0, 5258, 5256,
		1, 0, 0, 0, 5258, 5257, 1, 0, 0, 0, 5259, 623, 1, 0, 0, 0, 5260, 5265,
		3, 622, 311, 0, 5261, 5262, 5, 773, 0, 0, 5262, 5264, 3, 622, 311, 0, 5263,
		5261, 1, 0, 0, 0, 5264, 5267, 1, 0, 0, 0, 5265, 5263, 1, 0, 0, 0, 5265,
		5266, 1, 0, 0, 0, 5266, 625, 1, 0, 0, 0, 5267, 5265, 1, 0, 0, 0, 5268,
		5284, 7, 72, 0, 0, 5269, 5271, 3, 628, 314, 0, 5270, 5269, 1, 0, 0, 0,
		5270, 5271, 1, 0, 0, 0, 5271, 5272, 1, 0, 0, 0, 5272, 5284, 5, 289, 0,
		0, 5273, 5274, 5, 445, 0, 0, 5274, 5276, 5, 289, 0, 0, 5275, 5277, 3, 782,
		391, 0, 5276, 5275, 1, 0, 0, 0, 5276, 5277, 1, 0, 0, 0, 5277, 5284, 1,
		0, 0, 0, 5278, 5279, 4, 313, 121, 0, 5279, 5280, 5, 430, 0, 0, 5280, 5284,
		5, 47, 0, 0, 5281, 5282, 4, 313, 122, 0, 5282, 5284, 5, 389, 0, 0, 5283,
		5268, 1, 0, 0, 0, 5283, 5270, 1, 0, 0, 0, 5283, 5273, 1, 0, 0, 0, 5283,
		5278, 1, 0, 0, 0, 5283, 5281, 1, 0, 0, 0, 5284, 627, 1, 0, 0, 0, 5285,
		5286, 7, 73, 0, 0, 5286, 629, 1, 0, 0, 0, 5287, 5295, 7, 18, 0, 0, 5288,
		5289, 5, 645, 0, 0, 5289, 5290, 5, 435, 0, 0, 5290, 5296, 5, 287, 0, 0,
		5291, 5293, 3, 1130, 565, 0, 5292, 5294, 3, 632, 316, 0, 5293, 5292, 1,
		0, 0, 0, 5293, 5294, 1, 0, 0, 0, 5294, 5296, 1, 0, 0, 0, 5295, 5288, 1,
		0, 0, 0, 5295, 5291, 1, 0, 0, 0, 5295, 5296, 1, 0, 0, 0, 5296, 631, 1,
		0, 0, 0, 5297, 5298, 4, 316, 123, 0, 5298, 5299, 5, 200, 0, 0, 5299, 5304,
		5, 179, 0, 0, 5300, 5301, 5, 645, 0, 0, 5301, 5302, 5, 435, 0, 0, 5302,
		5304, 5, 287, 0, 0, 5303, 5297, 1, 0, 0, 0, 5303, 5300, 1, 0, 0, 0, 5304,
		633, 1, 0, 0, 0, 5305, 5306, 3, 1102, 551, 0, 5306, 5308, 3, 640, 320,
		0, 5307, 5309, 3, 620, 310, 0, 5308, 5307, 1, 0, 0, 0, 5308, 5309, 1, 0,
		0, 0, 5309, 5312, 1, 0, 0, 0, 5310, 5311, 5, 232, 0, 0, 5311, 5313, 5,
		270, 0, 0, 5312, 5310, 1, 0, 0, 0, 5312, 5313, 1, 0, 0, 0, 5313, 5316,
		1, 0, 0, 0, 5314, 5316, 3, 636, 318, 0, 5315, 5305, 1, 0, 0, 0, 5315, 5314,
		1, 0, 0, 0, 5316, 635, 1, 0, 0, 0, 5317, 5322, 3, 638, 319, 0, 5318, 5319,
		5, 773, 0, 0, 5319, 5321, 3, 638, 319, 0, 5320, 5318, 1, 0, 0, 0, 5321,
		5324, 1, 0, 0, 0, 5322, 5320, 1, 0, 0, 0, 5322, 5323, 1, 0, 0, 0, 5323,
		637, 1, 0, 0, 0, 5324, 5322, 1, 0, 0, 0, 5325, 5327, 3, 1102, 551, 0, 5326,
		5328, 3, 620, 310, 0, 5327, 5326, 1, 0, 0, 0, 5327, 5328, 1, 0, 0, 0, 5328,
		5331, 1, 0, 0, 0, 5329, 5330, 5, 232, 0, 0, 5330, 5332, 5, 270, 0, 0, 5331,
		5329, 1, 0, 0, 0, 5331, 5332, 1, 0, 0, 0, 5332, 639, 1, 0, 0, 0, 5333,
		5334, 5, 405, 0, 0, 5334, 5335, 5, 776, 0, 0, 5335, 5336, 3, 52, 26, 0,
		5336, 5337, 5, 777, 0, 0, 5337, 641, 1, 0, 0, 0, 5338, 5343, 3, 644, 322,
		0, 5339, 5343, 3, 654, 327, 0, 5340, 5343, 3, 656, 328, 0, 5341, 5343,
		3, 660, 330, 0, 5342, 5338, 1, 0, 0, 0, 5342, 5339, 1, 0, 0, 0, 5342, 5340,
		1, 0, 0, 0, 5342, 5341, 1, 0, 0, 0, 5343, 643, 1, 0, 0, 0, 5344, 5345,
		5, 97, 0, 0, 5345, 5346, 5, 709, 0, 0, 5346, 5347, 5, 217, 0, 0, 5347,
		5348, 3, 1128, 564, 0, 5348, 5350, 5, 599, 0, 0, 5349, 5351, 3, 1190, 595,
		0, 5350, 5349, 1, 0, 0, 0, 5350, 5351, 1, 0, 0, 0, 5351, 5352, 1, 0, 0,
		0, 5352, 5354, 7, 74, 0, 0, 5353, 5355, 3, 646, 323, 0, 5354, 5353, 1,
		0, 0, 0, 5354, 5355, 1, 0, 0, 0, 5355, 5357, 1, 0, 0, 0, 5356, 5358, 3,
		650, 325, 0, 5357, 5356, 1, 0, 0, 0, 5357, 5358, 1, 0, 0, 0, 5358, 5360,
		1, 0, 0, 0, 5359, 5361, 3, 652, 326, 0, 5360, 5359, 1, 0, 0, 0, 5360, 5361,
		1, 0, 0, 0, 5361, 645, 1, 0, 0, 0, 5362, 5364, 5, 711, 0, 0, 5363, 5365,
		3, 1190, 595, 0, 5364, 5363, 1, 0, 0, 0, 5364, 5365, 1, 0, 0, 0, 5365,
		5366, 1, 0, 0, 0, 5366, 5373, 3, 648, 324, 0, 5367, 5369, 5, 773, 0, 0,
		5368, 5367, 1, 0, 0, 0, 5368, 5369, 1, 0, 0, 0, 5369, 5370, 1, 0, 0, 0,
		5370, 5372, 3, 648, 324, 0, 5371, 5368, 1, 0, 0, 0, 5372, 5375, 1, 0, 0,
		0, 5373, 5371, 1, 0, 0, 0, 5373, 5374, 1, 0, 0, 0, 5374, 647, 1, 0, 0,
		0, 5375, 5373, 1, 0, 0, 0, 5376, 5379, 5, 747, 0, 0, 5377, 5378, 5, 759,
		0, 0, 5378, 5380, 5, 747, 0, 0, 5379, 5377, 1, 0, 0, 0, 5379, 5380, 1,
		0, 0, 0, 5380, 649, 1, 0, 0, 0, 5381, 5383, 5, 708, 0, 0, 5382, 5384, 3,
		1190, 595, 0, 5383, 5382, 1, 0, 0, 0, 5383, 5384, 1, 0, 0, 0, 5384, 5385,
		1, 0, 0, 0, 5385, 5386, 5, 747, 0, 0, 5386, 651, 1, 0, 0, 0, 5387, 5388,
		7, 75, 0, 0, 5388, 653, 1, 0, 0, 0, 5389, 5390, 5, 11, 0, 0, 5390, 5391,
		5, 709, 0, 0, 5391, 5392, 5, 217, 0, 0, 5392, 5394, 3, 1122, 561, 0, 5393,
		5395, 3, 646, 323, 0, 5394, 5393, 1, 0, 0, 0, 5394, 5395, 1, 0, 0, 0, 5395,
		5397, 1, 0, 0, 0, 5396, 5398, 3, 650, 325, 0, 5397, 5396, 1, 0, 0, 0, 5397,
		5398, 1, 0, 0, 0, 5398, 5400, 1, 0, 0, 0, 5399, 5401, 3, 652, 326, 0, 5400,
		5399, 1, 0, 0, 0, 5400, 5401, 1, 0, 0, 0, 5401, 5403, 1, 0, 0, 0, 5402,
		5404, 5, 198, 0, 0, 5403, 5402, 1, 0, 0, 0, 5403, 5404, 1, 0, 0, 0, 5404,
		655, 1, 0, 0, 0, 5405, 5406, 5, 506, 0, 0, 5406, 5407, 5, 709, 0, 0, 5407,
		5408, 5, 217, 0, 0, 5408, 5411, 3, 1128, 564, 0, 5409, 5410, 5, 200, 0,
		0, 5410, 5412, 3, 658, 329, 0, 5411, 5409, 1, 0, 0, 0, 5411, 5412, 1, 0,
		0, 0, 5412, 657, 1, 0, 0, 0, 5413, 5420, 3, 1142, 571, 0, 5414, 5416, 5,
		773, 0, 0, 5415, 5414, 1, 0, 0, 0, 5415, 5416, 1, 0, 0, 0, 5416, 5417,
		1, 0, 0, 0, 5417, 5419, 3, 1142, 571, 0, 5418, 5415, 1, 0, 0, 0, 5419,
		5422, 1, 0, 0, 0, 5420, 5418, 1, 0, 0, 0, 5420, 5421, 1, 0, 0, 0, 5421,
		659, 1, 0, 0, 0, 5422, 5420, 1, 0, 0, 0, 5423, 5424, 5, 148, 0, 0, 5424,
		5425, 5, 709, 0, 0, 5425, 5426, 5, 217, 0, 0, 5426, 5428, 3, 1122, 561,
		0, 5427, 5429, 5, 198, 0, 0, 5428, 5427, 1, 0, 0, 0, 5428, 5429, 1, 0,
		0, 0, 5429, 661, 1, 0, 0, 0, 5430, 5437, 3, 664, 332, 0, 5431, 5437, 3,
		666, 333, 0, 5432, 5437, 3, 670, 335, 0, 5433, 5437, 3, 672, 336, 0, 5434,
		5435, 4, 331, 124, 0, 5435, 5437, 3, 674, 337, 0, 5436, 5430, 1, 0, 0,
		0, 5436, 5431, 1, 0, 0, 0, 5436, 5432, 1, 0, 0, 0, 5436, 5433, 1, 0, 0,
		0, 5436, 5434, 1, 0, 0, 0, 5437, 663, 1, 0, 0, 0, 5438, 5439, 7, 76, 0,
		0, 5439, 5442, 3, 1102, 551, 0, 5440, 5443, 3, 1156, 578, 0, 5441, 5443,
		3, 1046, 523, 0, 5442, 5440, 1, 0, 0, 0, 5442, 5441, 1, 0, 0, 0, 5442,
		5443, 1, 0, 0, 0, 5443, 665, 1, 0, 0, 0, 5444, 5460, 7, 76, 0, 0, 5445,
		5446, 4, 333, 125, 0, 5446, 5461, 5, 180, 0, 0, 5447, 5448, 4, 333, 126,
		0, 5448, 5461, 5, 404, 0, 0, 5449, 5450, 4, 333, 127, 0, 5450, 5451, 5,
		201, 0, 0, 5451, 5452, 5, 750, 0, 0, 5452, 5461, 3, 1180, 590, 0, 5453,
		5454, 4, 333, 128, 0, 5454, 5461, 5, 14, 0, 0, 5455, 5456, 4, 333, 129,
		0, 5456, 5457, 5, 14, 0, 0, 5457, 5458, 5, 201, 0, 0, 5458, 5459, 5, 750,
		0, 0, 5459, 5461, 3, 1180, 590, 0, 5460, 5445, 1, 0, 0, 0, 5460, 5447,
		1, 0, 0, 0, 5460, 5449, 1, 0, 0, 0, 5460, 5453, 1, 0, 0, 0, 5460, 5455,
		1, 0, 0, 0, 5460, 5461, 1, 0, 0, 0, 5461, 5462, 1, 0, 0, 0, 5462, 5463,
		3, 668, 334, 0, 5463, 667, 1, 0, 0, 0, 5464, 5477, 3, 266, 133, 0, 5465,
		5470, 4, 334, 130, 0, 5466, 5471, 3, 220, 110, 0, 5467, 5471, 3, 232, 116,
		0, 5468, 5471, 3, 264, 132, 0, 5469, 5471, 3, 416, 208, 0, 5470, 5466,
		1, 0, 0, 0, 5470, 5467, 1, 0, 0, 0, 5470, 5468, 1, 0, 0, 0, 5470, 5469,
		1, 0, 0, 0, 5471, 5477, 1, 0, 0, 0, 5472, 5473, 4, 334, 131, 0, 5473, 5474,
		5, 200, 0, 0, 5474, 5475, 5, 84, 0, 0, 5475, 5477, 3, 1142, 571, 0, 5476,
		5464, 1, 0, 0, 0, 5476, 5465, 1, 0, 0, 0, 5476, 5472, 1, 0, 0, 0, 5477,
		669, 1, 0, 0, 0, 5478, 5479, 5, 222, 0, 0, 5479, 5480, 3, 1180, 590, 0,
		5480, 671, 1, 0, 0, 0, 5481, 5482, 5, 620, 0, 0, 5482, 5483, 3, 1128, 564,
		0, 5483, 673, 1, 0, 0, 0, 5484, 5485, 5, 714, 0, 0, 5485, 675, 1, 0, 0,
		0, 5486, 5487, 6, 338, -1, 0, 5487, 5493, 3, 678, 339, 0, 5488, 5490, 5,
		257, 0, 0, 5489, 5491, 3, 760, 380, 0, 5490, 5489, 1, 0, 0, 0, 5490, 5491,
		1, 0, 0, 0, 5491, 5492, 1, 0, 0, 0, 5492, 5494, 7, 77, 0, 0, 5493, 5488,
		1, 0, 0, 0, 5493, 5494, 1, 0, 0, 0, 5494, 5498, 1, 0, 0, 0, 5495, 5496,
		5, 371, 0, 0, 5496, 5498, 3, 676, 338, 4, 5497, 5486, 1, 0, 0, 0, 5497,
		5495, 1, 0, 0, 0, 5498, 5510, 1, 0, 0, 0, 5499, 5500, 10, 3, 0, 0, 5500,
		5501, 7, 78, 0, 0, 5501, 5509, 3, 676, 338, 4, 5502, 5503, 10, 2, 0, 0,
		5503, 5504, 5, 654, 0, 0, 5504, 5509, 3, 676, 338, 3, 5505, 5506, 10, 1,
		0, 0, 5506, 5507, 7, 79, 0, 0, 5507, 5509, 3, 676, 338, 2, 5508, 5499,
		1, 0, 0, 0, 5508, 5502, 1, 0, 0, 0, 5508, 5505, 1, 0, 0, 0, 5509, 5512,
		1, 0, 0, 0, 5510, 5508, 1, 0, 0, 0, 5510, 5511, 1, 0, 0, 0, 5511, 677,
		1, 0, 0, 0, 5512, 5510, 1, 0, 0, 0, 5513, 5514, 6, 339, -1, 0, 5514, 5515,
		3, 682, 341, 0, 5515, 5533, 1, 0, 0, 0, 5516, 5517, 10, 3, 0, 0, 5517,
		5519, 5, 257, 0, 0, 5518, 5520, 3, 760, 380, 0, 5519, 5518, 1, 0, 0, 0,
		5519, 5520, 1, 0, 0, 0, 5520, 5521, 1, 0, 0, 0, 5521, 5532, 5, 376, 0,
		0, 5522, 5523, 10, 2, 0, 0, 5523, 5524, 3, 680, 340, 0, 5524, 5525, 3,
		682, 341, 0, 5525, 5532, 1, 0, 0, 0, 5526, 5527, 10, 1, 0, 0, 5527, 5528,
		3, 680, 340, 0, 5528, 5529, 7, 80, 0, 0, 5529, 5530, 3, 280, 140, 0, 5530,
		5532, 1, 0, 0, 0, 5531, 5516, 1, 0, 0, 0, 5531, 5522, 1, 0, 0, 0, 5531,
		5526, 1, 0, 0, 0, 5532, 5535, 1, 0, 0, 0, 5533, 5531, 1, 0, 0, 0, 5533,
		5534, 1, 0, 0, 0, 5534, 679, 1, 0, 0, 0, 5535, 5533, 1, 0, 0, 0, 5536,
		5537, 7, 81, 0, 0, 5537, 681, 1, 0, 0, 0, 5538, 5552, 3, 686, 343, 0, 5539,
		5541, 3, 760, 380, 0, 5540, 5539, 1, 0, 0, 0, 5540, 5541, 1, 0, 0, 0, 5541,
		5542, 1, 0, 0, 0, 5542, 5553, 3, 684, 342, 0, 5543, 5544, 4, 341, 138,
		0, 5544, 5546, 5, 733, 0, 0, 5545, 5547, 5, 668, 0, 0, 5546, 5545, 1, 0,
		0, 0, 5546, 5547, 1, 0, 0, 0, 5547, 5548, 1, 0, 0, 0, 5548, 5553, 3, 772,
		386, 0, 5549, 5550, 5, 521, 0, 0, 5550, 5551, 5, 275, 0, 0, 5551, 5553,
		3, 686, 343, 0, 5552, 5540, 1, 0, 0, 0, 5552, 5543, 1, 0, 0, 0, 5552, 5549,
		1, 0, 0, 0, 5552, 5553, 1, 0, 0, 0, 5553, 683, 1, 0, 0, 0, 5554, 5560,
		5, 251, 0, 0, 5555, 5561, 3, 280, 140, 0, 5556, 5557, 5, 776, 0, 0, 5557,
		5558, 3, 756, 378, 0, 5558, 5559, 5, 777, 0, 0, 5559, 5561, 1, 0, 0, 0,
		5560, 5555, 1, 0, 0, 0, 5560, 5556, 1, 0, 0, 0, 5561, 5576, 1, 0, 0, 0,
		5562, 5563, 5, 30, 0, 0, 5563, 5564, 3, 686, 343, 0, 5564, 5565, 5, 15,
		0, 0, 5565, 5566, 3, 682, 341, 0, 5566, 5576, 1, 0, 0, 0, 5567, 5568, 5,
		275, 0, 0, 5568, 5571, 3, 688, 344, 0, 5569, 5570, 5, 168, 0, 0, 5570,
		5572, 3, 688, 344, 0, 5571, 5569, 1, 0, 0, 0, 5571, 5572, 1, 0, 0, 0, 5572,
		5576, 1, 0, 0, 0, 5573, 5574, 5, 444, 0, 0, 5574, 5576, 3, 686, 343, 0,
		5575, 5554, 1, 0, 0, 0, 5575, 5562, 1, 0, 0, 0, 5575, 5567, 1, 0, 0, 0,
		5575, 5573, 1, 0, 0, 0, 5576, 685, 1, 0, 0, 0, 5577, 5578, 6, 343, -1,
		0, 5578, 5579, 3, 688, 344, 0, 5579, 5606, 1, 0, 0, 0, 5580, 5581, 10,
		7, 0, 0, 5581, 5582, 5, 769, 0, 0, 5582, 5605, 3, 686, 343, 8, 5583, 5584,
		10, 6, 0, 0, 5584, 5585, 7, 82, 0, 0, 5585, 5605, 3, 686, 343, 7, 5586,
		5587, 10, 5, 0, 0, 5587, 5588, 7, 83, 0, 0, 5588, 5605, 3, 686, 343, 6,
		5589, 5590, 10, 3, 0, 0, 5590, 5591, 7, 84, 0, 0, 5591, 5605, 3, 686, 343,
		4, 5592, 5593, 10, 2, 0, 0, 5593, 5594, 5, 768, 0, 0, 5594, 5605, 3, 686,
		343, 3, 5595, 5596, 10, 1, 0, 0, 5596, 5597, 5, 771, 0, 0, 5597, 5605,
		3, 686, 343, 2, 5598, 5599, 10, 4, 0, 0, 5599, 5600, 7, 83, 0, 0, 5600,
		5601, 5, 247, 0, 0, 5601, 5602, 3, 676, 338, 0, 5602, 5603, 3, 764, 382,
		0, 5603, 5605, 1, 0, 0, 0, 5604, 5580, 1, 0, 0, 0, 5604, 5583, 1, 0, 0,
		0, 5604, 5586, 1, 0, 0, 0, 5604, 5589, 1, 0, 0, 0, 5604, 5592, 1, 0, 0,
		0, 5604, 5595, 1, 0, 0, 0, 5604, 5598, 1, 0, 0, 0, 5605, 5608, 1, 0, 0,
		0, 5606, 5604, 1, 0, 0, 0, 5606, 5607, 1, 0, 0, 0, 5607, 687, 1, 0, 0,
		0, 5608, 5606, 1, 0, 0, 0, 5609, 5610, 6, 344, -1, 0, 5610, 5614, 3, 740,
		370, 0, 5611, 5612, 3, 1190, 595, 0, 5612, 5613, 3, 676, 338, 0, 5613,
		5615, 1, 0, 0, 0, 5614, 5611, 1, 0, 0, 0, 5614, 5615, 1, 0, 0, 0, 5615,
		5719, 1, 0, 0, 0, 5616, 5618, 3, 1046, 523, 0, 5617, 5619, 3, 692, 346,
		0, 5618, 5617, 1, 0, 0, 0, 5618, 5619, 1, 0, 0, 0, 5619, 5719, 1, 0, 0,
		0, 5620, 5719, 3, 716, 358, 0, 5621, 5719, 3, 734, 367, 0, 5622, 5719,
		3, 1148, 574, 0, 5623, 5719, 5, 787, 0, 0, 5624, 5719, 3, 694, 347, 0,
		5625, 5626, 4, 344, 146, 0, 5626, 5719, 3, 696, 348, 0, 5627, 5628, 4,
		344, 147, 0, 5628, 5719, 3, 698, 349, 0, 5629, 5630, 7, 85, 0, 0, 5630,
		5719, 3, 688, 344, 14, 5631, 5632, 3, 762, 381, 0, 5632, 5633, 3, 688,
		344, 13, 5633, 5719, 1, 0, 0, 0, 5634, 5636, 5, 487, 0, 0, 5635, 5634,
		1, 0, 0, 0, 5635, 5636, 1, 0, 0, 0, 5636, 5637, 1, 0, 0, 0, 5637, 5638,
		5, 776, 0, 0, 5638, 5639, 3, 756, 378, 0, 5639, 5640, 5, 777, 0, 0, 5640,
		5719, 1, 0, 0, 0, 5641, 5643, 5, 174, 0, 0, 5642, 5641, 1, 0, 0, 0, 5642,
		5643, 1, 0, 0, 0, 5643, 5644, 1, 0, 0, 0, 5644, 5719, 3, 280, 140, 0, 5645,
		5646, 5, 778, 0, 0, 5646, 5647, 3, 1128, 564, 0, 5647, 5648, 3, 676, 338,
		0, 5648, 5649, 5, 779, 0, 0, 5649, 5719, 1, 0, 0, 0, 5650, 5651, 5, 320,
		0, 0, 5651, 5652, 3, 710, 355, 0, 5652, 5653, 5, 7, 0, 0, 5653, 5654, 5,
		776, 0, 0, 5654, 5656, 3, 686, 343, 0, 5655, 5657, 3, 714, 357, 0, 5656,
		5655, 1, 0, 0, 0, 5656, 5657, 1, 0, 0, 0, 5657, 5658, 1, 0, 0, 0, 5658,
		5659, 5, 777, 0, 0, 5659, 5719, 1, 0, 0, 0, 5660, 5661, 5, 32, 0, 0, 5661,
		5719, 3, 688, 344, 8, 5662, 5663, 5, 52, 0, 0, 5663, 5664, 5, 776, 0, 0,
		5664, 5665, 3, 676, 338, 0, 5665, 5666, 5, 17, 0, 0, 5666, 5668, 3, 754,
		377, 0, 5667, 5669, 3, 690, 345, 0, 5668, 5667, 1, 0, 0, 0, 5668, 5669,
		1, 0, 0, 0, 5669, 5670, 1, 0, 0, 0, 5670, 5671, 5, 777, 0, 0, 5671, 5719,
		1, 0, 0, 0, 5672, 5674, 5, 51, 0, 0, 5673, 5675, 3, 676, 338, 0, 5674,
		5673, 1, 0, 0, 0, 5674, 5675, 1, 0, 0, 0, 5675, 5679, 1, 0, 0, 0, 5676,
		5677, 3, 748, 374, 0, 5677, 5678, 3, 750, 375, 0, 5678, 5680, 1, 0, 0,
		0, 5679, 5676, 1, 0, 0, 0, 5680, 5681, 1, 0, 0, 0, 5681, 5679, 1, 0, 0,
		0, 5681, 5682, 1, 0, 0, 0, 5682, 5684, 1, 0, 0, 0, 5683, 5685, 3, 752,
		376, 0, 5684, 5683, 1, 0, 0, 0, 5684, 5685, 1, 0, 0, 0, 5685, 5686, 1,
		0, 0, 0, 5686, 5687, 5, 159, 0, 0, 5687, 5719, 1, 0, 0, 0, 5688, 5689,
		5, 94, 0, 0, 5689, 5690, 5, 776, 0, 0, 5690, 5691, 3, 676, 338, 0, 5691,
		5692, 5, 773, 0, 0, 5692, 5693, 3, 754, 377, 0, 5693, 5694, 5, 777, 0,
		0, 5694, 5719, 1, 0, 0, 0, 5695, 5696, 5, 94, 0, 0, 5696, 5697, 5, 776,
		0, 0, 5697, 5698, 3, 676, 338, 0, 5698, 5699, 5, 621, 0, 0, 5699, 5700,
		3, 936, 468, 0, 5700, 5701, 5, 777, 0, 0, 5701, 5719, 1, 0, 0, 0, 5702,
		5703, 5, 128, 0, 0, 5703, 5704, 5, 776, 0, 0, 5704, 5705, 3, 1136, 568,
		0, 5705, 5706, 5, 777, 0, 0, 5706, 5719, 1, 0, 0, 0, 5707, 5708, 5, 626,
		0, 0, 5708, 5709, 5, 776, 0, 0, 5709, 5710, 3, 1136, 568, 0, 5710, 5711,
		5, 777, 0, 0, 5711, 5719, 1, 0, 0, 0, 5712, 5713, 5, 247, 0, 0, 5713, 5714,
		3, 676, 338, 0, 5714, 5715, 3, 764, 382, 0, 5715, 5716, 5, 758, 0, 0, 5716,
		5717, 3, 676, 338, 0, 5717, 5719, 1, 0, 0, 0, 5718, 5609, 1, 0, 0, 0, 5718,
		5616, 1, 0, 0, 0, 5718, 5620, 1, 0, 0, 0, 5718, 5621, 1, 0, 0, 0, 5718,
		5622, 1, 0, 0, 0, 5718, 5623, 1, 0, 0, 0, 5718, 5624, 1, 0, 0, 0, 5718,
		5625, 1, 0, 0, 0, 5718, 5627, 1, 0, 0, 0, 5718, 5629, 1, 0, 0, 0, 5718,
		5631, 1, 0, 0, 0, 5718, 5635, 1, 0, 0, 0, 5718, 5642, 1, 0, 0, 0, 5718,
		5645, 1, 0, 0, 0, 5718, 5650, 1, 0, 0, 0, 5718, 5660, 1, 0, 0, 0, 5718,
		5662, 1, 0, 0, 0, 5718, 5672, 1, 0, 0, 0, 5718, 5688, 1, 0, 0, 0, 5718,
		5695, 1, 0, 0, 0, 5718, 5702, 1, 0, 0, 0, 5718, 5707, 1, 0, 0, 0, 5718,
		5712, 1, 0, 0, 0, 5719, 5728, 1, 0, 0, 0, 5720, 5721, 10, 15, 0, 0, 5721,
		5722, 5, 746, 0, 0, 5722, 5727, 3, 688, 344, 16, 5723, 5724, 10, 21, 0,
		0, 5724, 5725, 5, 69, 0, 0, 5725, 5727, 3, 1180, 590, 0, 5726, 5720, 1,
		0, 0, 0, 5726, 5723, 1, 0, 0, 0, 5727, 5730, 1, 0, 0, 0, 5728, 5726, 1,
		0, 0, 0, 5728, 5729, 1, 0, 0, 0, 5729, 689, 1, 0, 0, 0, 5730, 5728, 1,
		0, 0, 0, 5731, 5732, 4, 345, 150, 0, 5732, 5733, 5, 731, 0, 0, 5733, 691,
		1, 0, 0, 0, 5734, 5735, 4, 346, 151, 0, 5735, 5736, 5, 781, 0, 0, 5736,
		5741, 3, 1154, 577, 0, 5737, 5738, 4, 346, 152, 0, 5738, 5739, 5, 782,
		0, 0, 5739, 5741, 3, 1154, 577, 0, 5740, 5734, 1, 0, 0, 0, 5740, 5737,
		1, 0, 0, 0, 5741, 693, 1, 0, 0, 0, 5742, 5743, 5, 26, 0, 0, 5743, 5745,
		5, 776, 0, 0, 5744, 5746, 5, 143, 0, 0, 5745, 5744, 1, 0, 0, 0, 5745, 5746,
		1, 0, 0, 0, 5746, 5747, 1, 0, 0, 0, 5747, 5748, 3, 708, 354, 0, 5748, 5751,
		5, 777, 0, 0, 5749, 5750, 4, 347, 153, 0, 5750, 5752, 3, 700, 350, 0, 5751,
		5749, 1, 0, 0, 0, 5751, 5752, 1, 0, 0, 0, 5752, 5874, 1, 0, 0, 0, 5753,
		5754, 7, 86, 0, 0, 5754, 5755, 5, 776, 0, 0, 5755, 5756, 3, 708, 354, 0,
		5756, 5759, 5, 777, 0, 0, 5757, 5758, 4, 347, 154, 0, 5758, 5760, 3, 700,
		350, 0, 5759, 5757, 1, 0, 0, 0, 5759, 5760, 1, 0, 0, 0, 5760, 5874, 1,
		0, 0, 0, 5761, 5762, 4, 347, 155, 0, 5762, 5874, 3, 706, 353, 0, 5763,
		5764, 5, 95, 0, 0, 5764, 5766, 5, 776, 0, 0, 5765, 5767, 5, 10, 0, 0, 5766,
		5765, 1, 0, 0, 0, 5766, 5767, 1, 0, 0, 0, 5767, 5768, 1, 0, 0, 0, 5768,
		5769, 5, 760, 0, 0, 5769, 5772, 5, 777, 0, 0, 5770, 5771, 4, 347, 156,
		0, 5771, 5773, 3, 700, 350, 0, 5772, 5770, 1, 0, 0, 0, 5772, 5773, 1, 0,
		0, 0, 5773, 5874, 1, 0, 0, 0, 5774, 5775, 5, 95, 0, 0, 5775, 5783, 5, 776,
		0, 0, 5776, 5778, 5, 10, 0, 0, 5777, 5776, 1, 0, 0, 0, 5777, 5778, 1, 0,
		0, 0, 5778, 5779, 1, 0, 0, 0, 5779, 5784, 5, 760, 0, 0, 5780, 5784, 3,
		708, 354, 0, 5781, 5782, 5, 143, 0, 0, 5782, 5784, 3, 756, 378, 0, 5783,
		5777, 1, 0, 0, 0, 5783, 5780, 1, 0, 0, 0, 5783, 5781, 1, 0, 0, 0, 5784,
		5785, 1, 0, 0, 0, 5785, 5788, 5, 777, 0, 0, 5786, 5787, 4, 347, 157, 0,
		5787, 5789, 3, 700, 350, 0, 5788, 5786, 1, 0, 0, 0, 5788, 5789, 1, 0, 0,
		0, 5789, 5874, 1, 0, 0, 0, 5790, 5791, 5, 345, 0, 0, 5791, 5793, 5, 776,
		0, 0, 5792, 5794, 5, 143, 0, 0, 5793, 5792, 1, 0, 0, 0, 5793, 5794, 1,
		0, 0, 0, 5794, 5795, 1, 0, 0, 0, 5795, 5796, 3, 708, 354, 0, 5796, 5799,
		5, 777, 0, 0, 5797, 5798, 4, 347, 158, 0, 5798, 5800, 3, 700, 350, 0, 5799,
		5797, 1, 0, 0, 0, 5799, 5800, 1, 0, 0, 0, 5800, 5874, 1, 0, 0, 0, 5801,
		5802, 5, 326, 0, 0, 5802, 5804, 5, 776, 0, 0, 5803, 5805, 5, 143, 0, 0,
		5804, 5803, 1, 0, 0, 0, 5804, 5805, 1, 0, 0, 0, 5805, 5806, 1, 0, 0, 0,
		5806, 5807, 3, 708, 354, 0, 5807, 5810, 5, 777, 0, 0, 5808, 5809, 4, 347,
		159, 0, 5809, 5811, 3, 700, 350, 0, 5810, 5808, 1, 0, 0, 0, 5810, 5811,
		1, 0, 0, 0, 5811, 5874, 1, 0, 0, 0, 5812, 5813, 5, 551, 0, 0, 5813, 5814,
		5, 776, 0, 0, 5814, 5815, 3, 708, 354, 0, 5815, 5818, 5, 777, 0, 0, 5816,
		5817, 4, 347, 160, 0, 5817, 5819, 3, 700, 350, 0, 5818, 5816, 1, 0, 0,
		0, 5818, 5819, 1, 0, 0, 0, 5819, 5874, 1, 0, 0, 0, 5820, 5821, 5, 632,
		0, 0, 5821, 5822, 5, 776, 0, 0, 5822, 5823, 3, 708, 354, 0, 5823, 5826,
		5, 777, 0, 0, 5824, 5825, 4, 347, 161, 0, 5825, 5827, 3, 700, 350, 0, 5826,
		5824, 1, 0, 0, 0, 5826, 5827, 1, 0, 0, 0, 5827, 5874, 1, 0, 0, 0, 5828,
		5829, 5, 548, 0, 0, 5829, 5830, 5, 776, 0, 0, 5830, 5831, 3, 708, 354,
		0, 5831, 5834, 5, 777, 0, 0, 5832, 5833, 4, 347, 162, 0, 5833, 5835, 3,
		700, 350, 0, 5834, 5832, 1, 0, 0, 0, 5834, 5835, 1, 0, 0, 0, 5835, 5874,
		1, 0, 0, 0, 5836, 5837, 5, 635, 0, 0, 5837, 5838, 5, 776, 0, 0, 5838, 5839,
		3, 708, 354, 0, 5839, 5842, 5, 777, 0, 0, 5840, 5841, 4, 347, 163, 0, 5841,
		5843, 3, 700, 350, 0, 5842, 5840, 1, 0, 0, 0, 5842, 5843, 1, 0, 0, 0, 5843,
		5874, 1, 0, 0, 0, 5844, 5845, 5, 564, 0, 0, 5845, 5847, 5, 776, 0, 0, 5846,
		5848, 5, 143, 0, 0, 5847, 5846, 1, 0, 0, 0, 5847, 5848, 1, 0, 0, 0, 5848,
		5849, 1, 0, 0, 0, 5849, 5850, 3, 708, 354, 0, 5850, 5853, 5, 777, 0, 0,
		5851, 5852, 4, 347, 164, 0, 5852, 5854, 3, 700, 350, 0, 5853, 5851, 1,
		0, 0, 0, 5853, 5854, 1, 0, 0, 0, 5854, 5874, 1, 0, 0, 0, 5855, 5856, 5,
		218, 0, 0, 5856, 5858, 5, 776, 0, 0, 5857, 5859, 5, 143, 0, 0, 5858, 5857,
		1, 0, 0, 0, 5858, 5859, 1, 0, 0, 0, 5859, 5860, 1, 0, 0, 0, 5860, 5862,
		3, 756, 378, 0, 5861, 5863, 3, 328, 164, 0, 5862, 5861, 1, 0, 0, 0, 5862,
		5863, 1, 0, 0, 0, 5863, 5866, 1, 0, 0, 0, 5864, 5865, 5, 499, 0, 0, 5865,
		5867, 3, 1156, 578, 0, 5866, 5864, 1, 0, 0, 0, 5866, 5867, 1, 0, 0, 0,
		5867, 5868, 1, 0, 0, 0, 5868, 5871, 5, 777, 0, 0, 5869, 5870, 4, 347, 165,
		0, 5870, 5872, 3, 700, 350, 0, 5871, 5869, 1, 0, 0, 0, 5871, 5872, 1, 0,
		0, 0, 5872, 5874, 1, 0, 0, 0, 5873, 5742, 1, 0, 0, 0, 5873, 5753, 1, 0,
		0, 0, 5873, 5761, 1, 0, 0, 0, 5873, 5763, 1, 0, 0, 0, 5873, 5774, 1, 0,
		0, 0, 5873, 5790, 1, 0, 0, 0, 5873, 5801, 1, 0, 0, 0, 5873, 5812, 1, 0,
		0, 0, 5873, 5820, 1, 0, 0, 0, 5873, 5828, 1, 0, 0, 0, 5873, 5836, 1, 0,
		0, 0, 5873, 5844, 1, 0, 0, 0, 5873, 5855, 1, 0, 0, 0, 5874, 695, 1, 0,
		0, 0, 5875, 5876, 5, 672, 0, 0, 5876, 5877, 5, 776, 0, 0, 5877, 5878, 3,
		756, 378, 0, 5878, 5879, 5, 777, 0, 0, 5879, 697, 1, 0, 0, 0, 5880, 5881,
		7, 87, 0, 0, 5881, 5882, 3, 1188, 594, 0, 5882, 5883, 3, 700, 350, 0, 5883,
		5923, 1, 0, 0, 0, 5884, 5885, 5, 688, 0, 0, 5885, 5886, 3, 772, 386, 0,
		5886, 5887, 3, 700, 350, 0, 5887, 5923, 1, 0, 0, 0, 5888, 5889, 7, 88,
		0, 0, 5889, 5890, 5, 776, 0, 0, 5890, 5892, 3, 676, 338, 0, 5891, 5893,
		3, 702, 351, 0, 5892, 5891, 1, 0, 0, 0, 5892, 5893, 1, 0, 0, 0, 5893, 5894,
		1, 0, 0, 0, 5894, 5896, 5, 777, 0, 0, 5895, 5897, 3, 704, 352, 0, 5896,
		5895, 1, 0, 0, 0, 5896, 5897, 1, 0, 0, 0, 5897, 5898, 1, 0, 0, 0, 5898,
		5899, 3, 700, 350, 0, 5899, 5923, 1, 0, 0, 0, 5900, 5901, 7, 89, 0, 0,
		5901, 5903, 3, 770, 385, 0, 5902, 5904, 3, 704, 352, 0, 5903, 5902, 1,
		0, 0, 0, 5903, 5904, 1, 0, 0, 0, 5904, 5905, 1, 0, 0, 0, 5905, 5906, 3,
		700, 350, 0, 5906, 5923, 1, 0, 0, 0, 5907, 5908, 5, 687, 0, 0, 5908, 5909,
		5, 776, 0, 0, 5909, 5910, 3, 676, 338, 0, 5910, 5911, 5, 773, 0, 0, 5911,
		5912, 3, 688, 344, 0, 5912, 5915, 5, 777, 0, 0, 5913, 5914, 5, 203, 0,
		0, 5914, 5916, 7, 90, 0, 0, 5915, 5913, 1, 0, 0, 0, 5915, 5916, 1, 0, 0,
		0, 5916, 5918, 1, 0, 0, 0, 5917, 5919, 3, 704, 352, 0, 5918, 5917, 1, 0,
		0, 0, 5918, 5919, 1, 0, 0, 0, 5919, 5920, 1, 0, 0, 0, 5920, 5921, 3, 700,
		350, 0, 5921, 5923, 1, 0, 0, 0, 5922, 5880, 1, 0, 0, 0, 5922, 5884, 1,
		0, 0, 0, 5922, 5888, 1, 0, 0, 0, 5922, 5900, 1, 0, 0, 0, 5922, 5907, 1,
		0, 0, 0, 5923, 699, 1, 0, 0, 0, 5924, 5927, 5, 691, 0, 0, 5925, 5928, 3,
		1124, 562, 0, 5926, 5928, 3, 302, 151, 0, 5927, 5925, 1, 0, 0, 0, 5927,
		5926, 1, 0, 0, 0, 5928, 701, 1, 0, 0, 0, 5929, 5932, 5, 773, 0, 0, 5930,
		5933, 3, 1144, 572, 0, 5931, 5933, 5, 787, 0, 0, 5932, 5930, 1, 0, 0, 0,
		5932, 5931, 1, 0, 0, 0, 5933, 5936, 1, 0, 0, 0, 5934, 5935, 5, 773, 0,
		0, 5935, 5937, 3, 676, 338, 0, 5936, 5934, 1, 0, 0, 0, 5936, 5937, 1, 0,
		0, 0, 5937, 703, 1, 0, 0, 0, 5938, 5939, 7, 91, 0, 0, 5939, 5940, 5, 689,
		0, 0, 5940, 705, 1, 0, 0, 0, 5941, 5942, 5, 667, 0, 0, 5942, 5943, 5, 776,
		0, 0, 5943, 5944, 3, 708, 354, 0, 5944, 5946, 5, 777, 0, 0, 5945, 5947,
		3, 700, 350, 0, 5946, 5945, 1, 0, 0, 0, 5946, 5947, 1, 0, 0, 0, 5947, 5958,
		1, 0, 0, 0, 5948, 5949, 5, 666, 0, 0, 5949, 5950, 5, 776, 0, 0, 5950, 5951,
		3, 708, 354, 0, 5951, 5952, 5, 773, 0, 0, 5952, 5953, 3, 708, 354, 0, 5953,
		5955, 5, 777, 0, 0, 5954, 5956, 3, 700, 350, 0, 5955, 5954, 1, 0, 0, 0,
		5955, 5956, 1, 0, 0, 0, 5956, 5958, 1, 0, 0, 0, 5957, 5941, 1, 0, 0, 0,
		5957, 5948, 1, 0, 0, 0, 5958, 707, 1, 0, 0, 0, 5959, 5961, 5, 10, 0, 0,
		5960, 5959, 1, 0, 0, 0, 5960, 5961, 1, 0, 0, 0, 5961, 5962, 1, 0, 0, 0,
		5962, 5963, 3, 676, 338, 0, 5963, 709, 1, 0, 0, 0, 5964, 5970, 3, 712,
		356, 0, 5965, 5966, 5, 776, 0, 0, 5966, 5967, 3, 712, 356, 0, 5967, 5968,
		5, 777, 0, 0, 5968, 5970, 1, 0, 0, 0, 5969, 5964, 1, 0, 0, 0, 5969, 5965,
		1, 0, 0, 0, 5970, 711, 1, 0, 0, 0, 5971, 5976, 3, 1136, 568, 0, 5972, 5973,
		5, 773, 0, 0, 5973, 5975, 3, 1136, 568, 0, 5974, 5972, 1, 0, 0, 0, 5975,
		5978, 1, 0, 0, 0, 5976, 5974, 1, 0, 0, 0, 5976, 5977, 1, 0, 0, 0, 5977,
		713, 1, 0, 0, 0, 5978, 5976, 1, 0, 0, 0, 5979, 5980, 5, 251, 0, 0, 5980,
		5981, 5, 41, 0, 0, 5981, 5995, 5, 346, 0, 0, 5982, 5983, 5, 251, 0, 0,
		5983, 5984, 5, 359, 0, 0, 5984, 5985, 5, 267, 0, 0, 5985, 5989, 5, 346,
		0, 0, 5986, 5987, 5, 645, 0, 0, 5987, 5988, 5, 430, 0, 0, 5988, 5990, 5,
		176, 0, 0, 5989, 5986, 1, 0, 0, 0, 5989, 5990, 1, 0, 0, 0, 5990, 5995,
		1, 0, 0, 0, 5991, 5992, 5, 645, 0, 0, 5992, 5993, 5, 430, 0, 0, 5993, 5995,
		5, 176, 0, 0, 5994, 5979, 1, 0, 0, 0, 5994, 5982, 1, 0, 0, 0, 5994, 5991,
		1, 0, 0, 0, 5995, 715, 1, 0, 0, 0, 5996, 5997, 5, 60, 0, 0, 5997, 5998,
		5, 776, 0, 0, 5998, 6001, 3, 756, 378, 0, 5999, 6000, 5, 621, 0, 0, 6000,
		6002, 3, 936, 468, 0, 6001, 5999, 1, 0, 0, 0, 6001, 6002, 1, 0, 0, 0, 6002,
		6003, 1, 0, 0, 0, 6003, 6004, 5, 777, 0, 0, 6004, 6270, 1, 0, 0, 0, 6005,
		6007, 5, 105, 0, 0, 6006, 6008, 3, 1188, 594, 0, 6007, 6006, 1, 0, 0, 0,
		6007, 6008, 1, 0, 0, 0, 6008, 6270, 1, 0, 0, 0, 6009, 6010, 5, 116, 0,
		0, 6010, 6270, 3, 770, 385, 0, 6011, 6012, 5, 122, 0, 0, 6012, 6270, 3,
		770, 385, 0, 6013, 6014, 5, 229, 0, 0, 6014, 6270, 3, 770, 385, 0, 6015,
		6016, 5, 242, 0, 0, 6016, 6017, 5, 776, 0, 0, 6017, 6018, 3, 676, 338,
		0, 6018, 6019, 5, 773, 0, 0, 6019, 6020, 3, 676, 338, 0, 6020, 6021, 5,
		773, 0, 0, 6021, 6022, 3, 676, 338, 0, 6022, 6023, 5, 773, 0, 0, 6023,
		6024, 3, 676, 338, 0, 6024, 6025, 5, 777, 0, 0, 6025, 6270, 1, 0, 0, 0,
		6026, 6027, 5, 247, 0, 0, 6027, 6028, 5, 776, 0, 0, 6028, 6031, 3, 676,
		338, 0, 6029, 6030, 5, 773, 0, 0, 6030, 6032, 3, 676, 338, 0, 6031, 6029,
		1, 0, 0, 0, 6032, 6033, 1, 0, 0, 0, 6033, 6031, 1, 0, 0, 0, 6033, 6034,
		1, 0, 0, 0, 6034, 6035, 1, 0, 0, 0, 6035, 6036, 5, 777, 0, 0, 6036, 6270,
		1, 0, 0, 0, 6037, 6038, 5, 272, 0, 0, 6038, 6039, 5, 776, 0, 0, 6039, 6040,
		3, 676, 338, 0, 6040, 6041, 5, 773, 0, 0, 6041, 6042, 3, 676, 338, 0, 6042,
		6043, 5, 777, 0, 0, 6043, 6270, 1, 0, 0, 0, 6044, 6045, 5, 343, 0, 0, 6045,
		6270, 3, 770, 385, 0, 6046, 6047, 5, 350, 0, 0, 6047, 6270, 3, 770, 385,
		0, 6048, 6049, 5, 478, 0, 0, 6049, 6050, 5, 776, 0, 0, 6050, 6051, 3, 676,
		338, 0, 6051, 6052, 5, 773, 0, 0, 6052, 6053, 3, 676, 338, 0, 6053, 6054,
		5, 777, 0, 0, 6054, 6270, 1, 0, 0, 0, 6055, 6056, 5, 495, 0, 0, 6056, 6270,
		3, 770, 385, 0, 6057, 6058, 5, 586, 0, 0, 6058, 6270, 3, 770, 385, 0, 6059,
		6060, 5, 583, 0, 0, 6060, 6061, 5, 776, 0, 0, 6061, 6064, 3, 676, 338,
		0, 6062, 6063, 5, 773, 0, 0, 6063, 6065, 3, 676, 338, 0, 6064, 6062, 1,
		0, 0, 0, 6064, 6065, 1, 0, 0, 0, 6065, 6066, 1, 0, 0, 0, 6066, 6067, 5,
		777, 0, 0, 6067, 6270, 1, 0, 0, 0, 6068, 6270, 3, 730, 365, 0, 6069, 6070,
		5, 618, 0, 0, 6070, 6270, 3, 1188, 594, 0, 6071, 6072, 5, 626, 0, 0, 6072,
		6270, 3, 770, 385, 0, 6073, 6074, 5, 656, 0, 0, 6074, 6270, 3, 770, 385,
		0, 6075, 6076, 7, 92, 0, 0, 6076, 6077, 5, 776, 0, 0, 6077, 6078, 3, 676,
		338, 0, 6078, 6084, 5, 773, 0, 0, 6079, 6085, 3, 676, 338, 0, 6080, 6081,
		5, 247, 0, 0, 6081, 6082, 3, 676, 338, 0, 6082, 6083, 3, 764, 382, 0, 6083,
		6085, 1, 0, 0, 0, 6084, 6079, 1, 0, 0, 0, 6084, 6080, 1, 0, 0, 0, 6085,
		6086, 1, 0, 0, 0, 6086, 6087, 5, 777, 0, 0, 6087, 6270, 1, 0, 0, 0, 6088,
		6090, 5, 100, 0, 0, 6089, 6091, 3, 1188, 594, 0, 6090, 6089, 1, 0, 0, 0,
		6090, 6091, 1, 0, 0, 0, 6091, 6270, 1, 0, 0, 0, 6092, 6094, 5, 108, 0,
		0, 6093, 6095, 3, 720, 360, 0, 6094, 6093, 1, 0, 0, 0, 6094, 6095, 1, 0,
		0, 0, 6095, 6270, 1, 0, 0, 0, 6096, 6097, 7, 93, 0, 0, 6097, 6098, 5, 776,
		0, 0, 6098, 6099, 3, 676, 338, 0, 6099, 6100, 5, 773, 0, 0, 6100, 6101,
		5, 247, 0, 0, 6101, 6102, 3, 676, 338, 0, 6102, 6103, 3, 764, 382, 0, 6103,
		6104, 5, 777, 0, 0, 6104, 6270, 1, 0, 0, 0, 6105, 6106, 5, 182, 0, 0, 6106,
		6107, 5, 776, 0, 0, 6107, 6108, 3, 764, 382, 0, 6108, 6109, 5, 203, 0,
		0, 6109, 6110, 3, 676, 338, 0, 6110, 6111, 5, 777, 0, 0, 6111, 6270, 1,
		0, 0, 0, 6112, 6113, 5, 213, 0, 0, 6113, 6114, 5, 776, 0, 0, 6114, 6115,
		3, 728, 364, 0, 6115, 6116, 5, 773, 0, 0, 6116, 6117, 3, 676, 338, 0, 6117,
		6118, 5, 777, 0, 0, 6118, 6270, 1, 0, 0, 0, 6119, 6121, 5, 372, 0, 0, 6120,
		6122, 3, 720, 360, 0, 6121, 6120, 1, 0, 0, 0, 6121, 6122, 1, 0, 0, 0, 6122,
		6270, 1, 0, 0, 0, 6123, 6124, 5, 414, 0, 0, 6124, 6125, 5, 776, 0, 0, 6125,
		6126, 3, 686, 343, 0, 6126, 6127, 5, 251, 0, 0, 6127, 6128, 3, 676, 338,
		0, 6128, 6129, 5, 777, 0, 0, 6129, 6270, 1, 0, 0, 0, 6130, 6270, 3, 732,
		366, 0, 6131, 6133, 5, 569, 0, 0, 6132, 6134, 3, 720, 360, 0, 6133, 6132,
		1, 0, 0, 0, 6133, 6134, 1, 0, 0, 0, 6134, 6270, 1, 0, 0, 0, 6135, 6136,
		7, 94, 0, 0, 6136, 6137, 5, 776, 0, 0, 6137, 6138, 3, 766, 383, 0, 6138,
		6139, 5, 773, 0, 0, 6139, 6140, 3, 676, 338, 0, 6140, 6141, 5, 773, 0,
		0, 6141, 6142, 3, 676, 338, 0, 6142, 6143, 5, 777, 0, 0, 6143, 6270, 1,
		0, 0, 0, 6144, 6146, 5, 622, 0, 0, 6145, 6147, 3, 1188, 594, 0, 6146, 6145,
		1, 0, 0, 0, 6146, 6147, 1, 0, 0, 0, 6147, 6270, 1, 0, 0, 0, 6148, 6150,
		5, 624, 0, 0, 6149, 6151, 3, 720, 360, 0, 6150, 6149, 1, 0, 0, 0, 6150,
		6151, 1, 0, 0, 0, 6151, 6270, 1, 0, 0, 0, 6152, 6154, 5, 623, 0, 0, 6153,
		6155, 3, 720, 360, 0, 6154, 6153, 1, 0, 0, 0, 6154, 6155, 1, 0, 0, 0, 6155,
		6270, 1, 0, 0, 0, 6156, 6157, 5, 19, 0, 0, 6157, 6270, 3, 770, 385, 0,
		6158, 6159, 5, 58, 0, 0, 6159, 6270, 3, 770, 385, 0, 6160, 6161, 5, 67,
		0, 0, 6161, 6270, 3, 768, 384, 0, 6162, 6163, 5, 70, 0, 0, 6163, 6270,
		3, 770, 385, 0, 6164, 6165, 5, 109, 0, 0, 6165, 6270, 3, 1188, 594, 0,
		6166, 6167, 5, 231, 0, 0, 6167, 6168, 5, 776, 0, 0, 6168, 6169, 3, 676,
		338, 0, 6169, 6170, 5, 773, 0, 0, 6170, 6171, 3, 676, 338, 0, 6171, 6172,
		5, 773, 0, 0, 6172, 6173, 3, 676, 338, 0, 6173, 6174, 5, 777, 0, 0, 6174,
		6270, 1, 0, 0, 0, 6175, 6176, 5, 201, 0, 0, 6176, 6177, 5, 776, 0, 0, 6177,
		6178, 3, 676, 338, 0, 6178, 6179, 5, 773, 0, 0, 6179, 6182, 3, 676, 338,
		0, 6180, 6181, 5, 773, 0, 0, 6181, 6183, 3, 676, 338, 0, 6182, 6180, 1,
		0, 0, 0, 6182, 6183, 1, 0, 0, 0, 6183, 6184, 1, 0, 0, 0, 6184, 6185, 5,
		777, 0, 0, 6185, 6270, 1, 0, 0, 0, 6186, 6187, 5, 337, 0, 0, 6187, 6270,
		3, 770, 385, 0, 6188, 6189, 5, 349, 0, 0, 6189, 6190, 5, 776, 0, 0, 6190,
		6191, 3, 676, 338, 0, 6191, 6192, 5, 773, 0, 0, 6192, 6193, 3, 676, 338,
		0, 6193, 6194, 5, 777, 0, 0, 6194, 6270, 1, 0, 0, 0, 6195, 6196, 4, 358,
		166, 0, 6196, 6197, 5, 382, 0, 0, 6197, 6198, 5, 776, 0, 0, 6198, 6199,
		3, 1160, 580, 0, 6199, 6200, 5, 777, 0, 0, 6200, 6270, 1, 0, 0, 0, 6201,
		6202, 4, 358, 167, 0, 6202, 6203, 5, 406, 0, 0, 6203, 6270, 3, 770, 385,
		0, 6204, 6205, 5, 429, 0, 0, 6205, 6270, 3, 770, 385, 0, 6206, 6207, 5,
		457, 0, 0, 6207, 6208, 5, 776, 0, 0, 6208, 6209, 3, 676, 338, 0, 6209,
		6210, 5, 773, 0, 0, 6210, 6211, 3, 676, 338, 0, 6211, 6212, 5, 777, 0,
		0, 6212, 6270, 1, 0, 0, 0, 6213, 6214, 5, 458, 0, 0, 6214, 6215, 5, 776,
		0, 0, 6215, 6216, 3, 676, 338, 0, 6216, 6217, 5, 773, 0, 0, 6217, 6218,
		3, 676, 338, 0, 6218, 6219, 5, 773, 0, 0, 6219, 6220, 3, 676, 338, 0, 6220,
		6221, 5, 777, 0, 0, 6221, 6270, 1, 0, 0, 0, 6222, 6223, 5, 476, 0, 0, 6223,
		6270, 3, 770, 385, 0, 6224, 6225, 5, 485, 0, 0, 6225, 6270, 3, 1188, 594,
		0, 6226, 6227, 5, 597, 0, 0, 6227, 6228, 5, 776, 0, 0, 6228, 6229, 3, 676,
		338, 0, 6229, 6230, 5, 773, 0, 0, 6230, 6231, 3, 676, 338, 0, 6231, 6232,
		5, 777, 0, 0, 6232, 6270, 1, 0, 0, 0, 6233, 6234, 5, 640, 0, 0, 6234, 6235,
		5, 776, 0, 0, 6235, 6238, 3, 676, 338, 0, 6236, 6237, 5, 773, 0, 0, 6237,
		6239, 3, 676, 338, 0, 6238, 6236, 1, 0, 0, 0, 6238, 6239, 1, 0, 0, 0, 6239,
		6240, 1, 0, 0, 0, 6240, 6241, 5, 777, 0, 0, 6241, 6270, 1, 0, 0, 0, 6242,
		6243, 5, 641, 0, 0, 6243, 6244, 5, 776, 0, 0, 6244, 6264, 3, 676, 338,
		0, 6245, 6246, 5, 17, 0, 0, 6246, 6247, 5, 60, 0, 0, 6247, 6249, 3, 932,
		466, 0, 6248, 6245, 1, 0, 0, 0, 6248, 6249, 1, 0, 0, 0, 6249, 6252, 1,
		0, 0, 0, 6250, 6251, 4, 358, 168, 0, 6251, 6253, 3, 724, 362, 0, 6252,
		6250, 1, 0, 0, 0, 6252, 6253, 1, 0, 0, 0, 6253, 6265, 1, 0, 0, 0, 6254,
		6255, 5, 17, 0, 0, 6255, 6256, 5, 32, 0, 0, 6256, 6265, 3, 932, 466, 0,
		6257, 6258, 5, 773, 0, 0, 6258, 6259, 3, 1140, 570, 0, 6259, 6260, 5, 773,
		0, 0, 6260, 6261, 3, 1140, 570, 0, 6261, 6262, 5, 773, 0, 0, 6262, 6263,
		3, 1140, 570, 0, 6263, 6265, 1, 0, 0, 0, 6264, 6248, 1, 0, 0, 0, 6264,
		6254, 1, 0, 0, 0, 6264, 6257, 1, 0, 0, 0, 6265, 6266, 1, 0, 0, 0, 6266,
		6267, 5, 777, 0, 0, 6267, 6270, 1, 0, 0, 0, 6268, 6270, 3, 718, 359, 0,
		6269, 5996, 1, 0, 0, 0, 6269, 6005, 1, 0, 0, 0, 6269, 6009, 1, 0, 0, 0,
		6269, 6011, 1, 0, 0, 0, 6269, 6013, 1, 0, 0, 0, 6269, 6015, 1, 0, 0, 0,
		6269, 6026, 1, 0, 0, 0, 6269, 6037, 1, 0, 0, 0, 6269, 6044, 1, 0, 0, 0,
		6269, 6046, 1, 0, 0, 0, 6269, 6048, 1, 0, 0, 0, 6269, 6055, 1, 0, 0, 0,
		6269, 6057, 1, 0, 0, 0, 6269, 6059, 1, 0, 0, 0, 6269, 6068, 1, 0, 0, 0,
		6269, 6069, 1, 0, 0, 0, 6269, 6071, 1, 0, 0, 0, 6269, 6073, 1, 0, 0, 0,
		6269, 6075, 1, 0, 0, 0, 6269, 6088, 1, 0, 0, 0, 6269, 6092, 1, 0, 0, 0,
		6269, 6096, 1, 0, 0, 0, 6269, 6105, 1, 0, 0, 0, 6269, 6112, 1, 0, 0, 0,
		6269, 6119, 1, 0, 0, 0, 6269, 6123, 1, 0, 0, 0, 6269, 6130, 1, 0, 0, 0,
		6269, 6131, 1, 0, 0, 0, 6269, 6135, 1, 0, 0, 0, 6269, 6144, 1, 0, 0, 0,
		6269, 6148, 1, 0, 0, 0, 6269, 6152, 1, 0, 0, 0, 6269, 6156, 1, 0, 0, 0,
		6269, 6158, 1, 0, 0, 0, 6269, 6160, 1, 0, 0, 0, 6269, 6162, 1, 0, 0, 0,
		6269, 6164, 1, 0, 0, 0, 6269, 6166, 1, 0, 0, 0, 6269, 6175, 1, 0, 0, 0,
		6269, 6186, 1, 0, 0, 0, 6269, 6188, 1, 0, 0, 0, 6269, 6195, 1, 0, 0, 0,
		6269, 6201, 1, 0, 0, 0, 6269, 6204, 1, 0, 0, 0, 6269, 6206, 1, 0, 0, 0,
		6269, 6213, 1, 0, 0, 0, 6269, 6222, 1, 0, 0, 0, 6269, 6224, 1, 0, 0, 0,
		6269, 6226, 1, 0, 0, 0, 6269, 6233, 1, 0, 0, 0, 6269, 6242, 1, 0, 0, 0,
		6269, 6268, 1, 0, 0, 0, 6270, 717, 1, 0, 0, 0, 6271, 6272, 4, 359, 169,
		0, 6272, 6273, 5, 90, 0, 0, 6273, 6274, 5, 776, 0, 0, 6274, 6275, 3, 676,
		338, 0, 6275, 6276, 5, 773, 0, 0, 6276, 6277, 3, 676, 338, 0, 6277, 6278,
		5, 777, 0, 0, 6278, 6303, 1, 0, 0, 0, 6279, 6280, 5, 211, 0, 0, 6280, 6282,
		5, 776, 0, 0, 6281, 6283, 3, 756, 378, 0, 6282, 6281, 1, 0, 0, 0, 6282,
		6283, 1, 0, 0, 0, 6283, 6284, 1, 0, 0, 0, 6284, 6303, 5, 777, 0, 0, 6285,
		6286, 5, 279, 0, 0, 6286, 6303, 3, 768, 384, 0, 6287, 6288, 5, 351, 0,
		0, 6288, 6303, 3, 768, 384, 0, 6289, 6290, 5, 352, 0, 0, 6290, 6303, 3,
		768, 384, 0, 6291, 6292, 5, 353, 0, 0, 6292, 6303, 3, 768, 384, 0, 6293,
		6294, 5, 411, 0, 0, 6294, 6295, 5, 776, 0, 0, 6295, 6296, 3, 676, 338,
		0, 6296, 6297, 5, 773, 0, 0, 6297, 6298, 3, 676, 338, 0, 6298, 6299, 5,
		777, 0, 0, 6299, 6303, 1, 0, 0, 0, 6300, 6301, 5, 412, 0, 0, 6301, 6303,
		3, 768, 384, 0, 6302, 6271, 1, 0, 0, 0, 6302, 6279, 1, 0, 0, 0, 6302, 6285,
		1, 0, 0, 0, 6302, 6287, 1, 0, 0, 0, 6302, 6289, 1, 0, 0, 0, 6302, 6291,
		1, 0, 0, 0, 6302, 6293, 1, 0, 0, 0, 6302, 6300, 1, 0, 0, 0, 6303, 719,
		1, 0, 0, 0, 6304, 6306, 5, 776, 0, 0, 6305, 6307, 3, 722, 361, 0, 6306,
		6305, 1, 0, 0, 0, 6306, 6307, 1, 0, 0, 0, 6307, 6308, 1, 0, 0, 0, 6308,
		6309, 5, 777, 0, 0, 6309, 721, 1, 0, 0, 0, 6310, 6311, 4, 361, 170, 0,
		6311, 6312, 5, 747, 0, 0, 6312, 723, 1, 0, 0, 0, 6313, 6326, 5, 274, 0,
		0, 6314, 6315, 3, 1142, 571, 0, 6315, 6316, 5, 759, 0, 0, 6316, 6317, 3,
		1142, 571, 0, 6317, 6327, 1, 0, 0, 0, 6318, 6323, 3, 726, 363, 0, 6319,
		6320, 5, 773, 0, 0, 6320, 6322, 3, 726, 363, 0, 6321, 6319, 1, 0, 0, 0,
		6322, 6325, 1, 0, 0, 0, 6323, 6321, 1, 0, 0, 0, 6323, 6324, 1, 0, 0, 0,
		6324, 6327, 1, 0, 0, 0, 6325, 6323, 1, 0, 0, 0, 6326, 6314, 1, 0, 0, 0,
		6326, 6318, 1, 0, 0, 0, 6327, 725, 1, 0, 0, 0, 6328, 6334, 3, 1142, 571,
		0, 6329, 6331, 7, 33, 0, 0, 6330, 6332, 5, 476, 0, 0, 6331, 6330, 1, 0,
		0, 0, 6331, 6332, 1, 0, 0, 0, 6332, 6335, 1, 0, 0, 0, 6333, 6335, 5, 476,
		0, 0, 6334, 6329, 1, 0, 0, 0, 6334, 6333, 1, 0, 0, 0, 6334, 6335, 1, 0,
		0, 0, 6335, 727, 1, 0, 0, 0, 6336, 6337, 7, 95, 0, 0, 6337, 729, 1, 0,
		0, 0, 6338, 6339, 5, 595, 0, 0, 6339, 6363, 5, 776, 0, 0, 6340, 6343, 3,
		676, 338, 0, 6341, 6342, 5, 203, 0, 0, 6342, 6344, 3, 676, 338, 0, 6343,
		6341, 1, 0, 0, 0, 6343, 6344, 1, 0, 0, 0, 6344, 6364, 1, 0, 0, 0, 6345,
		6347, 5, 269, 0, 0, 6346, 6348, 3, 676, 338, 0, 6347, 6346, 1, 0, 0, 0,
		6347, 6348, 1, 0, 0, 0, 6348, 6349, 1, 0, 0, 0, 6349, 6350, 5, 203, 0,
		0, 6350, 6364, 3, 676, 338, 0, 6351, 6353, 5, 591, 0, 0, 6352, 6354, 3,
		676, 338, 0, 6353, 6352, 1, 0, 0, 0, 6353, 6354, 1, 0, 0, 0, 6354, 6355,
		1, 0, 0, 0, 6355, 6356, 5, 203, 0, 0, 6356, 6364, 3, 676, 338, 0, 6357,
		6359, 5, 43, 0, 0, 6358, 6360, 3, 676, 338, 0, 6359, 6358, 1, 0, 0, 0,
		6359, 6360, 1, 0, 0, 0, 6360, 6361, 1, 0, 0, 0, 6361, 6362, 5, 203, 0,
		0, 6362, 6364, 3, 676, 338, 0, 6363, 6340, 1, 0, 0, 0, 6363, 6345, 1, 0,
		0, 0, 6363, 6351, 1, 0, 0, 0, 6363, 6357, 1, 0, 0, 0, 6364, 6365, 1, 0,
		0, 0, 6365, 6366, 5, 777, 0, 0, 6366, 731, 1, 0, 0, 0, 6367, 6368, 5, 563,
		0, 0, 6368, 6369, 5, 776, 0, 0, 6369, 6382, 3, 676, 338, 0, 6370, 6371,
		5, 773, 0, 0, 6371, 6374, 3, 676, 338, 0, 6372, 6373, 5, 773, 0, 0, 6373,
		6375, 3, 676, 338, 0, 6374, 6372, 1, 0, 0, 0, 6374, 6375, 1, 0, 0, 0, 6375,
		6383, 1, 0, 0, 0, 6376, 6377, 5, 203, 0, 0, 6377, 6380, 3, 676, 338, 0,
		6378, 6379, 5, 200, 0, 0, 6379, 6381, 3, 676, 338, 0, 6380, 6378, 1, 0,
		0, 0, 6380, 6381, 1, 0, 0, 0, 6381, 6383, 1, 0, 0, 0, 6382, 6370, 1, 0,
		0, 0, 6382, 6376, 1, 0, 0, 0, 6383, 6384, 1, 0, 0, 0, 6384, 6385, 5, 777,
		0, 0, 6385, 733, 1, 0, 0, 0, 6386, 6387, 3, 1126, 563, 0, 6387, 6389, 5,
		776, 0, 0, 6388, 6390, 3, 736, 368, 0, 6389, 6388, 1, 0, 0, 0, 6389, 6390,
		1, 0, 0, 0, 6390, 6391, 1, 0, 0, 0, 6391, 6392, 5, 777, 0, 0, 6392, 6401,
		1, 0, 0, 0, 6393, 6394, 3, 1134, 567, 0, 6394, 6396, 5, 776, 0, 0, 6395,
		6397, 3, 756, 378, 0, 6396, 6395, 1, 0, 0, 0, 6396, 6397, 1, 0, 0, 0, 6397,
		6398, 1, 0, 0, 0, 6398, 6399, 5, 777, 0, 0, 6399, 6401, 1, 0, 0, 0, 6400,
		6386, 1, 0, 0, 0, 6400, 6393, 1, 0, 0, 0, 6401, 735, 1, 0, 0, 0, 6402,
		6407, 3, 738, 369, 0, 6403, 6404, 5, 773, 0, 0, 6404, 6406, 3, 738, 369,
		0, 6405, 6403, 1, 0, 0, 0, 6406, 6409, 1, 0, 0, 0, 6407, 6405, 1, 0, 0,
		0, 6407, 6408, 1, 0, 0, 0, 6408, 737, 1, 0, 0, 0, 6409, 6407, 1, 0, 0,
		0, 6410, 6412, 3, 676, 338, 0, 6411, 6413, 3, 356, 178, 0, 6412, 6411,
		1, 0, 0, 0, 6412, 6413, 1, 0, 0, 0, 6413, 739, 1, 0, 0, 0, 6414, 6417,
		3, 742, 371, 0, 6415, 6417, 3, 744, 372, 0, 6416, 6414, 1, 0, 0, 0, 6416,
		6415, 1, 0, 0, 0, 6417, 741, 1, 0, 0, 0, 6418, 6419, 5, 783, 0, 0, 6419,
		6422, 3, 1180, 590, 0, 6420, 6422, 5, 784, 0, 0, 6421, 6418, 1, 0, 0, 0,
		6421, 6420, 1, 0, 0, 0, 6422, 743, 1, 0, 0, 0, 6423, 6425, 5, 785, 0, 0,
		6424, 6426, 3, 1194, 597, 0, 6425, 6424, 1, 0, 0, 0, 6425, 6426, 1, 0,
		0, 0, 6426, 6427, 1, 0, 0, 0, 6427, 6429, 3, 1180, 590, 0, 6428, 6430,
		3, 1138, 569, 0, 6429, 6428, 1, 0, 0, 0, 6429, 6430, 1, 0, 0, 0, 6430,
		745, 1, 0, 0, 0, 6431, 6432, 4, 373, 171, 0, 6432, 6434, 3, 1128, 564,
		0, 6433, 6435, 3, 1138, 569, 0, 6434, 6433, 1, 0, 0, 0, 6434, 6435, 1,
		0, 0, 0, 6435, 6442, 1, 0, 0, 0, 6436, 6437, 4, 373, 172, 0, 6437, 6439,
		3, 1182, 591, 0, 6438, 6440, 3, 1138, 569, 0, 6439, 6438, 1, 0, 0, 0, 6439,
		6440, 1, 0, 0, 0, 6440, 6442, 1, 0, 0, 0, 6441, 6431, 1, 0, 0, 0, 6441,
		6436, 1, 0, 0, 0, 6442, 6446, 1, 0, 0, 0, 6443, 6444, 5, 128, 0, 0, 6444,
		6446, 3, 1138, 569, 0, 6445, 6441, 1, 0, 0, 0, 6445, 6443, 1, 0, 0, 0,
		6446, 747, 1, 0, 0, 0, 6447, 6448, 5, 642, 0, 0, 6448, 6449, 3, 676, 338,
		0, 6449, 749, 1, 0, 0, 0, 6450, 6451, 5, 582, 0, 0, 6451, 6452, 3, 676,
		338, 0, 6452, 751, 1, 0, 0, 0, 6453, 6454, 5, 154, 0, 0, 6454, 6455, 3,
		676, 338, 0, 6455, 753, 1, 0, 0, 0, 6456, 6458, 5, 32, 0, 0, 6457, 6459,
		3, 922, 461, 0, 6458, 6457, 1, 0, 0, 0, 6458, 6459, 1, 0, 0, 0, 6459, 6502,
		1, 0, 0, 0, 6460, 6462, 5, 60, 0, 0, 6461, 6463, 3, 922, 461, 0, 6462,
		6461, 1, 0, 0, 0, 6462, 6463, 1, 0, 0, 0, 6463, 6465, 1, 0, 0, 0, 6464,
		6466, 3, 926, 463, 0, 6465, 6464, 1, 0, 0, 0, 6465, 6466, 1, 0, 0, 0, 6466,
		6502, 1, 0, 0, 0, 6467, 6469, 3, 918, 459, 0, 6468, 6470, 3, 922, 461,
		0, 6469, 6468, 1, 0, 0, 0, 6469, 6470, 1, 0, 0, 0, 6470, 6502, 1, 0, 0,
		0, 6471, 6473, 5, 512, 0, 0, 6472, 6474, 5, 249, 0, 0, 6473, 6472, 1, 0,
		0, 0, 6473, 6474, 1, 0, 0, 0, 6474, 6502, 1, 0, 0, 0, 6475, 6477, 5, 612,
		0, 0, 6476, 6478, 5, 249, 0, 0, 6477, 6476, 1, 0, 0, 0, 6477, 6478, 1,
		0, 0, 0, 6478, 6502, 1, 0, 0, 0, 6479, 6502, 5, 116, 0, 0, 6480, 6482,
		5, 586, 0, 0, 6481, 6483, 3, 934, 467, 0, 6482, 6481, 1, 0, 0, 0, 6482,
		6483, 1, 0, 0, 0, 6483, 6502, 1, 0, 0, 0, 6484, 6486, 5, 113, 0, 0, 6485,
		6487, 3, 934, 467, 0, 6486, 6485, 1, 0, 0, 0, 6486, 6487, 1, 0, 0, 0, 6487,
		6502, 1, 0, 0, 0, 6488, 6490, 5, 126, 0, 0, 6489, 6491, 3, 1174, 587, 0,
		6490, 6489, 1, 0, 0, 0, 6490, 6491, 1, 0, 0, 0, 6491, 6502, 1, 0, 0, 0,
		6492, 6493, 4, 377, 173, 0, 6493, 6502, 5, 262, 0, 0, 6494, 6495, 4, 377,
		174, 0, 6495, 6502, 3, 920, 460, 0, 6496, 6497, 4, 377, 175, 0, 6497, 6499,
		5, 195, 0, 0, 6498, 6500, 3, 1176, 588, 0, 6499, 6498, 1, 0, 0, 0, 6499,
		6500, 1, 0, 0, 0, 6500, 6502, 1, 0, 0, 0, 6501, 6456, 1, 0, 0, 0, 6501,
		6460, 1, 0, 0, 0, 6501, 6467, 1, 0, 0, 0, 6501, 6471, 1, 0, 0, 0, 6501,
		6475, 1, 0, 0, 0, 6501, 6479, 1, 0, 0, 0, 6501, 6480, 1, 0, 0, 0, 6501,
		6484, 1, 0, 0, 0, 6501, 6488, 1, 0, 0, 0, 6501, 6492, 1, 0, 0, 0, 6501,
		6494, 1, 0, 0, 0, 6501, 6496, 1, 0, 0, 0, 6502, 755, 1, 0, 0, 0, 6503,
		6508, 3, 676, 338, 0, 6504, 6505, 5, 773, 0, 0, 6505, 6507, 3, 676, 338,
		0, 6506, 6504, 1, 0, 0, 0, 6507, 6510, 1, 0, 0, 0, 6508, 6506, 1, 0, 0,
		0, 6508, 6509, 1, 0, 0, 0, 6509, 757, 1, 0, 0, 0, 6510, 6508, 1, 0, 0,
		0, 6511, 6512, 5, 60, 0, 0, 6512, 6515, 5, 506, 0, 0, 6513, 6515, 5, 58,
		0, 0, 6514, 6511, 1, 0, 0, 0, 6514, 6513, 1, 0, 0, 0, 6515, 759, 1, 0,
		0, 0, 6516, 6517, 7, 96, 0, 0, 6517, 761, 1, 0, 0, 0, 6518, 6519, 7, 97,
		0, 0, 6519, 763, 1, 0, 0, 0, 6520, 6523, 3, 766, 383, 0, 6521, 6523, 7,
		98, 0, 0, 6522, 6520, 1, 0, 0, 0, 6522, 6521, 1, 0, 0, 0, 6523, 765, 1,
		0, 0, 0, 6524, 6525, 7, 99, 0, 0, 6525, 767, 1, 0, 0, 0, 6526, 6527, 5,
		776, 0, 0, 6527, 6528, 3, 756, 378, 0, 6528, 6529, 5, 777, 0, 0, 6529,
		769, 1, 0, 0, 0, 6530, 6531, 5, 776, 0, 0, 6531, 6532, 3, 676, 338, 0,
		6532, 6533, 5, 777, 0, 0, 6533, 771, 1, 0, 0, 0, 6534, 6535, 5, 776, 0,
		0, 6535, 6536, 3, 688, 344, 0, 6536, 6537, 5, 777, 0, 0, 6537, 773, 1,
		0, 0, 0, 6538, 6543, 3, 776, 388, 0, 6539, 6540, 5, 773, 0, 0, 6540, 6542,
		3, 776, 388, 0, 6541, 6539, 1, 0, 0, 0, 6542, 6545, 1, 0, 0, 0, 6543, 6541,
		1, 0, 0, 0, 6543, 6544, 1, 0, 0, 0, 6544, 775, 1, 0, 0, 0, 6545, 6543,
		1, 0, 0, 0, 6546, 6548, 3, 676, 338, 0, 6547, 6549, 3, 330, 165, 0, 6548,
		6547, 1, 0, 0, 0, 6548, 6549, 1, 0, 0, 0, 6549, 777, 1, 0, 0, 0, 6550,
		6555, 3, 780, 390, 0, 6551, 6552, 5, 773, 0, 0, 6552, 6554, 3, 780, 390,
		0, 6553, 6551, 1, 0, 0, 0, 6554, 6557, 1, 0, 0, 0, 6555, 6553, 1, 0, 0,
		0, 6555, 6556, 1, 0, 0, 0, 6556, 779, 1, 0, 0, 0, 6557, 6555, 1, 0, 0,
		0, 6558, 6559, 3, 676, 338, 0, 6559, 781, 1, 0, 0, 0, 6560, 6561, 4, 391,
		176, 0, 6561, 6562, 5, 200, 0, 0, 6562, 6563, 5, 57, 0, 0, 6563, 6564,
		3, 1162, 581, 0, 6564, 783, 1, 0, 0, 0, 6565, 6579, 3, 2, 1, 0, 6566, 6579,
		3, 786, 393, 0, 6567, 6579, 3, 788, 394, 0, 6568, 6579, 3, 796, 398, 0,
		6569, 6579, 3, 800, 400, 0, 6570, 6579, 3, 802, 401, 0, 6571, 6579, 3,
		808, 404, 0, 6572, 6579, 3, 810, 405, 0, 6573, 6579, 3, 838, 419, 0, 6574,
		6579, 3, 836, 418, 0, 6575, 6579, 3, 856, 428, 0, 6576, 6579, 3, 860, 430,
		0, 6577, 6579, 3, 858, 429, 0, 6578, 6565, 1, 0, 0, 0, 6578, 6566, 1, 0,
		0, 0, 6578, 6567, 1, 0, 0, 0, 6578, 6568, 1, 0, 0, 0, 6578, 6569, 1, 0,
		0, 0, 6578, 6570, 1, 0, 0, 0, 6578, 6571, 1, 0, 0, 0, 6578, 6572, 1, 0,
		0, 0, 6578, 6573, 1, 0, 0, 0, 6578, 6574, 1, 0, 0, 0, 6578, 6575, 1, 0,
		0, 0, 6578, 6576, 1, 0, 0, 0, 6578, 6577, 1, 0, 0, 0, 6579, 785, 1, 0,
		0, 0, 6580, 6581, 5, 475, 0, 0, 6581, 6582, 3, 676, 338, 0, 6582, 787,
		1, 0, 0, 0, 6583, 6584, 5, 231, 0, 0, 6584, 6585, 3, 790, 395, 0, 6585,
		6586, 5, 159, 0, 0, 6586, 6587, 5, 231, 0, 0, 6587, 789, 1, 0, 0, 0, 6588,
		6589, 3, 676, 338, 0, 6589, 6594, 3, 792, 396, 0, 6590, 6591, 5, 155, 0,
		0, 6591, 6595, 3, 790, 395, 0, 6592, 6593, 5, 154, 0, 0, 6593, 6595, 3,
		794, 397, 0, 6594, 6590, 1, 0, 0, 0, 6594, 6592, 1, 0, 0, 0, 6594, 6595,
		1, 0, 0, 0, 6595, 791, 1, 0, 0, 0, 6596, 6597, 5, 582, 0, 0, 6597, 6598,
		3, 794, 397, 0, 6598, 793, 1, 0, 0, 0, 6599, 6600, 3, 784, 392, 0, 6600,
		6601, 5, 774, 0, 0, 6601, 6603, 1, 0, 0, 0, 6602, 6599, 1, 0, 0, 0, 6603,
		6604, 1, 0, 0, 0, 6604, 6602, 1, 0, 0, 0, 6604, 6605, 1, 0, 0, 0, 6605,
		795, 1, 0, 0, 0, 6606, 6608, 5, 51, 0, 0, 6607, 6609, 3, 676, 338, 0, 6608,
		6607, 1, 0, 0, 0, 6608, 6609, 1, 0, 0, 0, 6609, 6613, 1, 0, 0, 0, 6610,
		6611, 3, 748, 374, 0, 6611, 6612, 3, 792, 396, 0, 6612, 6614, 1, 0, 0,
		0, 6613, 6610, 1, 0, 0, 0, 6614, 6615, 1, 0, 0, 0, 6615, 6613, 1, 0, 0,
		0, 6615, 6616, 1, 0, 0, 0, 6616, 6618, 1, 0, 0, 0, 6617, 6619, 3, 798,
		399, 0, 6618, 6617, 1, 0, 0, 0, 6618, 6619, 1, 0, 0, 0, 6619, 6620, 1,
		0, 0, 0, 6620, 6621, 5, 159, 0, 0, 6621, 6622, 5, 51, 0, 0, 6622, 797,
		1, 0, 0, 0, 6623, 6624, 5, 154, 0, 0, 6624, 6625, 3, 794, 397, 0, 6625,
		799, 1, 0, 0, 0, 6626, 6627, 3, 804, 402, 0, 6627, 6629, 3, 806, 403, 0,
		6628, 6630, 3, 1112, 556, 0, 6629, 6628, 1, 0, 0, 0, 6629, 6630, 1, 0,
		0, 0, 6630, 801, 1, 0, 0, 0, 6631, 6632, 3, 806, 403, 0, 6632, 803, 1,
		0, 0, 0, 6633, 6634, 3, 1110, 555, 0, 6634, 6635, 5, 775, 0, 0, 6635, 805,
		1, 0, 0, 0, 6636, 6638, 5, 29, 0, 0, 6637, 6639, 3, 818, 409, 0, 6638,
		6637, 1, 0, 0, 0, 6638, 6639, 1, 0, 0, 0, 6639, 6641, 1, 0, 0, 0, 6640,
		6642, 3, 794, 397, 0, 6641, 6640, 1, 0, 0, 0, 6641, 6642, 1, 0, 0, 0, 6642,
		6643, 1, 0, 0, 0, 6643, 6644, 5, 159, 0, 0, 6644, 807, 1, 0, 0, 0, 6645,
		6646, 3, 804, 402, 0, 6646, 6648, 3, 810, 405, 0, 6647, 6649, 3, 1112,
		556, 0, 6648, 6647, 1, 0, 0, 0, 6648, 6649, 1, 0, 0, 0, 6649, 809, 1, 0,
		0, 0, 6650, 6654, 3, 812, 406, 0, 6651, 6654, 3, 814, 407, 0, 6652, 6654,
		3, 816, 408, 0, 6653, 6650, 1, 0, 0, 0, 6653, 6651, 1, 0, 0, 0, 6653, 6652,
		1, 0, 0, 0, 6654, 811, 1, 0, 0, 0, 6655, 6656, 5, 294, 0, 0, 6656, 6657,
		3, 794, 397, 0, 6657, 6658, 5, 159, 0, 0, 6658, 6659, 5, 294, 0, 0, 6659,
		813, 1, 0, 0, 0, 6660, 6661, 5, 644, 0, 0, 6661, 6662, 3, 676, 338, 0,
		6662, 6663, 5, 147, 0, 0, 6663, 6664, 3, 794, 397, 0, 6664, 6665, 5, 159,
		0, 0, 6665, 6666, 5, 644, 0, 0, 6666, 815, 1, 0, 0, 0, 6667, 6668, 5, 457,
		0, 0, 6668, 6669, 3, 794, 397, 0, 6669, 6670, 5, 613, 0, 0, 6670, 6671,
		3, 676, 338, 0, 6671, 6672, 5, 159, 0, 0, 6672, 6673, 5, 457, 0, 0, 6673,
		817, 1, 0, 0, 0, 6674, 6675, 3, 820, 410, 0, 6675, 6676, 5, 774, 0, 0,
		6676, 6678, 1, 0, 0, 0, 6677, 6674, 1, 0, 0, 0, 6678, 6679, 1, 0, 0, 0,
		6679, 6677, 1, 0, 0, 0, 6679, 6680, 1, 0, 0, 0, 6680, 819, 1, 0, 0, 0,
		6681, 6686, 3, 822, 411, 0, 6682, 6686, 3, 824, 412, 0, 6683, 6686, 3,
		830, 415, 0, 6684, 6686, 3, 834, 417, 0, 6685, 6681, 1, 0, 0, 0, 6685,
		6682, 1, 0, 0, 0, 6685, 6683, 1, 0, 0, 0, 6685, 6684, 1, 0, 0, 0, 6686,
		821, 1, 0, 0, 0, 6687, 6688, 5, 127, 0, 0, 6688, 6689, 3, 1130, 565, 0,
		6689, 6691, 3, 916, 458, 0, 6690, 6692, 3, 986, 493, 0, 6691, 6690, 1,
		0, 0, 0, 6691, 6692, 1, 0, 0, 0, 6692, 6695, 1, 0, 0, 0, 6693, 6694, 5,
		128, 0, 0, 6694, 6696, 3, 676, 338, 0, 6695, 6693, 1, 0, 0, 0, 6695, 6696,
		1, 0, 0, 0, 6696, 823, 1, 0, 0, 0, 6697, 6698, 5, 127, 0, 0, 6698, 6699,
		3, 1128, 564, 0, 6699, 6700, 5, 83, 0, 0, 6700, 6701, 5, 200, 0, 0, 6701,
		6702, 3, 826, 413, 0, 6702, 825, 1, 0, 0, 0, 6703, 6706, 3, 1140, 570,
		0, 6704, 6706, 3, 828, 414, 0, 6705, 6703, 1, 0, 0, 0, 6705, 6704, 1, 0,
		0, 0, 6706, 827, 1, 0, 0, 0, 6707, 6709, 5, 526, 0, 0, 6708, 6710, 5, 627,
		0, 0, 6709, 6708, 1, 0, 0, 0, 6709, 6710, 1, 0, 0, 0, 6710, 6711, 1, 0,
		0, 0, 6711, 6712, 3, 1160, 580, 0, 6712, 829, 1, 0, 0, 0, 6713, 6714, 5,
		127, 0, 0, 6714, 6715, 7, 100, 0, 0, 6715, 6716, 5, 219, 0, 0, 6716, 6717,
		5, 200, 0, 0, 6717, 6722, 3, 832, 416, 0, 6718, 6719, 5, 773, 0, 0, 6719,
		6721, 3, 832, 416, 0, 6720, 6718, 1, 0, 0, 0, 6721, 6724, 1, 0, 0, 0, 6722,
		6720, 1, 0, 0, 0, 6722, 6723, 1, 0, 0, 0, 6723, 6725, 1, 0, 0, 0, 6724,
		6722, 1, 0, 0, 0, 6725, 6726, 3, 784, 392, 0, 6726, 831, 1, 0, 0, 0, 6727,
		6735, 3, 826, 413, 0, 6728, 6735, 3, 1128, 564, 0, 6729, 6735, 5, 527,
		0, 0, 6730, 6731, 3, 760, 380, 0, 6731, 6732, 5, 202, 0, 0, 6732, 6735,
		1, 0, 0, 0, 6733, 6735, 5, 525, 0, 0, 6734, 6727, 1, 0, 0, 0, 6734, 6728,
		1, 0, 0, 0, 6734, 6729, 1, 0, 0, 0, 6734, 6730, 1, 0, 0, 0, 6734, 6733,
		1, 0, 0, 0, 6735, 833, 1, 0, 0, 0, 6736, 6737, 5, 127, 0, 0, 6737, 6738,
		3, 1128, 564, 0, 6738, 6739, 5, 106, 0, 0, 6739, 6740, 5, 200, 0, 0, 6740,
		6741, 3, 266, 133, 0, 6741, 835, 1, 0, 0, 0, 6742, 6743, 5, 260, 0, 0,
		6743, 6744, 3, 1112, 556, 0, 6744, 837, 1, 0, 0, 0, 6745, 6746, 5, 271,
		0, 0, 6746, 6747, 3, 1112, 556, 0, 6747, 839, 1, 0, 0, 0, 6748, 6752, 5,
		207, 0, 0, 6749, 6753, 5, 101, 0, 0, 6750, 6751, 4, 420, 177, 0, 6751,
		6753, 5, 540, 0, 0, 6752, 6749, 1, 0, 0, 0, 6752, 6750, 1, 0, 0, 0, 6752,
		6753, 1, 0, 0, 0, 6753, 6754, 1, 0, 0, 0, 6754, 6773, 5, 138, 0, 0, 6755,
		6760, 3, 844, 422, 0, 6756, 6757, 5, 773, 0, 0, 6757, 6759, 3, 844, 422,
		0, 6758, 6756, 1, 0, 0, 0, 6759, 6762, 1, 0, 0, 0, 6760, 6758, 1, 0, 0,
		0, 6760, 6761, 1, 0, 0, 0, 6761, 6774, 1, 0, 0, 0, 6762, 6760, 1, 0, 0,
		0, 6763, 6764, 5, 83, 0, 0, 6764, 6765, 3, 842, 421, 0, 6765, 6770, 3,
		846, 423, 0, 6766, 6767, 5, 773, 0, 0, 6767, 6769, 3, 846, 423, 0, 6768,
		6766, 1, 0, 0, 0, 6769, 6772, 1, 0, 0, 0, 6770, 6768, 1, 0, 0, 0, 6770,
		6771, 1, 0, 0, 0, 6771, 6774, 1, 0, 0, 0, 6772, 6770, 1, 0, 0, 0, 6773,
		6755, 1, 0, 0, 0, 6773, 6763, 1, 0, 0, 0, 6774, 841, 1, 0, 0, 0, 6775,
		6779, 3, 1148, 574, 0, 6776, 6779, 3, 740, 370, 0, 6777, 6779, 3, 1134,
		567, 0, 6778, 6775, 1, 0, 0, 0, 6778, 6776, 1, 0, 0, 0, 6778, 6777, 1,
		0, 0, 0, 6779, 843, 1, 0, 0, 0, 6780, 6783, 3, 740, 370, 0, 6781, 6783,
		3, 1128, 564, 0, 6782, 6780, 1, 0, 0, 0, 6782, 6781, 1, 0, 0, 0, 6783,
		6784, 1, 0, 0, 0, 6784, 6785, 5, 750, 0, 0, 6785, 6786, 7, 101, 0, 0, 6786,
		845, 1, 0, 0, 0, 6787, 6790, 3, 740, 370, 0, 6788, 6790, 3, 1128, 564,
		0, 6789, 6787, 1, 0, 0, 0, 6789, 6788, 1, 0, 0, 0, 6790, 6791, 1, 0, 0,
		0, 6791, 6794, 5, 750, 0, 0, 6792, 6795, 3, 848, 424, 0, 6793, 6795, 5,
		473, 0, 0, 6794, 6792, 1, 0, 0, 0, 6794, 6793, 1, 0, 0, 0, 6795, 847, 1,
		0, 0, 0, 6796, 6797, 7, 102, 0, 0, 6797, 849, 1, 0, 0, 0, 6798, 6801, 5,
		511, 0, 0, 6799, 6802, 3, 1128, 564, 0, 6800, 6802, 3, 828, 414, 0, 6801,
		6799, 1, 0, 0, 0, 6801, 6800, 1, 0, 0, 0, 6802, 6812, 1, 0, 0, 0, 6803,
		6804, 5, 506, 0, 0, 6804, 6809, 3, 854, 427, 0, 6805, 6806, 5, 773, 0,
		0, 6806, 6808, 3, 854, 427, 0, 6807, 6805, 1, 0, 0, 0, 6808, 6811, 1, 0,
		0, 0, 6809, 6807, 1, 0, 0, 0, 6809, 6810, 1, 0, 0, 0, 6810, 6813, 1, 0,
		0, 0, 6811, 6809, 1, 0, 0, 0, 6812, 6803, 1, 0, 0, 0, 6812, 6813, 1, 0,
		0, 0, 6813, 851, 1, 0, 0, 0, 6814, 6817, 5, 469, 0, 0, 6815, 6818, 3, 1128,
		564, 0, 6816, 6818, 3, 828, 414, 0, 6817, 6815, 1, 0, 0, 0, 6817, 6816,
		1, 0, 0, 0, 6817, 6818, 1, 0, 0, 0, 6818, 6828, 1, 0, 0, 0, 6819, 6820,
		5, 506, 0, 0, 6820, 6825, 3, 854, 427, 0, 6821, 6822, 5, 773, 0, 0, 6822,
		6824, 3, 854, 427, 0, 6823, 6821, 1, 0, 0, 0, 6824, 6827, 1, 0, 0, 0, 6825,
		6823, 1, 0, 0, 0, 6825, 6826, 1, 0, 0, 0, 6826, 6829, 1, 0, 0, 0, 6827,
		6825, 1, 0, 0, 0, 6828, 6819, 1, 0, 0, 0, 6828, 6829, 1, 0, 0, 0, 6829,
		853, 1, 0, 0, 0, 6830, 6831, 3, 848, 424, 0, 6831, 6832, 5, 750, 0, 0,
		6832, 6833, 3, 842, 421, 0, 6833, 855, 1, 0, 0, 0, 6834, 6835, 5, 387,
		0, 0, 6835, 6836, 3, 1128, 564, 0, 6836, 857, 1, 0, 0, 0, 6837, 6838, 5,
		66, 0, 0, 6838, 6839, 3, 1128, 564, 0, 6839, 859, 1, 0, 0, 0, 6840, 6845,
		5, 186, 0, 0, 6841, 6843, 5, 367, 0, 0, 6842, 6841, 1, 0, 0, 0, 6842, 6843,
		1, 0, 0, 0, 6843, 6844, 1, 0, 0, 0, 6844, 6846, 5, 203, 0, 0, 6845, 6842,
		1, 0, 0, 0, 6845, 6846, 1, 0, 0, 0, 6846, 6847, 1, 0, 0, 0, 6847, 6848,
		3, 1128, 564, 0, 6848, 6849, 5, 248, 0, 0, 6849, 6850, 3, 1130, 565, 0,
		6850, 861, 1, 0, 0, 0, 6851, 6852, 5, 21, 0, 0, 6852, 6865, 3, 676, 338,
		0, 6853, 6854, 5, 171, 0, 0, 6854, 6855, 3, 676, 338, 0, 6855, 6858, 3,
		764, 382, 0, 6856, 6857, 5, 542, 0, 0, 6857, 6859, 3, 676, 338, 0, 6858,
		6856, 1, 0, 0, 0, 6858, 6859, 1, 0, 0, 0, 6859, 6862, 1, 0, 0, 0, 6860,
		6861, 5, 160, 0, 0, 6861, 6863, 3, 676, 338, 0, 6862, 6860, 1, 0, 0, 0,
		6862, 6863, 1, 0, 0, 0, 6863, 6865, 1, 0, 0, 0, 6864, 6851, 1, 0, 0, 0,
		6864, 6853, 1, 0, 0, 0, 6865, 863, 1, 0, 0, 0, 6866, 6867, 3, 1040, 520,
		0, 6867, 6869, 3, 876, 438, 0, 6868, 6870, 3, 866, 433, 0, 6869, 6868,
		1, 0, 0, 0, 6869, 6870, 1, 0, 0, 0, 6870, 865, 1, 0, 0, 0, 6871, 6872,
		4, 433, 178, 0, 6872, 6875, 3, 868, 434, 0, 6873, 6875, 3, 886, 443, 0,
		6874, 6871, 1, 0, 0, 0, 6874, 6873, 1, 0, 0, 0, 6875, 867, 1, 0, 0, 0,
		6876, 6877, 5, 62, 0, 0, 6877, 6878, 3, 770, 385, 0, 6878, 869, 1, 0, 0,
		0, 6879, 6881, 5, 371, 0, 0, 6880, 6879, 1, 0, 0, 0, 6880, 6881, 1, 0,
		0, 0, 6881, 6882, 1, 0, 0, 0, 6882, 6883, 5, 730, 0, 0, 6883, 871, 1, 0,
		0, 0, 6884, 6886, 7, 38, 0, 0, 6885, 6887, 3, 108, 54, 0, 6886, 6885, 1,
		0, 0, 0, 6886, 6887, 1, 0, 0, 0, 6887, 6888, 1, 0, 0, 0, 6888, 6892, 3,
		898, 449, 0, 6889, 6891, 3, 902, 451, 0, 6890, 6889, 1, 0, 0, 0, 6891,
		6894, 1, 0, 0, 0, 6892, 6890, 1, 0, 0, 0, 6892, 6893, 1, 0, 0, 0, 6893,
		6960, 1, 0, 0, 0, 6894, 6892, 1, 0, 0, 0, 6895, 6897, 5, 205, 0, 0, 6896,
		6898, 3, 406, 203, 0, 6897, 6896, 1, 0, 0, 0, 6897, 6898, 1, 0, 0, 0, 6898,
		6900, 1, 0, 0, 0, 6899, 6901, 3, 1050, 525, 0, 6900, 6899, 1, 0, 0, 0,
		6900, 6901, 1, 0, 0, 0, 6901, 6902, 1, 0, 0, 0, 6902, 6906, 3, 898, 449,
		0, 6903, 6905, 3, 910, 455, 0, 6904, 6903, 1, 0, 0, 0, 6905, 6908, 1, 0,
		0, 0, 6906, 6904, 1, 0, 0, 0, 6906, 6907, 1, 0, 0, 0, 6907, 6960, 1, 0,
		0, 0, 6908, 6906, 1, 0, 0, 0, 6909, 6911, 5, 523, 0, 0, 6910, 6912, 3,
		406, 203, 0, 6911, 6910, 1, 0, 0, 0, 6911, 6912, 1, 0, 0, 0, 6912, 6914,
		1, 0, 0, 0, 6913, 6915, 3, 1050, 525, 0, 6914, 6913, 1, 0, 0, 0, 6914,
		6915, 1, 0, 0, 0, 6915, 6916, 1, 0, 0, 0, 6916, 6920, 3, 898, 449, 0, 6917,
		6919, 3, 912, 456, 0, 6918, 6917, 1, 0, 0, 0, 6919, 6922, 1, 0, 0, 0, 6920,
		6918, 1, 0, 0, 0, 6920, 6921, 1, 0, 0, 0, 6921, 6960, 1, 0, 0, 0, 6922,
		6920, 1, 0, 0, 0, 6923, 6925, 3, 874, 437, 0, 6924, 6923, 1, 0, 0, 0, 6924,
		6925, 1, 0, 0, 0, 6925, 6957, 1, 0, 0, 0, 6926, 6927, 5, 420, 0, 0, 6927,
		6933, 5, 265, 0, 0, 6928, 6930, 5, 609, 0, 0, 6929, 6931, 3, 406, 203,
		0, 6930, 6929, 1, 0, 0, 0, 6930, 6931, 1, 0, 0, 0, 6931, 6933, 1, 0, 0,
		0, 6932, 6926, 1, 0, 0, 0, 6932, 6928, 1, 0, 0, 0, 6933, 6935, 1, 0, 0,
		0, 6934, 6936, 3, 108, 54, 0, 6935, 6934, 1, 0, 0, 0, 6935, 6936, 1, 0,
		0, 0, 6936, 6937, 1, 0, 0, 0, 6937, 6941, 3, 898, 449, 0, 6938, 6940, 3,
		902, 451, 0, 6939, 6938, 1, 0, 0, 0, 6940, 6943, 1, 0, 0, 0, 6941, 6939,
		1, 0, 0, 0, 6941, 6942, 1, 0, 0, 0, 6942, 6958, 1, 0, 0, 0, 6943, 6941,
		1, 0, 0, 0, 6944, 6945, 5, 199, 0, 0, 6945, 6947, 5, 265, 0, 0, 6946, 6948,
		3, 1050, 525, 0, 6947, 6946, 1, 0, 0, 0, 6947, 6948, 1, 0, 0, 0, 6948,
		6949, 1, 0, 0, 0, 6949, 6950, 3, 890, 445, 0, 6950, 6951, 3, 886, 443,
		0, 6951, 6958, 1, 0, 0, 0, 6952, 6955, 3, 868, 434, 0, 6953, 6954, 4, 436,
		179, 0, 6954, 6956, 3, 870, 435, 0, 6955, 6953, 1, 0, 0, 0, 6955, 6956,
		1, 0, 0, 0, 6956, 6958, 1, 0, 0, 0, 6957, 6932, 1, 0, 0, 0, 6957, 6944,
		1, 0, 0, 0, 6957, 6952, 1, 0, 0, 0, 6958, 6960, 1, 0, 0, 0, 6959, 6884,
		1, 0, 0, 0, 6959, 6895, 1, 0, 0, 0, 6959, 6909, 1, 0, 0, 0, 6959, 6924,
		1, 0, 0, 0, 6960, 873, 1, 0, 0, 0, 6961, 6963, 5, 86, 0, 0, 6962, 6964,
		3, 1128, 564, 0, 6963, 6962, 1, 0, 0, 0, 6963, 6964, 1, 0, 0, 0, 6964,
		875, 1, 0, 0, 0, 6965, 7001, 3, 916, 458, 0, 6966, 6968, 3, 878, 439, 0,
		6967, 6966, 1, 0, 0, 0, 6968, 6971, 1, 0, 0, 0, 6969, 6967, 1, 0, 0, 0,
		6969, 6970, 1, 0, 0, 0, 6970, 7002, 1, 0, 0, 0, 6971, 6969, 1, 0, 0, 0,
		6972, 6974, 4, 438, 180, 0, 6973, 6975, 3, 986, 493, 0, 6974, 6973, 1,
		0, 0, 0, 6974, 6975, 1, 0, 0, 0, 6975, 6978, 1, 0, 0, 0, 6976, 6977, 5,
		209, 0, 0, 6977, 6979, 5, 12, 0, 0, 6978, 6976, 1, 0, 0, 0, 6978, 6979,
		1, 0, 0, 0, 6979, 6980, 1, 0, 0, 0, 6980, 6981, 5, 17, 0, 0, 6981, 6983,
		3, 770, 385, 0, 6982, 6984, 7, 103, 0, 0, 6983, 6982, 1, 0, 0, 0, 6983,
		6984, 1, 0, 0, 0, 6984, 6999, 1, 0, 0, 0, 6985, 6989, 4, 438, 181, 0, 6986,
		6988, 3, 884, 442, 0, 6987, 6986, 1, 0, 0, 0, 6988, 6991, 1, 0, 0, 0, 6989,
		6987, 1, 0, 0, 0, 6989, 6990, 1, 0, 0, 0, 6990, 7000, 1, 0, 0, 0, 6991,
		6989, 1, 0, 0, 0, 6992, 6996, 4, 438, 182, 0, 6993, 6995, 3, 878, 439,
		0, 6994, 6993, 1, 0, 0, 0, 6995, 6998, 1, 0, 0, 0, 6996, 6994, 1, 0, 0,
		0, 6996, 6997, 1, 0, 0, 0, 6997, 7000, 1, 0, 0, 0, 6998, 6996, 1, 0, 0,
		0, 6999, 6985, 1, 0, 0, 0, 6999, 6992, 1, 0, 0, 0, 7000, 7002, 1, 0, 0,
		0, 7001, 6969, 1, 0, 0, 0, 7001, 6972, 1, 0, 0, 0, 7002, 877, 1, 0, 0,
		0, 7003, 7005, 5, 371, 0, 0, 7004, 7003, 1, 0, 0, 0, 7004, 7005, 1, 0,
		0, 0, 7005, 7006, 1, 0, 0, 0, 7006, 7056, 3, 1170, 585, 0, 7007, 7008,
		4, 439, 183, 0, 7008, 7009, 5, 371, 0, 0, 7009, 7056, 5, 720, 0, 0, 7010,
		7018, 5, 128, 0, 0, 7011, 7019, 3, 1150, 575, 0, 7012, 7014, 5, 372, 0,
		0, 7013, 7015, 3, 720, 360, 0, 7014, 7013, 1, 0, 0, 0, 7014, 7015, 1, 0,
		0, 0, 7015, 7019, 1, 0, 0, 0, 7016, 7017, 4, 439, 184, 0, 7017, 7019, 3,
		770, 385, 0, 7018, 7011, 1, 0, 0, 0, 7018, 7012, 1, 0, 0, 0, 7018, 7016,
		1, 0, 0, 0, 7019, 7056, 1, 0, 0, 0, 7020, 7021, 5, 383, 0, 0, 7021, 7022,
		5, 614, 0, 0, 7022, 7024, 5, 372, 0, 0, 7023, 7025, 3, 720, 360, 0, 7024,
		7023, 1, 0, 0, 0, 7024, 7025, 1, 0, 0, 0, 7025, 7056, 1, 0, 0, 0, 7026,
		7056, 5, 24, 0, 0, 7027, 7028, 5, 501, 0, 0, 7028, 7029, 5, 128, 0, 0,
		7029, 7056, 5, 627, 0, 0, 7030, 7032, 5, 420, 0, 0, 7031, 7030, 1, 0, 0,
		0, 7031, 7032, 1, 0, 0, 0, 7032, 7033, 1, 0, 0, 0, 7033, 7056, 5, 265,
		0, 0, 7034, 7036, 5, 609, 0, 0, 7035, 7037, 5, 265, 0, 0, 7036, 7035, 1,
		0, 0, 0, 7036, 7037, 1, 0, 0, 0, 7037, 7056, 1, 0, 0, 0, 7038, 7039, 5,
		75, 0, 0, 7039, 7056, 3, 1160, 580, 0, 7040, 7056, 3, 986, 493, 0, 7041,
		7042, 5, 74, 0, 0, 7042, 7056, 3, 880, 440, 0, 7043, 7044, 5, 553, 0, 0,
		7044, 7056, 3, 882, 441, 0, 7045, 7046, 4, 439, 185, 0, 7046, 7047, 5,
		707, 0, 0, 7047, 7056, 3, 1146, 573, 0, 7048, 7050, 4, 439, 186, 0, 7049,
		7051, 3, 874, 437, 0, 7050, 7049, 1, 0, 0, 0, 7050, 7051, 1, 0, 0, 0, 7051,
		7052, 1, 0, 0, 0, 7052, 7056, 3, 868, 434, 0, 7053, 7054, 4, 439, 187,
		0, 7054, 7056, 3, 870, 435, 0, 7055, 7004, 1, 0, 0, 0, 7055, 7007, 1, 0,
		0, 0, 7055, 7010, 1, 0, 0, 0, 7055, 7020, 1, 0, 0, 0, 7055, 7026, 1, 0,
		0, 0, 7055, 7027, 1, 0, 0, 0, 7055, 7031, 1, 0, 0, 0, 7055, 7034, 1, 0,
		0, 0, 7055, 7038, 1, 0, 0, 0, 7055, 7040, 1, 0, 0, 0, 7055, 7041, 1, 0,
		0, 0, 7055, 7043, 1, 0, 0, 0, 7055, 7045, 1, 0, 0, 0, 7055, 7048, 1, 0,
		0, 0, 7055, 7053, 1, 0, 0, 0, 7056, 879, 1, 0, 0, 0, 7057, 7058, 7, 104,
		0, 0, 7058, 881, 1, 0, 0, 0, 7059, 7060, 7, 105, 0, 0, 7060, 883, 1, 0,
		0, 0, 7061, 7063, 5, 609, 0, 0, 7062, 7064, 5, 265, 0, 0, 7063, 7062, 1,
		0, 0, 0, 7063, 7064, 1, 0, 0, 0, 7064, 7076, 1, 0, 0, 0, 7065, 7066, 5,
		75, 0, 0, 7066, 7076, 3, 1156, 578, 0, 7067, 7069, 3, 760, 380, 0, 7068,
		7067, 1, 0, 0, 0, 7068, 7069, 1, 0, 0, 0, 7069, 7070, 1, 0, 0, 0, 7070,
		7076, 5, 376, 0, 0, 7071, 7073, 5, 420, 0, 0, 7072, 7071, 1, 0, 0, 0, 7072,
		7073, 1, 0, 0, 0, 7073, 7074, 1, 0, 0, 0, 7074, 7076, 5, 265, 0, 0, 7075,
		7061, 1, 0, 0, 0, 7075, 7065, 1, 0, 0, 0, 7075, 7068, 1, 0, 0, 0, 7075,
		7072, 1, 0, 0, 0, 7076, 885, 1, 0, 0, 0, 7077, 7078, 5, 443, 0, 0, 7078,
		7080, 3, 1102, 551, 0, 7079, 7081, 3, 1132, 566, 0, 7080, 7079, 1, 0, 0,
		0, 7080, 7081, 1, 0, 0, 0, 7081, 7084, 1, 0, 0, 0, 7082, 7083, 5, 320,
		0, 0, 7083, 7085, 7, 106, 0, 0, 7084, 7082, 1, 0, 0, 0, 7084, 7085, 1,
		0, 0, 0, 7085, 7102, 1, 0, 0, 0, 7086, 7087, 5, 383, 0, 0, 7087, 7088,
		5, 614, 0, 0, 7088, 7092, 3, 888, 444, 0, 7089, 7090, 5, 383, 0, 0, 7090,
		7091, 5, 133, 0, 0, 7091, 7093, 3, 888, 444, 0, 7092, 7089, 1, 0, 0, 0,
		7092, 7093, 1, 0, 0, 0, 7093, 7103, 1, 0, 0, 0, 7094, 7095, 5, 383, 0,
		0, 7095, 7096, 5, 133, 0, 0, 7096, 7100, 3, 888, 444, 0, 7097, 7098, 5,
		383, 0, 0, 7098, 7099, 5, 614, 0, 0, 7099, 7101, 3, 888, 444, 0, 7100,
		7097, 1, 0, 0, 0, 7100, 7101, 1, 0, 0, 0, 7101, 7103, 1, 0, 0, 0, 7102,
		7086, 1, 0, 0, 0, 7102, 7094, 1, 0, 0, 0, 7102, 7103, 1, 0, 0, 0, 7103,
		887, 1, 0, 0, 0, 7104, 7110, 7, 2, 0, 0, 7105, 7106, 5, 506, 0, 0, 7106,
		7110, 3, 1170, 585, 0, 7107, 7108, 5, 373, 0, 0, 7108, 7110, 5, 3, 0, 0,
		7109, 7104, 1, 0, 0, 0, 7109, 7105, 1, 0, 0, 0, 7109, 7107, 1, 0, 0, 0,
		7110, 889, 1, 0, 0, 0, 7111, 7112, 5, 776, 0, 0, 7112, 7117, 3, 892, 446,
		0, 7113, 7114, 5, 773, 0, 0, 7114, 7116, 3, 892, 446, 0, 7115, 7113, 1,
		0, 0, 0, 7116, 7119, 1, 0, 0, 0, 7117, 7115, 1, 0, 0, 0, 7117, 7118, 1,
		0, 0, 0, 7118, 7120, 1, 0, 0, 0, 7119, 7117, 1, 0, 0, 0, 7120, 7121, 5,
		777, 0, 0, 7121, 891, 1, 0, 0, 0, 7122, 7124, 3, 1128, 564, 0, 7123, 7125,
		3, 922, 461, 0, 7124, 7123, 1, 0, 0, 0, 7124, 7125, 1, 0, 0, 0, 7125, 7127,
		1, 0, 0, 0, 7126, 7128, 3, 330, 165, 0, 7127, 7126, 1, 0, 0, 0, 7127, 7128,
		1, 0, 0, 0, 7128, 893, 1, 0, 0, 0, 7129, 7130, 5, 776, 0, 0, 7130, 7135,
		3, 896, 448, 0, 7131, 7132, 5, 773, 0, 0, 7132, 7134, 3, 896, 448, 0, 7133,
		7131, 1, 0, 0, 0, 7134, 7137, 1, 0, 0, 0, 7135, 7133, 1, 0, 0, 0, 7135,
		7136, 1, 0, 0, 0, 7136, 7138, 1, 0, 0, 0, 7137, 7135, 1, 0, 0, 0, 7138,
		7139, 5, 777, 0, 0, 7139, 895, 1, 0, 0, 0, 7140, 7146, 3, 892, 446, 0,
		7141, 7143, 3, 770, 385, 0, 7142, 7144, 3, 330, 165, 0, 7143, 7142, 1,
		0, 0, 0, 7143, 7144, 1, 0, 0, 0, 7144, 7146, 1, 0, 0, 0, 7145, 7140, 1,
		0, 0, 0, 7145, 7141, 1, 0, 0, 0, 7146, 897, 1, 0, 0, 0, 7147, 7148, 4,
		449, 188, 0, 7148, 7152, 3, 894, 447, 0, 7149, 7150, 4, 449, 189, 0, 7150,
		7152, 3, 890, 445, 0, 7151, 7147, 1, 0, 0, 0, 7151, 7149, 1, 0, 0, 0, 7152,
		899, 1, 0, 0, 0, 7153, 7154, 7, 107, 0, 0, 7154, 901, 1, 0, 0, 0, 7155,
		7158, 3, 904, 452, 0, 7156, 7158, 3, 908, 454, 0, 7157, 7155, 1, 0, 0,
		0, 7157, 7156, 1, 0, 0, 0, 7158, 903, 1, 0, 0, 0, 7159, 7161, 5, 264, 0,
		0, 7160, 7162, 5, 750, 0, 0, 7161, 7160, 1, 0, 0, 0, 7161, 7162, 1, 0,
		0, 0, 7162, 7163, 1, 0, 0, 0, 7163, 7169, 3, 1140, 570, 0, 7164, 7165,
		5, 75, 0, 0, 7165, 7169, 3, 1160, 580, 0, 7166, 7167, 4, 452, 190, 0, 7167,
		7169, 3, 906, 453, 0, 7168, 7159, 1, 0, 0, 0, 7168, 7164, 1, 0, 0, 0, 7168,
		7166, 1, 0, 0, 0, 7169, 905, 1, 0, 0, 0, 7170, 7171, 7, 108, 0, 0, 7171,
		907, 1, 0, 0, 0, 7172, 7173, 7, 109, 0, 0, 7173, 7174, 3, 900, 450, 0,
		7174, 909, 1, 0, 0, 0, 7175, 7180, 3, 904, 452, 0, 7176, 7177, 5, 645,
		0, 0, 7177, 7178, 5, 401, 0, 0, 7178, 7180, 3, 1128, 564, 0, 7179, 7175,
		1, 0, 0, 0, 7179, 7176, 1, 0, 0, 0, 7180, 911, 1, 0, 0, 0, 7181, 7182,
		3, 904, 452, 0, 7182, 913, 1, 0, 0, 0, 7183, 7184, 3, 916, 458, 0, 7184,
		7185, 5, 0, 0, 1, 7185, 915, 1, 0, 0, 0, 7186, 7188, 7, 110, 0, 0, 7187,
		7189, 3, 922, 461, 0, 7188, 7187, 1, 0, 0, 0, 7188, 7189, 1, 0, 0, 0, 7189,
		7191, 1, 0, 0, 0, 7190, 7192, 3, 924, 462, 0, 7191, 7190, 1, 0, 0, 0, 7191,
		7192, 1, 0, 0, 0, 7192, 7334, 1, 0, 0, 0, 7193, 7199, 5, 437, 0, 0, 7194,
		7196, 5, 146, 0, 0, 7195, 7197, 5, 416, 0, 0, 7196, 7195, 1, 0, 0, 0, 7196,
		7197, 1, 0, 0, 0, 7197, 7199, 1, 0, 0, 0, 7198, 7193, 1, 0, 0, 0, 7198,
		7194, 1, 0, 0, 0, 7199, 7201, 1, 0, 0, 0, 7200, 7202, 3, 1178, 589, 0,
		7201, 7200, 1, 0, 0, 0, 7201, 7202, 1, 0, 0, 0, 7202, 7204, 1, 0, 0, 0,
		7203, 7205, 3, 924, 462, 0, 7204, 7203, 1, 0, 0, 0, 7204, 7205, 1, 0, 0,
		0, 7205, 7334, 1, 0, 0, 0, 7206, 7208, 7, 111, 0, 0, 7207, 7209, 3, 1174,
		587, 0, 7208, 7207, 1, 0, 0, 0, 7208, 7209, 1, 0, 0, 0, 7209, 7211, 1,
		0, 0, 0, 7210, 7212, 3, 924, 462, 0, 7211, 7210, 1, 0, 0, 0, 7211, 7212,
		1, 0, 0, 0, 7212, 7334, 1, 0, 0, 0, 7213, 7215, 5, 37, 0, 0, 7214, 7216,
		3, 922, 461, 0, 7215, 7214, 1, 0, 0, 0, 7215, 7216, 1, 0, 0, 0, 7216, 7334,
		1, 0, 0, 0, 7217, 7334, 7, 112, 0, 0, 7218, 7220, 5, 60, 0, 0, 7219, 7221,
		3, 922, 461, 0, 7220, 7219, 1, 0, 0, 0, 7220, 7221, 1, 0, 0, 0, 7221, 7223,
		1, 0, 0, 0, 7222, 7224, 3, 926, 463, 0, 7223, 7222, 1, 0, 0, 0, 7223, 7224,
		1, 0, 0, 0, 7224, 7334, 1, 0, 0, 0, 7225, 7227, 3, 918, 459, 0, 7226, 7228,
		3, 922, 461, 0, 7227, 7226, 1, 0, 0, 0, 7227, 7228, 1, 0, 0, 0, 7228, 7230,
		1, 0, 0, 0, 7229, 7231, 5, 32, 0, 0, 7230, 7229, 1, 0, 0, 0, 7230, 7231,
		1, 0, 0, 0, 7231, 7334, 1, 0, 0, 0, 7232, 7234, 5, 32, 0, 0, 7233, 7235,
		3, 922, 461, 0, 7234, 7233, 1, 0, 0, 0, 7234, 7235, 1, 0, 0, 0, 7235, 7334,
		1, 0, 0, 0, 7236, 7237, 5, 60, 0, 0, 7237, 7240, 5, 633, 0, 0, 7238, 7240,
		5, 629, 0, 0, 7239, 7236, 1, 0, 0, 0, 7239, 7238, 1, 0, 0, 0, 7240, 7241,
		1, 0, 0, 0, 7241, 7243, 3, 922, 461, 0, 7242, 7244, 3, 926, 463, 0, 7243,
		7242, 1, 0, 0, 0, 7243, 7244, 1, 0, 0, 0, 7244, 7334, 1, 0, 0, 0, 7245,
		7246, 5, 358, 0, 0, 7246, 7256, 5, 629, 0, 0, 7247, 7256, 5, 379, 0, 0,
		7248, 7249, 5, 361, 0, 0, 7249, 7256, 5, 629, 0, 0, 7250, 7251, 5, 358,
		0, 0, 7251, 7252, 5, 60, 0, 0, 7252, 7256, 5, 633, 0, 0, 7253, 7254, 5,
		361, 0, 0, 7254, 7256, 5, 633, 0, 0, 7255, 7245, 1, 0, 0, 0, 7255, 7247,
		1, 0, 0, 0, 7255, 7248, 1, 0, 0, 0, 7255, 7250, 1, 0, 0, 0, 7255, 7253,
		1, 0, 0, 0, 7256, 7257, 1, 0, 0, 0, 7257, 7259, 3, 922, 461, 0, 7258, 7260,
		5, 32, 0, 0, 7259, 7258, 1, 0, 0, 0, 7259, 7260, 1, 0, 0, 0, 7260, 7334,
		1, 0, 0, 0, 7261, 7262, 5, 628, 0, 0, 7262, 7334, 3, 922, 461, 0, 7263,
		7265, 5, 656, 0, 0, 7264, 7266, 3, 922, 461, 0, 7265, 7264, 1, 0, 0, 0,
		7265, 7266, 1, 0, 0, 0, 7266, 7268, 1, 0, 0, 0, 7267, 7269, 3, 924, 462,
		0, 7268, 7267, 1, 0, 0, 0, 7268, 7269, 1, 0, 0, 0, 7269, 7334, 1, 0, 0,
		0, 7270, 7334, 5, 116, 0, 0, 7271, 7273, 5, 586, 0, 0, 7272, 7274, 3, 934,
		467, 0, 7273, 7272, 1, 0, 0, 0, 7273, 7274, 1, 0, 0, 0, 7274, 7334, 1,
		0, 0, 0, 7275, 7277, 5, 583, 0, 0, 7276, 7278, 3, 934, 467, 0, 7277, 7276,
		1, 0, 0, 0, 7277, 7278, 1, 0, 0, 0, 7278, 7334, 1, 0, 0, 0, 7279, 7281,
		5, 113, 0, 0, 7280, 7282, 3, 934, 467, 0, 7281, 7280, 1, 0, 0, 0, 7281,
		7282, 1, 0, 0, 0, 7282, 7334, 1, 0, 0, 0, 7283, 7334, 5, 587, 0, 0, 7284,
		7286, 5, 39, 0, 0, 7285, 7287, 3, 922, 461, 0, 7286, 7285, 1, 0, 0, 0,
		7286, 7287, 1, 0, 0, 0, 7287, 7334, 1, 0, 0, 0, 7288, 7334, 7, 113, 0,
		0, 7289, 7290, 5, 293, 0, 0, 7290, 7334, 5, 628, 0, 0, 7291, 7295, 5, 293,
		0, 0, 7292, 7293, 5, 60, 0, 0, 7293, 7296, 5, 633, 0, 0, 7294, 7296, 5,
		629, 0, 0, 7295, 7292, 1, 0, 0, 0, 7295, 7294, 1, 0, 0, 0, 7295, 7296,
		1, 0, 0, 0, 7296, 7298, 1, 0, 0, 0, 7297, 7299, 3, 926, 463, 0, 7298, 7297,
		1, 0, 0, 0, 7298, 7299, 1, 0, 0, 0, 7299, 7334, 1, 0, 0, 0, 7300, 7302,
		5, 589, 0, 0, 7301, 7303, 3, 926, 463, 0, 7302, 7301, 1, 0, 0, 0, 7302,
		7303, 1, 0, 0, 0, 7303, 7334, 1, 0, 0, 0, 7304, 7306, 5, 580, 0, 0, 7305,
		7307, 3, 922, 461, 0, 7306, 7305, 1, 0, 0, 0, 7306, 7307, 1, 0, 0, 0, 7307,
		7309, 1, 0, 0, 0, 7308, 7310, 3, 926, 463, 0, 7309, 7308, 1, 0, 0, 0, 7309,
		7310, 1, 0, 0, 0, 7310, 7334, 1, 0, 0, 0, 7311, 7313, 5, 332, 0, 0, 7312,
		7314, 3, 926, 463, 0, 7313, 7312, 1, 0, 0, 0, 7313, 7314, 1, 0, 0, 0, 7314,
		7334, 1, 0, 0, 0, 7315, 7317, 5, 291, 0, 0, 7316, 7318, 3, 926, 463, 0,
		7317, 7316, 1, 0, 0, 0, 7317, 7318, 1, 0, 0, 0, 7318, 7334, 1, 0, 0, 0,
		7319, 7320, 5, 164, 0, 0, 7320, 7322, 3, 1152, 576, 0, 7321, 7323, 3, 926,
		463, 0, 7322, 7321, 1, 0, 0, 0, 7322, 7323, 1, 0, 0, 0, 7323, 7334, 1,
		0, 0, 0, 7324, 7325, 5, 506, 0, 0, 7325, 7327, 3, 1152, 576, 0, 7326, 7328,
		3, 926, 463, 0, 7327, 7326, 1, 0, 0, 0, 7327, 7328, 1, 0, 0, 0, 7328, 7334,
		1, 0, 0, 0, 7329, 7334, 5, 501, 0, 0, 7330, 7331, 4, 458, 191, 0, 7331,
		7334, 5, 262, 0, 0, 7332, 7334, 7, 114, 0, 0, 7333, 7186, 1, 0, 0, 0, 7333,
		7198, 1, 0, 0, 0, 7333, 7206, 1, 0, 0, 0, 7333, 7213, 1, 0, 0, 0, 7333,
		7217, 1, 0, 0, 0, 7333, 7218, 1, 0, 0, 0, 7333, 7225, 1, 0, 0, 0, 7333,
		7232, 1, 0, 0, 0, 7333, 7239, 1, 0, 0, 0, 7333, 7255, 1, 0, 0, 0, 7333,
		7261, 1, 0, 0, 0, 7333, 7263, 1, 0, 0, 0, 7333, 7270, 1, 0, 0, 0, 7333,
		7271, 1, 0, 0, 0, 7333, 7275, 1, 0, 0, 0, 7333, 7279, 1, 0, 0, 0, 7333,
		7283, 1, 0, 0, 0, 7333, 7284, 1, 0, 0, 0, 7333, 7288, 1, 0, 0, 0, 7333,
		7289, 1, 0, 0, 0, 7333, 7291, 1, 0, 0, 0, 7333, 7300, 1, 0, 0, 0, 7333,
		7304, 1, 0, 0, 0, 7333, 7311, 1, 0, 0, 0, 7333, 7315, 1, 0, 0, 0, 7333,
		7319, 1, 0, 0, 0, 7333, 7324, 1, 0, 0, 0, 7333, 7329, 1, 0, 0, 0, 7333,
		7330, 1, 0, 0, 0, 7333, 7332, 1, 0, 0, 0, 7334, 917, 1, 0, 0, 0, 7335,
		7339, 5, 361, 0, 0, 7336, 7337, 5, 358, 0, 0, 7337, 7339, 5, 60, 0, 0,
		7338, 7335, 1, 0, 0, 0, 7338, 7336, 1, 0, 0, 0, 7339, 919, 1, 0, 0, 0,
		7340, 7346, 5, 437, 0, 0, 7341, 7343, 5, 146, 0, 0, 7342, 7344, 5, 416,
		0, 0, 7343, 7342, 1, 0, 0, 0, 7343, 7344, 1, 0, 0, 0, 7344, 7346, 1, 0,
		0, 0, 7345, 7340, 1, 0, 0, 0, 7345, 7341, 1, 0, 0, 0, 7346, 921, 1, 0,
		0, 0, 7347, 7350, 5, 776, 0, 0, 7348, 7351, 3, 1146, 573, 0, 7349, 7351,
		5, 790, 0, 0, 7350, 7348, 1, 0, 0, 0, 7350, 7349, 1, 0, 0, 0, 7351, 7352,
		1, 0, 0, 0, 7352, 7353, 5, 777, 0, 0, 7353, 923, 1, 0, 0, 0, 7354, 7356,
		7, 115, 0, 0, 7355, 7354, 1, 0, 0, 0, 7356, 7357, 1, 0, 0, 0, 7357, 7355,
		1, 0, 0, 0, 7357, 7358, 1, 0, 0, 0, 7358, 925, 1, 0, 0, 0, 7359, 7374,
		3, 928, 464, 0, 7360, 7374, 3, 930, 465, 0, 7361, 7374, 5, 46, 0, 0, 7362,
		7363, 3, 758, 379, 0, 7363, 7365, 3, 936, 468, 0, 7364, 7366, 5, 32, 0,
		0, 7365, 7364, 1, 0, 0, 0, 7365, 7366, 1, 0, 0, 0, 7366, 7374, 1, 0, 0,
		0, 7367, 7371, 5, 32, 0, 0, 7368, 7369, 3, 758, 379, 0, 7369, 7370, 3,
		936, 468, 0, 7370, 7372, 1, 0, 0, 0, 7371, 7368, 1, 0, 0, 0, 7371, 7372,
		1, 0, 0, 0, 7372, 7374, 1, 0, 0, 0, 7373, 7359, 1, 0, 0, 0, 7373, 7360,
		1, 0, 0, 0, 7373, 7361, 1, 0, 0, 0, 7373, 7362, 1, 0, 0, 0, 7373, 7367,
		1, 0, 0, 0, 7374, 927, 1, 0, 0, 0, 7375, 7377, 5, 19, 0, 0, 7376, 7378,
		5, 32, 0, 0, 7377, 7376, 1, 0, 0, 0, 7377, 7378, 1, 0, 0, 0, 7378, 7382,
		1, 0, 0, 0, 7379, 7380, 5, 32, 0, 0, 7380, 7382, 5, 19, 0, 0, 7381, 7375,
		1, 0, 0, 0, 7381, 7379, 1, 0, 0, 0, 7382, 929, 1, 0, 0, 0, 7383, 7385,
		5, 606, 0, 0, 7384, 7386, 5, 32, 0, 0, 7385, 7384, 1, 0, 0, 0, 7385, 7386,
		1, 0, 0, 0, 7386, 7390, 1, 0, 0, 0, 7387, 7388, 5, 32, 0, 0, 7388, 7390,
		5, 606, 0, 0, 7389, 7383, 1, 0, 0, 0, 7389, 7387, 1, 0, 0, 0, 7390, 931,
		1, 0, 0, 0, 7391, 7392, 5, 776, 0, 0, 7392, 7393, 3, 1142, 571, 0, 7393,
		7394, 5, 777, 0, 0, 7394, 933, 1, 0, 0, 0, 7395, 7396, 5, 776, 0, 0, 7396,
		7397, 5, 747, 0, 0, 7397, 7398, 5, 777, 0, 0, 7398, 935, 1, 0, 0, 0, 7399,
		7404, 3, 1180, 590, 0, 7400, 7404, 5, 32, 0, 0, 7401, 7402, 4, 468, 192,
		0, 7402, 7404, 5, 128, 0, 0, 7403, 7399, 1, 0, 0, 0, 7403, 7400, 1, 0,
		0, 0, 7403, 7401, 1, 0, 0, 0, 7404, 937, 1, 0, 0, 0, 7405, 7411, 3, 1180,
		590, 0, 7406, 7407, 4, 469, 193, 0, 7407, 7411, 5, 128, 0, 0, 7408, 7409,
		4, 469, 194, 0, 7409, 7411, 5, 32, 0, 0, 7410, 7405, 1, 0, 0, 0, 7410,
		7406, 1, 0, 0, 0, 7410, 7408, 1, 0, 0, 0, 7411, 939, 1, 0, 0, 0, 7412,
		7419, 3, 944, 472, 0, 7413, 7415, 5, 773, 0, 0, 7414, 7413, 1, 0, 0, 0,
		7414, 7415, 1, 0, 0, 0, 7415, 7416, 1, 0, 0, 0, 7416, 7418, 3, 944, 472,
		0, 7417, 7414, 1, 0, 0, 0, 7418, 7421, 1, 0, 0, 0, 7419, 7417, 1, 0, 0,
		0, 7419, 7420, 1, 0, 0, 0, 7420, 941, 1, 0, 0, 0, 7421, 7419, 1, 0, 0,
		0, 7422, 7424, 3, 944, 472, 0, 7423, 7422, 1, 0, 0, 0, 7424, 7425, 1, 0,
		0, 0, 7425, 7423, 1, 0, 0, 0, 7425, 7426, 1, 0, 0, 0, 7426, 943, 1, 0,
		0, 0, 7427, 7429, 5, 163, 0, 0, 7428, 7430, 5, 750, 0, 0, 7429, 7428, 1,
		0, 0, 0, 7429, 7430, 1, 0, 0, 0, 7430, 7431, 1, 0, 0, 0, 7431, 7557, 3,
		1094, 547, 0, 7432, 7433, 4, 472, 195, 0, 7433, 7435, 5, 721, 0, 0, 7434,
		7436, 3, 1190, 595, 0, 7435, 7434, 1, 0, 0, 0, 7435, 7436, 1, 0, 0, 0,
		7436, 7439, 1, 0, 0, 0, 7437, 7440, 5, 376, 0, 0, 7438, 7440, 3, 1180,
		590, 0, 7439, 7437, 1, 0, 0, 0, 7439, 7438, 1, 0, 0, 0, 7440, 7557, 1,
		0, 0, 0, 7441, 7443, 5, 323, 0, 0, 7442, 7444, 5, 750, 0, 0, 7443, 7442,
		1, 0, 0, 0, 7443, 7444, 1, 0, 0, 0, 7444, 7445, 1, 0, 0, 0, 7445, 7557,
		3, 1144, 572, 0, 7446, 7448, 5, 344, 0, 0, 7447, 7449, 5, 750, 0, 0, 7448,
		7447, 1, 0, 0, 0, 7448, 7449, 1, 0, 0, 0, 7449, 7450, 1, 0, 0, 0, 7450,
		7557, 3, 1144, 572, 0, 7451, 7453, 5, 25, 0, 0, 7452, 7454, 5, 750, 0,
		0, 7453, 7452, 1, 0, 0, 0, 7453, 7454, 1, 0, 0, 0, 7454, 7455, 1, 0, 0,
		0, 7455, 7557, 3, 1140, 570, 0, 7456, 7458, 5, 406, 0, 0, 7457, 7459, 5,
		750, 0, 0, 7458, 7457, 1, 0, 0, 0, 7458, 7459, 1, 0, 0, 0, 7459, 7460,
		1, 0, 0, 0, 7460, 7557, 3, 1154, 577, 0, 7461, 7463, 5, 75, 0, 0, 7462,
		7464, 5, 750, 0, 0, 7463, 7462, 1, 0, 0, 0, 7463, 7464, 1, 0, 0, 0, 7464,
		7465, 1, 0, 0, 0, 7465, 7557, 3, 1154, 577, 0, 7466, 7467, 4, 472, 196,
		0, 7467, 7469, 5, 81, 0, 0, 7468, 7470, 5, 750, 0, 0, 7469, 7468, 1, 0,
		0, 0, 7469, 7470, 1, 0, 0, 0, 7470, 7471, 1, 0, 0, 0, 7471, 7557, 3, 1156,
		578, 0, 7472, 7473, 4, 472, 197, 0, 7473, 7475, 5, 158, 0, 0, 7474, 7476,
		5, 750, 0, 0, 7475, 7474, 1, 0, 0, 0, 7475, 7476, 1, 0, 0, 0, 7476, 7477,
		1, 0, 0, 0, 7477, 7557, 3, 1156, 578, 0, 7478, 7480, 5, 24, 0, 0, 7479,
		7481, 5, 750, 0, 0, 7480, 7479, 1, 0, 0, 0, 7480, 7481, 1, 0, 0, 0, 7481,
		7482, 1, 0, 0, 0, 7482, 7557, 3, 1144, 572, 0, 7483, 7485, 5, 399, 0, 0,
		7484, 7486, 5, 750, 0, 0, 7485, 7484, 1, 0, 0, 0, 7485, 7486, 1, 0, 0,
		0, 7486, 7487, 1, 0, 0, 0, 7487, 7557, 3, 946, 473, 0, 7488, 7490, 7, 116,
		0, 0, 7489, 7491, 5, 750, 0, 0, 7490, 7489, 1, 0, 0, 0, 7490, 7491, 1,
		0, 0, 0, 7491, 7492, 1, 0, 0, 0, 7492, 7557, 3, 946, 473, 0, 7493, 7495,
		7, 117, 0, 0, 7494, 7496, 5, 750, 0, 0, 7495, 7494, 1, 0, 0, 0, 7495, 7496,
		1, 0, 0, 0, 7496, 7497, 1, 0, 0, 0, 7497, 7557, 3, 1140, 570, 0, 7498,
		7500, 5, 132, 0, 0, 7499, 7501, 5, 750, 0, 0, 7500, 7499, 1, 0, 0, 0, 7500,
		7501, 1, 0, 0, 0, 7501, 7502, 1, 0, 0, 0, 7502, 7557, 3, 1140, 570, 0,
		7503, 7505, 5, 486, 0, 0, 7504, 7506, 5, 750, 0, 0, 7505, 7504, 1, 0, 0,
		0, 7505, 7506, 1, 0, 0, 0, 7506, 7507, 1, 0, 0, 0, 7507, 7557, 7, 118,
		0, 0, 7508, 7510, 5, 608, 0, 0, 7509, 7511, 5, 750, 0, 0, 7510, 7509, 1,
		0, 0, 0, 7510, 7511, 1, 0, 0, 0, 7511, 7512, 1, 0, 0, 0, 7512, 7513, 5,
		776, 0, 0, 7513, 7514, 3, 1104, 552, 0, 7514, 7515, 5, 777, 0, 0, 7515,
		7557, 1, 0, 0, 0, 7516, 7557, 3, 952, 476, 0, 7517, 7557, 3, 948, 474,
		0, 7518, 7520, 5, 243, 0, 0, 7519, 7521, 5, 750, 0, 0, 7520, 7519, 1, 0,
		0, 0, 7520, 7521, 1, 0, 0, 0, 7521, 7522, 1, 0, 0, 0, 7522, 7557, 7, 119,
		0, 0, 7523, 7524, 5, 112, 0, 0, 7524, 7526, 5, 139, 0, 0, 7525, 7527, 5,
		750, 0, 0, 7526, 7525, 1, 0, 0, 0, 7526, 7527, 1, 0, 0, 0, 7527, 7528,
		1, 0, 0, 0, 7528, 7557, 3, 1156, 578, 0, 7529, 7530, 5, 236, 0, 0, 7530,
		7532, 5, 139, 0, 0, 7531, 7533, 5, 750, 0, 0, 7532, 7531, 1, 0, 0, 0, 7532,
		7533, 1, 0, 0, 0, 7533, 7534, 1, 0, 0, 0, 7534, 7557, 3, 1156, 578, 0,
		7535, 7541, 5, 572, 0, 0, 7536, 7538, 4, 472, 198, 0, 7537, 7539, 5, 750,
		0, 0, 7538, 7537, 1, 0, 0, 0, 7538, 7539, 1, 0, 0, 0, 7539, 7542, 1, 0,
		0, 0, 7540, 7542, 1, 0, 0, 0, 7541, 7536, 1, 0, 0, 0, 7541, 7540, 1, 0,
		0, 0, 7542, 7543, 1, 0, 0, 0, 7543, 7557, 3, 1128, 564, 0, 7544, 7545,
		5, 553, 0, 0, 7545, 7557, 7, 120, 0, 0, 7546, 7548, 5, 84, 0, 0, 7547,
		7549, 5, 750, 0, 0, 7548, 7547, 1, 0, 0, 0, 7548, 7549, 1, 0, 0, 0, 7549,
		7550, 1, 0, 0, 0, 7550, 7557, 3, 1156, 578, 0, 7551, 7553, 5, 264, 0, 0,
		7552, 7554, 5, 750, 0, 0, 7553, 7552, 1, 0, 0, 0, 7553, 7554, 1, 0, 0,
		0, 7554, 7555, 1, 0, 0, 0, 7555, 7557, 3, 1140, 570, 0, 7556, 7427, 1,
		0, 0, 0, 7556, 7432, 1, 0, 0, 0, 7556, 7441, 1, 0, 0, 0, 7556, 7446, 1,
		0, 0, 0, 7556, 7451, 1, 0, 0, 0, 7556, 7456, 1, 0, 0, 0, 7556, 7461, 1,
		0, 0, 0, 7556, 7466, 1, 0, 0, 0, 7556, 7472, 1, 0, 0, 0, 7556, 7478, 1,
		0, 0, 0, 7556, 7483, 1, 0, 0, 0, 7556, 7488, 1, 0, 0, 0, 7556, 7493, 1,
		0, 0, 0, 7556, 7498, 1, 0, 0, 0, 7556, 7503, 1, 0, 0, 0, 7556, 7508, 1,
		0, 0, 0, 7556, 7516, 1, 0, 0, 0, 7556, 7517, 1, 0, 0, 0, 7556, 7518, 1,
		0, 0, 0, 7556, 7523, 1, 0, 0, 0, 7556, 7529, 1, 0, 0, 0, 7556, 7535, 1,
		0, 0, 0, 7556, 7544, 1, 0, 0, 0, 7556, 7546, 1, 0, 0, 0, 7556, 7551, 1,
		0, 0, 0, 7557, 945, 1, 0, 0, 0, 7558, 7561, 3, 1140, 570, 0, 7559, 7561,
		5, 128, 0, 0, 7560, 7558, 1, 0, 0, 0, 7560, 7559, 1, 0, 0, 0, 7561, 947,
		1, 0, 0, 0, 7562, 7564, 5, 128, 0, 0, 7563, 7562, 1, 0, 0, 0, 7563, 7564,
		1, 0, 0, 0, 7564, 7565, 1, 0, 0, 0, 7565, 7567, 5, 69, 0, 0, 7566, 7568,
		5, 750, 0, 0, 7567, 7566, 1, 0, 0, 0, 7567, 7568, 1, 0, 0, 0, 7568, 7569,
		1, 0, 0, 0, 7569, 7570, 3, 938, 469, 0, 7570, 949, 1, 0, 0, 0, 7571, 7573,
		5, 128, 0, 0, 7572, 7571, 1, 0, 0, 0, 7572, 7573, 1, 0, 0, 0, 7573, 7574,
		1, 0, 0, 0, 7574, 7576, 5, 158, 0, 0, 7575, 7577, 5, 750, 0, 0, 7576, 7575,
		1, 0, 0, 0, 7576, 7577, 1, 0, 0, 0, 7577, 7578, 1, 0, 0, 0, 7578, 7579,
		3, 1154, 577, 0, 7579, 951, 1, 0, 0, 0, 7580, 7582, 5, 128, 0, 0, 7581,
		7580, 1, 0, 0, 0, 7581, 7582, 1, 0, 0, 0, 7582, 7583, 1, 0, 0, 0, 7583,
		7585, 3, 758, 379, 0, 7584, 7586, 5, 750, 0, 0, 7585, 7584, 1, 0, 0, 0,
		7585, 7586, 1, 0, 0, 0, 7586, 7587, 1, 0, 0, 0, 7587, 7588, 3, 936, 468,
		0, 7588, 953, 1, 0, 0, 0, 7589, 7590, 5, 405, 0, 0, 7590, 7591, 5, 45,
		0, 0, 7591, 7594, 3, 956, 478, 0, 7592, 7593, 5, 404, 0, 0, 7593, 7595,
		3, 1142, 571, 0, 7594, 7592, 1, 0, 0, 0, 7594, 7595, 1, 0, 0, 0, 7595,
		7597, 1, 0, 0, 0, 7596, 7598, 3, 958, 479, 0, 7597, 7596, 1, 0, 0, 0, 7597,
		7598, 1, 0, 0, 0, 7598, 7600, 1, 0, 0, 0, 7599, 7601, 3, 962, 481, 0, 7600,
		7599, 1, 0, 0, 0, 7600, 7601, 1, 0, 0, 0, 7601, 955, 1, 0, 0, 0, 7602,
		7604, 5, 277, 0, 0, 7603, 7602, 1, 0, 0, 0, 7603, 7604, 1, 0, 0, 0, 7604,
		7605, 1, 0, 0, 0, 7605, 7607, 5, 265, 0, 0, 7606, 7608, 3, 960, 480, 0,
		7607, 7606, 1, 0, 0, 0, 7607, 7608, 1, 0, 0, 0, 7608, 7609, 1, 0, 0, 0,
		7609, 7611, 5, 776, 0, 0, 7610, 7612, 3, 1130, 565, 0, 7611, 7610, 1, 0,
		0, 0, 7611, 7612, 1, 0, 0, 0, 7612, 7613, 1, 0, 0, 0, 7613, 7636, 5, 777,
		0, 0, 7614, 7616, 5, 277, 0, 0, 7615, 7614, 1, 0, 0, 0, 7615, 7616, 1,
		0, 0, 0, 7616, 7617, 1, 0, 0, 0, 7617, 7618, 5, 220, 0, 0, 7618, 7619,
		5, 776, 0, 0, 7619, 7620, 3, 686, 343, 0, 7620, 7621, 5, 777, 0, 0, 7621,
		7636, 1, 0, 0, 0, 7622, 7633, 7, 121, 0, 0, 7623, 7624, 5, 776, 0, 0, 7624,
		7625, 3, 686, 343, 0, 7625, 7626, 5, 777, 0, 0, 7626, 7634, 1, 0, 0, 0,
		7627, 7628, 5, 71, 0, 0, 7628, 7630, 5, 776, 0, 0, 7629, 7631, 3, 1130,
		565, 0, 7630, 7629, 1, 0, 0, 0, 7630, 7631, 1, 0, 0, 0, 7631, 7632, 1,
		0, 0, 0, 7632, 7634, 5, 777, 0, 0, 7633, 7623, 1, 0, 0, 0, 7633, 7627,
		1, 0, 0, 0, 7634, 7636, 1, 0, 0, 0, 7635, 7603, 1, 0, 0, 0, 7635, 7615,
		1, 0, 0, 0, 7635, 7622, 1, 0, 0, 0, 7636, 957, 1, 0, 0, 0, 7637, 7638,
		5, 561, 0, 0, 7638, 7640, 5, 45, 0, 0, 7639, 7641, 5, 277, 0, 0, 7640,
		7639, 1, 0, 0, 0, 7640, 7641, 1, 0, 0, 0, 7641, 7652, 1, 0, 0, 0, 7642,
		7643, 5, 220, 0, 0, 7643, 7644, 5, 776, 0, 0, 7644, 7645, 3, 686, 343,
		0, 7645, 7646, 5, 777, 0, 0, 7646, 7653, 1, 0, 0, 0, 7647, 7649, 5, 265,
		0, 0, 7648, 7650, 3, 960, 480, 0, 7649, 7648, 1, 0, 0, 0, 7649, 7650, 1,
		0, 0, 0, 7650, 7651, 1, 0, 0, 0, 7651, 7653, 3, 1132, 566, 0, 7652, 7642,
		1, 0, 0, 0, 7652, 7647, 1, 0, 0, 0, 7653, 7656, 1, 0, 0, 0, 7654, 7655,
		5, 560, 0, 0, 7655, 7657, 3, 1142, 571, 0, 7656, 7654, 1, 0, 0, 0, 7656,
		7657, 1, 0, 0, 0, 7657, 959, 1, 0, 0, 0, 7658, 7659, 4, 480, 199, 0, 7659,
		7660, 5, 9, 0, 0, 7660, 7661, 5, 750, 0, 0, 7661, 7662, 3, 1142, 571, 0,
		7662, 961, 1, 0, 0, 0, 7663, 7664, 5, 776, 0, 0, 7664, 7669, 3, 964, 482,
		0, 7665, 7666, 5, 773, 0, 0, 7666, 7668, 3, 964, 482, 0, 7667, 7665, 1,
		0, 0, 0, 7668, 7671, 1, 0, 0, 0, 7669, 7667, 1, 0, 0, 0, 7669, 7670, 1,
		0, 0, 0, 7670, 7672, 1, 0, 0, 0, 7671, 7669, 1, 0, 0, 0, 7672, 7673, 5,
		777, 0, 0, 7673, 963, 1, 0, 0, 0, 7674, 7675, 5, 405, 0, 0, 7675, 7686,
		3, 1128, 564, 0, 7676, 7677, 5, 626, 0, 0, 7677, 7678, 5, 273, 0, 0, 7678,
		7681, 5, 581, 0, 0, 7679, 7682, 3, 972, 486, 0, 7680, 7682, 5, 329, 0,
		0, 7681, 7679, 1, 0, 0, 0, 7681, 7680, 1, 0, 0, 0, 7682, 7687, 1, 0, 0,
		0, 7683, 7684, 5, 626, 0, 0, 7684, 7685, 5, 251, 0, 0, 7685, 7687, 3, 966,
		483, 0, 7686, 7676, 1, 0, 0, 0, 7686, 7683, 1, 0, 0, 0, 7686, 7687, 1,
		0, 0, 0, 7687, 7691, 1, 0, 0, 0, 7688, 7690, 3, 968, 484, 0, 7689, 7688,
		1, 0, 0, 0, 7690, 7693, 1, 0, 0, 0, 7691, 7689, 1, 0, 0, 0, 7691, 7692,
		1, 0, 0, 0, 7692, 7705, 1, 0, 0, 0, 7693, 7691, 1, 0, 0, 0, 7694, 7695,
		5, 776, 0, 0, 7695, 7700, 3, 970, 485, 0, 7696, 7697, 5, 773, 0, 0, 7697,
		7699, 3, 970, 485, 0, 7698, 7696, 1, 0, 0, 0, 7699, 7702, 1, 0, 0, 0, 7700,
		7698, 1, 0, 0, 0, 7700, 7701, 1, 0, 0, 0, 7701, 7703, 1, 0, 0, 0, 7702,
		7700, 1, 0, 0, 0, 7703, 7704, 5, 777, 0, 0, 7704, 7706, 1, 0, 0, 0, 7705,
		7694, 1, 0, 0, 0, 7705, 7706, 1, 0, 0, 0, 7706, 965, 1, 0, 0, 0, 7707,
		7720, 3, 972, 486, 0, 7708, 7709, 5, 776, 0, 0, 7709, 7714, 3, 972, 486,
		0, 7710, 7711, 5, 773, 0, 0, 7711, 7713, 3, 972, 486, 0, 7712, 7710, 1,
		0, 0, 0, 7713, 7716, 1, 0, 0, 0, 7714, 7712, 1, 0, 0, 0, 7714, 7715, 1,
		0, 0, 0, 7715, 7717, 1, 0, 0, 0, 7716, 7714, 1, 0, 0, 0, 7717, 7718, 5,
		777, 0, 0, 7718, 7720, 1, 0, 0, 0, 7719, 7707, 1, 0, 0, 0, 7719, 7708,
		1, 0, 0, 0, 7720, 967, 1, 0, 0, 0, 7721, 7723, 5, 572, 0, 0, 7722, 7724,
		5, 750, 0, 0, 7723, 7722, 1, 0, 0, 0, 7723, 7724, 1, 0, 0, 0, 7724, 7725,
		1, 0, 0, 0, 7725, 7756, 3, 1128, 564, 0, 7726, 7728, 5, 553, 0, 0, 7727,
		7726, 1, 0, 0, 0, 7727, 7728, 1, 0, 0, 0, 7728, 7729, 1, 0, 0, 0, 7729,
		7731, 5, 163, 0, 0, 7730, 7732, 5, 750, 0, 0, 7731, 7730, 1, 0, 0, 0, 7731,
		7732, 1, 0, 0, 0, 7732, 7733, 1, 0, 0, 0, 7733, 7756, 3, 1094, 547, 0,
		7734, 7736, 5, 368, 0, 0, 7735, 7737, 5, 750, 0, 0, 7736, 7735, 1, 0, 0,
		0, 7736, 7737, 1, 0, 0, 0, 7737, 7738, 1, 0, 0, 0, 7738, 7756, 3, 1142,
		571, 0, 7739, 7741, 7, 122, 0, 0, 7740, 7742, 5, 750, 0, 0, 7741, 7740,
		1, 0, 0, 0, 7741, 7742, 1, 0, 0, 0, 7742, 7743, 1, 0, 0, 0, 7743, 7756,
		3, 1142, 571, 0, 7744, 7745, 7, 123, 0, 0, 7745, 7747, 5, 139, 0, 0, 7746,
		7748, 5, 750, 0, 0, 7747, 7746, 1, 0, 0, 0, 7747, 7748, 1, 0, 0, 0, 7748,
		7749, 1, 0, 0, 0, 7749, 7756, 3, 1160, 580, 0, 7750, 7752, 5, 75, 0, 0,
		7751, 7753, 5, 750, 0, 0, 7752, 7751, 1, 0, 0, 0, 7752, 7753, 1, 0, 0,
		0, 7753, 7754, 1, 0, 0, 0, 7754, 7756, 3, 1160, 580, 0, 7755, 7721, 1,
		0, 0, 0, 7755, 7727, 1, 0, 0, 0, 7755, 7734, 1, 0, 0, 0, 7755, 7739, 1,
		0, 0, 0, 7755, 7744, 1, 0, 0, 0, 7755, 7750, 1, 0, 0, 0, 7756, 969, 1,
		0, 0, 0, 7757, 7758, 5, 561, 0, 0, 7758, 7762, 3, 1180, 590, 0, 7759, 7761,
		3, 968, 484, 0, 7760, 7759, 1, 0, 0, 0, 7761, 7764, 1, 0, 0, 0, 7762, 7760,
		1, 0, 0, 0, 7762, 7763, 1, 0, 0, 0, 7763, 971, 1, 0, 0, 0, 7764, 7762,
		1, 0, 0, 0, 7765, 7766, 5, 776, 0, 0, 7766, 7771, 3, 974, 487, 0, 7767,
		7768, 5, 773, 0, 0, 7768, 7770, 3, 974, 487, 0, 7769, 7767, 1, 0, 0, 0,
		7770, 7773, 1, 0, 0, 0, 7771, 7769, 1, 0, 0, 0, 7771, 7772, 1, 0, 0, 0,
		7772, 7774, 1, 0, 0, 0, 7773, 7771, 1, 0, 0, 0, 7774, 7775, 5, 777, 0,
		0, 7775, 973, 1, 0, 0, 0, 7776, 7779, 3, 686, 343, 0, 7777, 7779, 5, 329,
		0, 0, 7778, 7776, 1, 0, 0, 0, 7778, 7777, 1, 0, 0, 0, 7779, 975, 1, 0,
		0, 0, 7780, 7781, 5, 130, 0, 0, 7781, 7782, 5, 750, 0, 0, 7782, 7783, 3,
		1026, 513, 0, 7783, 977, 1, 0, 0, 0, 7784, 7785, 5, 231, 0, 0, 7785, 7786,
		5, 174, 0, 0, 7786, 979, 1, 0, 0, 0, 7787, 7788, 5, 231, 0, 0, 7788, 7789,
		3, 760, 380, 0, 7789, 7790, 5, 174, 0, 0, 7790, 981, 1, 0, 0, 0, 7791,
		7793, 7, 124, 0, 0, 7792, 7791, 1, 0, 0, 0, 7792, 7793, 1, 0, 0, 0, 7793,
		7794, 1, 0, 0, 0, 7794, 7795, 3, 984, 492, 0, 7795, 983, 1, 0, 0, 0, 7796,
		7797, 3, 1108, 554, 0, 7797, 7798, 3, 988, 494, 0, 7798, 985, 1, 0, 0,
		0, 7799, 7800, 5, 69, 0, 0, 7800, 7801, 3, 938, 469, 0, 7801, 987, 1, 0,
		0, 0, 7802, 7804, 3, 916, 458, 0, 7803, 7805, 3, 986, 493, 0, 7804, 7803,
		1, 0, 0, 0, 7804, 7805, 1, 0, 0, 0, 7805, 989, 1, 0, 0, 0, 7806, 7807,
		5, 776, 0, 0, 7807, 7808, 3, 1058, 529, 0, 7808, 7809, 5, 773, 0, 0, 7809,
		7810, 3, 1058, 529, 0, 7810, 7811, 5, 777, 0, 0, 7811, 991, 1, 0, 0, 0,
		7812, 7817, 3, 1074, 537, 0, 7813, 7814, 5, 773, 0, 0, 7814, 7816, 3, 1074,
		537, 0, 7815, 7813, 1, 0, 0, 0, 7816, 7819, 1, 0, 0, 0, 7817, 7815, 1,
		0, 0, 0, 7817, 7818, 1, 0, 0, 0, 7818, 993, 1, 0, 0, 0, 7819, 7817, 1,
		0, 0, 0, 7820, 7825, 3, 996, 498, 0, 7821, 7822, 5, 773, 0, 0, 7822, 7824,
		3, 996, 498, 0, 7823, 7821, 1, 0, 0, 0, 7824, 7827, 1, 0, 0, 0, 7825, 7823,
		1, 0, 0, 0, 7825, 7826, 1, 0, 0, 0, 7826, 995, 1, 0, 0, 0, 7827, 7825,
		1, 0, 0, 0, 7828, 7829, 3, 1046, 523, 0, 7829, 7832, 5, 750, 0, 0, 7830,
		7833, 3, 676, 338, 0, 7831, 7833, 5, 128, 0, 0, 7832, 7830, 1, 0, 0, 0,
		7832, 7831, 1, 0, 0, 0, 7833, 997, 1, 0, 0, 0, 7834, 7835, 3, 758, 379,
		0, 7835, 7836, 3, 936, 468, 0, 7836, 999, 1, 0, 0, 0, 7837, 7839, 5, 71,
		0, 0, 7838, 7840, 3, 1002, 501, 0, 7839, 7838, 1, 0, 0, 0, 7840, 7841,
		1, 0, 0, 0, 7841, 7839, 1, 0, 0, 0, 7841, 7842, 1, 0, 0, 0, 7842, 1001,
		1, 0, 0, 0, 7843, 7844, 5, 579, 0, 0, 7844, 7845, 5, 45, 0, 0, 7845, 7856,
		3, 1156, 578, 0, 7846, 7848, 5, 392, 0, 0, 7847, 7846, 1, 0, 0, 0, 7847,
		7848, 1, 0, 0, 0, 7848, 7849, 1, 0, 0, 0, 7849, 7850, 5, 157, 0, 0, 7850,
		7851, 5, 45, 0, 0, 7851, 7856, 3, 1156, 578, 0, 7852, 7853, 5, 167, 0,
		0, 7853, 7854, 5, 45, 0, 0, 7854, 7856, 3, 1156, 578, 0, 7855, 7843, 1,
		0, 0, 0, 7855, 7847, 1, 0, 0, 0, 7855, 7852, 1, 0, 0, 0, 7856, 1003, 1,
		0, 0, 0, 7857, 7859, 5, 278, 0, 0, 7858, 7860, 3, 1006, 503, 0, 7859, 7858,
		1, 0, 0, 0, 7860, 7861, 1, 0, 0, 0, 7861, 7859, 1, 0, 0, 0, 7861, 7862,
		1, 0, 0, 0, 7862, 1005, 1, 0, 0, 0, 7863, 7864, 7, 125, 0, 0, 7864, 7865,
		5, 45, 0, 0, 7865, 7866, 3, 1156, 578, 0, 7866, 1007, 1, 0, 0, 0, 7867,
		7872, 3, 1026, 513, 0, 7868, 7869, 5, 773, 0, 0, 7869, 7871, 3, 1026, 513,
		0, 7870, 7868, 1, 0, 0, 0, 7871, 7874, 1, 0, 0, 0, 7872, 7870, 1, 0, 0,
		0, 7872, 7873, 1, 0, 0, 0, 7873, 1009, 1, 0, 0, 0, 7874, 7872, 1, 0, 0,
		0, 7875, 7880, 3, 1014, 507, 0, 7876, 7877, 5, 773, 0, 0, 7877, 7879, 3,
		1014, 507, 0, 7878, 7876, 1, 0, 0, 0, 7879, 7882, 1, 0, 0, 0, 7880, 7878,
		1, 0, 0, 0, 7880, 7881, 1, 0, 0, 0, 7881, 1011, 1, 0, 0, 0, 7882, 7880,
		1, 0, 0, 0, 7883, 7888, 3, 1016, 508, 0, 7884, 7885, 5, 773, 0, 0, 7885,
		7887, 3, 1016, 508, 0, 7886, 7884, 1, 0, 0, 0, 7887, 7890, 1, 0, 0, 0,
		7888, 7886, 1, 0, 0, 0, 7888, 7889, 1, 0, 0, 0, 7889, 1013, 1, 0, 0, 0,
		7890, 7888, 1, 0, 0, 0, 7891, 7918, 3, 1026, 513, 0, 7892, 7916, 5, 230,
		0, 0, 7893, 7896, 5, 45, 0, 0, 7894, 7895, 4, 507, 200, 0, 7895, 7897,
		5, 406, 0, 0, 7896, 7894, 1, 0, 0, 0, 7896, 7897, 1, 0, 0, 0, 7897, 7898,
		1, 0, 0, 0, 7898, 7917, 3, 1156, 578, 0, 7899, 7900, 5, 645, 0, 0, 7900,
		7906, 3, 1180, 590, 0, 7901, 7902, 5, 17, 0, 0, 7902, 7907, 3, 1158, 579,
		0, 7903, 7904, 4, 507, 201, 0, 7904, 7905, 5, 45, 0, 0, 7905, 7907, 3,
		1156, 578, 0, 7906, 7901, 1, 0, 0, 0, 7906, 7903, 1, 0, 0, 0, 7906, 7907,
		1, 0, 0, 0, 7907, 7917, 1, 0, 0, 0, 7908, 7911, 4, 507, 202, 0, 7909, 7910,
		5, 645, 0, 0, 7910, 7912, 3, 1180, 590, 0, 7911, 7909, 1, 0, 0, 0, 7911,
		7912, 1, 0, 0, 0, 7912, 7913, 1, 0, 0, 0, 7913, 7914, 5, 45, 0, 0, 7914,
		7915, 5, 734, 0, 0, 7915, 7917, 5, 406, 0, 0, 7916, 7893, 1, 0, 0, 0, 7916,
		7899, 1, 0, 0, 0, 7916, 7908, 1, 0, 0, 0, 7917, 7919, 1, 0, 0, 0, 7918,
		7892, 1, 0, 0, 0, 7918, 7919, 1, 0, 0, 0, 7919, 1015, 1, 0, 0, 0, 7920,
		7949, 3, 1026, 513, 0, 7921, 7944, 5, 230, 0, 0, 7922, 7923, 5, 645, 0,
		0, 7923, 7925, 3, 1180, 590, 0, 7924, 7922, 1, 0, 0, 0, 7924, 7925, 1,
		0, 0, 0, 7925, 7926, 1, 0, 0, 0, 7926, 7927, 5, 45, 0, 0, 7927, 7930, 3,
		1156, 578, 0, 7928, 7929, 5, 458, 0, 0, 7929, 7931, 3, 1156, 578, 0, 7930,
		7928, 1, 0, 0, 0, 7930, 7931, 1, 0, 0, 0, 7931, 7933, 1, 0, 0, 0, 7932,
		7934, 3, 1018, 509, 0, 7933, 7932, 1, 0, 0, 0, 7933, 7934, 1, 0, 0, 0,
		7934, 7945, 1, 0, 0, 0, 7935, 7936, 5, 645, 0, 0, 7936, 7942, 3, 1180,
		590, 0, 7937, 7938, 5, 17, 0, 0, 7938, 7940, 3, 1158, 579, 0, 7939, 7941,
		3, 1018, 509, 0, 7940, 7939, 1, 0, 0, 0, 7940, 7941, 1, 0, 0, 0, 7941,
		7943, 1, 0, 0, 0, 7942, 7937, 1, 0, 0, 0, 7942, 7943, 1, 0, 0, 0, 7943,
		7945, 1, 0, 0, 0, 7944, 7924, 1, 0, 0, 0, 7944, 7935, 1, 0, 0, 0, 7944,
		7945, 1, 0, 0, 0, 7945, 7950, 1, 0, 0, 0, 7946, 7948, 3, 1020, 510, 0,
		7947, 7946, 1, 0, 0, 0, 7947, 7948, 1, 0, 0, 0, 7948, 7950, 1, 0, 0, 0,
		7949, 7921, 1, 0, 0, 0, 7949, 7947, 1, 0, 0, 0, 7950, 1017, 1, 0, 0, 0,
		7951, 7952, 5, 727, 0, 0, 7952, 7953, 5, 101, 0, 0, 7953, 7954, 5, 406,
		0, 0, 7954, 1019, 1, 0, 0, 0, 7955, 7956, 5, 141, 0, 0, 7956, 7957, 5,
		728, 0, 0, 7957, 7958, 5, 406, 0, 0, 7958, 1021, 1, 0, 0, 0, 7959, 7960,
		5, 458, 0, 0, 7960, 7961, 3, 1156, 578, 0, 7961, 1023, 1, 0, 0, 0, 7962,
		7966, 3, 1180, 590, 0, 7963, 7964, 5, 783, 0, 0, 7964, 7967, 3, 1180, 590,
		0, 7965, 7967, 5, 784, 0, 0, 7966, 7963, 1, 0, 0, 0, 7966, 7965, 1, 0,
		0, 0, 7966, 7967, 1, 0, 0, 0, 7967, 1025, 1, 0, 0, 0, 7968, 7974, 3, 1024,
		512, 0, 7969, 7971, 5, 105, 0, 0, 7970, 7972, 3, 1188, 594, 0, 7971, 7970,
		1, 0, 0, 0, 7971, 7972, 1, 0, 0, 0, 7972, 7974, 1, 0, 0, 0, 7973, 7968,
		1, 0, 0, 0, 7973, 7969, 1, 0, 0, 0, 7974, 1027, 1, 0, 0, 0, 7975, 7976,
		5, 275, 0, 0, 7976, 7977, 3, 1154, 577, 0, 7977, 1029, 1, 0, 0, 0, 7978,
		7981, 3, 1028, 514, 0, 7979, 7981, 3, 358, 179, 0, 7980, 7978, 1, 0, 0,
		0, 7980, 7979, 1, 0, 0, 0, 7981, 1031, 1, 0, 0, 0, 7982, 7983, 7, 126,
		0, 0, 7983, 1033, 1, 0, 0, 0, 7984, 7985, 7, 127, 0, 0, 7985, 1035, 1,
		0, 0, 0, 7986, 7987, 4, 518, 203, 0, 7987, 7988, 5, 405, 0, 0, 7988, 7989,
		3, 1132, 566, 0, 7989, 1037, 1, 0, 0, 0, 7990, 7996, 3, 1138, 569, 0, 7991,
		7993, 3, 1134, 567, 0, 7992, 7994, 3, 1138, 569, 0, 7993, 7992, 1, 0, 0,
		0, 7993, 7994, 1, 0, 0, 0, 7994, 7996, 1, 0, 0, 0, 7995, 7990, 1, 0, 0,
		0, 7995, 7991, 1, 0, 0, 0, 7996, 1039, 1, 0, 0, 0, 7997, 7998, 4, 520,
		204, 0, 7998, 8002, 3, 1128, 564, 0, 7999, 8000, 4, 520, 205, 0, 8000,
		8002, 3, 1038, 519, 0, 8001, 7997, 1, 0, 0, 0, 8001, 7999, 1, 0, 0, 0,
		8002, 1041, 1, 0, 0, 0, 8003, 8004, 3, 1128, 564, 0, 8004, 1043, 1, 0,
		0, 0, 8005, 8006, 5, 776, 0, 0, 8006, 8011, 3, 1042, 521, 0, 8007, 8008,
		5, 773, 0, 0, 8008, 8010, 3, 1042, 521, 0, 8009, 8007, 1, 0, 0, 0, 8010,
		8013, 1, 0, 0, 0, 8011, 8009, 1, 0, 0, 0, 8011, 8012, 1, 0, 0, 0, 8012,
		8014, 1, 0, 0, 0, 8013, 8011, 1, 0, 0, 0, 8014, 8015, 5, 777, 0, 0, 8015,
		1045, 1, 0, 0, 0, 8016, 8017, 3, 1038, 519, 0, 8017, 1047, 1, 0, 0, 0,
		8018, 8021, 3, 1046, 523, 0, 8019, 8021, 3, 1054, 527, 0, 8020, 8018, 1,
		0, 0, 0, 8020, 8019, 1, 0, 0, 0, 8021, 1049, 1, 0, 0, 0, 8022, 8023, 3,
		1128, 564, 0, 8023, 1051, 1, 0, 0, 0, 8024, 8025, 3, 1038, 519, 0, 8025,
		1053, 1, 0, 0, 0, 8026, 8027, 3, 1128, 564, 0, 8027, 8031, 5, 772, 0, 0,
		8028, 8029, 3, 1128, 564, 0, 8029, 8030, 5, 772, 0, 0, 8030, 8032, 1, 0,
		0, 0, 8031, 8028, 1, 0, 0, 0, 8031, 8032, 1, 0, 0, 0, 8032, 8033, 1, 0,
		0, 0, 8033, 8034, 5, 760, 0, 0, 8034, 1055, 1, 0, 0, 0, 8035, 8036, 3,
		1128, 564, 0, 8036, 1057, 1, 0, 0, 0, 8037, 8038, 3, 1128, 564, 0, 8038,
		1059, 1, 0, 0, 0, 8039, 8040, 3, 1134, 567, 0, 8040, 1061, 1, 0, 0, 0,
		8041, 8042, 3, 1134, 567, 0, 8042, 1063, 1, 0, 0, 0, 8043, 8044, 3, 1134,
		567, 0, 8044, 1065, 1, 0, 0, 0, 8045, 8046, 3, 1134, 567, 0, 8046, 1067,
		1, 0, 0, 0, 8047, 8048, 3, 1134, 567, 0, 8048, 1069, 1, 0, 0, 0, 8049,
		8050, 3, 1134, 567, 0, 8050, 1071, 1, 0, 0, 0, 8051, 8054, 3, 1134, 567,
		0, 8052, 8054, 3, 1138, 569, 0, 8053, 8051, 1, 0, 0, 0, 8053, 8052, 1,
		0, 0, 0, 8054, 1073, 1, 0, 0, 0, 8055, 8058, 3, 1134, 567, 0, 8056, 8058,
		3, 1138, 569, 0, 8057, 8055, 1, 0, 0, 0, 8057, 8056, 1, 0, 0, 0, 8058,
		1075, 1, 0, 0, 0, 8059, 8060, 3, 1128, 564, 0, 8060, 1077, 1, 0, 0, 0,
		8061, 8062, 3, 1128, 564, 0, 8062, 1079, 1, 0, 0, 0, 8063, 8064, 3, 1128,
		564, 0, 8064, 1081, 1, 0, 0, 0, 8065, 8066, 3, 1128, 564, 0, 8066, 1083,
		1, 0, 0, 0, 8067, 8068, 3, 1134, 567, 0, 8068, 1085, 1, 0, 0, 0, 8069,
		8070, 3, 1134, 567, 0, 8070, 1087, 1, 0, 0, 0, 8071, 8072, 3, 1128, 564,
		0, 8072, 1089, 1, 0, 0, 0, 8073, 8074, 3, 1180, 590, 0, 8074, 1091, 1,
		0, 0, 0, 8075, 8076, 3, 1180, 590, 0, 8076, 1093, 1, 0, 0, 0, 8077, 8078,
		3, 1180, 590, 0, 8078, 1095, 1, 0, 0, 0, 8079, 8082, 3, 1134, 567, 0, 8080,
		8082, 3, 1138, 569, 0, 8081, 8079, 1, 0, 0, 0, 8081, 8080, 1, 0, 0, 0,
		8082, 1097, 1, 0, 0, 0, 8083, 8084, 3, 1058, 529, 0, 8084, 8085, 3, 1138,
		569, 0, 8085, 1099, 1, 0, 0, 0, 8086, 8094, 3, 1128, 564, 0, 8087, 8088,
		5, 772, 0, 0, 8088, 8095, 5, 760, 0, 0, 8089, 8092, 3, 1138, 569, 0, 8090,
		8091, 5, 772, 0, 0, 8091, 8093, 5, 760, 0, 0, 8092, 8090, 1, 0, 0, 0, 8092,
		8093, 1, 0, 0, 0, 8093, 8095, 1, 0, 0, 0, 8094, 8087, 1, 0, 0, 0, 8094,
		8089, 1, 0, 0, 0, 8094, 8095, 1, 0, 0, 0, 8095, 1101, 1, 0, 0, 0, 8096,
		8099, 3, 1134, 567, 0, 8097, 8099, 3, 1138, 569, 0, 8098, 8096, 1, 0, 0,
		0, 8098, 8097, 1, 0, 0, 0, 8099, 1103, 1, 0, 0, 0, 8100, 8105, 3, 1102,
		551, 0, 8101, 8102, 5, 773, 0, 0, 8102, 8104, 3, 1102, 551, 0, 8103, 8101,
		1, 0, 0, 0, 8104, 8107, 1, 0, 0, 0, 8105, 8103, 1, 0, 0, 0, 8105, 8106,
		1, 0, 0, 0, 8106, 1105, 1, 0, 0, 0, 8107, 8105, 1, 0, 0, 0, 8108, 8113,
		3, 1100, 550, 0, 8109, 8110, 5, 773, 0, 0, 8110, 8112, 3, 1100, 550, 0,
		8111, 8109, 1, 0, 0, 0, 8112, 8115, 1, 0, 0, 0, 8113, 8111, 1, 0, 0, 0,
		8113, 8114, 1, 0, 0, 0, 8114, 1107, 1, 0, 0, 0, 8115, 8113, 1, 0, 0, 0,
		8116, 8117, 3, 1128, 564, 0, 8117, 1109, 1, 0, 0, 0, 8118, 8121, 3, 1126,
		563, 0, 8119, 8121, 3, 1204, 602, 0, 8120, 8118, 1, 0, 0, 0, 8120, 8119,
		1, 0, 0, 0, 8121, 1111, 1, 0, 0, 0, 8122, 8123, 3, 1110, 555, 0, 8123,
		1113, 1, 0, 0, 0, 8124, 8127, 3, 1126, 563, 0, 8125, 8127, 3, 1210, 605,
		0, 8126, 8124, 1, 0, 0, 0, 8126, 8125, 1, 0, 0, 0, 8127, 1115, 1, 0, 0,
		0, 8128, 8129, 3, 1114, 557, 0, 8129, 1117, 1, 0, 0, 0, 8130, 8131, 3,
		1128, 564, 0, 8131, 1119, 1, 0, 0, 0, 8132, 8133, 3, 1154, 577, 0, 8133,
		1121, 1, 0, 0, 0, 8134, 8135, 3, 1128, 564, 0, 8135, 1123, 1, 0, 0, 0,
		8136, 8137, 3, 1128, 564, 0, 8137, 1125, 1, 0, 0, 0, 8138, 8142, 7, 128,
		0, 0, 8139, 8140, 4, 563, 206, 0, 8140, 8142, 5, 798, 0, 0, 8141, 8138,
		1, 0, 0, 0, 8141, 8139, 1, 0, 0, 0, 8142, 1127, 1, 0, 0, 0, 8143, 8146,
		3, 1126, 563, 0, 8144, 8146, 3, 1198, 599, 0, 8145, 8143, 1, 0, 0, 0, 8145,
		8144, 1, 0, 0, 0, 8146, 1129, 1, 0, 0, 0, 8147, 8152, 3, 1128, 564, 0,
		8148, 8149, 5, 773, 0, 0, 8149, 8151, 3, 1128, 564, 0, 8150, 8148, 1, 0,
		0, 0, 8151, 8154, 1, 0, 0, 0, 8152, 8150, 1, 0, 0, 0, 8152, 8153, 1, 0,
		0, 0, 8153, 1131, 1, 0, 0, 0, 8154, 8152, 1, 0, 0, 0, 8155, 8156, 5, 776,
		0, 0, 8156, 8157, 3, 1130, 565, 0, 8157, 8158, 5, 777, 0, 0, 8158, 1133,
		1, 0, 0, 0, 8159, 8161, 3, 1128, 564, 0, 8160, 8162, 3, 1138, 569, 0, 8161,
		8160, 1, 0, 0, 0, 8161, 8162, 1, 0, 0, 0, 8162, 1135, 1, 0, 0, 0, 8163,
		8168, 3, 1128, 564, 0, 8164, 8166, 3, 1138, 569, 0, 8165, 8167, 3, 1138,
		569, 0, 8166, 8165, 1, 0, 0, 0, 8166, 8167, 1, 0, 0, 0, 8167, 8169, 1,
		0, 0, 0, 8168, 8164, 1, 0, 0, 0, 8168, 8169, 1, 0, 0, 0, 8169, 8175, 1,
		0, 0, 0, 8170, 8171, 4, 568, 207, 0, 8171, 8172, 3, 1138, 569, 0, 8172,
		8173, 3, 1138, 569, 0, 8173, 8175, 1, 0, 0, 0, 8174, 8163, 1, 0, 0, 0,
		8174, 8170, 1, 0, 0, 0, 8175, 1137, 1, 0, 0, 0, 8176, 8177, 5, 772, 0,
		0, 8177, 8178, 3, 1128, 564, 0, 8178, 1139, 1, 0, 0, 0, 8179, 8180, 7,
		129, 0, 0, 8180, 1141, 1, 0, 0, 0, 8181, 8182, 7, 130, 0, 0, 8182, 1143,
		1, 0, 0, 0, 8183, 8184, 7, 131, 0, 0, 8184, 1145, 1, 0, 0, 0, 8185, 8191,
		5, 747, 0, 0, 8186, 8187, 4, 573, 208, 0, 8187, 8191, 5, 788, 0, 0, 8188,
		8191, 5, 749, 0, 0, 8189, 8191, 5, 748, 0, 0, 8190, 8185, 1, 0, 0, 0, 8190,
		8186, 1, 0, 0, 0, 8190, 8188, 1, 0, 0, 0, 8190, 8189, 1, 0, 0, 0, 8191,
		1147, 1, 0, 0, 0, 8192, 8202, 3, 1160, 580, 0, 8193, 8202, 3, 1166, 583,
		0, 8194, 8202, 3, 1172, 586, 0, 8195, 8202, 3, 1170, 585, 0, 8196, 8202,
		3, 1168, 584, 0, 8197, 8199, 5, 794, 0, 0, 8198, 8197, 1, 0, 0, 0, 8198,
		8199, 1, 0, 0, 0, 8199, 8200, 1, 0, 0, 0, 8200, 8202, 7, 132, 0, 0, 8201,
		8192, 1, 0, 0, 0, 8201, 8193, 1, 0, 0, 0, 8201, 8194, 1, 0, 0, 0, 8201,
		8195, 1, 0, 0, 0, 8201, 8196, 1, 0, 0, 0, 8201, 8198, 1, 0, 0, 0, 8202,
		1149, 1, 0, 0, 0, 8203, 8209, 3, 1148, 574, 0, 8204, 8205, 5, 758, 0, 0,
		8205, 8209, 3, 1140, 570, 0, 8206, 8207, 5, 759, 0, 0, 8207, 8209, 3, 1140,
		570, 0, 8208, 8203, 1, 0, 0, 0, 8208, 8204, 1, 0, 0, 0, 8208, 8206, 1,
		0, 0, 0, 8209, 1151, 1, 0, 0, 0, 8210, 8211, 5, 776, 0, 0, 8211, 8216,
		3, 1156, 578, 0, 8212, 8213, 5, 773, 0, 0, 8213, 8215, 3, 1156, 578, 0,
		8214, 8212, 1, 0, 0, 0, 8215, 8218, 1, 0, 0, 0, 8216, 8214, 1, 0, 0, 0,
		8216, 8217, 1, 0, 0, 0, 8217, 8219, 1, 0, 0, 0, 8218, 8216, 1, 0, 0, 0,
		8219, 8220, 5, 777, 0, 0, 8220, 1153, 1, 0, 0, 0, 8221, 8225, 5, 799, 0,
		0, 8222, 8223, 4, 577, 209, 0, 8223, 8225, 5, 798, 0, 0, 8224, 8221, 1,
		0, 0, 0, 8224, 8222, 1, 0, 0, 0, 8225, 1155, 1, 0, 0, 0, 8226, 8230, 3,
		1154, 577, 0, 8227, 8230, 5, 788, 0, 0, 8228, 8230, 5, 789, 0, 0, 8229,
		8226, 1, 0, 0, 0, 8229, 8227, 1, 0, 0, 0, 8229, 8228, 1, 0, 0, 0, 8230,
		1157, 1, 0, 0, 0, 8231, 8235, 3, 1154, 577, 0, 8232, 8233, 4, 579, 210,
		0, 8233, 8235, 5, 788, 0, 0, 8234, 8231, 1, 0, 0, 0, 8234, 8232, 1, 0,
		0, 0, 8235, 1159, 1, 0, 0, 0, 8236, 8238, 5, 794, 0, 0, 8237, 8236, 1,
		0, 0, 0, 8237, 8238, 1, 0, 0, 0, 8238, 8239, 1, 0, 0, 0, 8239, 8242, 3,
		1154, 577, 0, 8240, 8242, 5, 796, 0, 0, 8241, 8237, 1, 0, 0, 0, 8241, 8240,
		1, 0, 0, 0, 8242, 8246, 1, 0, 0, 0, 8243, 8245, 3, 1154, 577, 0, 8244,
		8243, 1, 0, 0, 0, 8245, 8248, 1, 0, 0, 0, 8246, 8244, 1, 0, 0, 0, 8246,
		8247, 1, 0, 0, 0, 8247, 1161, 1, 0, 0, 0, 8248, 8246, 1, 0, 0, 0, 8249,
		8250, 3, 1154, 577, 0, 8250, 1163, 1, 0, 0, 0, 8251, 8256, 3, 1154, 577,
		0, 8252, 8253, 5, 773, 0, 0, 8253, 8255, 3, 1154, 577, 0, 8254, 8252, 1,
		0, 0, 0, 8255, 8258, 1, 0, 0, 0, 8256, 8254, 1, 0, 0, 0, 8256, 8257, 1,
		0, 0, 0, 8257, 1165, 1, 0, 0, 0, 8258, 8256, 1, 0, 0, 0, 8259, 8260, 7,
		131, 0, 0, 8260, 1167, 1, 0, 0, 0, 8261, 8262, 7, 133, 0, 0, 8262, 1169,
		1, 0, 0, 0, 8263, 8264, 7, 134, 0, 0, 8264, 1171, 1, 0, 0, 0, 8265, 8266,
		5, 116, 0, 0, 8266, 8272, 5, 799, 0, 0, 8267, 8268, 5, 586, 0, 0, 8268,
		8272, 5, 799, 0, 0, 8269, 8270, 5, 583, 0, 0, 8270, 8272, 5, 799, 0, 0,
		8271, 8265, 1, 0, 0, 0, 8271, 8267, 1, 0, 0, 0, 8271, 8269, 1, 0, 0, 0,
		8272, 1173, 1, 0, 0, 0, 8273, 8276, 3, 922, 461, 0, 8274, 8276, 3, 1178,
		589, 0, 8275, 8273, 1, 0, 0, 0, 8275, 8274, 1, 0, 0, 0, 8276, 1175, 1,
		0, 0, 0, 8277, 8278, 3, 1178, 589, 0, 8278, 1177, 1, 0, 0, 0, 8279, 8280,
		5, 776, 0, 0, 8280, 8281, 5, 747, 0, 0, 8281, 8282, 5, 773, 0, 0, 8282,
		8283, 5, 747, 0, 0, 8283, 8284, 5, 777, 0, 0, 8284, 1179, 1, 0, 0, 0, 8285,
		8288, 3, 1128, 564, 0, 8286, 8288, 3, 1154, 577, 0, 8287, 8285, 1, 0, 0,
		0, 8287, 8286, 1, 0, 0, 0, 8288, 1181, 1, 0, 0, 0, 8289, 8292, 3, 1126,
		563, 0, 8290, 8292, 3, 1212, 606, 0, 8291, 8289, 1, 0, 0, 0, 8291, 8290,
		1, 0, 0, 0, 8292, 1183, 1, 0, 0, 0, 8293, 8296, 3, 1114, 557, 0, 8294,
		8296, 3, 1154, 577, 0, 8295, 8293, 1, 0, 0, 0, 8295, 8294, 1, 0, 0, 0,
		8296, 1185, 1, 0, 0, 0, 8297, 8300, 3, 1146, 573, 0, 8298, 8300, 3, 1126,
		563, 0, 8299, 8297, 1, 0, 0, 0, 8299, 8298, 1, 0, 0, 0, 8300, 1187, 1,
		0, 0, 0, 8301, 8302, 5, 776, 0, 0, 8302, 8303, 5, 777, 0, 0, 8303, 1189,
		1, 0, 0, 0, 8304, 8305, 7, 135, 0, 0, 8305, 1191, 1, 0, 0, 0, 8306, 8307,
		7, 136, 0, 0, 8307, 1193, 1, 0, 0, 0, 8308, 8309, 5, 214, 0, 0, 8309, 8315,
		5, 772, 0, 0, 8310, 8311, 5, 284, 0, 0, 8311, 8315, 5, 772, 0, 0, 8312,
		8313, 5, 502, 0, 0, 8313, 8315, 5, 772, 0, 0, 8314, 8308, 1, 0, 0, 0, 8314,
		8310, 1, 0, 0, 0, 8314, 8312, 1, 0, 0, 0, 8315, 1195, 1, 0, 0, 0, 8316,
		8317, 5, 658, 0, 0, 8317, 8327, 5, 772, 0, 0, 8318, 8319, 5, 673, 0, 0,
		8319, 8327, 5, 772, 0, 0, 8320, 8321, 5, 214, 0, 0, 8321, 8327, 5, 772,
		0, 0, 8322, 8323, 5, 284, 0, 0, 8323, 8327, 5, 772, 0, 0, 8324, 8325, 5,
		502, 0, 0, 8325, 8327, 5, 772, 0, 0, 8326, 8316, 1, 0, 0, 0, 8326, 8318,
		1, 0, 0, 0, 8326, 8320, 1, 0, 0, 0, 8326, 8322, 1, 0, 0, 0, 8326, 8324,
		1, 0, 0, 0, 8327, 1197, 1, 0, 0, 0, 8328, 8336, 4, 599, 211, 0, 8329, 8337,
		3, 1204, 602, 0, 8330, 8337, 3, 1216, 608, 0, 8331, 8337, 5, 173, 0, 0,
		8332, 8333, 4, 599, 212, 0, 8333, 8337, 5, 510, 0, 0, 8334, 8335, 4, 599,
		213, 0, 8335, 8337, 5, 714, 0, 0, 8336, 8329, 1, 0, 0, 0, 8336, 8330, 1,
		0, 0, 0, 8336, 8331, 1, 0, 0, 0, 8336, 8332, 1, 0, 0, 0, 8336, 8334, 1,
		0, 0, 0, 8337, 8346, 1, 0, 0, 0, 8338, 8344, 3, 1208, 604, 0, 8339, 8344,
		3, 1200, 600, 0, 8340, 8344, 3, 1202, 601, 0, 8341, 8344, 3, 1206, 603,
		0, 8342, 8344, 3, 1214, 607, 0, 8343, 8338, 1, 0, 0, 0, 8343, 8339, 1,
		0, 0, 0, 8343, 8340, 1, 0, 0, 0, 8343, 8341, 1, 0, 0, 0, 8343, 8342, 1,
		0, 0, 0, 8344, 8346, 1, 0, 0, 0, 8345, 8328, 1, 0, 0, 0, 8345, 8343, 1,
		0, 0, 0, 8346, 1199, 1, 0, 0, 0, 8347, 8348, 7, 137, 0, 0, 8348, 1201,
		1, 0, 0, 0, 8349, 8350, 7, 138, 0, 0, 8350, 1203, 1, 0, 0, 0, 8351, 8362,
		4, 602, 214, 0, 8352, 8363, 3, 1218, 609, 0, 8353, 8363, 5, 170, 0, 0,
		8354, 8363, 5, 188, 0, 0, 8355, 8363, 5, 369, 0, 0, 8356, 8363, 5, 423,
		0, 0, 8357, 8363, 5, 427, 0, 0, 8358, 8363, 5, 451, 0, 0, 8359, 8363, 5,
		459, 0, 0, 8360, 8363, 5, 709, 0, 0, 8361, 8363, 5, 565, 0, 0, 8362, 8352,
		1, 0, 0, 0, 8362, 8353, 1, 0, 0, 0, 8362, 8354, 1, 0, 0, 0, 8362, 8355,
		1, 0, 0, 0, 8362, 8356, 1, 0, 0, 0, 8362, 8357, 1, 0, 0, 0, 8362, 8358,
		1, 0, 0, 0, 8362, 8359, 1, 0, 0, 0, 8362, 8360, 1, 0, 0, 0, 8362, 8361,
		1, 0, 0, 0, 8363, 8370, 1, 0, 0, 0, 8364, 8368, 3, 1208, 604, 0, 8365,
		8368, 3, 1206, 603, 0, 8366, 8368, 3, 1214, 607, 0, 8367, 8364, 1, 0, 0,
		0, 8367, 8365, 1, 0, 0, 0, 8367, 8366, 1, 0, 0, 0, 8368, 8370, 1, 0, 0,
		0, 8369, 8351, 1, 0, 0, 0, 8369, 8367, 1, 0, 0, 0, 8370, 1205, 1, 0, 0,
		0, 8371, 8372, 7, 139, 0, 0, 8372, 1207, 1, 0, 0, 0, 8373, 8377, 7, 140,
		0, 0, 8374, 8375, 4, 604, 215, 0, 8375, 8377, 7, 141, 0, 0, 8376, 8373,
		1, 0, 0, 0, 8376, 8374, 1, 0, 0, 0, 8377, 1209, 1, 0, 0, 0, 8378, 8381,
		4, 605, 216, 0, 8379, 8382, 3, 1218, 609, 0, 8380, 8382, 3, 1216, 608,
		0, 8381, 8379, 1, 0, 0, 0, 8381, 8380, 1, 0, 0, 0, 8382, 8389, 1, 0, 0,
		0, 8383, 8387, 3, 1208, 604, 0, 8384, 8387, 3, 1202, 601, 0, 8385, 8387,
		3, 1214, 607, 0, 8386, 8383, 1, 0, 0, 0, 8386, 8384, 1, 0, 0, 0, 8386,
		8385, 1, 0, 0, 0, 8387, 8389, 1, 0, 0, 0, 8388, 8378, 1, 0, 0, 0, 8388,
		8386, 1, 0, 0, 0, 8389, 1211, 1, 0, 0, 0, 8390, 8395, 3, 1208, 604, 0,
		8391, 8395, 3, 1200, 600, 0, 8392, 8395, 3, 1202, 601, 0, 8393, 8395, 3,
		1206, 603, 0, 8394, 8390, 1, 0, 0, 0, 8394, 8391, 1, 0, 0, 0, 8394, 8392,
		1, 0, 0, 0, 8394, 8393, 1, 0, 0, 0, 8395, 1213, 1, 0, 0, 0, 8396, 8397,
		7, 136, 0, 0, 8397, 1215, 1, 0, 0, 0, 8398, 8404, 7, 142, 0, 0, 8399, 8400,
		4, 608, 217, 0, 8400, 8404, 5, 510, 0, 0, 8401, 8402, 4, 608, 218, 0, 8402,
		8404, 5, 234, 0, 0, 8403, 8398, 1, 0, 0, 0, 8403, 8399, 1, 0, 0, 0, 8403,
		8401, 1, 0, 0, 0, 8404, 1217, 1, 0, 0, 0, 8405, 8415, 7, 143, 0, 0, 8406,
		8407, 4, 609, 219, 0, 8407, 8415, 5, 510, 0, 0, 8408, 8409, 4, 609, 220,
		0, 8409, 8415, 7, 144, 0, 0, 8410, 8411, 4, 609, 221, 0, 8411, 8415, 7,
		145, 0, 0, 8412, 8413, 4, 609, 222, 0, 8413, 8415, 5, 660, 0, 0, 8414,
		8405, 1, 0, 0, 0, 8414, 8406, 1, 0, 0, 0, 8414, 8408, 1, 0, 0, 0, 8414,
		8410, 1, 0, 0, 0, 8414, 8412, 1, 0, 0, 0, 8415, 1219, 1, 0, 0, 0, 1123,
		1223, 1227, 1230, 1232, 1268, 1276, 1281, 1297, 1304, 1311, 1314, 1321,
		1326, 1329, 1334, 1340, 1342, 1346, 1350, 1359, 1363, 1368, 1374, 1381,
		1385, 1390, 1395, 1402, 1405, 1411, 1414, 1421, 1431, 1436, 1441, 1449,
		1455, 1459, 1464, 1473, 1479, 1485, 1491, 1500, 1506, 1515, 1529, 1533,
		1539, 1543, 1549, 1553, 1558, 1561, 1567, 1573, 1579, 1583, 1588, 1592,
		1596, 1604, 1606, 1619, 1627, 1635, 1639, 1668, 1684, 1687, 1696, 1701,
		1707, 1712, 1716, 1721, 1725, 1729, 1733, 1737, 1741, 1743, 1754, 1762,
		1771, 1776, 1779, 1784, 1791, 1799, 1803, 1808, 1815, 1820, 1825, 1833,
		1837, 1842, 1845, 1848, 1851, 1858, 1865, 1869, 1893, 1897, 1903, 1910,
		1913, 1917, 1924, 1927, 1930, 1933, 1942, 1949, 1954, 1957, 1960, 1966,
		1972, 1975, 1980, 1990, 1993, 1999, 2005, 2015, 2018, 2026, 2032, 2043,
		2046, 2051, 2070, 2073, 2076, 2082, 2085, 2087, 2093, 2103, 2113, 2116,
		2119, 2124, 2130, 2143, 2147, 2152, 2161, 2178, 2197, 2206, 2209, 2217,
		2222, 2226, 2233, 2238, 2253, 2257, 2263, 2269, 2275, 2281, 2287, 2292,
		2296, 2304, 2310, 2316, 2321, 2324, 2327, 2336, 2339, 2350, 2362, 2371,
		2375, 2384, 2387, 2393, 2395, 2399, 2406, 2419, 2426, 2432, 2435, 2452,
		2472, 2476, 2482, 2488, 2494, 2499, 2506, 2513, 2518, 2521, 2525, 2529,
		2534, 2538, 2542, 2548, 2553, 2556, 2560, 2566, 2570, 2574, 2582, 2590,
		2599, 2608, 2621, 2624, 2628, 2634, 2642, 2647, 2650, 2653, 2656, 2659,
		2661, 2667, 2669, 2684, 2690, 2697, 2700, 2702, 2704, 2714, 2716, 2720,
		2723, 2726, 2730, 2735, 2741, 2744, 2747, 2753, 2756, 2765, 2774, 2778,
		2782, 2788, 2793, 2798, 2803, 2807, 2813, 2824, 2827, 2832, 2838, 2841,
		2844, 2847, 2850, 2864, 2867, 2871, 2875, 2881, 2886, 2890, 2895, 2898,
		2902, 2908, 2912, 2916, 2925, 2930, 2934, 2938, 2941, 2945, 2948, 2950,
		2954, 2960, 2964, 2966, 2970, 2974, 2978, 2985, 2987, 2996, 3002, 3007,
		3010, 3013, 3016, 3019, 3023, 3038, 3042, 3048, 3051, 3054, 3060, 3065,
		3069, 3072, 3080, 3082, 3095, 3107, 3112, 3115, 3118, 3123, 3129, 3145,
		3165, 3174, 3178, 3185, 3190, 3199, 3206, 3217, 3224, 3233, 3242, 3254,
		3259, 3266, 3270, 3276, 3281, 3286, 3290, 3296, 3302, 3304, 3307, 3311,
		3321, 3326, 3331, 3338, 3347, 3355, 3360, 3364, 3370, 3373, 3376, 3380,
		3384, 3394, 3398, 3401, 3404, 3409, 3415, 3419, 3425, 3428, 3430, 3435,
		3447, 3456, 3469, 3472, 3477, 3484, 3488, 3492, 3494, 3508, 3515, 3524,
		3530, 3539, 3543, 3547, 3557, 3559, 3567, 3574, 3579, 3583, 3587, 3590,
		3596, 3599, 3602, 3608, 3615, 3620, 3624, 3627, 3630, 3633, 3635, 3639,
		3647, 3653, 3657, 3662, 3665, 3668, 3671, 3673, 3678, 3687, 3700, 3702,
		3706, 3712, 3715, 3718, 3724, 3731, 3733, 3741, 3747, 3752, 3755, 3762,
		3764, 3773, 3782, 3791, 3799, 3803, 3810, 3813, 3815, 3823, 3829, 3839,
		3846, 3940, 3944, 3950, 3964, 3972, 3975, 3987, 3992, 3998, 4005, 4012,
		4019, 4026, 4033, 4040, 4043, 4050, 4058, 4066, 4076, 4082, 4086, 4090,
		4095, 4098, 4100, 4109, 4115, 4122, 4127, 4132, 4137, 4140, 4147, 4160,
		4166, 4172, 4179, 4187, 4193, 4205, 4207, 4213, 4217, 4219, 4223, 4236,
		4242, 4250, 4261, 4265, 4278, 4285, 4291, 4298, 4300, 4310, 4318, 4321,
		4326, 4330, 4336, 4339, 4344, 4355, 4357, 4369, 4374, 4382, 4388, 4390,
		4392, 4398, 4410, 4415, 4417, 4421, 4427, 4430, 4433, 4443, 4445, 4451,
		4458, 4464, 4474, 4478, 4483, 4500, 4516, 4521, 4529, 4537, 4542, 4548,
		4551, 4553, 4562, 4568, 4574, 4576, 4580, 4591, 4601, 4606, 4611, 4616,
		4624, 4628, 4633, 4642, 4654, 4668, 4677, 4679, 4686, 4693, 4697, 4703,
		4711, 4718, 4722, 4728, 4735, 4738, 4747, 4753, 4758, 4781, 4784, 4800,
		4805, 4808, 4812, 4815, 4829, 4835, 4840, 4843, 4845, 4849, 4854, 4856,
		4868, 4874, 4896, 4900, 4902, 4910, 4914, 4923, 4933, 4940, 4943, 4947,
		4950, 4953, 4957, 4960, 4964, 4967, 4972, 4975, 4980, 4983, 4989, 4993,
		4999, 5002, 5011, 5013, 5019, 5023, 5026, 5029, 5033, 5039, 5042, 5045,
		5055, 5059, 5068, 5071, 5076, 5079, 5082, 5086, 5089, 5094, 5098, 5106,
		5119, 5137, 5142, 5147, 5155, 5161, 5163, 5167, 5170, 5184, 5194, 5198,
		5206, 5209, 5213, 5223, 5227, 5234, 5239, 5247, 5252, 5258, 5265, 5270,
		5276, 5283, 5293, 5295, 5303, 5308, 5312, 5315, 5322, 5327, 5331, 5342,
		5350, 5354, 5357, 5360, 5364, 5368, 5373, 5379, 5383, 5394, 5397, 5400,
		5403, 5411, 5415, 5420, 5428, 5436, 5442, 5460, 5470, 5476, 5490, 5493,
		5497, 5508, 5510, 5519, 5531, 5533, 5540, 5546, 5552, 5560, 5571, 5575,
		5604, 5606, 5614, 5618, 5635, 5642, 5656, 5668, 5674, 5681, 5684, 5718,
		5726, 5728, 5740, 5745, 5751, 5759, 5766, 5772, 5777, 5783, 5788, 5793,
		5799, 5804, 5810, 5818, 5826, 5834, 5842, 5847, 5853, 5858, 5862, 5866,
		5871, 5873, 5892, 5896, 5903, 5915, 5918, 5922, 5927, 5932, 5936, 5946,
		5955, 5957, 5960, 5969, 5976, 5989, 5994, 6001, 6007, 6033, 6064, 6084,
		6090, 6094, 6121, 6133, 6146, 6150, 6154, 6182, 6238, 6248, 6252, 6264,
		6269, 6282, 6302, 6306, 6323, 6326, 6331, 6334, 6343, 6347, 6353, 6359,
		6363, 6374, 6380, 6382, 6389, 6396, 6400, 6407, 6412, 6416, 6421, 6425,
		6429, 6434, 6439, 6441, 6445, 6458, 6462, 6465, 6469, 6473, 6477, 6482,
		6486, 6490, 6499, 6501, 6508, 6514, 6522, 6543, 6548, 6555, 6578, 6594,
		6604, 6608, 6615, 6618, 6629, 6638, 6641, 6648, 6653, 6679, 6685, 6691,
		6695, 6705, 6709, 6722, 6734, 6752, 6760, 6770, 6773, 6778, 6782, 6789,
		6794, 6801, 6809, 6812, 6817, 6825, 6828, 6842, 6845, 6858, 6862, 6864,
		6869, 6874, 6880, 6886, 6892, 6897, 6900, 6906, 6911, 6914, 6920, 6924,
		6930, 6932, 6935, 6941, 6947, 6955, 6957, 6959, 6963, 6969, 6974, 6978,
		6983, 6989, 6996, 6999, 7001, 7004, 7014, 7018, 7024, 7031, 7036, 7050,
		7055, 7063, 7068, 7072, 7075, 7080, 7084, 7092, 7100, 7102, 7109, 7117,
		7124, 7127, 7135, 7143, 7145, 7151, 7157, 7161, 7168, 7179, 7188, 7191,
		7196, 7198, 7201, 7204, 7208, 7211, 7215, 7220, 7223, 7227, 7230, 7234,
		7239, 7243, 7255, 7259, 7265, 7268, 7273, 7277, 7281, 7286, 7295, 7298,
		7302, 7306, 7309, 7313, 7317, 7322, 7327, 7333, 7338, 7343, 7345, 7350,
		7357, 7365, 7371, 7373, 7377, 7381, 7385, 7389, 7403, 7410, 7414, 7419,
		7425, 7429, 7435, 7439, 7443, 7448, 7453, 7458, 7463, 7469, 7475, 7480,
		7485, 7490, 7495, 7500, 7505, 7510, 7520, 7526, 7532, 7538, 7541, 7548,
		7553, 7556, 7560, 7563, 7567, 7572, 7576, 7581, 7585, 7594, 7597, 7600,
		7603, 7607, 7611, 7615, 7630, 7633, 7635, 7640, 7649, 7652, 7656, 7669,
		7681, 7686, 7691, 7700, 7705, 7714, 7719, 7723, 7727, 7731, 7736, 7741,
		7747, 7752, 7755, 7762, 7771, 7778, 7792, 7804, 7817, 7825, 7832, 7841,
		7847, 7855, 7861, 7872, 7880, 7888, 7896, 7906, 7911, 7916, 7918, 7924,
		7930, 7933, 7940, 7942, 7944, 7947, 7949, 7966, 7971, 7973, 7980, 7993,
		7995, 8001, 8011, 8020, 8031, 8053, 8057, 8081, 8092, 8094, 8098, 8105,
		8113, 8120, 8126, 8141, 8145, 8152, 8161, 8166, 8168, 8174, 8190, 8198,
		8201, 8208, 8216, 8224, 8229, 8234, 8237, 8241, 8246, 8256, 8271, 8275,
		8287, 8291, 8295, 8299, 8314, 8326, 8336, 8343, 8345, 8362, 8367, 8369,
		8376, 8381, 8386, 8388, 8394, 8403, 8414,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// MySQLParserInit initializes any static state used to implement MySQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewMySQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func MySQLParserInit() {
	staticData := &MySQLParserParserStaticData
	staticData.once.Do(mysqlparserParserInit)
}

// NewMySQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewMySQLParser(input antlr.TokenStream) *MySQLParser {
	MySQLParserInit()
	this := new(MySQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &MySQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "MySQLParser.g4"

	return this
}

// MySQLParser tokens.
const (
	MySQLParserEOF                                    = antlr.TokenEOF
	MySQLParserACCESSIBLE_SYMBOL                      = 1
	MySQLParserACCOUNT_SYMBOL                         = 2
	MySQLParserACTION_SYMBOL                          = 3
	MySQLParserADD_SYMBOL                             = 4
	MySQLParserADDDATE_SYMBOL                         = 5
	MySQLParserAFTER_SYMBOL                           = 6
	MySQLParserAGAINST_SYMBOL                         = 7
	MySQLParserAGGREGATE_SYMBOL                       = 8
	MySQLParserALGORITHM_SYMBOL                       = 9
	MySQLParserALL_SYMBOL                             = 10
	MySQLParserALTER_SYMBOL                           = 11
	MySQLParserALWAYS_SYMBOL                          = 12
	MySQLParserANALYSE_SYMBOL                         = 13
	MySQLParserANALYZE_SYMBOL                         = 14
	MySQLParserAND_SYMBOL                             = 15
	MySQLParserANY_SYMBOL                             = 16
	MySQLParserAS_SYMBOL                              = 17
	MySQLParserASC_SYMBOL                             = 18
	MySQLParserASCII_SYMBOL                           = 19
	MySQLParserASENSITIVE_SYMBOL                      = 20
	MySQLParserAT_SYMBOL                              = 21
	MySQLParserAUTHORS_SYMBOL                         = 22
	MySQLParserAUTOEXTEND_SIZE_SYMBOL                 = 23
	MySQLParserAUTO_INCREMENT_SYMBOL                  = 24
	MySQLParserAVG_ROW_LENGTH_SYMBOL                  = 25
	MySQLParserAVG_SYMBOL                             = 26
	MySQLParserBACKUP_SYMBOL                          = 27
	MySQLParserBEFORE_SYMBOL                          = 28
	MySQLParserBEGIN_SYMBOL                           = 29
	MySQLParserBETWEEN_SYMBOL                         = 30
	MySQLParserBIGINT_SYMBOL                          = 31
	MySQLParserBINARY_SYMBOL                          = 32
	MySQLParserBINLOG_SYMBOL                          = 33
	MySQLParserBIN_NUM_SYMBOL                         = 34
	MySQLParserBIT_AND_SYMBOL                         = 35
	MySQLParserBIT_OR_SYMBOL                          = 36
	MySQLParserBIT_SYMBOL                             = 37
	MySQLParserBIT_XOR_SYMBOL                         = 38
	MySQLParserBLOB_SYMBOL                            = 39
	MySQLParserBLOCK_SYMBOL                           = 40
	MySQLParserBOOLEAN_SYMBOL                         = 41
	MySQLParserBOOL_SYMBOL                            = 42
	MySQLParserBOTH_SYMBOL                            = 43
	MySQLParserBTREE_SYMBOL                           = 44
	MySQLParserBY_SYMBOL                              = 45
	MySQLParserBYTE_SYMBOL                            = 46
	MySQLParserCACHE_SYMBOL                           = 47
	MySQLParserCALL_SYMBOL                            = 48
	MySQLParserCASCADE_SYMBOL                         = 49
	MySQLParserCASCADED_SYMBOL                        = 50
	MySQLParserCASE_SYMBOL                            = 51
	MySQLParserCAST_SYMBOL                            = 52
	MySQLParserCATALOG_NAME_SYMBOL                    = 53
	MySQLParserCHAIN_SYMBOL                           = 54
	MySQLParserCHANGE_SYMBOL                          = 55
	MySQLParserCHANGED_SYMBOL                         = 56
	MySQLParserCHANNEL_SYMBOL                         = 57
	MySQLParserCHARSET_SYMBOL                         = 58
	MySQLParserCHARACTER_SYMBOL                       = 59
	MySQLParserCHAR_SYMBOL                            = 60
	MySQLParserCHECKSUM_SYMBOL                        = 61
	MySQLParserCHECK_SYMBOL                           = 62
	MySQLParserCIPHER_SYMBOL                          = 63
	MySQLParserCLASS_ORIGIN_SYMBOL                    = 64
	MySQLParserCLIENT_SYMBOL                          = 65
	MySQLParserCLOSE_SYMBOL                           = 66
	MySQLParserCOALESCE_SYMBOL                        = 67
	MySQLParserCODE_SYMBOL                            = 68
	MySQLParserCOLLATE_SYMBOL                         = 69
	MySQLParserCOLLATION_SYMBOL                       = 70
	MySQLParserCOLUMNS_SYMBOL                         = 71
	MySQLParserCOLUMN_SYMBOL                          = 72
	MySQLParserCOLUMN_NAME_SYMBOL                     = 73
	MySQLParserCOLUMN_FORMAT_SYMBOL                   = 74
	MySQLParserCOMMENT_SYMBOL                         = 75
	MySQLParserCOMMITTED_SYMBOL                       = 76
	MySQLParserCOMMIT_SYMBOL                          = 77
	MySQLParserCOMPACT_SYMBOL                         = 78
	MySQLParserCOMPLETION_SYMBOL                      = 79
	MySQLParserCOMPRESSED_SYMBOL                      = 80
	MySQLParserCOMPRESSION_SYMBOL                     = 81
	MySQLParserCONCURRENT_SYMBOL                      = 82
	MySQLParserCONDITION_SYMBOL                       = 83
	MySQLParserCONNECTION_SYMBOL                      = 84
	MySQLParserCONSISTENT_SYMBOL                      = 85
	MySQLParserCONSTRAINT_SYMBOL                      = 86
	MySQLParserCONSTRAINT_CATALOG_SYMBOL              = 87
	MySQLParserCONSTRAINT_NAME_SYMBOL                 = 88
	MySQLParserCONSTRAINT_SCHEMA_SYMBOL               = 89
	MySQLParserCONTAINS_SYMBOL                        = 90
	MySQLParserCONTEXT_SYMBOL                         = 91
	MySQLParserCONTINUE_SYMBOL                        = 92
	MySQLParserCONTRIBUTORS_SYMBOL                    = 93
	MySQLParserCONVERT_SYMBOL                         = 94
	MySQLParserCOUNT_SYMBOL                           = 95
	MySQLParserCPU_SYMBOL                             = 96
	MySQLParserCREATE_SYMBOL                          = 97
	MySQLParserCROSS_SYMBOL                           = 98
	MySQLParserCUBE_SYMBOL                            = 99
	MySQLParserCURDATE_SYMBOL                         = 100
	MySQLParserCURRENT_SYMBOL                         = 101
	MySQLParserCURRENT_DATE_SYMBOL                    = 102
	MySQLParserCURRENT_TIME_SYMBOL                    = 103
	MySQLParserCURRENT_TIMESTAMP_SYMBOL               = 104
	MySQLParserCURRENT_USER_SYMBOL                    = 105
	MySQLParserCURSOR_SYMBOL                          = 106
	MySQLParserCURSOR_NAME_SYMBOL                     = 107
	MySQLParserCURTIME_SYMBOL                         = 108
	MySQLParserDATABASE_SYMBOL                        = 109
	MySQLParserDATABASES_SYMBOL                       = 110
	MySQLParserDATAFILE_SYMBOL                        = 111
	MySQLParserDATA_SYMBOL                            = 112
	MySQLParserDATETIME_SYMBOL                        = 113
	MySQLParserDATE_ADD_SYMBOL                        = 114
	MySQLParserDATE_SUB_SYMBOL                        = 115
	MySQLParserDATE_SYMBOL                            = 116
	MySQLParserDAYOFMONTH_SYMBOL                      = 117
	MySQLParserDAY_HOUR_SYMBOL                        = 118
	MySQLParserDAY_MICROSECOND_SYMBOL                 = 119
	MySQLParserDAY_MINUTE_SYMBOL                      = 120
	MySQLParserDAY_SECOND_SYMBOL                      = 121
	MySQLParserDAY_SYMBOL                             = 122
	MySQLParserDEALLOCATE_SYMBOL                      = 123
	MySQLParserDEC_SYMBOL                             = 124
	MySQLParserDECIMAL_NUM_SYMBOL                     = 125
	MySQLParserDECIMAL_SYMBOL                         = 126
	MySQLParserDECLARE_SYMBOL                         = 127
	MySQLParserDEFAULT_SYMBOL                         = 128
	MySQLParserDEFAULT_AUTH_SYMBOL                    = 129
	MySQLParserDEFINER_SYMBOL                         = 130
	MySQLParserDELAYED_SYMBOL                         = 131
	MySQLParserDELAY_KEY_WRITE_SYMBOL                 = 132
	MySQLParserDELETE_SYMBOL                          = 133
	MySQLParserDESC_SYMBOL                            = 134
	MySQLParserDESCRIBE_SYMBOL                        = 135
	MySQLParserDES_KEY_FILE_SYMBOL                    = 136
	MySQLParserDETERMINISTIC_SYMBOL                   = 137
	MySQLParserDIAGNOSTICS_SYMBOL                     = 138
	MySQLParserDIRECTORY_SYMBOL                       = 139
	MySQLParserDISABLE_SYMBOL                         = 140
	MySQLParserDISCARD_SYMBOL                         = 141
	MySQLParserDISK_SYMBOL                            = 142
	MySQLParserDISTINCT_SYMBOL                        = 143
	MySQLParserDISTINCTROW_SYMBOL                     = 144
	MySQLParserDIV_SYMBOL                             = 145
	MySQLParserDOUBLE_SYMBOL                          = 146
	MySQLParserDO_SYMBOL                              = 147
	MySQLParserDROP_SYMBOL                            = 148
	MySQLParserDUAL_SYMBOL                            = 149
	MySQLParserDUMPFILE_SYMBOL                        = 150
	MySQLParserDUPLICATE_SYMBOL                       = 151
	MySQLParserDYNAMIC_SYMBOL                         = 152
	MySQLParserEACH_SYMBOL                            = 153
	MySQLParserELSE_SYMBOL                            = 154
	MySQLParserELSEIF_SYMBOL                          = 155
	MySQLParserENABLE_SYMBOL                          = 156
	MySQLParserENCLOSED_SYMBOL                        = 157
	MySQLParserENCRYPTION_SYMBOL                      = 158
	MySQLParserEND_SYMBOL                             = 159
	MySQLParserENDS_SYMBOL                            = 160
	MySQLParserEND_OF_INPUT_SYMBOL                    = 161
	MySQLParserENGINES_SYMBOL                         = 162
	MySQLParserENGINE_SYMBOL                          = 163
	MySQLParserENUM_SYMBOL                            = 164
	MySQLParserERROR_SYMBOL                           = 165
	MySQLParserERRORS_SYMBOL                          = 166
	MySQLParserESCAPED_SYMBOL                         = 167
	MySQLParserESCAPE_SYMBOL                          = 168
	MySQLParserEVENTS_SYMBOL                          = 169
	MySQLParserEVENT_SYMBOL                           = 170
	MySQLParserEVERY_SYMBOL                           = 171
	MySQLParserEXCHANGE_SYMBOL                        = 172
	MySQLParserEXECUTE_SYMBOL                         = 173
	MySQLParserEXISTS_SYMBOL                          = 174
	MySQLParserEXIT_SYMBOL                            = 175
	MySQLParserEXPANSION_SYMBOL                       = 176
	MySQLParserEXPIRE_SYMBOL                          = 177
	MySQLParserEXPLAIN_SYMBOL                         = 178
	MySQLParserEXPORT_SYMBOL                          = 179
	MySQLParserEXTENDED_SYMBOL                        = 180
	MySQLParserEXTENT_SIZE_SYMBOL                     = 181
	MySQLParserEXTRACT_SYMBOL                         = 182
	MySQLParserFALSE_SYMBOL                           = 183
	MySQLParserFAST_SYMBOL                            = 184
	MySQLParserFAULTS_SYMBOL                          = 185
	MySQLParserFETCH_SYMBOL                           = 186
	MySQLParserFIELDS_SYMBOL                          = 187
	MySQLParserFILE_SYMBOL                            = 188
	MySQLParserFILE_BLOCK_SIZE_SYMBOL                 = 189
	MySQLParserFILTER_SYMBOL                          = 190
	MySQLParserFIRST_SYMBOL                           = 191
	MySQLParserFIXED_SYMBOL                           = 192
	MySQLParserFLOAT4_SYMBOL                          = 193
	MySQLParserFLOAT8_SYMBOL                          = 194
	MySQLParserFLOAT_SYMBOL                           = 195
	MySQLParserFLUSH_SYMBOL                           = 196
	MySQLParserFOLLOWS_SYMBOL                         = 197
	MySQLParserFORCE_SYMBOL                           = 198
	MySQLParserFOREIGN_SYMBOL                         = 199
	MySQLParserFOR_SYMBOL                             = 200
	MySQLParserFORMAT_SYMBOL                          = 201
	MySQLParserFOUND_SYMBOL                           = 202
	MySQLParserFROM_SYMBOL                            = 203
	MySQLParserFULL_SYMBOL                            = 204
	MySQLParserFULLTEXT_SYMBOL                        = 205
	MySQLParserFUNCTION_SYMBOL                        = 206
	MySQLParserGET_SYMBOL                             = 207
	MySQLParserGENERAL_SYMBOL                         = 208
	MySQLParserGENERATED_SYMBOL                       = 209
	MySQLParserGROUP_REPLICATION_SYMBOL               = 210
	MySQLParserGEOMETRYCOLLECTION_SYMBOL              = 211
	MySQLParserGEOMETRY_SYMBOL                        = 212
	MySQLParserGET_FORMAT_SYMBOL                      = 213
	MySQLParserGLOBAL_SYMBOL                          = 214
	MySQLParserGRANT_SYMBOL                           = 215
	MySQLParserGRANTS_SYMBOL                          = 216
	MySQLParserGROUP_SYMBOL                           = 217
	MySQLParserGROUP_CONCAT_SYMBOL                    = 218
	MySQLParserHANDLER_SYMBOL                         = 219
	MySQLParserHASH_SYMBOL                            = 220
	MySQLParserHAVING_SYMBOL                          = 221
	MySQLParserHELP_SYMBOL                            = 222
	MySQLParserHIGH_PRIORITY_SYMBOL                   = 223
	MySQLParserHOST_SYMBOL                            = 224
	MySQLParserHOSTS_SYMBOL                           = 225
	MySQLParserHOUR_MICROSECOND_SYMBOL                = 226
	MySQLParserHOUR_MINUTE_SYMBOL                     = 227
	MySQLParserHOUR_SECOND_SYMBOL                     = 228
	MySQLParserHOUR_SYMBOL                            = 229
	MySQLParserIDENTIFIED_SYMBOL                      = 230
	MySQLParserIF_SYMBOL                              = 231
	MySQLParserIGNORE_SYMBOL                          = 232
	MySQLParserIGNORE_SERVER_IDS_SYMBOL               = 233
	MySQLParserIMPORT_SYMBOL                          = 234
	MySQLParserINDEXES_SYMBOL                         = 235
	MySQLParserINDEX_SYMBOL                           = 236
	MySQLParserINFILE_SYMBOL                          = 237
	MySQLParserINITIAL_SIZE_SYMBOL                    = 238
	MySQLParserINNER_SYMBOL                           = 239
	MySQLParserINOUT_SYMBOL                           = 240
	MySQLParserINSENSITIVE_SYMBOL                     = 241
	MySQLParserINSERT_SYMBOL                          = 242
	MySQLParserINSERT_METHOD_SYMBOL                   = 243
	MySQLParserINSTANCE_SYMBOL                        = 244
	MySQLParserINSTALL_SYMBOL                         = 245
	MySQLParserINTEGER_SYMBOL                         = 246
	MySQLParserINTERVAL_SYMBOL                        = 247
	MySQLParserINTO_SYMBOL                            = 248
	MySQLParserINT_SYMBOL                             = 249
	MySQLParserINVOKER_SYMBOL                         = 250
	MySQLParserIN_SYMBOL                              = 251
	MySQLParserIO_AFTER_GTIDS_SYMBOL                  = 252
	MySQLParserIO_BEFORE_GTIDS_SYMBOL                 = 253
	MySQLParserIO_THREAD_SYMBOL                       = 254
	MySQLParserIO_SYMBOL                              = 255
	MySQLParserIPC_SYMBOL                             = 256
	MySQLParserIS_SYMBOL                              = 257
	MySQLParserISOLATION_SYMBOL                       = 258
	MySQLParserISSUER_SYMBOL                          = 259
	MySQLParserITERATE_SYMBOL                         = 260
	MySQLParserJOIN_SYMBOL                            = 261
	MySQLParserJSON_SYMBOL                            = 262
	MySQLParserKEYS_SYMBOL                            = 263
	MySQLParserKEY_BLOCK_SIZE_SYMBOL                  = 264
	MySQLParserKEY_SYMBOL                             = 265
	MySQLParserKILL_SYMBOL                            = 266
	MySQLParserLANGUAGE_SYMBOL                        = 267
	MySQLParserLAST_SYMBOL                            = 268
	MySQLParserLEADING_SYMBOL                         = 269
	MySQLParserLEAVES_SYMBOL                          = 270
	MySQLParserLEAVE_SYMBOL                           = 271
	MySQLParserLEFT_SYMBOL                            = 272
	MySQLParserLESS_SYMBOL                            = 273
	MySQLParserLEVEL_SYMBOL                           = 274
	MySQLParserLIKE_SYMBOL                            = 275
	MySQLParserLIMIT_SYMBOL                           = 276
	MySQLParserLINEAR_SYMBOL                          = 277
	MySQLParserLINES_SYMBOL                           = 278
	MySQLParserLINESTRING_SYMBOL                      = 279
	MySQLParserLIST_SYMBOL                            = 280
	MySQLParserLOAD_SYMBOL                            = 281
	MySQLParserLOCALTIME_SYMBOL                       = 282
	MySQLParserLOCALTIMESTAMP_SYMBOL                  = 283
	MySQLParserLOCAL_SYMBOL                           = 284
	MySQLParserLOCATOR_SYMBOL                         = 285
	MySQLParserLOCKS_SYMBOL                           = 286
	MySQLParserLOCK_SYMBOL                            = 287
	MySQLParserLOGFILE_SYMBOL                         = 288
	MySQLParserLOGS_SYMBOL                            = 289
	MySQLParserLONGBLOB_SYMBOL                        = 290
	MySQLParserLONGTEXT_SYMBOL                        = 291
	MySQLParserLONG_NUM_SYMBOL                        = 292
	MySQLParserLONG_SYMBOL                            = 293
	MySQLParserLOOP_SYMBOL                            = 294
	MySQLParserLOW_PRIORITY_SYMBOL                    = 295
	MySQLParserMASTER_AUTO_POSITION_SYMBOL            = 296
	MySQLParserMASTER_BIND_SYMBOL                     = 297
	MySQLParserMASTER_CONNECT_RETRY_SYMBOL            = 298
	MySQLParserMASTER_DELAY_SYMBOL                    = 299
	MySQLParserMASTER_HOST_SYMBOL                     = 300
	MySQLParserMASTER_LOG_FILE_SYMBOL                 = 301
	MySQLParserMASTER_LOG_POS_SYMBOL                  = 302
	MySQLParserMASTER_PASSWORD_SYMBOL                 = 303
	MySQLParserMASTER_PORT_SYMBOL                     = 304
	MySQLParserMASTER_RETRY_COUNT_SYMBOL              = 305
	MySQLParserMASTER_SERVER_ID_SYMBOL                = 306
	MySQLParserMASTER_SSL_CAPATH_SYMBOL               = 307
	MySQLParserMASTER_SSL_CA_SYMBOL                   = 308
	MySQLParserMASTER_SSL_CERT_SYMBOL                 = 309
	MySQLParserMASTER_SSL_CIPHER_SYMBOL               = 310
	MySQLParserMASTER_SSL_CRL_SYMBOL                  = 311
	MySQLParserMASTER_SSL_CRLPATH_SYMBOL              = 312
	MySQLParserMASTER_SSL_KEY_SYMBOL                  = 313
	MySQLParserMASTER_SSL_SYMBOL                      = 314
	MySQLParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL   = 315
	MySQLParserMASTER_SYMBOL                          = 316
	MySQLParserMASTER_TLS_VERSION_SYMBOL              = 317
	MySQLParserMASTER_USER_SYMBOL                     = 318
	MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL         = 319
	MySQLParserMATCH_SYMBOL                           = 320
	MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL        = 321
	MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL            = 322
	MySQLParserMAX_ROWS_SYMBOL                        = 323
	MySQLParserMAX_SIZE_SYMBOL                        = 324
	MySQLParserMAX_STATEMENT_TIME_SYMBOL              = 325
	MySQLParserMAX_SYMBOL                             = 326
	MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL            = 327
	MySQLParserMAX_USER_CONNECTIONS_SYMBOL            = 328
	MySQLParserMAXVALUE_SYMBOL                        = 329
	MySQLParserMEDIUMBLOB_SYMBOL                      = 330
	MySQLParserMEDIUMINT_SYMBOL                       = 331
	MySQLParserMEDIUMTEXT_SYMBOL                      = 332
	MySQLParserMEDIUM_SYMBOL                          = 333
	MySQLParserMEMORY_SYMBOL                          = 334
	MySQLParserMERGE_SYMBOL                           = 335
	MySQLParserMESSAGE_TEXT_SYMBOL                    = 336
	MySQLParserMICROSECOND_SYMBOL                     = 337
	MySQLParserMID_SYMBOL                             = 338
	MySQLParserMIDDLEINT_SYMBOL                       = 339
	MySQLParserMIGRATE_SYMBOL                         = 340
	MySQLParserMINUTE_MICROSECOND_SYMBOL              = 341
	MySQLParserMINUTE_SECOND_SYMBOL                   = 342
	MySQLParserMINUTE_SYMBOL                          = 343
	MySQLParserMIN_ROWS_SYMBOL                        = 344
	MySQLParserMIN_SYMBOL                             = 345
	MySQLParserMODE_SYMBOL                            = 346
	MySQLParserMODIFIES_SYMBOL                        = 347
	MySQLParserMODIFY_SYMBOL                          = 348
	MySQLParserMOD_SYMBOL                             = 349
	MySQLParserMONTH_SYMBOL                           = 350
	MySQLParserMULTILINESTRING_SYMBOL                 = 351
	MySQLParserMULTIPOINT_SYMBOL                      = 352
	MySQLParserMULTIPOLYGON_SYMBOL                    = 353
	MySQLParserMUTEX_SYMBOL                           = 354
	MySQLParserMYSQL_ERRNO_SYMBOL                     = 355
	MySQLParserNAMES_SYMBOL                           = 356
	MySQLParserNAME_SYMBOL                            = 357
	MySQLParserNATIONAL_SYMBOL                        = 358
	MySQLParserNATURAL_SYMBOL                         = 359
	MySQLParserNCHAR_STRING_SYMBOL                    = 360
	MySQLParserNCHAR_SYMBOL                           = 361
	MySQLParserNDB_SYMBOL                             = 362
	MySQLParserNDBCLUSTER_SYMBOL                      = 363
	MySQLParserNEG_SYMBOL                             = 364
	MySQLParserNEVER_SYMBOL                           = 365
	MySQLParserNEW_SYMBOL                             = 366
	MySQLParserNEXT_SYMBOL                            = 367
	MySQLParserNODEGROUP_SYMBOL                       = 368
	MySQLParserNONE_SYMBOL                            = 369
	MySQLParserNONBLOCKING_SYMBOL                     = 370
	MySQLParserNOT_SYMBOL                             = 371
	MySQLParserNOW_SYMBOL                             = 372
	MySQLParserNO_SYMBOL                              = 373
	MySQLParserNO_WAIT_SYMBOL                         = 374
	MySQLParserNO_WRITE_TO_BINLOG_SYMBOL              = 375
	MySQLParserNULL_SYMBOL                            = 376
	MySQLParserNUMBER_SYMBOL                          = 377
	MySQLParserNUMERIC_SYMBOL                         = 378
	MySQLParserNVARCHAR_SYMBOL                        = 379
	MySQLParserOFFLINE_SYMBOL                         = 380
	MySQLParserOFFSET_SYMBOL                          = 381
	MySQLParserOLD_PASSWORD_SYMBOL                    = 382
	MySQLParserON_SYMBOL                              = 383
	MySQLParserONE_SYMBOL                             = 384
	MySQLParserONLINE_SYMBOL                          = 385
	MySQLParserONLY_SYMBOL                            = 386
	MySQLParserOPEN_SYMBOL                            = 387
	MySQLParserOPTIMIZE_SYMBOL                        = 388
	MySQLParserOPTIMIZER_COSTS_SYMBOL                 = 389
	MySQLParserOPTIONS_SYMBOL                         = 390
	MySQLParserOPTION_SYMBOL                          = 391
	MySQLParserOPTIONALLY_SYMBOL                      = 392
	MySQLParserORDER_SYMBOL                           = 393
	MySQLParserOR_SYMBOL                              = 394
	MySQLParserOUTER_SYMBOL                           = 395
	MySQLParserOUTFILE_SYMBOL                         = 396
	MySQLParserOUT_SYMBOL                             = 397
	MySQLParserOWNER_SYMBOL                           = 398
	MySQLParserPACK_KEYS_SYMBOL                       = 399
	MySQLParserPAGE_SYMBOL                            = 400
	MySQLParserPARSER_SYMBOL                          = 401
	MySQLParserPARTIAL_SYMBOL                         = 402
	MySQLParserPARTITIONING_SYMBOL                    = 403
	MySQLParserPARTITIONS_SYMBOL                      = 404
	MySQLParserPARTITION_SYMBOL                       = 405
	MySQLParserPASSWORD_SYMBOL                        = 406
	MySQLParserPHASE_SYMBOL                           = 407
	MySQLParserPLUGINS_SYMBOL                         = 408
	MySQLParserPLUGIN_DIR_SYMBOL                      = 409
	MySQLParserPLUGIN_SYMBOL                          = 410
	MySQLParserPOINT_SYMBOL                           = 411
	MySQLParserPOLYGON_SYMBOL                         = 412
	MySQLParserPORT_SYMBOL                            = 413
	MySQLParserPOSITION_SYMBOL                        = 414
	MySQLParserPRECEDES_SYMBOL                        = 415
	MySQLParserPRECISION_SYMBOL                       = 416
	MySQLParserPREPARE_SYMBOL                         = 417
	MySQLParserPRESERVE_SYMBOL                        = 418
	MySQLParserPREV_SYMBOL                            = 419
	MySQLParserPRIMARY_SYMBOL                         = 420
	MySQLParserPRIVILEGES_SYMBOL                      = 421
	MySQLParserPROCEDURE_SYMBOL                       = 422
	MySQLParserPROCESS_SYMBOL                         = 423
	MySQLParserPROCESSLIST_SYMBOL                     = 424
	MySQLParserPROFILE_SYMBOL                         = 425
	MySQLParserPROFILES_SYMBOL                        = 426
	MySQLParserPROXY_SYMBOL                           = 427
	MySQLParserPURGE_SYMBOL                           = 428
	MySQLParserQUARTER_SYMBOL                         = 429
	MySQLParserQUERY_SYMBOL                           = 430
	MySQLParserQUICK_SYMBOL                           = 431
	MySQLParserRANGE_SYMBOL                           = 432
	MySQLParserREADS_SYMBOL                           = 433
	MySQLParserREAD_ONLY_SYMBOL                       = 434
	MySQLParserREAD_SYMBOL                            = 435
	MySQLParserREAD_WRITE_SYMBOL                      = 436
	MySQLParserREAL_SYMBOL                            = 437
	MySQLParserREBUILD_SYMBOL                         = 438
	MySQLParserRECOVER_SYMBOL                         = 439
	MySQLParserREDOFILE_SYMBOL                        = 440
	MySQLParserREDO_BUFFER_SIZE_SYMBOL                = 441
	MySQLParserREDUNDANT_SYMBOL                       = 442
	MySQLParserREFERENCES_SYMBOL                      = 443
	MySQLParserREGEXP_SYMBOL                          = 444
	MySQLParserRELAY_SYMBOL                           = 445
	MySQLParserRELAYLOG_SYMBOL                        = 446
	MySQLParserRELAY_LOG_FILE_SYMBOL                  = 447
	MySQLParserRELAY_LOG_POS_SYMBOL                   = 448
	MySQLParserRELAY_THREAD_SYMBOL                    = 449
	MySQLParserRELEASE_SYMBOL                         = 450
	MySQLParserRELOAD_SYMBOL                          = 451
	MySQLParserREMOVE_SYMBOL                          = 452
	MySQLParserRENAME_SYMBOL                          = 453
	MySQLParserREORGANIZE_SYMBOL                      = 454
	MySQLParserREPAIR_SYMBOL                          = 455
	MySQLParserREPEATABLE_SYMBOL                      = 456
	MySQLParserREPEAT_SYMBOL                          = 457
	MySQLParserREPLACE_SYMBOL                         = 458
	MySQLParserREPLICATION_SYMBOL                     = 459
	MySQLParserREPLICATE_DO_DB_SYMBOL                 = 460
	MySQLParserREPLICATE_IGNORE_DB_SYMBOL             = 461
	MySQLParserREPLICATE_DO_TABLE_SYMBOL              = 462
	MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL          = 463
	MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL         = 464
	MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL     = 465
	MySQLParserREPLICATE_REWRITE_DB_SYMBOL            = 466
	MySQLParserREQUIRE_SYMBOL                         = 467
	MySQLParserRESET_SYMBOL                           = 468
	MySQLParserRESIGNAL_SYMBOL                        = 469
	MySQLParserRESTORE_SYMBOL                         = 470
	MySQLParserRESTRICT_SYMBOL                        = 471
	MySQLParserRESUME_SYMBOL                          = 472
	MySQLParserRETURNED_SQLSTATE_SYMBOL               = 473
	MySQLParserRETURNS_SYMBOL                         = 474
	MySQLParserRETURN_SYMBOL                          = 475
	MySQLParserREVERSE_SYMBOL                         = 476
	MySQLParserREVOKE_SYMBOL                          = 477
	MySQLParserRIGHT_SYMBOL                           = 478
	MySQLParserRLIKE_SYMBOL                           = 479
	MySQLParserROLLBACK_SYMBOL                        = 480
	MySQLParserROLLUP_SYMBOL                          = 481
	MySQLParserROTATE_SYMBOL                          = 482
	MySQLParserROUTINE_SYMBOL                         = 483
	MySQLParserROWS_SYMBOL                            = 484
	MySQLParserROW_COUNT_SYMBOL                       = 485
	MySQLParserROW_FORMAT_SYMBOL                      = 486
	MySQLParserROW_SYMBOL                             = 487
	MySQLParserRTREE_SYMBOL                           = 488
	MySQLParserSAVEPOINT_SYMBOL                       = 489
	MySQLParserSCHEDULE_SYMBOL                        = 490
	MySQLParserSCHEMA_SYMBOL                          = 491
	MySQLParserSCHEMA_NAME_SYMBOL                     = 492
	MySQLParserSCHEMAS_SYMBOL                         = 493
	MySQLParserSECOND_MICROSECOND_SYMBOL              = 494
	MySQLParserSECOND_SYMBOL                          = 495
	MySQLParserSECURITY_SYMBOL                        = 496
	MySQLParserSELECT_SYMBOL                          = 497
	MySQLParserSENSITIVE_SYMBOL                       = 498
	MySQLParserSEPARATOR_SYMBOL                       = 499
	MySQLParserSERIALIZABLE_SYMBOL                    = 500
	MySQLParserSERIAL_SYMBOL                          = 501
	MySQLParserSESSION_SYMBOL                         = 502
	MySQLParserSERVER_SYMBOL                          = 503
	MySQLParserSERVER_OPTIONS_SYMBOL                  = 504
	MySQLParserSESSION_USER_SYMBOL                    = 505
	MySQLParserSET_SYMBOL                             = 506
	MySQLParserSET_VAR_SYMBOL                         = 507
	MySQLParserSHARE_SYMBOL                           = 508
	MySQLParserSHOW_SYMBOL                            = 509
	MySQLParserSHUTDOWN_SYMBOL                        = 510
	MySQLParserSIGNAL_SYMBOL                          = 511
	MySQLParserSIGNED_SYMBOL                          = 512
	MySQLParserSIMPLE_SYMBOL                          = 513
	MySQLParserSLAVE_SYMBOL                           = 514
	MySQLParserSLOW_SYMBOL                            = 515
	MySQLParserSMALLINT_SYMBOL                        = 516
	MySQLParserSNAPSHOT_SYMBOL                        = 517
	MySQLParserSOME_SYMBOL                            = 518
	MySQLParserSOCKET_SYMBOL                          = 519
	MySQLParserSONAME_SYMBOL                          = 520
	MySQLParserSOUNDS_SYMBOL                          = 521
	MySQLParserSOURCE_SYMBOL                          = 522
	MySQLParserSPATIAL_SYMBOL                         = 523
	MySQLParserSPECIFIC_SYMBOL                        = 524
	MySQLParserSQLEXCEPTION_SYMBOL                    = 525
	MySQLParserSQLSTATE_SYMBOL                        = 526
	MySQLParserSQLWARNING_SYMBOL                      = 527
	MySQLParserSQL_AFTER_GTIDS_SYMBOL                 = 528
	MySQLParserSQL_AFTER_MTS_GAPS_SYMBOL              = 529
	MySQLParserSQL_BEFORE_GTIDS_SYMBOL                = 530
	MySQLParserSQL_BIG_RESULT_SYMBOL                  = 531
	MySQLParserSQL_BUFFER_RESULT_SYMBOL               = 532
	MySQLParserSQL_CACHE_SYMBOL                       = 533
	MySQLParserSQL_CALC_FOUND_ROWS_SYMBOL             = 534
	MySQLParserSQL_NO_CACHE_SYMBOL                    = 535
	MySQLParserSQL_SMALL_RESULT_SYMBOL                = 536
	MySQLParserSQL_SYMBOL                             = 537
	MySQLParserSQL_THREAD_SYMBOL                      = 538
	MySQLParserSSL_SYMBOL                             = 539
	MySQLParserSTACKED_SYMBOL                         = 540
	MySQLParserSTARTING_SYMBOL                        = 541
	MySQLParserSTARTS_SYMBOL                          = 542
	MySQLParserSTART_SYMBOL                           = 543
	MySQLParserSTATS_AUTO_RECALC_SYMBOL               = 544
	MySQLParserSTATS_PERSISTENT_SYMBOL                = 545
	MySQLParserSTATS_SAMPLE_PAGES_SYMBOL              = 546
	MySQLParserSTATUS_SYMBOL                          = 547
	MySQLParserSTDDEV_SAMP_SYMBOL                     = 548
	MySQLParserSTDDEV_SYMBOL                          = 549
	MySQLParserSTDDEV_POP_SYMBOL                      = 550
	MySQLParserSTD_SYMBOL                             = 551
	MySQLParserSTOP_SYMBOL                            = 552
	MySQLParserSTORAGE_SYMBOL                         = 553
	MySQLParserSTORED_SYMBOL                          = 554
	MySQLParserSTRAIGHT_JOIN_SYMBOL                   = 555
	MySQLParserSTRING_SYMBOL                          = 556
	MySQLParserSUBCLASS_ORIGIN_SYMBOL                 = 557
	MySQLParserSUBDATE_SYMBOL                         = 558
	MySQLParserSUBJECT_SYMBOL                         = 559
	MySQLParserSUBPARTITIONS_SYMBOL                   = 560
	MySQLParserSUBPARTITION_SYMBOL                    = 561
	MySQLParserSUBSTR_SYMBOL                          = 562
	MySQLParserSUBSTRING_SYMBOL                       = 563
	MySQLParserSUM_SYMBOL                             = 564
	MySQLParserSUPER_SYMBOL                           = 565
	MySQLParserSUSPEND_SYMBOL                         = 566
	MySQLParserSWAPS_SYMBOL                           = 567
	MySQLParserSWITCHES_SYMBOL                        = 568
	MySQLParserSYSDATE_SYMBOL                         = 569
	MySQLParserSYSTEM_USER_SYMBOL                     = 570
	MySQLParserTABLES_SYMBOL                          = 571
	MySQLParserTABLESPACE_SYMBOL                      = 572
	MySQLParserTABLE_REF_PRIORITY_SYMBOL              = 573
	MySQLParserTABLE_SYMBOL                           = 574
	MySQLParserTABLE_CHECKSUM_SYMBOL                  = 575
	MySQLParserTABLE_NAME_SYMBOL                      = 576
	MySQLParserTEMPORARY_SYMBOL                       = 577
	MySQLParserTEMPTABLE_SYMBOL                       = 578
	MySQLParserTERMINATED_SYMBOL                      = 579
	MySQLParserTEXT_SYMBOL                            = 580
	MySQLParserTHAN_SYMBOL                            = 581
	MySQLParserTHEN_SYMBOL                            = 582
	MySQLParserTIMESTAMP_SYMBOL                       = 583
	MySQLParserTIMESTAMP_ADD_SYMBOL                   = 584
	MySQLParserTIMESTAMP_DIFF_SYMBOL                  = 585
	MySQLParserTIME_SYMBOL                            = 586
	MySQLParserTINYBLOB_SYMBOL                        = 587
	MySQLParserTINYINT_SYMBOL                         = 588
	MySQLParserTINYTEXT_SYMBOL                        = 589
	MySQLParserTO_SYMBOL                              = 590
	MySQLParserTRAILING_SYMBOL                        = 591
	MySQLParserTRANSACTION_SYMBOL                     = 592
	MySQLParserTRIGGERS_SYMBOL                        = 593
	MySQLParserTRIGGER_SYMBOL                         = 594
	MySQLParserTRIM_SYMBOL                            = 595
	MySQLParserTRUE_SYMBOL                            = 596
	MySQLParserTRUNCATE_SYMBOL                        = 597
	MySQLParserTYPES_SYMBOL                           = 598
	MySQLParserTYPE_SYMBOL                            = 599
	MySQLParserUDF_RETURNS_SYMBOL                     = 600
	MySQLParserUNCOMMITTED_SYMBOL                     = 601
	MySQLParserUNDEFINED_SYMBOL                       = 602
	MySQLParserUNDOFILE_SYMBOL                        = 603
	MySQLParserUNDO_BUFFER_SIZE_SYMBOL                = 604
	MySQLParserUNDO_SYMBOL                            = 605
	MySQLParserUNICODE_SYMBOL                         = 606
	MySQLParserUNINSTALL_SYMBOL                       = 607
	MySQLParserUNION_SYMBOL                           = 608
	MySQLParserUNIQUE_SYMBOL                          = 609
	MySQLParserUNKNOWN_SYMBOL                         = 610
	MySQLParserUNLOCK_SYMBOL                          = 611
	MySQLParserUNSIGNED_SYMBOL                        = 612
	MySQLParserUNTIL_SYMBOL                           = 613
	MySQLParserUPDATE_SYMBOL                          = 614
	MySQLParserUPGRADE_SYMBOL                         = 615
	MySQLParserUSAGE_SYMBOL                           = 616
	MySQLParserUSER_RESOURCES_SYMBOL                  = 617
	MySQLParserUSER_SYMBOL                            = 618
	MySQLParserUSE_FRM_SYMBOL                         = 619
	MySQLParserUSE_SYMBOL                             = 620
	MySQLParserUSING_SYMBOL                           = 621
	MySQLParserUTC_DATE_SYMBOL                        = 622
	MySQLParserUTC_TIMESTAMP_SYMBOL                   = 623
	MySQLParserUTC_TIME_SYMBOL                        = 624
	MySQLParserVALIDATION_SYMBOL                      = 625
	MySQLParserVALUES_SYMBOL                          = 626
	MySQLParserVALUE_SYMBOL                           = 627
	MySQLParserVARBINARY_SYMBOL                       = 628
	MySQLParserVARCHAR_SYMBOL                         = 629
	MySQLParserVARCHARACTER_SYMBOL                    = 630
	MySQLParserVARIABLES_SYMBOL                       = 631
	MySQLParserVARIANCE_SYMBOL                        = 632
	MySQLParserVARYING_SYMBOL                         = 633
	MySQLParserVAR_POP_SYMBOL                         = 634
	MySQLParserVAR_SAMP_SYMBOL                        = 635
	MySQLParserVIEW_SYMBOL                            = 636
	MySQLParserVIRTUAL_SYMBOL                         = 637
	MySQLParserWAIT_SYMBOL                            = 638
	MySQLParserWARNINGS_SYMBOL                        = 639
	MySQLParserWEEK_SYMBOL                            = 640
	MySQLParserWEIGHT_STRING_SYMBOL                   = 641
	MySQLParserWHEN_SYMBOL                            = 642
	MySQLParserWHERE_SYMBOL                           = 643
	MySQLParserWHILE_SYMBOL                           = 644
	MySQLParserWITH_SYMBOL                            = 645
	MySQLParserWITHOUT_SYMBOL                         = 646
	MySQLParserWORK_SYMBOL                            = 647
	MySQLParserWRAPPER_SYMBOL                         = 648
	MySQLParserWRITE_SYMBOL                           = 649
	MySQLParserX509_SYMBOL                            = 650
	MySQLParserXA_SYMBOL                              = 651
	MySQLParserXID_SYMBOL                             = 652
	MySQLParserXML_SYMBOL                             = 653
	MySQLParserXOR_SYMBOL                             = 654
	MySQLParserYEAR_MONTH_SYMBOL                      = 655
	MySQLParserYEAR_SYMBOL                            = 656
	MySQLParserZEROFILL_SYMBOL                        = 657
	MySQLParserPERSIST_SYMBOL                         = 658
	MySQLParserROLE_SYMBOL                            = 659
	MySQLParserADMIN_SYMBOL                           = 660
	MySQLParserINVISIBLE_SYMBOL                       = 661
	MySQLParserVISIBLE_SYMBOL                         = 662
	MySQLParserEXCEPT_SYMBOL                          = 663
	MySQLParserCOMPONENT_SYMBOL                       = 664
	MySQLParserRECURSIVE_SYMBOL                       = 665
	MySQLParserJSON_OBJECTAGG_SYMBOL                  = 666
	MySQLParserJSON_ARRAYAGG_SYMBOL                   = 667
	MySQLParserOF_SYMBOL                              = 668
	MySQLParserSKIP_SYMBOL                            = 669
	MySQLParserLOCKED_SYMBOL                          = 670
	MySQLParserNOWAIT_SYMBOL                          = 671
	MySQLParserGROUPING_SYMBOL                        = 672
	MySQLParserPERSIST_ONLY_SYMBOL                    = 673
	MySQLParserHISTOGRAM_SYMBOL                       = 674
	MySQLParserBUCKETS_SYMBOL                         = 675
	MySQLParserREMOTE_SYMBOL                          = 676
	MySQLParserCLONE_SYMBOL                           = 677
	MySQLParserCUME_DIST_SYMBOL                       = 678
	MySQLParserDENSE_RANK_SYMBOL                      = 679
	MySQLParserEXCLUDE_SYMBOL                         = 680
	MySQLParserFIRST_VALUE_SYMBOL                     = 681
	MySQLParserFOLLOWING_SYMBOL                       = 682
	MySQLParserGROUPS_SYMBOL                          = 683
	MySQLParserLAG_SYMBOL                             = 684
	MySQLParserLAST_VALUE_SYMBOL                      = 685
	MySQLParserLEAD_SYMBOL                            = 686
	MySQLParserNTH_VALUE_SYMBOL                       = 687
	MySQLParserNTILE_SYMBOL                           = 688
	MySQLParserNULLS_SYMBOL                           = 689
	MySQLParserOTHERS_SYMBOL                          = 690
	MySQLParserOVER_SYMBOL                            = 691
	MySQLParserPERCENT_RANK_SYMBOL                    = 692
	MySQLParserPRECEDING_SYMBOL                       = 693
	MySQLParserRANK_SYMBOL                            = 694
	MySQLParserRESPECT_SYMBOL                         = 695
	MySQLParserROW_NUMBER_SYMBOL                      = 696
	MySQLParserTIES_SYMBOL                            = 697
	MySQLParserUNBOUNDED_SYMBOL                       = 698
	MySQLParserWINDOW_SYMBOL                          = 699
	MySQLParserEMPTY_SYMBOL                           = 700
	MySQLParserJSON_TABLE_SYMBOL                      = 701
	MySQLParserNESTED_SYMBOL                          = 702
	MySQLParserORDINALITY_SYMBOL                      = 703
	MySQLParserPATH_SYMBOL                            = 704
	MySQLParserHISTORY_SYMBOL                         = 705
	MySQLParserREUSE_SYMBOL                           = 706
	MySQLParserSRID_SYMBOL                            = 707
	MySQLParserTHREAD_PRIORITY_SYMBOL                 = 708
	MySQLParserRESOURCE_SYMBOL                        = 709
	MySQLParserSYSTEM_SYMBOL                          = 710
	MySQLParserVCPU_SYMBOL                            = 711
	MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL          = 712
	MySQLParserGET_MASTER_PUBLIC_KEY_SYMBOL           = 713
	MySQLParserRESTART_SYMBOL                         = 714
	MySQLParserDEFINITION_SYMBOL                      = 715
	MySQLParserDESCRIPTION_SYMBOL                     = 716
	MySQLParserORGANIZATION_SYMBOL                    = 717
	MySQLParserREFERENCE_SYMBOL                       = 718
	MySQLParserOPTIONAL_SYMBOL                        = 719
	MySQLParserSECONDARY_SYMBOL                       = 720
	MySQLParserSECONDARY_ENGINE_SYMBOL                = 721
	MySQLParserSECONDARY_LOAD_SYMBOL                  = 722
	MySQLParserSECONDARY_UNLOAD_SYMBOL                = 723
	MySQLParserACTIVE_SYMBOL                          = 724
	MySQLParserINACTIVE_SYMBOL                        = 725
	MySQLParserLATERAL_SYMBOL                         = 726
	MySQLParserRETAIN_SYMBOL                          = 727
	MySQLParserOLD_SYMBOL                             = 728
	MySQLParserNETWORK_NAMESPACE_SYMBOL               = 729
	MySQLParserENFORCED_SYMBOL                        = 730
	MySQLParserARRAY_SYMBOL                           = 731
	MySQLParserOJ_SYMBOL                              = 732
	MySQLParserMEMBER_SYMBOL                          = 733
	MySQLParserRANDOM_SYMBOL                          = 734
	MySQLParserMASTER_COMPRESSION_ALGORITHM_SYMBOL    = 735
	MySQLParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL   = 736
	MySQLParserPRIVILEGE_CHECKS_USER_SYMBOL           = 737
	MySQLParserMASTER_TLS_CIPHERSUITES_SYMBOL         = 738
	MySQLParserREQUIRE_ROW_FORMAT_SYMBOL              = 739
	MySQLParserPASSWORD_LOCK_TIME_SYMBOL              = 740
	MySQLParserFAILED_LOGIN_ATTEMPTS_SYMBOL           = 741
	MySQLParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL = 742
	MySQLParserSTREAM_SYMBOL                          = 743
	MySQLParserOFF_SYMBOL                             = 744
	MySQLParserNOT2_SYMBOL                            = 745
	MySQLParserCONCAT_PIPES_SYMBOL                    = 746
	MySQLParserINT_NUMBER                             = 747
	MySQLParserLONG_NUMBER                            = 748
	MySQLParserULONGLONG_NUMBER                       = 749
	MySQLParserEQUAL_OPERATOR                         = 750
	MySQLParserASSIGN_OPERATOR                        = 751
	MySQLParserNULL_SAFE_EQUAL_OPERATOR               = 752
	MySQLParserGREATER_OR_EQUAL_OPERATOR              = 753
	MySQLParserGREATER_THAN_OPERATOR                  = 754
	MySQLParserLESS_OR_EQUAL_OPERATOR                 = 755
	MySQLParserLESS_THAN_OPERATOR                     = 756
	MySQLParserNOT_EQUAL_OPERATOR                     = 757
	MySQLParserPLUS_OPERATOR                          = 758
	MySQLParserMINUS_OPERATOR                         = 759
	MySQLParserMULT_OPERATOR                          = 760
	MySQLParserDIV_OPERATOR                           = 761
	MySQLParserMOD_OPERATOR                           = 762
	MySQLParserLOGICAL_NOT_OPERATOR                   = 763
	MySQLParserBITWISE_NOT_OPERATOR                   = 764
	MySQLParserSHIFT_LEFT_OPERATOR                    = 765
	MySQLParserSHIFT_RIGHT_OPERATOR                   = 766
	MySQLParserLOGICAL_AND_OPERATOR                   = 767
	MySQLParserBITWISE_AND_OPERATOR                   = 768
	MySQLParserBITWISE_XOR_OPERATOR                   = 769
	MySQLParserLOGICAL_OR_OPERATOR                    = 770
	MySQLParserBITWISE_OR_OPERATOR                    = 771
	MySQLParserDOT_SYMBOL                             = 772
	MySQLParserCOMMA_SYMBOL                           = 773
	MySQLParserSEMICOLON_SYMBOL                       = 774
	MySQLParserCOLON_SYMBOL                           = 775
	MySQLParserOPEN_PAR_SYMBOL                        = 776
	MySQLParserCLOSE_PAR_SYMBOL                       = 777
	MySQLParserOPEN_CURLY_SYMBOL                      = 778
	MySQLParserCLOSE_CURLY_SYMBOL                     = 779
	MySQLParserUNDERLINE_SYMBOL                       = 780
	MySQLParserJSON_SEPARATOR_SYMBOL                  = 781
	MySQLParserJSON_UNQUOTED_SEPARATOR_SYMBOL         = 782
	MySQLParserAT_SIGN_SYMBOL                         = 783
	MySQLParserAT_TEXT_SUFFIX                         = 784
	MySQLParserAT_AT_SIGN_SYMBOL                      = 785
	MySQLParserNULL2_SYMBOL                           = 786
	MySQLParserPARAM_MARKER                           = 787
	MySQLParserHEX_NUMBER                             = 788
	MySQLParserBIN_NUMBER                             = 789
	MySQLParserDECIMAL_NUMBER                         = 790
	MySQLParserFLOAT_NUMBER                           = 791
	MySQLParserWHITESPACE                             = 792
	MySQLParserINVALID_INPUT                          = 793
	MySQLParserUNDERSCORE_CHARSET                     = 794
	MySQLParserIDENTIFIER                             = 795
	MySQLParserNCHAR_TEXT                             = 796
	MySQLParserBACK_TICK_QUOTED_ID                    = 797
	MySQLParserDOUBLE_QUOTED_TEXT                     = 798
	MySQLParserSINGLE_QUOTED_TEXT                     = 799
	MySQLParserVERSION_COMMENT_START                  = 800
	MySQLParserMYSQL_COMMENT_START                    = 801
	MySQLParserVERSION_COMMENT_END                    = 802
	MySQLParserBLOCK_COMMENT                          = 803
	MySQLParserPOUND_COMMENT                          = 804
	MySQLParserDASHDASH_COMMENT                       = 805
	MySQLParserNOT_EQUAL2_OPERATOR                    = 806
)

// MySQLParser rules.
const (
	MySQLParserRULE_query                                       = 0
	MySQLParserRULE_simpleStatement                             = 1
	MySQLParserRULE_alterStatement                              = 2
	MySQLParserRULE_alterDatabase                               = 3
	MySQLParserRULE_alterEvent                                  = 4
	MySQLParserRULE_alterLogfileGroup                           = 5
	MySQLParserRULE_alterLogfileGroupOptions                    = 6
	MySQLParserRULE_alterLogfileGroupOption                     = 7
	MySQLParserRULE_alterServer                                 = 8
	MySQLParserRULE_alterTable                                  = 9
	MySQLParserRULE_alterTableActions                           = 10
	MySQLParserRULE_alterCommandList                            = 11
	MySQLParserRULE_alterCommandsModifierList                   = 12
	MySQLParserRULE_standaloneAlterCommands                     = 13
	MySQLParserRULE_alterPartition                              = 14
	MySQLParserRULE_alterList                                   = 15
	MySQLParserRULE_alterCommandsModifier                       = 16
	MySQLParserRULE_alterListItem                               = 17
	MySQLParserRULE_place                                       = 18
	MySQLParserRULE_restrict                                    = 19
	MySQLParserRULE_alterOrderList                              = 20
	MySQLParserRULE_alterAlgorithmOption                        = 21
	MySQLParserRULE_alterLockOption                             = 22
	MySQLParserRULE_indexLockAndAlgorithm                       = 23
	MySQLParserRULE_withValidation                              = 24
	MySQLParserRULE_removePartitioning                          = 25
	MySQLParserRULE_allOrPartitionNameList                      = 26
	MySQLParserRULE_alterTablespace                             = 27
	MySQLParserRULE_alterUndoTablespace                         = 28
	MySQLParserRULE_undoTableSpaceOptions                       = 29
	MySQLParserRULE_undoTableSpaceOption                        = 30
	MySQLParserRULE_alterTablespaceOptions                      = 31
	MySQLParserRULE_alterTablespaceOption                       = 32
	MySQLParserRULE_changeTablespaceOption                      = 33
	MySQLParserRULE_alterView                                   = 34
	MySQLParserRULE_viewTail                                    = 35
	MySQLParserRULE_viewSelect                                  = 36
	MySQLParserRULE_viewCheckOption                             = 37
	MySQLParserRULE_createStatement                             = 38
	MySQLParserRULE_createDatabase                              = 39
	MySQLParserRULE_createDatabaseOption                        = 40
	MySQLParserRULE_createTable                                 = 41
	MySQLParserRULE_tableElementList                            = 42
	MySQLParserRULE_tableElement                                = 43
	MySQLParserRULE_duplicateAsQueryExpression                  = 44
	MySQLParserRULE_queryExpressionOrParens                     = 45
	MySQLParserRULE_createRoutine                               = 46
	MySQLParserRULE_createProcedure                             = 47
	MySQLParserRULE_createFunction                              = 48
	MySQLParserRULE_createUdf                                   = 49
	MySQLParserRULE_routineCreateOption                         = 50
	MySQLParserRULE_routineAlterOptions                         = 51
	MySQLParserRULE_routineOption                               = 52
	MySQLParserRULE_createIndex                                 = 53
	MySQLParserRULE_indexNameAndType                            = 54
	MySQLParserRULE_createIndexTarget                           = 55
	MySQLParserRULE_createLogfileGroup                          = 56
	MySQLParserRULE_logfileGroupOptions                         = 57
	MySQLParserRULE_logfileGroupOption                          = 58
	MySQLParserRULE_createServer                                = 59
	MySQLParserRULE_serverOptions                               = 60
	MySQLParserRULE_serverOption                                = 61
	MySQLParserRULE_createTablespace                            = 62
	MySQLParserRULE_createUndoTablespace                        = 63
	MySQLParserRULE_tsDataFileName                              = 64
	MySQLParserRULE_tsDataFile                                  = 65
	MySQLParserRULE_tablespaceOptions                           = 66
	MySQLParserRULE_tablespaceOption                            = 67
	MySQLParserRULE_tsOptionInitialSize                         = 68
	MySQLParserRULE_tsOptionUndoRedoBufferSize                  = 69
	MySQLParserRULE_tsOptionAutoextendSize                      = 70
	MySQLParserRULE_tsOptionMaxSize                             = 71
	MySQLParserRULE_tsOptionExtentSize                          = 72
	MySQLParserRULE_tsOptionNodegroup                           = 73
	MySQLParserRULE_tsOptionEngine                              = 74
	MySQLParserRULE_tsOptionWait                                = 75
	MySQLParserRULE_tsOptionComment                             = 76
	MySQLParserRULE_tsOptionFileblockSize                       = 77
	MySQLParserRULE_tsOptionEncryption                          = 78
	MySQLParserRULE_createView                                  = 79
	MySQLParserRULE_viewReplaceOrAlgorithm                      = 80
	MySQLParserRULE_viewAlgorithm                               = 81
	MySQLParserRULE_viewSuid                                    = 82
	MySQLParserRULE_createTrigger                               = 83
	MySQLParserRULE_triggerFollowsPrecedesClause                = 84
	MySQLParserRULE_createEvent                                 = 85
	MySQLParserRULE_createRole                                  = 86
	MySQLParserRULE_createSpatialReference                      = 87
	MySQLParserRULE_srsAttribute                                = 88
	MySQLParserRULE_dropStatement                               = 89
	MySQLParserRULE_dropDatabase                                = 90
	MySQLParserRULE_dropEvent                                   = 91
	MySQLParserRULE_dropFunction                                = 92
	MySQLParserRULE_dropProcedure                               = 93
	MySQLParserRULE_dropIndex                                   = 94
	MySQLParserRULE_dropLogfileGroup                            = 95
	MySQLParserRULE_dropLogfileGroupOption                      = 96
	MySQLParserRULE_dropServer                                  = 97
	MySQLParserRULE_dropTable                                   = 98
	MySQLParserRULE_dropTableSpace                              = 99
	MySQLParserRULE_dropTrigger                                 = 100
	MySQLParserRULE_dropView                                    = 101
	MySQLParserRULE_dropRole                                    = 102
	MySQLParserRULE_dropSpatialReference                        = 103
	MySQLParserRULE_dropUndoTablespace                          = 104
	MySQLParserRULE_renameTableStatement                        = 105
	MySQLParserRULE_renamePair                                  = 106
	MySQLParserRULE_truncateTableStatement                      = 107
	MySQLParserRULE_importStatement                             = 108
	MySQLParserRULE_callStatement                               = 109
	MySQLParserRULE_deleteStatement                             = 110
	MySQLParserRULE_partitionDelete                             = 111
	MySQLParserRULE_deleteStatementOption                       = 112
	MySQLParserRULE_doStatement                                 = 113
	MySQLParserRULE_handlerStatement                            = 114
	MySQLParserRULE_handlerReadOrScan                           = 115
	MySQLParserRULE_insertStatement                             = 116
	MySQLParserRULE_insertLockOption                            = 117
	MySQLParserRULE_insertFromConstructor                       = 118
	MySQLParserRULE_fields                                      = 119
	MySQLParserRULE_insertValues                                = 120
	MySQLParserRULE_insertQueryExpression                       = 121
	MySQLParserRULE_valueList                                   = 122
	MySQLParserRULE_values                                      = 123
	MySQLParserRULE_valuesReference                             = 124
	MySQLParserRULE_insertUpdateList                            = 125
	MySQLParserRULE_loadStatement                               = 126
	MySQLParserRULE_dataOrXml                                   = 127
	MySQLParserRULE_xmlRowsIdentifiedBy                         = 128
	MySQLParserRULE_loadDataFileTail                            = 129
	MySQLParserRULE_loadDataFileTargetList                      = 130
	MySQLParserRULE_fieldOrVariableList                         = 131
	MySQLParserRULE_replaceStatement                            = 132
	MySQLParserRULE_selectStatement                             = 133
	MySQLParserRULE_selectStatementWithInto                     = 134
	MySQLParserRULE_queryExpression                             = 135
	MySQLParserRULE_queryExpressionBody                         = 136
	MySQLParserRULE_queryExpressionParens                       = 137
	MySQLParserRULE_queryPrimary                                = 138
	MySQLParserRULE_querySpecification                          = 139
	MySQLParserRULE_subquery                                    = 140
	MySQLParserRULE_querySpecOption                             = 141
	MySQLParserRULE_limitClause                                 = 142
	MySQLParserRULE_simpleLimitClause                           = 143
	MySQLParserRULE_limitOptions                                = 144
	MySQLParserRULE_limitOption                                 = 145
	MySQLParserRULE_intoClause                                  = 146
	MySQLParserRULE_procedureAnalyseClause                      = 147
	MySQLParserRULE_havingClause                                = 148
	MySQLParserRULE_windowClause                                = 149
	MySQLParserRULE_windowDefinition                            = 150
	MySQLParserRULE_windowSpec                                  = 151
	MySQLParserRULE_windowSpecDetails                           = 152
	MySQLParserRULE_windowFrameClause                           = 153
	MySQLParserRULE_windowFrameUnits                            = 154
	MySQLParserRULE_windowFrameExtent                           = 155
	MySQLParserRULE_windowFrameStart                            = 156
	MySQLParserRULE_windowFrameBetween                          = 157
	MySQLParserRULE_windowFrameBound                            = 158
	MySQLParserRULE_windowFrameExclusion                        = 159
	MySQLParserRULE_withClause                                  = 160
	MySQLParserRULE_commonTableExpression                       = 161
	MySQLParserRULE_groupByClause                               = 162
	MySQLParserRULE_olapOption                                  = 163
	MySQLParserRULE_orderClause                                 = 164
	MySQLParserRULE_direction                                   = 165
	MySQLParserRULE_fromClause                                  = 166
	MySQLParserRULE_tableReferenceList                          = 167
	MySQLParserRULE_tableValueConstructor                       = 168
	MySQLParserRULE_explicitTable                               = 169
	MySQLParserRULE_rowValueExplicit                            = 170
	MySQLParserRULE_selectOption                                = 171
	MySQLParserRULE_lockingClauseList                           = 172
	MySQLParserRULE_lockingClause                               = 173
	MySQLParserRULE_lockStrengh                                 = 174
	MySQLParserRULE_lockedRowAction                             = 175
	MySQLParserRULE_selectItemList                              = 176
	MySQLParserRULE_selectItem                                  = 177
	MySQLParserRULE_selectAlias                                 = 178
	MySQLParserRULE_whereClause                                 = 179
	MySQLParserRULE_tableReference                              = 180
	MySQLParserRULE_escapedTableReference                       = 181
	MySQLParserRULE_joinedTable                                 = 182
	MySQLParserRULE_naturalJoinType                             = 183
	MySQLParserRULE_innerJoinType                               = 184
	MySQLParserRULE_outerJoinType                               = 185
	MySQLParserRULE_tableFactor                                 = 186
	MySQLParserRULE_singleTable                                 = 187
	MySQLParserRULE_singleTableParens                           = 188
	MySQLParserRULE_derivedTable                                = 189
	MySQLParserRULE_tableReferenceListParens                    = 190
	MySQLParserRULE_tableFunction                               = 191
	MySQLParserRULE_columnsClause                               = 192
	MySQLParserRULE_jtColumn                                    = 193
	MySQLParserRULE_onEmptyOrError                              = 194
	MySQLParserRULE_onEmpty                                     = 195
	MySQLParserRULE_onError                                     = 196
	MySQLParserRULE_jtOnResponse                                = 197
	MySQLParserRULE_unionOption                                 = 198
	MySQLParserRULE_tableAlias                                  = 199
	MySQLParserRULE_indexHintList                               = 200
	MySQLParserRULE_indexHint                                   = 201
	MySQLParserRULE_indexHintType                               = 202
	MySQLParserRULE_keyOrIndex                                  = 203
	MySQLParserRULE_constraintKeyType                           = 204
	MySQLParserRULE_indexHintClause                             = 205
	MySQLParserRULE_indexList                                   = 206
	MySQLParserRULE_indexListElement                            = 207
	MySQLParserRULE_updateStatement                             = 208
	MySQLParserRULE_transactionOrLockingStatement               = 209
	MySQLParserRULE_transactionStatement                        = 210
	MySQLParserRULE_beginWork                                   = 211
	MySQLParserRULE_transactionCharacteristic                   = 212
	MySQLParserRULE_savepointStatement                          = 213
	MySQLParserRULE_lockStatement                               = 214
	MySQLParserRULE_lockItem                                    = 215
	MySQLParserRULE_lockOption                                  = 216
	MySQLParserRULE_xaStatement                                 = 217
	MySQLParserRULE_xaConvert                                   = 218
	MySQLParserRULE_xid                                         = 219
	MySQLParserRULE_replicationStatement                        = 220
	MySQLParserRULE_resetOption                                 = 221
	MySQLParserRULE_masterResetOptions                          = 222
	MySQLParserRULE_replicationLoad                             = 223
	MySQLParserRULE_changeMaster                                = 224
	MySQLParserRULE_changeMasterOptions                         = 225
	MySQLParserRULE_masterOption                                = 226
	MySQLParserRULE_privilegeCheckDef                           = 227
	MySQLParserRULE_tablePrimaryKeyCheckDef                     = 228
	MySQLParserRULE_masterTlsCiphersuitesDef                    = 229
	MySQLParserRULE_masterFileDef                               = 230
	MySQLParserRULE_serverIdList                                = 231
	MySQLParserRULE_changeReplication                           = 232
	MySQLParserRULE_filterDefinition                            = 233
	MySQLParserRULE_filterDbList                                = 234
	MySQLParserRULE_filterTableList                             = 235
	MySQLParserRULE_filterStringList                            = 236
	MySQLParserRULE_filterWildDbTableString                     = 237
	MySQLParserRULE_filterDbPairList                            = 238
	MySQLParserRULE_slave                                       = 239
	MySQLParserRULE_slaveUntilOptions                           = 240
	MySQLParserRULE_slaveConnectionOptions                      = 241
	MySQLParserRULE_slaveThreadOptions                          = 242
	MySQLParserRULE_slaveThreadOption                           = 243
	MySQLParserRULE_groupReplication                            = 244
	MySQLParserRULE_preparedStatement                           = 245
	MySQLParserRULE_executeStatement                            = 246
	MySQLParserRULE_executeVarList                              = 247
	MySQLParserRULE_cloneStatement                              = 248
	MySQLParserRULE_dataDirSSL                                  = 249
	MySQLParserRULE_ssl                                         = 250
	MySQLParserRULE_accountManagementStatement                  = 251
	MySQLParserRULE_alterUser                                   = 252
	MySQLParserRULE_alterUserTail                               = 253
	MySQLParserRULE_userFunction                                = 254
	MySQLParserRULE_createUser                                  = 255
	MySQLParserRULE_createUserTail                              = 256
	MySQLParserRULE_defaultRoleClause                           = 257
	MySQLParserRULE_requireClause                               = 258
	MySQLParserRULE_connectOptions                              = 259
	MySQLParserRULE_accountLockPasswordExpireOptions            = 260
	MySQLParserRULE_dropUser                                    = 261
	MySQLParserRULE_grant                                       = 262
	MySQLParserRULE_grantTargetList                             = 263
	MySQLParserRULE_grantOptions                                = 264
	MySQLParserRULE_exceptRoleList                              = 265
	MySQLParserRULE_withRoles                                   = 266
	MySQLParserRULE_grantAs                                     = 267
	MySQLParserRULE_versionedRequireClause                      = 268
	MySQLParserRULE_renameUser                                  = 269
	MySQLParserRULE_revoke                                      = 270
	MySQLParserRULE_onTypeTo                                    = 271
	MySQLParserRULE_aclType                                     = 272
	MySQLParserRULE_roleOrPrivilegesList                        = 273
	MySQLParserRULE_roleOrPrivilege                             = 274
	MySQLParserRULE_grantIdentifier                             = 275
	MySQLParserRULE_requireList                                 = 276
	MySQLParserRULE_requireListElement                          = 277
	MySQLParserRULE_grantOption                                 = 278
	MySQLParserRULE_setRole                                     = 279
	MySQLParserRULE_roleList                                    = 280
	MySQLParserRULE_role                                        = 281
	MySQLParserRULE_tableAdministrationStatement                = 282
	MySQLParserRULE_histogram                                   = 283
	MySQLParserRULE_checkOption                                 = 284
	MySQLParserRULE_repairType                                  = 285
	MySQLParserRULE_installUninstallStatment                    = 286
	MySQLParserRULE_setStatement                                = 287
	MySQLParserRULE_startOptionValueList                        = 288
	MySQLParserRULE_transactionCharacteristics                  = 289
	MySQLParserRULE_transactionAccessMode                       = 290
	MySQLParserRULE_isolationLevel                              = 291
	MySQLParserRULE_optionValueListContinued                    = 292
	MySQLParserRULE_optionValueNoOptionType                     = 293
	MySQLParserRULE_optionValue                                 = 294
	MySQLParserRULE_setSystemVariable                           = 295
	MySQLParserRULE_startOptionValueListFollowingOptionType     = 296
	MySQLParserRULE_optionValueFollowingOptionType              = 297
	MySQLParserRULE_setExprOrDefault                            = 298
	MySQLParserRULE_showStatement                               = 299
	MySQLParserRULE_showCommandType                             = 300
	MySQLParserRULE_nonBlocking                                 = 301
	MySQLParserRULE_fromOrIn                                    = 302
	MySQLParserRULE_inDb                                        = 303
	MySQLParserRULE_profileType                                 = 304
	MySQLParserRULE_otherAdministrativeStatement                = 305
	MySQLParserRULE_keyCacheListOrParts                         = 306
	MySQLParserRULE_keyCacheList                                = 307
	MySQLParserRULE_assignToKeycache                            = 308
	MySQLParserRULE_assignToKeycachePartition                   = 309
	MySQLParserRULE_cacheKeyList                                = 310
	MySQLParserRULE_keyUsageElement                             = 311
	MySQLParserRULE_keyUsageList                                = 312
	MySQLParserRULE_flushOption                                 = 313
	MySQLParserRULE_logType                                     = 314
	MySQLParserRULE_flushTables                                 = 315
	MySQLParserRULE_flushTablesOptions                          = 316
	MySQLParserRULE_preloadTail                                 = 317
	MySQLParserRULE_preloadList                                 = 318
	MySQLParserRULE_preloadKeys                                 = 319
	MySQLParserRULE_adminPartition                              = 320
	MySQLParserRULE_resourceGroupManagement                     = 321
	MySQLParserRULE_createResourceGroup                         = 322
	MySQLParserRULE_resourceGroupVcpuList                       = 323
	MySQLParserRULE_vcpuNumOrRange                              = 324
	MySQLParserRULE_resourceGroupPriority                       = 325
	MySQLParserRULE_resourceGroupEnableDisable                  = 326
	MySQLParserRULE_alterResourceGroup                          = 327
	MySQLParserRULE_setResourceGroup                            = 328
	MySQLParserRULE_threadIdList                                = 329
	MySQLParserRULE_dropResourceGroup                           = 330
	MySQLParserRULE_utilityStatement                            = 331
	MySQLParserRULE_describeStatement                           = 332
	MySQLParserRULE_explainStatement                            = 333
	MySQLParserRULE_explainableStatement                        = 334
	MySQLParserRULE_helpCommand                                 = 335
	MySQLParserRULE_useCommand                                  = 336
	MySQLParserRULE_restartServer                               = 337
	MySQLParserRULE_expr                                        = 338
	MySQLParserRULE_boolPri                                     = 339
	MySQLParserRULE_compOp                                      = 340
	MySQLParserRULE_predicate                                   = 341
	MySQLParserRULE_predicateOperations                         = 342
	MySQLParserRULE_bitExpr                                     = 343
	MySQLParserRULE_simpleExpr                                  = 344
	MySQLParserRULE_arrayCast                                   = 345
	MySQLParserRULE_jsonOperator                                = 346
	MySQLParserRULE_sumExpr                                     = 347
	MySQLParserRULE_groupingOperation                           = 348
	MySQLParserRULE_windowFunctionCall                          = 349
	MySQLParserRULE_windowingClause                             = 350
	MySQLParserRULE_leadLagInfo                                 = 351
	MySQLParserRULE_nullTreatment                               = 352
	MySQLParserRULE_jsonFunction                                = 353
	MySQLParserRULE_inSumExpr                                   = 354
	MySQLParserRULE_identListArg                                = 355
	MySQLParserRULE_identList                                   = 356
	MySQLParserRULE_fulltextOptions                             = 357
	MySQLParserRULE_runtimeFunctionCall                         = 358
	MySQLParserRULE_geometryFunction                            = 359
	MySQLParserRULE_timeFunctionParameters                      = 360
	MySQLParserRULE_fractionalPrecision                         = 361
	MySQLParserRULE_weightStringLevels                          = 362
	MySQLParserRULE_weightStringLevelListItem                   = 363
	MySQLParserRULE_dateTimeTtype                               = 364
	MySQLParserRULE_trimFunction                                = 365
	MySQLParserRULE_substringFunction                           = 366
	MySQLParserRULE_functionCall                                = 367
	MySQLParserRULE_udfExprList                                 = 368
	MySQLParserRULE_udfExpr                                     = 369
	MySQLParserRULE_variable                                    = 370
	MySQLParserRULE_userVariable                                = 371
	MySQLParserRULE_systemVariable                              = 372
	MySQLParserRULE_internalVariableName                        = 373
	MySQLParserRULE_whenExpression                              = 374
	MySQLParserRULE_thenExpression                              = 375
	MySQLParserRULE_elseExpression                              = 376
	MySQLParserRULE_castType                                    = 377
	MySQLParserRULE_exprList                                    = 378
	MySQLParserRULE_charset                                     = 379
	MySQLParserRULE_notRule                                     = 380
	MySQLParserRULE_not2Rule                                    = 381
	MySQLParserRULE_interval                                    = 382
	MySQLParserRULE_intervalTimeStamp                           = 383
	MySQLParserRULE_exprListWithParentheses                     = 384
	MySQLParserRULE_exprWithParentheses                         = 385
	MySQLParserRULE_simpleExprWithParentheses                   = 386
	MySQLParserRULE_orderList                                   = 387
	MySQLParserRULE_orderExpression                             = 388
	MySQLParserRULE_groupList                                   = 389
	MySQLParserRULE_groupingExpression                          = 390
	MySQLParserRULE_channel                                     = 391
	MySQLParserRULE_compoundStatement                           = 392
	MySQLParserRULE_returnStatement                             = 393
	MySQLParserRULE_ifStatement                                 = 394
	MySQLParserRULE_ifBody                                      = 395
	MySQLParserRULE_thenStatement                               = 396
	MySQLParserRULE_compoundStatementList                       = 397
	MySQLParserRULE_caseStatement                               = 398
	MySQLParserRULE_elseStatement                               = 399
	MySQLParserRULE_labeledBlock                                = 400
	MySQLParserRULE_unlabeledBlock                              = 401
	MySQLParserRULE_label                                       = 402
	MySQLParserRULE_beginEndBlock                               = 403
	MySQLParserRULE_labeledControl                              = 404
	MySQLParserRULE_unlabeledControl                            = 405
	MySQLParserRULE_loopBlock                                   = 406
	MySQLParserRULE_whileDoBlock                                = 407
	MySQLParserRULE_repeatUntilBlock                            = 408
	MySQLParserRULE_spDeclarations                              = 409
	MySQLParserRULE_spDeclaration                               = 410
	MySQLParserRULE_variableDeclaration                         = 411
	MySQLParserRULE_conditionDeclaration                        = 412
	MySQLParserRULE_spCondition                                 = 413
	MySQLParserRULE_sqlstate                                    = 414
	MySQLParserRULE_handlerDeclaration                          = 415
	MySQLParserRULE_handlerCondition                            = 416
	MySQLParserRULE_cursorDeclaration                           = 417
	MySQLParserRULE_iterateStatement                            = 418
	MySQLParserRULE_leaveStatement                              = 419
	MySQLParserRULE_getDiagnostics                              = 420
	MySQLParserRULE_signalAllowedExpr                           = 421
	MySQLParserRULE_statementInformationItem                    = 422
	MySQLParserRULE_conditionInformationItem                    = 423
	MySQLParserRULE_signalInformationItemName                   = 424
	MySQLParserRULE_signalStatement                             = 425
	MySQLParserRULE_resignalStatement                           = 426
	MySQLParserRULE_signalInformationItem                       = 427
	MySQLParserRULE_cursorOpen                                  = 428
	MySQLParserRULE_cursorClose                                 = 429
	MySQLParserRULE_cursorFetch                                 = 430
	MySQLParserRULE_schedule                                    = 431
	MySQLParserRULE_columnDefinition                            = 432
	MySQLParserRULE_checkOrReferences                           = 433
	MySQLParserRULE_checkConstraint                             = 434
	MySQLParserRULE_constraintEnforcement                       = 435
	MySQLParserRULE_tableConstraintDef                          = 436
	MySQLParserRULE_constraintName                              = 437
	MySQLParserRULE_fieldDefinition                             = 438
	MySQLParserRULE_columnAttribute                             = 439
	MySQLParserRULE_columnFormat                                = 440
	MySQLParserRULE_storageMedia                                = 441
	MySQLParserRULE_gcolAttribute                               = 442
	MySQLParserRULE_references                                  = 443
	MySQLParserRULE_deleteOption                                = 444
	MySQLParserRULE_keyList                                     = 445
	MySQLParserRULE_keyPart                                     = 446
	MySQLParserRULE_keyListWithExpression                       = 447
	MySQLParserRULE_keyPartOrExpression                         = 448
	MySQLParserRULE_keyListVariants                             = 449
	MySQLParserRULE_indexType                                   = 450
	MySQLParserRULE_indexOption                                 = 451
	MySQLParserRULE_commonIndexOption                           = 452
	MySQLParserRULE_visibility                                  = 453
	MySQLParserRULE_indexTypeClause                             = 454
	MySQLParserRULE_fulltextIndexOption                         = 455
	MySQLParserRULE_spatialIndexOption                          = 456
	MySQLParserRULE_dataTypeDefinition                          = 457
	MySQLParserRULE_dataType                                    = 458
	MySQLParserRULE_nchar                                       = 459
	MySQLParserRULE_realType                                    = 460
	MySQLParserRULE_fieldLength                                 = 461
	MySQLParserRULE_fieldOptions                                = 462
	MySQLParserRULE_charsetWithOptBinary                        = 463
	MySQLParserRULE_ascii                                       = 464
	MySQLParserRULE_unicode                                     = 465
	MySQLParserRULE_wsNumCodepoints                             = 466
	MySQLParserRULE_typeDatetimePrecision                       = 467
	MySQLParserRULE_charsetName                                 = 468
	MySQLParserRULE_collationName                               = 469
	MySQLParserRULE_createTableOptions                          = 470
	MySQLParserRULE_createTableOptionsSpaceSeparated            = 471
	MySQLParserRULE_createTableOption                           = 472
	MySQLParserRULE_ternaryOption                               = 473
	MySQLParserRULE_defaultCollation                            = 474
	MySQLParserRULE_defaultEncryption                           = 475
	MySQLParserRULE_defaultCharset                              = 476
	MySQLParserRULE_partitionClause                             = 477
	MySQLParserRULE_partitionTypeDef                            = 478
	MySQLParserRULE_subPartitions                               = 479
	MySQLParserRULE_partitionKeyAlgorithm                       = 480
	MySQLParserRULE_partitionDefinitions                        = 481
	MySQLParserRULE_partitionDefinition                         = 482
	MySQLParserRULE_partitionValuesIn                           = 483
	MySQLParserRULE_partitionOption                             = 484
	MySQLParserRULE_subpartitionDefinition                      = 485
	MySQLParserRULE_partitionValueItemListParen                 = 486
	MySQLParserRULE_partitionValueItem                          = 487
	MySQLParserRULE_definerClause                               = 488
	MySQLParserRULE_ifExists                                    = 489
	MySQLParserRULE_ifNotExists                                 = 490
	MySQLParserRULE_procedureParameter                          = 491
	MySQLParserRULE_functionParameter                           = 492
	MySQLParserRULE_collate                                     = 493
	MySQLParserRULE_typeWithOptCollate                          = 494
	MySQLParserRULE_schemaIdentifierPair                        = 495
	MySQLParserRULE_viewRefList                                 = 496
	MySQLParserRULE_updateList                                  = 497
	MySQLParserRULE_updateElement                               = 498
	MySQLParserRULE_charsetClause                               = 499
	MySQLParserRULE_fieldsClause                                = 500
	MySQLParserRULE_fieldTerm                                   = 501
	MySQLParserRULE_linesClause                                 = 502
	MySQLParserRULE_lineTerm                                    = 503
	MySQLParserRULE_userList                                    = 504
	MySQLParserRULE_createUserList                              = 505
	MySQLParserRULE_alterUserList                               = 506
	MySQLParserRULE_createUserEntry                             = 507
	MySQLParserRULE_alterUserEntry                              = 508
	MySQLParserRULE_retainCurrentPassword                       = 509
	MySQLParserRULE_discardOldPassword                          = 510
	MySQLParserRULE_replacePassword                             = 511
	MySQLParserRULE_userIdentifierOrText                        = 512
	MySQLParserRULE_user                                        = 513
	MySQLParserRULE_likeClause                                  = 514
	MySQLParserRULE_likeOrWhere                                 = 515
	MySQLParserRULE_onlineOption                                = 516
	MySQLParserRULE_noWriteToBinLog                             = 517
	MySQLParserRULE_usePartition                                = 518
	MySQLParserRULE_fieldIdentifier                             = 519
	MySQLParserRULE_columnName                                  = 520
	MySQLParserRULE_columnInternalRef                           = 521
	MySQLParserRULE_columnInternalRefList                       = 522
	MySQLParserRULE_columnRef                                   = 523
	MySQLParserRULE_insertIdentifier                            = 524
	MySQLParserRULE_indexName                                   = 525
	MySQLParserRULE_indexRef                                    = 526
	MySQLParserRULE_tableWild                                   = 527
	MySQLParserRULE_schemaName                                  = 528
	MySQLParserRULE_schemaRef                                   = 529
	MySQLParserRULE_procedureName                               = 530
	MySQLParserRULE_procedureRef                                = 531
	MySQLParserRULE_functionName                                = 532
	MySQLParserRULE_functionRef                                 = 533
	MySQLParserRULE_triggerName                                 = 534
	MySQLParserRULE_triggerRef                                  = 535
	MySQLParserRULE_viewName                                    = 536
	MySQLParserRULE_viewRef                                     = 537
	MySQLParserRULE_tablespaceName                              = 538
	MySQLParserRULE_tablespaceRef                               = 539
	MySQLParserRULE_logfileGroupName                            = 540
	MySQLParserRULE_logfileGroupRef                             = 541
	MySQLParserRULE_eventName                                   = 542
	MySQLParserRULE_eventRef                                    = 543
	MySQLParserRULE_udfName                                     = 544
	MySQLParserRULE_serverName                                  = 545
	MySQLParserRULE_serverRef                                   = 546
	MySQLParserRULE_engineRef                                   = 547
	MySQLParserRULE_tableName                                   = 548
	MySQLParserRULE_filterTableRef                              = 549
	MySQLParserRULE_tableRefWithWildcard                        = 550
	MySQLParserRULE_tableRef                                    = 551
	MySQLParserRULE_tableRefList                                = 552
	MySQLParserRULE_tableAliasRefList                           = 553
	MySQLParserRULE_parameterName                               = 554
	MySQLParserRULE_labelIdentifier                             = 555
	MySQLParserRULE_labelRef                                    = 556
	MySQLParserRULE_roleIdentifier                              = 557
	MySQLParserRULE_roleRef                                     = 558
	MySQLParserRULE_pluginRef                                   = 559
	MySQLParserRULE_componentRef                                = 560
	MySQLParserRULE_resourceGroupRef                            = 561
	MySQLParserRULE_windowName                                  = 562
	MySQLParserRULE_pureIdentifier                              = 563
	MySQLParserRULE_identifier                                  = 564
	MySQLParserRULE_identifierList                              = 565
	MySQLParserRULE_identifierListWithParentheses               = 566
	MySQLParserRULE_qualifiedIdentifier                         = 567
	MySQLParserRULE_simpleIdentifier                            = 568
	MySQLParserRULE_dotIdentifier                               = 569
	MySQLParserRULE_ulong_number                                = 570
	MySQLParserRULE_real_ulong_number                           = 571
	MySQLParserRULE_ulonglong_number                            = 572
	MySQLParserRULE_real_ulonglong_number                       = 573
	MySQLParserRULE_literal                                     = 574
	MySQLParserRULE_signedLiteral                               = 575
	MySQLParserRULE_stringList                                  = 576
	MySQLParserRULE_textStringLiteral                           = 577
	MySQLParserRULE_textString                                  = 578
	MySQLParserRULE_textStringHash                              = 579
	MySQLParserRULE_textLiteral                                 = 580
	MySQLParserRULE_textStringNoLinebreak                       = 581
	MySQLParserRULE_textStringLiteralList                       = 582
	MySQLParserRULE_numLiteral                                  = 583
	MySQLParserRULE_boolLiteral                                 = 584
	MySQLParserRULE_nullLiteral                                 = 585
	MySQLParserRULE_temporalLiteral                             = 586
	MySQLParserRULE_floatOptions                                = 587
	MySQLParserRULE_standardFloatOptions                        = 588
	MySQLParserRULE_precision                                   = 589
	MySQLParserRULE_textOrIdentifier                            = 590
	MySQLParserRULE_lValueIdentifier                            = 591
	MySQLParserRULE_roleIdentifierOrText                        = 592
	MySQLParserRULE_sizeNumber                                  = 593
	MySQLParserRULE_parentheses                                 = 594
	MySQLParserRULE_equal                                       = 595
	MySQLParserRULE_optionType                                  = 596
	MySQLParserRULE_varIdentType                                = 597
	MySQLParserRULE_setVarIdentType                             = 598
	MySQLParserRULE_identifierKeyword                           = 599
	MySQLParserRULE_identifierKeywordsAmbiguous1RolesAndLabels  = 600
	MySQLParserRULE_identifierKeywordsAmbiguous2Labels          = 601
	MySQLParserRULE_labelKeyword                                = 602
	MySQLParserRULE_identifierKeywordsAmbiguous3Roles           = 603
	MySQLParserRULE_identifierKeywordsUnambiguous               = 604
	MySQLParserRULE_roleKeyword                                 = 605
	MySQLParserRULE_lValueKeyword                               = 606
	MySQLParserRULE_identifierKeywordsAmbiguous4SystemVariables = 607
	MySQLParserRULE_roleOrIdentifierKeyword                     = 608
	MySQLParserRULE_roleOrLabelKeyword                          = 609
)

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	SimpleStatement() ISimpleStatementContext
	BeginWork() IBeginWorkContext
	SEMICOLON_SYMBOL() antlr.TerminalNode

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySQLParserEOF, 0)
}

func (s *QueryContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *QueryContext) BeginWork() IBeginWorkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginWorkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginWorkContext)
}

func (s *QueryContext) SEMICOLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSEMICOLON_SYMBOL, 0)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, MySQLParserRULE_query)
	p.SetState(1232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.Match(MySQLParserEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1223)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1221)
				p.SimpleStatement()
			}

		case 2:
			{
				p.SetState(1222)
				p.BeginWork()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1230)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserSEMICOLON_SYMBOL:
			{
				p.SetState(1225)
				p.Match(MySQLParserSEMICOLON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1227)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1226)
					p.Match(MySQLParserEOF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case MySQLParserEOF:
			{
				p.SetState(1229)
				p.Match(MySQLParserEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleStatementContext is an interface to support dynamic dispatch.
type ISimpleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterStatement() IAlterStatementContext
	CreateStatement() ICreateStatementContext
	DropStatement() IDropStatementContext
	RenameTableStatement() IRenameTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	ImportStatement() IImportStatementContext
	CallStatement() ICallStatementContext
	DeleteStatement() IDeleteStatementContext
	DoStatement() IDoStatementContext
	HandlerStatement() IHandlerStatementContext
	InsertStatement() IInsertStatementContext
	LoadStatement() ILoadStatementContext
	ReplaceStatement() IReplaceStatementContext
	SelectStatement() ISelectStatementContext
	UpdateStatement() IUpdateStatementContext
	TransactionOrLockingStatement() ITransactionOrLockingStatementContext
	ReplicationStatement() IReplicationStatementContext
	PreparedStatement() IPreparedStatementContext
	CloneStatement() ICloneStatementContext
	AccountManagementStatement() IAccountManagementStatementContext
	TableAdministrationStatement() ITableAdministrationStatementContext
	InstallUninstallStatment() IInstallUninstallStatmentContext
	SetStatement() ISetStatementContext
	ShowStatement() IShowStatementContext
	ResourceGroupManagement() IResourceGroupManagementContext
	OtherAdministrativeStatement() IOtherAdministrativeStatementContext
	UtilityStatement() IUtilityStatementContext
	GetDiagnostics() IGetDiagnosticsContext
	SignalStatement() ISignalStatementContext
	ResignalStatement() IResignalStatementContext

	// IsSimpleStatementContext differentiates from other interfaces.
	IsSimpleStatementContext()
}

type SimpleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleStatementContext() *SimpleStatementContext {
	var p = new(SimpleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleStatement
	return p
}

func InitEmptySimpleStatementContext(p *SimpleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleStatement
}

func (*SimpleStatementContext) IsSimpleStatementContext() {}

func NewSimpleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleStatementContext {
	var p = new(SimpleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_simpleStatement

	return p
}

func (s *SimpleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleStatementContext) AlterStatement() IAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *SimpleStatementContext) CreateStatement() ICreateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStatementContext)
}

func (s *SimpleStatementContext) DropStatement() IDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatementContext)
}

func (s *SimpleStatementContext) RenameTableStatement() IRenameTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameTableStatementContext)
}

func (s *SimpleStatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *SimpleStatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *SimpleStatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *SimpleStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *SimpleStatementContext) DoStatement() IDoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoStatementContext)
}

func (s *SimpleStatementContext) HandlerStatement() IHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerStatementContext)
}

func (s *SimpleStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *SimpleStatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *SimpleStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *SimpleStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *SimpleStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *SimpleStatementContext) TransactionOrLockingStatement() ITransactionOrLockingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionOrLockingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionOrLockingStatementContext)
}

func (s *SimpleStatementContext) ReplicationStatement() IReplicationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationStatementContext)
}

func (s *SimpleStatementContext) PreparedStatement() IPreparedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreparedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreparedStatementContext)
}

func (s *SimpleStatementContext) CloneStatement() ICloneStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloneStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloneStatementContext)
}

func (s *SimpleStatementContext) AccountManagementStatement() IAccountManagementStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccountManagementStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccountManagementStatementContext)
}

func (s *SimpleStatementContext) TableAdministrationStatement() ITableAdministrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAdministrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAdministrationStatementContext)
}

func (s *SimpleStatementContext) InstallUninstallStatment() IInstallUninstallStatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallUninstallStatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallUninstallStatmentContext)
}

func (s *SimpleStatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *SimpleStatementContext) ShowStatement() IShowStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatementContext)
}

func (s *SimpleStatementContext) ResourceGroupManagement() IResourceGroupManagementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupManagementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupManagementContext)
}

func (s *SimpleStatementContext) OtherAdministrativeStatement() IOtherAdministrativeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOtherAdministrativeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOtherAdministrativeStatementContext)
}

func (s *SimpleStatementContext) UtilityStatement() IUtilityStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUtilityStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUtilityStatementContext)
}

func (s *SimpleStatementContext) GetDiagnostics() IGetDiagnosticsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetDiagnosticsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetDiagnosticsContext)
}

func (s *SimpleStatementContext) SignalStatement() ISignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalStatementContext)
}

func (s *SimpleStatementContext) ResignalStatement() IResignalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResignalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResignalStatementContext)
}

func (s *SimpleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleStatement(s)
	}
}

func (s *SimpleStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SimpleStatement() (localctx ISimpleStatementContext) {
	localctx = NewSimpleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, MySQLParserRULE_simpleStatement)
	p.SetState(1268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1234)
			p.AlterStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1235)
			p.CreateStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1236)
			p.DropStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1237)
			p.RenameTableStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1238)
			p.TruncateTableStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(1239)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1240)
			p.ImportStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1241)
			p.CallStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1242)
			p.DeleteStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1243)
			p.DoStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1244)
			p.HandlerStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1245)
			p.InsertStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1246)
			p.LoadStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1247)
			p.ReplaceStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1248)
			p.SelectStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1249)
			p.UpdateStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1250)
			p.TransactionOrLockingStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1251)
			p.ReplicationStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1252)
			p.PreparedStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		p.SetState(1253)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1254)
			p.CloneStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1255)
			p.AccountManagementStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1256)
			p.TableAdministrationStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1257)
			p.InstallUninstallStatment()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1258)
			p.SetStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1259)
			p.ShowStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		p.SetState(1260)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1261)
			p.ResourceGroupManagement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1262)
			p.OtherAdministrativeStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1263)
			p.UtilityStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		p.SetState(1264)

		if !(serverVersion >= 50604) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50604", ""))
			goto errorExit
		}
		{
			p.SetState(1265)
			p.GetDiagnostics()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1266)
			p.SignalStatement()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1267)
			p.ResignalStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER_SYMBOL() antlr.TerminalNode
	AlterTable() IAlterTableContext
	AlterDatabase() IAlterDatabaseContext
	PROCEDURE_SYMBOL() antlr.TerminalNode
	ProcedureRef() IProcedureRefContext
	FUNCTION_SYMBOL() antlr.TerminalNode
	FunctionRef() IFunctionRefContext
	AlterView() IAlterViewContext
	AlterEvent() IAlterEventContext
	AlterTablespace() IAlterTablespaceContext
	AlterUndoTablespace() IAlterUndoTablespaceContext
	AlterLogfileGroup() IAlterLogfileGroupContext
	AlterServer() IAlterServerContext
	INSTANCE_SYMBOL() antlr.TerminalNode
	ROTATE_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	MASTER_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	RoutineAlterOptions() IRoutineAlterOptionsContext

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterStatement
	return p
}

func InitEmptyAlterStatementContext(p *AlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterStatement
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALTER_SYMBOL, 0)
}

func (s *AlterStatementContext) AlterTable() IAlterTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableContext)
}

func (s *AlterStatementContext) AlterDatabase() IAlterDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseContext)
}

func (s *AlterStatementContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *AlterStatementContext) ProcedureRef() IProcedureRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureRefContext)
}

func (s *AlterStatementContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *AlterStatementContext) FunctionRef() IFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionRefContext)
}

func (s *AlterStatementContext) AlterView() IAlterViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewContext)
}

func (s *AlterStatementContext) AlterEvent() IAlterEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterEventContext)
}

func (s *AlterStatementContext) AlterTablespace() IAlterTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceContext)
}

func (s *AlterStatementContext) AlterUndoTablespace() IAlterUndoTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUndoTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUndoTablespaceContext)
}

func (s *AlterStatementContext) AlterLogfileGroup() IAlterLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupContext)
}

func (s *AlterStatementContext) AlterServer() IAlterServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterServerContext)
}

func (s *AlterStatementContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTANCE_SYMBOL, 0)
}

func (s *AlterStatementContext) ROTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROTATE_SYMBOL, 0)
}

func (s *AlterStatementContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *AlterStatementContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *AlterStatementContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *AlterStatementContext) RoutineAlterOptions() IRoutineAlterOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineAlterOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineAlterOptionsContext)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterStatement() (localctx IAlterStatementContext) {
	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, MySQLParserRULE_alterStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(MySQLParserALTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1271)
			p.AlterTable()
		}

	case 2:
		{
			p.SetState(1272)
			p.AlterDatabase()
		}

	case 3:
		{
			p.SetState(1273)
			p.Match(MySQLParserPROCEDURE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1274)
			p.ProcedureRef()
		}
		p.SetState(1276)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&4611686018427420673) != 0) || _la == MySQLParserLANGUAGE_SYMBOL || ((int64((_la-347)) & ^0x3f) == 0 && ((int64(1)<<(_la-347))&83886081) != 0) || _la == MySQLParserREADS_SYMBOL || _la == MySQLParserSQL_SYMBOL {
			{
				p.SetState(1275)
				p.RoutineAlterOptions()
			}

		}

	case 4:
		{
			p.SetState(1278)
			p.Match(MySQLParserFUNCTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1279)
			p.FunctionRef()
		}
		p.SetState(1281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&4611686018427420673) != 0) || _la == MySQLParserLANGUAGE_SYMBOL || ((int64((_la-347)) & ^0x3f) == 0 && ((int64(1)<<(_la-347))&83886081) != 0) || _la == MySQLParserREADS_SYMBOL || _la == MySQLParserSQL_SYMBOL {
			{
				p.SetState(1280)
				p.RoutineAlterOptions()
			}

		}

	case 5:
		{
			p.SetState(1283)
			p.AlterView()
		}

	case 6:
		{
			p.SetState(1284)
			p.AlterEvent()
		}

	case 7:
		{
			p.SetState(1285)
			p.AlterTablespace()
		}

	case 8:
		p.SetState(1286)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(1287)
			p.AlterUndoTablespace()
		}

	case 9:
		{
			p.SetState(1288)
			p.AlterLogfileGroup()
		}

	case 10:
		{
			p.SetState(1289)
			p.AlterServer()
		}

	case 11:
		p.SetState(1290)

		if !(serverVersion >= 50713) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50713", ""))
			goto errorExit
		}
		{
			p.SetState(1291)
			p.Match(MySQLParserINSTANCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1292)
			p.Match(MySQLParserROTATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1293)
			p.TextOrIdentifier()
		}
		{
			p.SetState(1294)
			p.Match(MySQLParserMASTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.Match(MySQLParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseContext is an interface to support dynamic dispatch.
type IAlterDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	UPGRADE_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	NAME_SYMBOL() antlr.TerminalNode
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsAlterDatabaseContext differentiates from other interfaces.
	IsAlterDatabaseContext()
}

type AlterDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseContext() *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterDatabase
	return p
}

func InitEmptyAlterDatabaseContext(p *AlterDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterDatabase
}

func (*AlterDatabaseContext) IsAlterDatabaseContext() {}

func NewAlterDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseContext {
	var p = new(AlterDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterDatabase

	return p
}

func (s *AlterDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *AlterDatabaseContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *AlterDatabaseContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPGRADE_SYMBOL, 0)
}

func (s *AlterDatabaseContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *AlterDatabaseContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *AlterDatabaseContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAME_SYMBOL, 0)
}

func (s *AlterDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *AlterDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterDatabase(s)
	}
}

func (s *AlterDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterDatabase(s)
	}
}

func (s *AlterDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterDatabase() (localctx IAlterDatabaseContext) {
	localctx = NewAlterDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, MySQLParserRULE_alterDatabase)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1299)
		p.Match(MySQLParserDATABASE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1300)
		p.SchemaRef()
	}
	p.SetState(1311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1301)
					p.CreateDatabaseOption()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1304)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.SetState(1306)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1307)
			p.Match(MySQLParserUPGRADE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1308)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1310)
			p.Match(MySQLParserNAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterEventContext is an interface to support dynamic dispatch.
type IAlterEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENT_SYMBOL() antlr.TerminalNode
	EventRef() IEventRefContext
	DefinerClause() IDefinerClauseContext
	AllON_SYMBOL() []antlr.TerminalNode
	ON_SYMBOL(i int) antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	Schedule() IScheduleContext
	COMPLETION_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	RENAME_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	ENABLE_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	DO_SYMBOL() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	NOT_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode

	// IsAlterEventContext differentiates from other interfaces.
	IsAlterEventContext()
}

type AlterEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterEventContext() *AlterEventContext {
	var p = new(AlterEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterEvent
	return p
}

func InitEmptyAlterEventContext(p *AlterEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterEvent
}

func (*AlterEventContext) IsAlterEventContext() {}

func NewAlterEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterEventContext {
	var p = new(AlterEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterEvent

	return p
}

func (s *AlterEventContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterEventContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *AlterEventContext) EventRef() IEventRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventRefContext)
}

func (s *AlterEventContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *AlterEventContext) AllON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserON_SYMBOL)
}

func (s *AlterEventContext) ON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, i)
}

func (s *AlterEventContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEDULE_SYMBOL, 0)
}

func (s *AlterEventContext) Schedule() IScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleContext)
}

func (s *AlterEventContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPLETION_SYMBOL, 0)
}

func (s *AlterEventContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRESERVE_SYMBOL, 0)
}

func (s *AlterEventContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRENAME_SYMBOL, 0)
}

func (s *AlterEventContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *AlterEventContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterEventContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *AlterEventContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *AlterEventContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *AlterEventContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *AlterEventContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *AlterEventContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *AlterEventContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *AlterEventContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *AlterEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterEvent(s)
	}
}

func (s *AlterEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterEvent(s)
	}
}

func (s *AlterEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterEvent() (localctx IAlterEventContext) {
	localctx = NewAlterEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, MySQLParserRULE_alterEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(1313)
			p.DefinerClause()
		}

	}
	{
		p.SetState(1316)
		p.Match(MySQLParserEVENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1317)
		p.EventRef()
	}
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1318)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1319)
			p.Match(MySQLParserSCHEDULE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1320)
			p.Schedule()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserON_SYMBOL {
		{
			p.SetState(1323)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Match(MySQLParserCOMPLETION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL {
			{
				p.SetState(1325)
				p.Match(MySQLParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1328)
			p.Match(MySQLParserPRESERVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserRENAME_SYMBOL {
		{
			p.SetState(1331)
			p.Match(MySQLParserRENAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Identifier()
		}

	}
	p.SetState(1342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySQLParserENABLE_SYMBOL:
		{
			p.SetState(1336)
			p.Match(MySQLParserENABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserDISABLE_SYMBOL:
		{
			p.SetState(1337)
			p.Match(MySQLParserDISABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserON_SYMBOL {
			{
				p.SetState(1338)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1339)
				p.Match(MySQLParserSLAVE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserEOF, MySQLParserCOMMENT_SYMBOL, MySQLParserDO_SYMBOL, MySQLParserSEMICOLON_SYMBOL:

	default:
	}
	p.SetState(1346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOMMENT_SYMBOL {
		{
			p.SetState(1344)
			p.Match(MySQLParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1345)
			p.TextLiteral()
		}

	}
	p.SetState(1350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDO_SYMBOL {
		{
			p.SetState(1348)
			p.Match(MySQLParserDO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1349)
			p.CompoundStatement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLogfileGroupContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGFILE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	LogfileGroupRef() ILogfileGroupRefContext
	ADD_SYMBOL() antlr.TerminalNode
	UNDOFILE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	AlterLogfileGroupOptions() IAlterLogfileGroupOptionsContext

	// IsAlterLogfileGroupContext differentiates from other interfaces.
	IsAlterLogfileGroupContext()
}

type AlterLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupContext() *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroup
	return p
}

func InitEmptyAlterLogfileGroupContext(p *AlterLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroup
}

func (*AlterLogfileGroupContext) IsAlterLogfileGroupContext() {}

func NewAlterLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupContext {
	var p = new(AlterLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterLogfileGroup

	return p
}

func (s *AlterLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *AlterLogfileGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *AlterLogfileGroupContext) LogfileGroupRef() ILogfileGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupRefContext)
}

func (s *AlterLogfileGroupContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *AlterLogfileGroupContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDOFILE_SYMBOL, 0)
}

func (s *AlterLogfileGroupContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *AlterLogfileGroupContext) AlterLogfileGroupOptions() IAlterLogfileGroupOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupOptionsContext)
}

func (s *AlterLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterLogfileGroup(s)
	}
}

func (s *AlterLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterLogfileGroup() (localctx IAlterLogfileGroupContext) {
	localctx = NewAlterLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, MySQLParserRULE_alterLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1352)
		p.Match(MySQLParserLOGFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1353)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1354)
		p.LogfileGroupRef()
	}
	{
		p.SetState(1355)
		p.Match(MySQLParserADD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1356)
		p.Match(MySQLParserUNDOFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1357)
		p.TextLiteral()
	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL {
		{
			p.SetState(1358)
			p.AlterLogfileGroupOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLogfileGroupOptionsContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterLogfileGroupOption() []IAlterLogfileGroupOptionContext
	AlterLogfileGroupOption(i int) IAlterLogfileGroupOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterLogfileGroupOptionsContext differentiates from other interfaces.
	IsAlterLogfileGroupOptionsContext()
}

type AlterLogfileGroupOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupOptionsContext() *AlterLogfileGroupOptionsContext {
	var p = new(AlterLogfileGroupOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOptions
	return p
}

func InitEmptyAlterLogfileGroupOptionsContext(p *AlterLogfileGroupOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOptions
}

func (*AlterLogfileGroupOptionsContext) IsAlterLogfileGroupOptionsContext() {}

func NewAlterLogfileGroupOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupOptionsContext {
	var p = new(AlterLogfileGroupOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOptions

	return p
}

func (s *AlterLogfileGroupOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupOptionsContext) AllAlterLogfileGroupOption() []IAlterLogfileGroupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterLogfileGroupOptionContext); ok {
			len++
		}
	}

	tst := make([]IAlterLogfileGroupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterLogfileGroupOptionContext); ok {
			tst[i] = t.(IAlterLogfileGroupOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterLogfileGroupOptionsContext) AlterLogfileGroupOption(i int) IAlterLogfileGroupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLogfileGroupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLogfileGroupOptionContext)
}

func (s *AlterLogfileGroupOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterLogfileGroupOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterLogfileGroupOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterLogfileGroupOptions(s)
	}
}

func (s *AlterLogfileGroupOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterLogfileGroupOptions(s)
	}
}

func (s *AlterLogfileGroupOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterLogfileGroupOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterLogfileGroupOptions() (localctx IAlterLogfileGroupOptionsContext) {
	localctx = NewAlterLogfileGroupOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, MySQLParserRULE_alterLogfileGroupOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1361)
		p.AlterLogfileGroupOption()
	}
	p.SetState(1368)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
		p.SetState(1363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(1362)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1365)
			p.AlterLogfileGroupOption()
		}

		p.SetState(1370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLogfileGroupOptionContext is an interface to support dynamic dispatch.
type IAlterLogfileGroupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TsOptionInitialSize() ITsOptionInitialSizeContext
	TsOptionEngine() ITsOptionEngineContext
	TsOptionWait() ITsOptionWaitContext

	// IsAlterLogfileGroupOptionContext differentiates from other interfaces.
	IsAlterLogfileGroupOptionContext()
}

type AlterLogfileGroupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLogfileGroupOptionContext() *AlterLogfileGroupOptionContext {
	var p = new(AlterLogfileGroupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOption
	return p
}

func InitEmptyAlterLogfileGroupOptionContext(p *AlterLogfileGroupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOption
}

func (*AlterLogfileGroupOptionContext) IsAlterLogfileGroupOptionContext() {}

func NewAlterLogfileGroupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLogfileGroupOptionContext {
	var p = new(AlterLogfileGroupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterLogfileGroupOption

	return p
}

func (s *AlterLogfileGroupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLogfileGroupOptionContext) TsOptionInitialSize() ITsOptionInitialSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionInitialSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionInitialSizeContext)
}

func (s *AlterLogfileGroupOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *AlterLogfileGroupOptionContext) TsOptionWait() ITsOptionWaitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionWaitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionWaitContext)
}

func (s *AlterLogfileGroupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLogfileGroupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLogfileGroupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterLogfileGroupOption(s)
	}
}

func (s *AlterLogfileGroupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterLogfileGroupOption(s)
	}
}

func (s *AlterLogfileGroupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterLogfileGroupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterLogfileGroupOption() (localctx IAlterLogfileGroupOptionContext) {
	localctx = NewAlterLogfileGroupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, MySQLParserRULE_alterLogfileGroupOption)
	p.SetState(1374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINITIAL_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1371)
			p.TsOptionInitialSize()
		}

	case MySQLParserENGINE_SYMBOL, MySQLParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1372)
			p.TsOptionEngine()
		}

	case MySQLParserNO_WAIT_SYMBOL, MySQLParserWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1373)
			p.TsOptionWait()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterServerContext is an interface to support dynamic dispatch.
type IAlterServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SERVER_SYMBOL() antlr.TerminalNode
	ServerRef() IServerRefContext
	ServerOptions() IServerOptionsContext

	// IsAlterServerContext differentiates from other interfaces.
	IsAlterServerContext()
}

type AlterServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterServerContext() *AlterServerContext {
	var p = new(AlterServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterServer
	return p
}

func InitEmptyAlterServerContext(p *AlterServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterServer
}

func (*AlterServerContext) IsAlterServerContext() {}

func NewAlterServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterServerContext {
	var p = new(AlterServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterServer

	return p
}

func (s *AlterServerContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterServerContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERVER_SYMBOL, 0)
}

func (s *AlterServerContext) ServerRef() IServerRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerRefContext)
}

func (s *AlterServerContext) ServerOptions() IServerOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionsContext)
}

func (s *AlterServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterServer(s)
	}
}

func (s *AlterServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterServer(s)
	}
}

func (s *AlterServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterServer() (localctx IAlterServerContext) {
	localctx = NewAlterServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, MySQLParserRULE_alterServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1376)
		p.Match(MySQLParserSERVER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1377)
		p.ServerRef()
	}
	{
		p.SetState(1378)
		p.ServerOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableContext is an interface to support dynamic dispatch.
type IAlterTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	OnlineOption() IOnlineOptionContext
	IGNORE_SYMBOL() antlr.TerminalNode
	AlterTableActions() IAlterTableActionsContext

	// IsAlterTableContext differentiates from other interfaces.
	IsAlterTableContext()
}

type AlterTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableContext() *AlterTableContext {
	var p = new(AlterTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTable
	return p
}

func InitEmptyAlterTableContext(p *AlterTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTable
}

func (*AlterTableContext) IsAlterTableContext() {}

func NewAlterTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableContext {
	var p = new(AlterTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterTable

	return p
}

func (s *AlterTableContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *AlterTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *AlterTableContext) OnlineOption() IOnlineOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnlineOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnlineOptionContext)
}

func (s *AlterTableContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *AlterTableContext) AlterTableActions() IAlterTableActionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableActionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableActionsContext)
}

func (s *AlterTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterTable(s)
	}
}

func (s *AlterTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterTable(s)
	}
}

func (s *AlterTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterTable() (localctx IAlterTableContext) {
	localctx = NewAlterTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, MySQLParserRULE_alterTable)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1381)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 23, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1380)
			p.OnlineOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1385)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		p.SetState(1383)

		if !(serverVersion < 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50700", ""))
			goto errorExit
		}
		{
			p.SetState(1384)
			p.Match(MySQLParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1387)
		p.Match(MySQLParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1388)
		p.TableRef()
	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1389)
			p.AlterTableActions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableActionsContext is an interface to support dynamic dispatch.
type IAlterTableActionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterCommandList() IAlterCommandListContext
	PartitionClause() IPartitionClauseContext
	RemovePartitioning() IRemovePartitioningContext
	StandaloneAlterCommands() IStandaloneAlterCommandsContext
	AlterCommandsModifierList() IAlterCommandsModifierListContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsAlterTableActionsContext differentiates from other interfaces.
	IsAlterTableActionsContext()
}

type AlterTableActionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableActionsContext() *AlterTableActionsContext {
	var p = new(AlterTableActionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTableActions
	return p
}

func InitEmptyAlterTableActionsContext(p *AlterTableActionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTableActions
}

func (*AlterTableActionsContext) IsAlterTableActionsContext() {}

func NewAlterTableActionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableActionsContext {
	var p = new(AlterTableActionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterTableActions

	return p
}

func (s *AlterTableActionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableActionsContext) AlterCommandList() IAlterCommandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCommandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCommandListContext)
}

func (s *AlterTableActionsContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *AlterTableActionsContext) RemovePartitioning() IRemovePartitioningContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemovePartitioningContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemovePartitioningContext)
}

func (s *AlterTableActionsContext) StandaloneAlterCommands() IStandaloneAlterCommandsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandaloneAlterCommandsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandaloneAlterCommandsContext)
}

func (s *AlterTableActionsContext) AlterCommandsModifierList() IAlterCommandsModifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCommandsModifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCommandsModifierListContext)
}

func (s *AlterTableActionsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *AlterTableActionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableActionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableActionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterTableActions(s)
	}
}

func (s *AlterTableActionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterTableActions(s)
	}
}

func (s *AlterTableActionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterTableActions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterTableActions() (localctx IAlterTableActionsContext) {
	localctx = NewAlterTableActionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, MySQLParserRULE_alterTableActions)
	p.SetState(1405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 28, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1392)
			p.AlterCommandList()
		}
		p.SetState(1395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case MySQLParserPARTITION_SYMBOL:
			{
				p.SetState(1393)
				p.PartitionClause()
			}

		case MySQLParserREMOVE_SYMBOL:
			{
				p.SetState(1394)
				p.RemovePartitioning()
			}

		case MySQLParserEOF, MySQLParserSEMICOLON_SYMBOL:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1397)
			p.PartitionClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1398)
			p.RemovePartitioning()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1402)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1399)
				p.AlterCommandsModifierList()
			}
			{
				p.SetState(1400)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1404)
			p.StandaloneAlterCommands()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCommandListContext is an interface to support dynamic dispatch.
type IAlterCommandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterCommandsModifierList() IAlterCommandsModifierListContext
	AlterList() IAlterListContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsAlterCommandListContext differentiates from other interfaces.
	IsAlterCommandListContext()
}

type AlterCommandListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterCommandListContext() *AlterCommandListContext {
	var p = new(AlterCommandListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandList
	return p
}

func InitEmptyAlterCommandListContext(p *AlterCommandListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandList
}

func (*AlterCommandListContext) IsAlterCommandListContext() {}

func NewAlterCommandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCommandListContext {
	var p = new(AlterCommandListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterCommandList

	return p
}

func (s *AlterCommandListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCommandListContext) AlterCommandsModifierList() IAlterCommandsModifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCommandsModifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCommandsModifierListContext)
}

func (s *AlterCommandListContext) AlterList() IAlterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterListContext)
}

func (s *AlterCommandListContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *AlterCommandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCommandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCommandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterCommandList(s)
	}
}

func (s *AlterCommandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterCommandList(s)
	}
}

func (s *AlterCommandListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterCommandList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterCommandList() (localctx IAlterCommandListContext) {
	localctx = NewAlterCommandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, MySQLParserRULE_alterCommandList)
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1407)
			p.AlterCommandsModifierList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1411)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1408)
				p.AlterCommandsModifierList()
			}
			{
				p.SetState(1409)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1413)
			p.AlterList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCommandsModifierListContext is an interface to support dynamic dispatch.
type IAlterCommandsModifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterCommandsModifier() []IAlterCommandsModifierContext
	AlterCommandsModifier(i int) IAlterCommandsModifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterCommandsModifierListContext differentiates from other interfaces.
	IsAlterCommandsModifierListContext()
}

type AlterCommandsModifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterCommandsModifierListContext() *AlterCommandsModifierListContext {
	var p = new(AlterCommandsModifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandsModifierList
	return p
}

func InitEmptyAlterCommandsModifierListContext(p *AlterCommandsModifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandsModifierList
}

func (*AlterCommandsModifierListContext) IsAlterCommandsModifierListContext() {}

func NewAlterCommandsModifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCommandsModifierListContext {
	var p = new(AlterCommandsModifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterCommandsModifierList

	return p
}

func (s *AlterCommandsModifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCommandsModifierListContext) AllAlterCommandsModifier() []IAlterCommandsModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterCommandsModifierContext); ok {
			len++
		}
	}

	tst := make([]IAlterCommandsModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterCommandsModifierContext); ok {
			tst[i] = t.(IAlterCommandsModifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterCommandsModifierListContext) AlterCommandsModifier(i int) IAlterCommandsModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCommandsModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCommandsModifierContext)
}

func (s *AlterCommandsModifierListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterCommandsModifierListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterCommandsModifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCommandsModifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCommandsModifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterCommandsModifierList(s)
	}
}

func (s *AlterCommandsModifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterCommandsModifierList(s)
	}
}

func (s *AlterCommandsModifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterCommandsModifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterCommandsModifierList() (localctx IAlterCommandsModifierListContext) {
	localctx = NewAlterCommandsModifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, MySQLParserRULE_alterCommandsModifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.AlterCommandsModifier()
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1417)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1418)
				p.AlterCommandsModifier()
			}

		}
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandaloneAlterCommandsContext is an interface to support dynamic dispatch.
type IStandaloneAlterCommandsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISCARD_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	AlterPartition() IAlterPartitionContext
	SECONDARY_LOAD_SYMBOL() antlr.TerminalNode
	SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode

	// IsStandaloneAlterCommandsContext differentiates from other interfaces.
	IsStandaloneAlterCommandsContext()
}

type StandaloneAlterCommandsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandaloneAlterCommandsContext() *StandaloneAlterCommandsContext {
	var p = new(StandaloneAlterCommandsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_standaloneAlterCommands
	return p
}

func InitEmptyStandaloneAlterCommandsContext(p *StandaloneAlterCommandsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_standaloneAlterCommands
}

func (*StandaloneAlterCommandsContext) IsStandaloneAlterCommandsContext() {}

func NewStandaloneAlterCommandsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandaloneAlterCommandsContext {
	var p = new(StandaloneAlterCommandsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_standaloneAlterCommands

	return p
}

func (s *StandaloneAlterCommandsContext) GetParser() antlr.Parser { return s.parser }

func (s *StandaloneAlterCommandsContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISCARD_SYMBOL, 0)
}

func (s *StandaloneAlterCommandsContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *StandaloneAlterCommandsContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *StandaloneAlterCommandsContext) AlterPartition() IAlterPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPartitionContext)
}

func (s *StandaloneAlterCommandsContext) SECONDARY_LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_LOAD_SYMBOL, 0)
}

func (s *StandaloneAlterCommandsContext) SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_UNLOAD_SYMBOL, 0)
}

func (s *StandaloneAlterCommandsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandaloneAlterCommandsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandaloneAlterCommandsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStandaloneAlterCommands(s)
	}
}

func (s *StandaloneAlterCommandsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStandaloneAlterCommands(s)
	}
}

func (s *StandaloneAlterCommandsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStandaloneAlterCommands(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StandaloneAlterCommands() (localctx IStandaloneAlterCommandsContext) {
	localctx = NewStandaloneAlterCommandsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, MySQLParserRULE_standaloneAlterCommands)
	var _la int

	p.SetState(1431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1424)
			p.Match(MySQLParserDISCARD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1425)
			p.Match(MySQLParserTABLESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1426)
			p.Match(MySQLParserIMPORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.Match(MySQLParserTABLESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1428)
			p.AlterPartition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1429)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(1430)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserSECONDARY_LOAD_SYMBOL || _la == MySQLParserSECONDARY_UNLOAD_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPartitionContext is an interface to support dynamic dispatch.
type IAlterPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_SYMBOL() antlr.TerminalNode
	PARTITION_SYMBOL() antlr.TerminalNode
	PartitionDefinitions() IPartitionDefinitionsContext
	PARTITIONS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	AllNoWriteToBinLog() []INoWriteToBinLogContext
	NoWriteToBinLog(i int) INoWriteToBinLogContext
	DROP_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	REBUILD_SYMBOL() antlr.TerminalNode
	AllOrPartitionNameList() IAllOrPartitionNameListContext
	OPTIMIZE_SYMBOL() antlr.TerminalNode
	ANALYZE_SYMBOL() antlr.TerminalNode
	CHECK_SYMBOL() antlr.TerminalNode
	AllCheckOption() []ICheckOptionContext
	CheckOption(i int) ICheckOptionContext
	REPAIR_SYMBOL() antlr.TerminalNode
	AllRepairType() []IRepairTypeContext
	RepairType(i int) IRepairTypeContext
	COALESCE_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	REORGANIZE_SYMBOL() antlr.TerminalNode
	INTO_SYMBOL() antlr.TerminalNode
	EXCHANGE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	WithValidation() IWithValidationContext
	DISCARD_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode

	// IsAlterPartitionContext differentiates from other interfaces.
	IsAlterPartitionContext()
}

type AlterPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPartitionContext() *AlterPartitionContext {
	var p = new(AlterPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterPartition
	return p
}

func InitEmptyAlterPartitionContext(p *AlterPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterPartition
}

func (*AlterPartitionContext) IsAlterPartitionContext() {}

func NewAlterPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPartitionContext {
	var p = new(AlterPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterPartition

	return p
}

func (s *AlterPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPartitionContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *AlterPartitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *AlterPartitionContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *AlterPartitionContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONS_SYMBOL, 0)
}

func (s *AlterPartitionContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *AlterPartitionContext) AllNoWriteToBinLog() []INoWriteToBinLogContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INoWriteToBinLogContext); ok {
			len++
		}
	}

	tst := make([]INoWriteToBinLogContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INoWriteToBinLogContext); ok {
			tst[i] = t.(INoWriteToBinLogContext)
			i++
		}
	}

	return tst
}

func (s *AlterPartitionContext) NoWriteToBinLog(i int) INoWriteToBinLogContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoWriteToBinLogContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoWriteToBinLogContext)
}

func (s *AlterPartitionContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *AlterPartitionContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AlterPartitionContext) REBUILD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREBUILD_SYMBOL, 0)
}

func (s *AlterPartitionContext) AllOrPartitionNameList() IAllOrPartitionNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllOrPartitionNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllOrPartitionNameListContext)
}

func (s *AlterPartitionContext) OPTIMIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIMIZE_SYMBOL, 0)
}

func (s *AlterPartitionContext) ANALYZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANALYZE_SYMBOL, 0)
}

func (s *AlterPartitionContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECK_SYMBOL, 0)
}

func (s *AlterPartitionContext) AllCheckOption() []ICheckOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckOptionContext); ok {
			tst[i] = t.(ICheckOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterPartitionContext) CheckOption(i int) ICheckOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckOptionContext)
}

func (s *AlterPartitionContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPAIR_SYMBOL, 0)
}

func (s *AlterPartitionContext) AllRepairType() []IRepairTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRepairTypeContext); ok {
			len++
		}
	}

	tst := make([]IRepairTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRepairTypeContext); ok {
			tst[i] = t.(IRepairTypeContext)
			i++
		}
	}

	return tst
}

func (s *AlterPartitionContext) RepairType(i int) IRepairTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTypeContext)
}

func (s *AlterPartitionContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOALESCE_SYMBOL, 0)
}

func (s *AlterPartitionContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUNCATE_SYMBOL, 0)
}

func (s *AlterPartitionContext) REORGANIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREORGANIZE_SYMBOL, 0)
}

func (s *AlterPartitionContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *AlterPartitionContext) EXCHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCHANGE_SYMBOL, 0)
}

func (s *AlterPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterPartitionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *AlterPartitionContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *AlterPartitionContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *AlterPartitionContext) WithValidation() IWithValidationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithValidationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithValidationContext)
}

func (s *AlterPartitionContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISCARD_SYMBOL, 0)
}

func (s *AlterPartitionContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *AlterPartitionContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *AlterPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterPartition(s)
	}
}

func (s *AlterPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterPartition(s)
	}
}

func (s *AlterPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterPartition() (localctx IAlterPartitionContext) {
	localctx = NewAlterPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, MySQLParserRULE_alterPartition)
	var _la int

	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1433)
			p.Match(MySQLParserADD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1434)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1436)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(1435)
				p.NoWriteToBinLog()
			}

		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserOPEN_PAR_SYMBOL:
			{
				p.SetState(1438)
				p.PartitionDefinitions()
			}

		case MySQLParserPARTITIONS_SYMBOL:
			{
				p.SetState(1439)
				p.Match(MySQLParserPARTITIONS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1440)
				p.Real_ulong_number()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1443)
			p.Match(MySQLParserDROP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1444)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1445)
			p.IdentifierList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1446)
			p.Match(MySQLParserREBUILD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1447)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1448)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1451)
			p.AllOrPartitionNameList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1452)
			p.Match(MySQLParserOPTIMIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1453)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1455)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1454)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1457)
			p.AllOrPartitionNameList()
		}
		p.SetState(1459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(1458)
				p.NoWriteToBinLog()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1461)
			p.Match(MySQLParserANALYZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1462)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1463)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1466)
			p.AllOrPartitionNameList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1467)
			p.Match(MySQLParserCHECK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1468)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1469)
			p.AllOrPartitionNameList()
		}
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCHANGED_SYMBOL || ((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&1048593) != 0) || _la == MySQLParserMEDIUM_SYMBOL || _la == MySQLParserQUICK_SYMBOL {
			{
				p.SetState(1470)
				p.CheckOption()
			}

			p.SetState(1475)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1476)
			p.Match(MySQLParserREPAIR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1479)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1478)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1481)
			p.AllOrPartitionNameList()
		}
		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserQUICK_SYMBOL || _la == MySQLParserUSE_FRM_SYMBOL {
			{
				p.SetState(1482)
				p.RepairType()
			}

			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1488)
			p.Match(MySQLParserCOALESCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1489)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(1490)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(1493)
			p.Real_ulong_number()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1494)
			p.Match(MySQLParserTRUNCATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1495)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1496)
			p.AllOrPartitionNameList()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1497)
			p.Match(MySQLParserREORGANIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1498)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1500)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1499)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1502)
				p.IdentifierList()
			}
			{
				p.SetState(1503)
				p.Match(MySQLParserINTO_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1504)
				p.PartitionDefinitions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1508)
			p.Match(MySQLParserEXCHANGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1509)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)
			p.Identifier()
		}
		{
			p.SetState(1511)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.TableRef()
		}
		p.SetState(1515)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1514)
				p.WithValidation()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(1517)

		if !(serverVersion >= 50704) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50704", ""))
			goto errorExit
		}
		{
			p.SetState(1518)
			p.Match(MySQLParserDISCARD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1519)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1520)
			p.AllOrPartitionNameList()
		}
		{
			p.SetState(1521)
			p.Match(MySQLParserTABLESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(1523)

		if !(serverVersion >= 50704) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50704", ""))
			goto errorExit
		}
		{
			p.SetState(1524)
			p.Match(MySQLParserIMPORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1525)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1526)
			p.AllOrPartitionNameList()
		}
		{
			p.SetState(1527)
			p.Match(MySQLParserTABLESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterListContext is an interface to support dynamic dispatch.
type IAlterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterListItem() []IAlterListItemContext
	AlterListItem(i int) IAlterListItemContext
	AllCreateTableOptionsSpaceSeparated() []ICreateTableOptionsSpaceSeparatedContext
	CreateTableOptionsSpaceSeparated(i int) ICreateTableOptionsSpaceSeparatedContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	AllAlterCommandsModifier() []IAlterCommandsModifierContext
	AlterCommandsModifier(i int) IAlterCommandsModifierContext

	// IsAlterListContext differentiates from other interfaces.
	IsAlterListContext()
}

type AlterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterListContext() *AlterListContext {
	var p = new(AlterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterList
	return p
}

func InitEmptyAlterListContext(p *AlterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterList
}

func (*AlterListContext) IsAlterListContext() {}

func NewAlterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterListContext {
	var p = new(AlterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterList

	return p
}

func (s *AlterListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterListContext) AllAlterListItem() []IAlterListItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterListItemContext); ok {
			len++
		}
	}

	tst := make([]IAlterListItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterListItemContext); ok {
			tst[i] = t.(IAlterListItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterListContext) AlterListItem(i int) IAlterListItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterListItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterListItemContext)
}

func (s *AlterListContext) AllCreateTableOptionsSpaceSeparated() []ICreateTableOptionsSpaceSeparatedContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableOptionsSpaceSeparatedContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableOptionsSpaceSeparatedContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableOptionsSpaceSeparatedContext); ok {
			tst[i] = t.(ICreateTableOptionsSpaceSeparatedContext)
			i++
		}
	}

	return tst
}

func (s *AlterListContext) CreateTableOptionsSpaceSeparated(i int) ICreateTableOptionsSpaceSeparatedContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionsSpaceSeparatedContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionsSpaceSeparatedContext)
}

func (s *AlterListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterListContext) AllAlterCommandsModifier() []IAlterCommandsModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterCommandsModifierContext); ok {
			len++
		}
	}

	tst := make([]IAlterCommandsModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterCommandsModifierContext); ok {
			tst[i] = t.(IAlterCommandsModifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterListContext) AlterCommandsModifier(i int) IAlterCommandsModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCommandsModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCommandsModifierContext)
}

func (s *AlterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterList(s)
	}
}

func (s *AlterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterList(s)
	}
}

func (s *AlterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterList() (localctx IAlterListContext) {
	localctx = NewAlterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, MySQLParserRULE_alterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1531)
			p.AlterListItem()
		}

	case 2:
		{
			p.SetState(1532)
			p.CreateTableOptionsSpaceSeparated()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(1535)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1536)
				p.AlterListItem()
			}

		case 2:
			{
				p.SetState(1537)
				p.AlterCommandsModifier()
			}

		case 3:
			{
				p.SetState(1538)
				p.CreateTableOptionsSpaceSeparated()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(1545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCommandsModifierContext is an interface to support dynamic dispatch.
type IAlterCommandsModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterAlgorithmOption() IAlterAlgorithmOptionContext
	AlterLockOption() IAlterLockOptionContext
	WithValidation() IWithValidationContext

	// IsAlterCommandsModifierContext differentiates from other interfaces.
	IsAlterCommandsModifierContext()
}

type AlterCommandsModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterCommandsModifierContext() *AlterCommandsModifierContext {
	var p = new(AlterCommandsModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandsModifier
	return p
}

func InitEmptyAlterCommandsModifierContext(p *AlterCommandsModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterCommandsModifier
}

func (*AlterCommandsModifierContext) IsAlterCommandsModifierContext() {}

func NewAlterCommandsModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCommandsModifierContext {
	var p = new(AlterCommandsModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterCommandsModifier

	return p
}

func (s *AlterCommandsModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCommandsModifierContext) AlterAlgorithmOption() IAlterAlgorithmOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterAlgorithmOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterAlgorithmOptionContext)
}

func (s *AlterCommandsModifierContext) AlterLockOption() IAlterLockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLockOptionContext)
}

func (s *AlterCommandsModifierContext) WithValidation() IWithValidationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithValidationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithValidationContext)
}

func (s *AlterCommandsModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCommandsModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCommandsModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterCommandsModifier(s)
	}
}

func (s *AlterCommandsModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterCommandsModifier(s)
	}
}

func (s *AlterCommandsModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterCommandsModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterCommandsModifier() (localctx IAlterCommandsModifierContext) {
	localctx = NewAlterCommandsModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, MySQLParserRULE_alterCommandsModifier)
	p.SetState(1549)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1546)
			p.AlterAlgorithmOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1547)
			p.AlterLockOption()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1548)
			p.WithValidation()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterListItemContext is an interface to support dynamic dispatch.
type IAlterListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	FieldDefinition() IFieldDefinitionContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	TableElementList() ITableElementListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	COLUMN_SYMBOL() antlr.TerminalNode
	CheckOrReferences() ICheckOrReferencesContext
	Place() IPlaceContext
	TableConstraintDef() ITableConstraintDefContext
	CHANGE_SYMBOL() antlr.TerminalNode
	ColumnInternalRef() IColumnInternalRefContext
	MODIFY_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode
	FOREIGN_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	PRIMARY_SYMBOL() antlr.TerminalNode
	KeyOrIndex() IKeyOrIndexContext
	IndexRef() IIndexRefContext
	CHECK_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SYMBOL() antlr.TerminalNode
	Restrict() IRestrictContext
	DISABLE_SYMBOL() antlr.TerminalNode
	KEYS_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	ALTER_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	ExprWithParentheses() IExprWithParenthesesContext
	SignedLiteral() ISignedLiteralContext
	INDEX_SYMBOL() antlr.TerminalNode
	Visibility() IVisibilityContext
	ConstraintEnforcement() IConstraintEnforcementContext
	RENAME_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	TableName() ITableNameContext
	AS_SYMBOL() antlr.TerminalNode
	IndexName() IIndexNameContext
	CONVERT_SYMBOL() antlr.TerminalNode
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext
	Collate() ICollateContext
	FORCE_SYMBOL() antlr.TerminalNode
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AlterOrderList() IAlterOrderListContext
	UPGRADE_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode

	// IsAlterListItemContext differentiates from other interfaces.
	IsAlterListItemContext()
}

type AlterListItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterListItemContext() *AlterListItemContext {
	var p = new(AlterListItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterListItem
	return p
}

func InitEmptyAlterListItemContext(p *AlterListItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterListItem
}

func (*AlterListItemContext) IsAlterListItemContext() {}

func NewAlterListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterListItemContext {
	var p = new(AlterListItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterListItem

	return p
}

func (s *AlterListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterListItemContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *AlterListItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterListItemContext) FieldDefinition() IFieldDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefinitionContext)
}

func (s *AlterListItemContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *AlterListItemContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *AlterListItemContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *AlterListItemContext) COLUMN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_SYMBOL, 0)
}

func (s *AlterListItemContext) CheckOrReferences() ICheckOrReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckOrReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckOrReferencesContext)
}

func (s *AlterListItemContext) Place() IPlaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlaceContext)
}

func (s *AlterListItemContext) TableConstraintDef() ITableConstraintDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintDefContext)
}

func (s *AlterListItemContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGE_SYMBOL, 0)
}

func (s *AlterListItemContext) ColumnInternalRef() IColumnInternalRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefContext)
}

func (s *AlterListItemContext) MODIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODIFY_SYMBOL, 0)
}

func (s *AlterListItemContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *AlterListItemContext) FOREIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOREIGN_SYMBOL, 0)
}

func (s *AlterListItemContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *AlterListItemContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *AlterListItemContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *AlterListItemContext) IndexRef() IIndexRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexRefContext)
}

func (s *AlterListItemContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECK_SYMBOL, 0)
}

func (s *AlterListItemContext) CONSTRAINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_SYMBOL, 0)
}

func (s *AlterListItemContext) Restrict() IRestrictContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictContext)
}

func (s *AlterListItemContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *AlterListItemContext) KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEYS_SYMBOL, 0)
}

func (s *AlterListItemContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *AlterListItemContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALTER_SYMBOL, 0)
}

func (s *AlterListItemContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *AlterListItemContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *AlterListItemContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *AlterListItemContext) SignedLiteral() ISignedLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedLiteralContext)
}

func (s *AlterListItemContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *AlterListItemContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *AlterListItemContext) ConstraintEnforcement() IConstraintEnforcementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintEnforcementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintEnforcementContext)
}

func (s *AlterListItemContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRENAME_SYMBOL, 0)
}

func (s *AlterListItemContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *AlterListItemContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AlterListItemContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *AlterListItemContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *AlterListItemContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONVERT_SYMBOL, 0)
}

func (s *AlterListItemContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *AlterListItemContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *AlterListItemContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *AlterListItemContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORCE_SYMBOL, 0)
}

func (s *AlterListItemContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDER_SYMBOL, 0)
}

func (s *AlterListItemContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *AlterListItemContext) AlterOrderList() IAlterOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterOrderListContext)
}

func (s *AlterListItemContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPGRADE_SYMBOL, 0)
}

func (s *AlterListItemContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONING_SYMBOL, 0)
}

func (s *AlterListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterListItem(s)
	}
}

func (s *AlterListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterListItem(s)
	}
}

func (s *AlterListItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterListItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterListItem() (localctx IAlterListItemContext) {
	localctx = NewAlterListItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, MySQLParserRULE_alterListItem)
	var _la int

	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1551)
			p.Match(MySQLParserADD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1552)
				p.Match(MySQLParserCOLUMN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1555)
				p.Identifier()
			}
			{
				p.SetState(1556)
				p.FieldDefinition()
			}
			p.SetState(1558)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1557)
					p.CheckOrReferences()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(1561)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserAFTER_SYMBOL || _la == MySQLParserFIRST_SYMBOL {
				{
					p.SetState(1560)
					p.Place()
				}

			}

		case 2:
			{
				p.SetState(1563)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1564)
				p.TableElementList()
			}
			{
				p.SetState(1565)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1569)
			p.Match(MySQLParserADD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)
			p.TableConstraintDef()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1571)
			p.Match(MySQLParserCHANGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1572)
				p.Match(MySQLParserCOLUMN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1575)
			p.ColumnInternalRef()
		}
		{
			p.SetState(1576)
			p.Identifier()
		}
		{
			p.SetState(1577)
			p.FieldDefinition()
		}
		p.SetState(1579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserAFTER_SYMBOL || _la == MySQLParserFIRST_SYMBOL {
			{
				p.SetState(1578)
				p.Place()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1581)
			p.Match(MySQLParserMODIFY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1583)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1582)
				p.Match(MySQLParserCOLUMN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1585)
			p.ColumnInternalRef()
		}
		{
			p.SetState(1586)
			p.FieldDefinition()
		}
		p.SetState(1588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserAFTER_SYMBOL || _la == MySQLParserFIRST_SYMBOL {
			{
				p.SetState(1587)
				p.Place()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1590)
			p.Match(MySQLParserDROP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1592)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1591)
					p.Match(MySQLParserCOLUMN_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1594)
				p.ColumnInternalRef()
			}
			p.SetState(1596)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL {
				{
					p.SetState(1595)
					p.Restrict()
				}

			}

		case 2:
			{
				p.SetState(1598)
				p.Match(MySQLParserFOREIGN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1599)
				p.Match(MySQLParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1606)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1600)

				if !(serverVersion >= 50700) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
					goto errorExit
				}
				{
					p.SetState(1601)
					p.ColumnInternalRef()
				}

			case 2:
				p.SetState(1602)

				if !(serverVersion < 50700) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50700", ""))
					goto errorExit
				}
				p.SetState(1604)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1603)
						p.ColumnInternalRef()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case 3:
			{
				p.SetState(1608)
				p.Match(MySQLParserPRIMARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1609)
				p.Match(MySQLParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(1610)
				p.KeyOrIndex()
			}
			{
				p.SetState(1611)
				p.IndexRef()
			}

		case 5:
			p.SetState(1613)

			if !(serverVersion >= 80017) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
				goto errorExit
			}
			{
				p.SetState(1614)
				p.Match(MySQLParserCHECK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1615)
				p.Identifier()
			}

		case 6:
			p.SetState(1616)

			if !(serverVersion >= 80019) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
				goto errorExit
			}
			{
				p.SetState(1617)
				p.Match(MySQLParserCONSTRAINT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1618)
				p.Identifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1621)
			p.Match(MySQLParserDISABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1622)
			p.Match(MySQLParserKEYS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1623)
			p.Match(MySQLParserENABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Match(MySQLParserKEYS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1625)
			p.Match(MySQLParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1627)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1626)
				p.Match(MySQLParserCOLUMN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1629)
			p.ColumnInternalRef()
		}
		p.SetState(1639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserSET_SYMBOL:
			{
				p.SetState(1630)
				p.Match(MySQLParserSET_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1631)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1635)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
			case 1:
				p.SetState(1632)

				if !(serverVersion >= 80014) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
					goto errorExit
				}
				{
					p.SetState(1633)
					p.ExprWithParentheses()
				}

			case 2:
				{
					p.SetState(1634)
					p.SignedLiteral()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		case MySQLParserDROP_SYMBOL:
			{
				p.SetState(1637)
				p.Match(MySQLParserDROP_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1638)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(1641)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1642)
			p.Match(MySQLParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1643)
			p.Match(MySQLParserINDEX_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1644)
			p.IndexRef()
		}
		{
			p.SetState(1645)
			p.Visibility()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(1647)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(1648)
			p.Match(MySQLParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1649)
			p.Match(MySQLParserCHECK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1650)
			p.Identifier()
		}
		{
			p.SetState(1651)
			p.ConstraintEnforcement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(1653)

		if !(serverVersion >= 80019) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
			goto errorExit
		}
		{
			p.SetState(1654)
			p.Match(MySQLParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1655)
			p.Match(MySQLParserCONSTRAINT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Identifier()
		}
		{
			p.SetState(1657)
			p.ConstraintEnforcement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(1659)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1660)
			p.Match(MySQLParserRENAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.Match(MySQLParserCOLUMN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.ColumnInternalRef()
		}
		{
			p.SetState(1663)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1664)
			p.Identifier()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1666)
			p.Match(MySQLParserRENAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1667)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserAS_SYMBOL || _la == MySQLParserTO_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1670)
			p.TableName()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(1671)

		if !(serverVersion >= 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
			goto errorExit
		}
		{
			p.SetState(1672)
			p.Match(MySQLParserRENAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1673)
			p.KeyOrIndex()
		}
		{
			p.SetState(1674)
			p.IndexRef()
		}
		{
			p.SetState(1675)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.IndexName()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1678)
			p.Match(MySQLParserCONVERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1679)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1680)
			p.Charset()
		}
		p.SetState(1684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1681)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(1682)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1683)
				p.CharsetName()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(1687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOLLATE_SYMBOL {
			{
				p.SetState(1686)
				p.Collate()
			}

		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1689)
			p.Match(MySQLParserFORCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1690)
			p.Match(MySQLParserORDER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1691)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1692)
			p.AlterOrderList()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		p.SetState(1693)

		if !(serverVersion >= 50708 && serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50708 && serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1694)
			p.Match(MySQLParserUPGRADE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1695)
			p.Match(MySQLParserPARTITIONING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPlaceContext is an interface to support dynamic dispatch.
type IPlaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AFTER_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	FIRST_SYMBOL() antlr.TerminalNode

	// IsPlaceContext differentiates from other interfaces.
	IsPlaceContext()
}

type PlaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlaceContext() *PlaceContext {
	var p = new(PlaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_place
	return p
}

func InitEmptyPlaceContext(p *PlaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_place
}

func (*PlaceContext) IsPlaceContext() {}

func NewPlaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlaceContext {
	var p = new(PlaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_place

	return p
}

func (s *PlaceContext) GetParser() antlr.Parser { return s.parser }

func (s *PlaceContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAFTER_SYMBOL, 0)
}

func (s *PlaceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PlaceContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *PlaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPlace(s)
	}
}

func (s *PlaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPlace(s)
	}
}

func (s *PlaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPlace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Place() (localctx IPlaceContext) {
	localctx = NewPlaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, MySQLParserRULE_place)
	p.SetState(1701)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserAFTER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1698)
			p.Match(MySQLParserAFTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1699)
			p.Identifier()
		}

	case MySQLParserFIRST_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1700)
			p.Match(MySQLParserFIRST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestrictContext is an interface to support dynamic dispatch.
type IRestrictContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode

	// IsRestrictContext differentiates from other interfaces.
	IsRestrictContext()
}

type RestrictContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrictContext() *RestrictContext {
	var p = new(RestrictContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_restrict
	return p
}

func InitEmptyRestrictContext(p *RestrictContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_restrict
}

func (*RestrictContext) IsRestrictContext() {}

func NewRestrictContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestrictContext {
	var p = new(RestrictContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_restrict

	return p
}

func (s *RestrictContext) GetParser() antlr.Parser { return s.parser }

func (s *RestrictContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTRICT_SYMBOL, 0)
}

func (s *RestrictContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADE_SYMBOL, 0)
}

func (s *RestrictContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestrictContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestrictContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRestrict(s)
	}
}

func (s *RestrictContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRestrict(s)
	}
}

func (s *RestrictContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRestrict(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Restrict() (localctx IRestrictContext) {
	localctx = NewRestrictContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, MySQLParserRULE_restrict)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1703)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterOrderListContext is an interface to support dynamic dispatch.
type IAlterOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDirection() []IDirectionContext
	Direction(i int) IDirectionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterOrderListContext differentiates from other interfaces.
	IsAlterOrderListContext()
}

type AlterOrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterOrderListContext() *AlterOrderListContext {
	var p = new(AlterOrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterOrderList
	return p
}

func InitEmptyAlterOrderListContext(p *AlterOrderListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterOrderList
}

func (*AlterOrderListContext) IsAlterOrderListContext() {}

func NewAlterOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterOrderListContext {
	var p = new(AlterOrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterOrderList

	return p
}

func (s *AlterOrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterOrderListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterOrderListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterOrderListContext) AllDirection() []IDirectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDirectionContext); ok {
			len++
		}
	}

	tst := make([]IDirectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDirectionContext); ok {
			tst[i] = t.(IDirectionContext)
			i++
		}
	}

	return tst
}

func (s *AlterOrderListContext) Direction(i int) IDirectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *AlterOrderListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterOrderListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterOrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterOrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterOrderListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterOrderList(s)
	}
}

func (s *AlterOrderListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterOrderList(s)
	}
}

func (s *AlterOrderListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterOrderList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterOrderList() (localctx IAlterOrderListContext) {
	localctx = NewAlterOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, MySQLParserRULE_alterOrderList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Identifier()
	}
	p.SetState(1707)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL {
		{
			p.SetState(1706)
			p.Direction()
		}

	}
	p.SetState(1716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1709)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1710)
				p.Identifier()
			}
			p.SetState(1712)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL {
				{
					p.SetState(1711)
					p.Direction()
				}

			}

		}
		p.SetState(1718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterAlgorithmOptionContext is an interface to support dynamic dispatch.
type IAlterAlgorithmOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALGORITHM_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsAlterAlgorithmOptionContext differentiates from other interfaces.
	IsAlterAlgorithmOptionContext()
}

type AlterAlgorithmOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterAlgorithmOptionContext() *AlterAlgorithmOptionContext {
	var p = new(AlterAlgorithmOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterAlgorithmOption
	return p
}

func InitEmptyAlterAlgorithmOptionContext(p *AlterAlgorithmOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterAlgorithmOption
}

func (*AlterAlgorithmOptionContext) IsAlterAlgorithmOptionContext() {}

func NewAlterAlgorithmOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterAlgorithmOptionContext {
	var p = new(AlterAlgorithmOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterAlgorithmOption

	return p
}

func (s *AlterAlgorithmOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterAlgorithmOptionContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALGORITHM_SYMBOL, 0)
}

func (s *AlterAlgorithmOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *AlterAlgorithmOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterAlgorithmOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *AlterAlgorithmOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterAlgorithmOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterAlgorithmOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterAlgorithmOption(s)
	}
}

func (s *AlterAlgorithmOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterAlgorithmOption(s)
	}
}

func (s *AlterAlgorithmOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterAlgorithmOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterAlgorithmOption() (localctx IAlterAlgorithmOptionContext) {
	localctx = NewAlterAlgorithmOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, MySQLParserRULE_alterAlgorithmOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1719)
		p.Match(MySQLParserALGORITHM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1720)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1723)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1724)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLockOptionContext is an interface to support dynamic dispatch.
type IAlterLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsAlterLockOptionContext differentiates from other interfaces.
	IsAlterLockOptionContext()
}

type AlterLockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLockOptionContext() *AlterLockOptionContext {
	var p = new(AlterLockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLockOption
	return p
}

func InitEmptyAlterLockOptionContext(p *AlterLockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterLockOption
}

func (*AlterLockOptionContext) IsAlterLockOptionContext() {}

func NewAlterLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLockOptionContext {
	var p = new(AlterLockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterLockOption

	return p
}

func (s *AlterLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLockOptionContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *AlterLockOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *AlterLockOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterLockOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *AlterLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterLockOption(s)
	}
}

func (s *AlterLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterLockOption(s)
	}
}

func (s *AlterLockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterLockOption() (localctx IAlterLockOptionContext) {
	localctx = NewAlterLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, MySQLParserRULE_alterLockOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1727)
		p.Match(MySQLParserLOCK_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1728)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1731)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(1732)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexLockAndAlgorithmContext is an interface to support dynamic dispatch.
type IIndexLockAndAlgorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterAlgorithmOption() IAlterAlgorithmOptionContext
	AlterLockOption() IAlterLockOptionContext

	// IsIndexLockAndAlgorithmContext differentiates from other interfaces.
	IsIndexLockAndAlgorithmContext()
}

type IndexLockAndAlgorithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexLockAndAlgorithmContext() *IndexLockAndAlgorithmContext {
	var p = new(IndexLockAndAlgorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexLockAndAlgorithm
	return p
}

func InitEmptyIndexLockAndAlgorithmContext(p *IndexLockAndAlgorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexLockAndAlgorithm
}

func (*IndexLockAndAlgorithmContext) IsIndexLockAndAlgorithmContext() {}

func NewIndexLockAndAlgorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexLockAndAlgorithmContext {
	var p = new(IndexLockAndAlgorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexLockAndAlgorithm

	return p
}

func (s *IndexLockAndAlgorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexLockAndAlgorithmContext) AlterAlgorithmOption() IAlterAlgorithmOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterAlgorithmOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterAlgorithmOptionContext)
}

func (s *IndexLockAndAlgorithmContext) AlterLockOption() IAlterLockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLockOptionContext)
}

func (s *IndexLockAndAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexLockAndAlgorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexLockAndAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexLockAndAlgorithm(s)
	}
}

func (s *IndexLockAndAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexLockAndAlgorithm(s)
	}
}

func (s *IndexLockAndAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexLockAndAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexLockAndAlgorithm() (localctx IIndexLockAndAlgorithmContext) {
	localctx = NewIndexLockAndAlgorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, MySQLParserRULE_indexLockAndAlgorithm)
	var _la int

	p.SetState(1743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserALGORITHM_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1735)
			p.AlterAlgorithmOption()
		}
		p.SetState(1737)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCK_SYMBOL {
			{
				p.SetState(1736)
				p.AlterLockOption()
			}

		}

	case MySQLParserLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1739)
			p.AlterLockOption()
		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserALGORITHM_SYMBOL {
			{
				p.SetState(1740)
				p.AlterAlgorithmOption()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithValidationContext is an interface to support dynamic dispatch.
type IWithValidationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALIDATION_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	WITHOUT_SYMBOL() antlr.TerminalNode

	// IsWithValidationContext differentiates from other interfaces.
	IsWithValidationContext()
}

type WithValidationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithValidationContext() *WithValidationContext {
	var p = new(WithValidationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withValidation
	return p
}

func InitEmptyWithValidationContext(p *WithValidationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withValidation
}

func (*WithValidationContext) IsWithValidationContext() {}

func NewWithValidationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithValidationContext {
	var p = new(WithValidationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_withValidation

	return p
}

func (s *WithValidationContext) GetParser() antlr.Parser { return s.parser }

func (s *WithValidationContext) VALIDATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALIDATION_SYMBOL, 0)
}

func (s *WithValidationContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *WithValidationContext) WITHOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITHOUT_SYMBOL, 0)
}

func (s *WithValidationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithValidationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithValidationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWithValidation(s)
	}
}

func (s *WithValidationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWithValidation(s)
	}
}

func (s *WithValidationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWithValidation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WithValidation() (localctx IWithValidationContext) {
	localctx = NewWithValidationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, MySQLParserRULE_withValidation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1745)

	if !(serverVersion >= 50706) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
		goto errorExit
	}
	{
		p.SetState(1746)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserWITH_SYMBOL || _la == MySQLParserWITHOUT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1747)
		p.Match(MySQLParserVALIDATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRemovePartitioningContext is an interface to support dynamic dispatch.
type IRemovePartitioningContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REMOVE_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode

	// IsRemovePartitioningContext differentiates from other interfaces.
	IsRemovePartitioningContext()
}

type RemovePartitioningContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemovePartitioningContext() *RemovePartitioningContext {
	var p = new(RemovePartitioningContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_removePartitioning
	return p
}

func InitEmptyRemovePartitioningContext(p *RemovePartitioningContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_removePartitioning
}

func (*RemovePartitioningContext) IsRemovePartitioningContext() {}

func NewRemovePartitioningContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemovePartitioningContext {
	var p = new(RemovePartitioningContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_removePartitioning

	return p
}

func (s *RemovePartitioningContext) GetParser() antlr.Parser { return s.parser }

func (s *RemovePartitioningContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREMOVE_SYMBOL, 0)
}

func (s *RemovePartitioningContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONING_SYMBOL, 0)
}

func (s *RemovePartitioningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemovePartitioningContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemovePartitioningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRemovePartitioning(s)
	}
}

func (s *RemovePartitioningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRemovePartitioning(s)
	}
}

func (s *RemovePartitioningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRemovePartitioning(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RemovePartitioning() (localctx IRemovePartitioningContext) {
	localctx = NewRemovePartitioningContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, MySQLParserRULE_removePartitioning)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1749)
		p.Match(MySQLParserREMOVE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1750)
		p.Match(MySQLParserPARTITIONING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAllOrPartitionNameListContext is an interface to support dynamic dispatch.
type IAllOrPartitionNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsAllOrPartitionNameListContext differentiates from other interfaces.
	IsAllOrPartitionNameListContext()
}

type AllOrPartitionNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAllOrPartitionNameListContext() *AllOrPartitionNameListContext {
	var p = new(AllOrPartitionNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_allOrPartitionNameList
	return p
}

func InitEmptyAllOrPartitionNameListContext(p *AllOrPartitionNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_allOrPartitionNameList
}

func (*AllOrPartitionNameListContext) IsAllOrPartitionNameListContext() {}

func NewAllOrPartitionNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AllOrPartitionNameListContext {
	var p = new(AllOrPartitionNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_allOrPartitionNameList

	return p
}

func (s *AllOrPartitionNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *AllOrPartitionNameListContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *AllOrPartitionNameListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AllOrPartitionNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllOrPartitionNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AllOrPartitionNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAllOrPartitionNameList(s)
	}
}

func (s *AllOrPartitionNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAllOrPartitionNameList(s)
	}
}

func (s *AllOrPartitionNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAllOrPartitionNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AllOrPartitionNameList() (localctx IAllOrPartitionNameListContext) {
	localctx = NewAllOrPartitionNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, MySQLParserRULE_allOrPartitionNameList)
	p.SetState(1754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1752)
			p.Match(MySQLParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1753)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTablespaceContext is an interface to support dynamic dispatch.
type IAlterTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceRef() ITablespaceRefContext
	DATAFILE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	RENAME_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	AlterTablespaceOptions() IAlterTablespaceOptionsContext
	ADD_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode
	CHANGE_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode
	ACCESSIBLE_SYMBOL() antlr.TerminalNode
	READ_ONLY_SYMBOL() antlr.TerminalNode
	READ_WRITE_SYMBOL() antlr.TerminalNode
	AllChangeTablespaceOption() []IChangeTablespaceOptionContext
	ChangeTablespaceOption(i int) IChangeTablespaceOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterTablespaceContext differentiates from other interfaces.
	IsAlterTablespaceContext()
}

type AlterTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTablespaceContext() *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespace
	return p
}

func InitEmptyAlterTablespaceContext(p *AlterTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespace
}

func (*AlterTablespaceContext) IsAlterTablespaceContext() {}

func NewAlterTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceContext {
	var p = new(AlterTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterTablespace

	return p
}

func (s *AlterTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *AlterTablespaceContext) TablespaceRef() ITablespaceRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceRefContext)
}

func (s *AlterTablespaceContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATAFILE_SYMBOL, 0)
}

func (s *AlterTablespaceContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *AlterTablespaceContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRENAME_SYMBOL, 0)
}

func (s *AlterTablespaceContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *AlterTablespaceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTablespaceContext) AlterTablespaceOptions() IAlterTablespaceOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceOptionsContext)
}

func (s *AlterTablespaceContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *AlterTablespaceContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *AlterTablespaceContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGE_SYMBOL, 0)
}

func (s *AlterTablespaceContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *AlterTablespaceContext) ACCESSIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACCESSIBLE_SYMBOL, 0)
}

func (s *AlterTablespaceContext) READ_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_ONLY_SYMBOL, 0)
}

func (s *AlterTablespaceContext) READ_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_WRITE_SYMBOL, 0)
}

func (s *AlterTablespaceContext) AllChangeTablespaceOption() []IChangeTablespaceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IChangeTablespaceOptionContext); ok {
			len++
		}
	}

	tst := make([]IChangeTablespaceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IChangeTablespaceOptionContext); ok {
			tst[i] = t.(IChangeTablespaceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterTablespaceContext) ChangeTablespaceOption(i int) IChangeTablespaceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeTablespaceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeTablespaceOptionContext)
}

func (s *AlterTablespaceContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterTablespaceContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterTablespace(s)
	}
}

func (s *AlterTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterTablespace() (localctx IAlterTablespaceContext) {
	localctx = NewAlterTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, MySQLParserRULE_alterTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1756)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1757)
		p.TablespaceRef()
	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1758)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserADD_SYMBOL || _la == MySQLParserDROP_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1759)
			p.Match(MySQLParserDATAFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1760)
			p.TextLiteral()
		}
		p.SetState(1762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserAUTOEXTEND_SIZE_SYMBOL || _la == MySQLParserENCRYPTION_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserMAX_SIZE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL {
			{
				p.SetState(1761)
				p.AlterTablespaceOptions()
			}

		}

	case 2:
		p.SetState(1764)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		p.SetState(1784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserEOF, MySQLParserSEMICOLON_SYMBOL:

		case MySQLParserCHANGE_SYMBOL:
			{
				p.SetState(1766)
				p.Match(MySQLParserCHANGE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1767)
				p.Match(MySQLParserDATAFILE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1768)
				p.TextLiteral()
			}
			p.SetState(1779)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserAUTOEXTEND_SIZE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserMAX_SIZE_SYMBOL {
				{
					p.SetState(1769)
					p.ChangeTablespaceOption()
				}
				p.SetState(1776)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				for _la == MySQLParserAUTOEXTEND_SIZE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserMAX_SIZE_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
					p.SetState(1771)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == MySQLParserCOMMA_SYMBOL {
						{
							p.SetState(1770)
							p.Match(MySQLParserCOMMA_SYMBOL)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(1773)
						p.ChangeTablespaceOption()
					}

					p.SetState(1778)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)
				}

			}

		case MySQLParserREAD_ONLY_SYMBOL, MySQLParserREAD_WRITE_SYMBOL:
			{
				p.SetState(1781)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserREAD_ONLY_SYMBOL || _la == MySQLParserREAD_WRITE_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case MySQLParserNOT_SYMBOL:
			{
				p.SetState(1782)
				p.Match(MySQLParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1783)
				p.Match(MySQLParserACCESSIBLE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		{
			p.SetState(1786)
			p.Match(MySQLParserRENAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1787)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1788)
			p.Identifier()
		}

	case 4:
		p.SetState(1789)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(1790)
			p.AlterTablespaceOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUndoTablespaceContext is an interface to support dynamic dispatch.
type IAlterUndoTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDO_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceRef() ITablespaceRefContext
	SET_SYMBOL() antlr.TerminalNode
	ACTIVE_SYMBOL() antlr.TerminalNode
	INACTIVE_SYMBOL() antlr.TerminalNode
	UndoTableSpaceOptions() IUndoTableSpaceOptionsContext

	// IsAlterUndoTablespaceContext differentiates from other interfaces.
	IsAlterUndoTablespaceContext()
}

type AlterUndoTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUndoTablespaceContext() *AlterUndoTablespaceContext {
	var p = new(AlterUndoTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUndoTablespace
	return p
}

func InitEmptyAlterUndoTablespaceContext(p *AlterUndoTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUndoTablespace
}

func (*AlterUndoTablespaceContext) IsAlterUndoTablespaceContext() {}

func NewAlterUndoTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUndoTablespaceContext {
	var p = new(AlterUndoTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterUndoTablespace

	return p
}

func (s *AlterUndoTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUndoTablespaceContext) UNDO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_SYMBOL, 0)
}

func (s *AlterUndoTablespaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *AlterUndoTablespaceContext) TablespaceRef() ITablespaceRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceRefContext)
}

func (s *AlterUndoTablespaceContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *AlterUndoTablespaceContext) ACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTIVE_SYMBOL, 0)
}

func (s *AlterUndoTablespaceContext) INACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINACTIVE_SYMBOL, 0)
}

func (s *AlterUndoTablespaceContext) UndoTableSpaceOptions() IUndoTableSpaceOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndoTableSpaceOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndoTableSpaceOptionsContext)
}

func (s *AlterUndoTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUndoTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUndoTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterUndoTablespace(s)
	}
}

func (s *AlterUndoTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterUndoTablespace(s)
	}
}

func (s *AlterUndoTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterUndoTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterUndoTablespace() (localctx IAlterUndoTablespaceContext) {
	localctx = NewAlterUndoTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, MySQLParserRULE_alterUndoTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1793)
		p.Match(MySQLParserUNDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1794)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1795)
		p.TablespaceRef()
	}
	{
		p.SetState(1796)
		p.Match(MySQLParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1797)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserACTIVE_SYMBOL || _la == MySQLParserINACTIVE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL {
		{
			p.SetState(1798)
			p.UndoTableSpaceOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUndoTableSpaceOptionsContext is an interface to support dynamic dispatch.
type IUndoTableSpaceOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUndoTableSpaceOption() []IUndoTableSpaceOptionContext
	UndoTableSpaceOption(i int) IUndoTableSpaceOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUndoTableSpaceOptionsContext differentiates from other interfaces.
	IsUndoTableSpaceOptionsContext()
}

type UndoTableSpaceOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUndoTableSpaceOptionsContext() *UndoTableSpaceOptionsContext {
	var p = new(UndoTableSpaceOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOptions
	return p
}

func InitEmptyUndoTableSpaceOptionsContext(p *UndoTableSpaceOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOptions
}

func (*UndoTableSpaceOptionsContext) IsUndoTableSpaceOptionsContext() {}

func NewUndoTableSpaceOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UndoTableSpaceOptionsContext {
	var p = new(UndoTableSpaceOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOptions

	return p
}

func (s *UndoTableSpaceOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *UndoTableSpaceOptionsContext) AllUndoTableSpaceOption() []IUndoTableSpaceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUndoTableSpaceOptionContext); ok {
			len++
		}
	}

	tst := make([]IUndoTableSpaceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUndoTableSpaceOptionContext); ok {
			tst[i] = t.(IUndoTableSpaceOptionContext)
			i++
		}
	}

	return tst
}

func (s *UndoTableSpaceOptionsContext) UndoTableSpaceOption(i int) IUndoTableSpaceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndoTableSpaceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndoTableSpaceOptionContext)
}

func (s *UndoTableSpaceOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *UndoTableSpaceOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *UndoTableSpaceOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndoTableSpaceOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UndoTableSpaceOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUndoTableSpaceOptions(s)
	}
}

func (s *UndoTableSpaceOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUndoTableSpaceOptions(s)
	}
}

func (s *UndoTableSpaceOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUndoTableSpaceOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UndoTableSpaceOptions() (localctx IUndoTableSpaceOptionsContext) {
	localctx = NewUndoTableSpaceOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, MySQLParserRULE_undoTableSpaceOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		p.UndoTableSpaceOption()
	}
	p.SetState(1808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
		p.SetState(1803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(1802)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1805)
			p.UndoTableSpaceOption()
		}

		p.SetState(1810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUndoTableSpaceOptionContext is an interface to support dynamic dispatch.
type IUndoTableSpaceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TsOptionEngine() ITsOptionEngineContext

	// IsUndoTableSpaceOptionContext differentiates from other interfaces.
	IsUndoTableSpaceOptionContext()
}

type UndoTableSpaceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUndoTableSpaceOptionContext() *UndoTableSpaceOptionContext {
	var p = new(UndoTableSpaceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOption
	return p
}

func InitEmptyUndoTableSpaceOptionContext(p *UndoTableSpaceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOption
}

func (*UndoTableSpaceOptionContext) IsUndoTableSpaceOptionContext() {}

func NewUndoTableSpaceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UndoTableSpaceOptionContext {
	var p = new(UndoTableSpaceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_undoTableSpaceOption

	return p
}

func (s *UndoTableSpaceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UndoTableSpaceOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *UndoTableSpaceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndoTableSpaceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UndoTableSpaceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUndoTableSpaceOption(s)
	}
}

func (s *UndoTableSpaceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUndoTableSpaceOption(s)
	}
}

func (s *UndoTableSpaceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUndoTableSpaceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UndoTableSpaceOption() (localctx IUndoTableSpaceOptionContext) {
	localctx = NewUndoTableSpaceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, MySQLParserRULE_undoTableSpaceOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1811)
		p.TsOptionEngine()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTablespaceOptionsContext is an interface to support dynamic dispatch.
type IAlterTablespaceOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterTablespaceOption() []IAlterTablespaceOptionContext
	AlterTablespaceOption(i int) IAlterTablespaceOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterTablespaceOptionsContext differentiates from other interfaces.
	IsAlterTablespaceOptionsContext()
}

type AlterTablespaceOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTablespaceOptionsContext() *AlterTablespaceOptionsContext {
	var p = new(AlterTablespaceOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespaceOptions
	return p
}

func InitEmptyAlterTablespaceOptionsContext(p *AlterTablespaceOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespaceOptions
}

func (*AlterTablespaceOptionsContext) IsAlterTablespaceOptionsContext() {}

func NewAlterTablespaceOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceOptionsContext {
	var p = new(AlterTablespaceOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterTablespaceOptions

	return p
}

func (s *AlterTablespaceOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceOptionsContext) AllAlterTablespaceOption() []IAlterTablespaceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterTablespaceOptionContext); ok {
			len++
		}
	}

	tst := make([]IAlterTablespaceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterTablespaceOptionContext); ok {
			tst[i] = t.(IAlterTablespaceOptionContext)
			i++
		}
	}

	return tst
}

func (s *AlterTablespaceOptionsContext) AlterTablespaceOption(i int) IAlterTablespaceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTablespaceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTablespaceOptionContext)
}

func (s *AlterTablespaceOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterTablespaceOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterTablespaceOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterTablespaceOptions(s)
	}
}

func (s *AlterTablespaceOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterTablespaceOptions(s)
	}
}

func (s *AlterTablespaceOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterTablespaceOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterTablespaceOptions() (localctx IAlterTablespaceOptionsContext) {
	localctx = NewAlterTablespaceOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, MySQLParserRULE_alterTablespaceOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.AlterTablespaceOption()
	}
	p.SetState(1820)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserAUTOEXTEND_SIZE_SYMBOL || _la == MySQLParserENCRYPTION_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserMAX_SIZE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(1814)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1817)
			p.AlterTablespaceOption()
		}

		p.SetState(1822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTablespaceOptionContext is an interface to support dynamic dispatch.
type IAlterTablespaceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode
	TsOptionAutoextendSize() ITsOptionAutoextendSizeContext
	TsOptionMaxSize() ITsOptionMaxSizeContext
	TsOptionEngine() ITsOptionEngineContext
	TsOptionWait() ITsOptionWaitContext
	TsOptionEncryption() ITsOptionEncryptionContext

	// IsAlterTablespaceOptionContext differentiates from other interfaces.
	IsAlterTablespaceOptionContext()
}

type AlterTablespaceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTablespaceOptionContext() *AlterTablespaceOptionContext {
	var p = new(AlterTablespaceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespaceOption
	return p
}

func InitEmptyAlterTablespaceOptionContext(p *AlterTablespaceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterTablespaceOption
}

func (*AlterTablespaceOptionContext) IsAlterTablespaceOptionContext() {}

func NewAlterTablespaceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTablespaceOptionContext {
	var p = new(AlterTablespaceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterTablespaceOption

	return p
}

func (s *AlterTablespaceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTablespaceOptionContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *AlterTablespaceOptionContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *AlterTablespaceOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *AlterTablespaceOptionContext) TsOptionAutoextendSize() ITsOptionAutoextendSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionAutoextendSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionAutoextendSizeContext)
}

func (s *AlterTablespaceOptionContext) TsOptionMaxSize() ITsOptionMaxSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionMaxSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionMaxSizeContext)
}

func (s *AlterTablespaceOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *AlterTablespaceOptionContext) TsOptionWait() ITsOptionWaitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionWaitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionWaitContext)
}

func (s *AlterTablespaceOptionContext) TsOptionEncryption() ITsOptionEncryptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEncryptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEncryptionContext)
}

func (s *AlterTablespaceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTablespaceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTablespaceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterTablespaceOption(s)
	}
}

func (s *AlterTablespaceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterTablespaceOption(s)
	}
}

func (s *AlterTablespaceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterTablespaceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterTablespaceOption() (localctx IAlterTablespaceOptionContext) {
	localctx = NewAlterTablespaceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, MySQLParserRULE_alterTablespaceOption)
	p.SetState(1833)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINITIAL_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1823)
			p.Match(MySQLParserINITIAL_SIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1825)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1824)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1827)
			p.SizeNumber()
		}

	case MySQLParserAUTOEXTEND_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1828)
			p.TsOptionAutoextendSize()
		}

	case MySQLParserMAX_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1829)
			p.TsOptionMaxSize()
		}

	case MySQLParserENGINE_SYMBOL, MySQLParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1830)
			p.TsOptionEngine()
		}

	case MySQLParserNO_WAIT_SYMBOL, MySQLParserWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1831)
			p.TsOptionWait()
		}

	case MySQLParserENCRYPTION_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1832)
			p.TsOptionEncryption()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeTablespaceOptionContext is an interface to support dynamic dispatch.
type IChangeTablespaceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode
	TsOptionAutoextendSize() ITsOptionAutoextendSizeContext
	TsOptionMaxSize() ITsOptionMaxSizeContext

	// IsChangeTablespaceOptionContext differentiates from other interfaces.
	IsChangeTablespaceOptionContext()
}

type ChangeTablespaceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeTablespaceOptionContext() *ChangeTablespaceOptionContext {
	var p = new(ChangeTablespaceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeTablespaceOption
	return p
}

func InitEmptyChangeTablespaceOptionContext(p *ChangeTablespaceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeTablespaceOption
}

func (*ChangeTablespaceOptionContext) IsChangeTablespaceOptionContext() {}

func NewChangeTablespaceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeTablespaceOptionContext {
	var p = new(ChangeTablespaceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_changeTablespaceOption

	return p
}

func (s *ChangeTablespaceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeTablespaceOptionContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *ChangeTablespaceOptionContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *ChangeTablespaceOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *ChangeTablespaceOptionContext) TsOptionAutoextendSize() ITsOptionAutoextendSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionAutoextendSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionAutoextendSizeContext)
}

func (s *ChangeTablespaceOptionContext) TsOptionMaxSize() ITsOptionMaxSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionMaxSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionMaxSizeContext)
}

func (s *ChangeTablespaceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeTablespaceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeTablespaceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterChangeTablespaceOption(s)
	}
}

func (s *ChangeTablespaceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitChangeTablespaceOption(s)
	}
}

func (s *ChangeTablespaceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitChangeTablespaceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ChangeTablespaceOption() (localctx IChangeTablespaceOptionContext) {
	localctx = NewChangeTablespaceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, MySQLParserRULE_changeTablespaceOption)
	p.SetState(1842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINITIAL_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1835)
			p.Match(MySQLParserINITIAL_SIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1837)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1836)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1839)
			p.SizeNumber()
		}

	case MySQLParserAUTOEXTEND_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1840)
			p.TsOptionAutoextendSize()
		}

	case MySQLParserMAX_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1841)
			p.TsOptionMaxSize()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewContext is an interface to support dynamic dispatch.
type IAlterViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VIEW_SYMBOL() antlr.TerminalNode
	ViewRef() IViewRefContext
	ViewTail() IViewTailContext
	ViewAlgorithm() IViewAlgorithmContext
	DefinerClause() IDefinerClauseContext
	ViewSuid() IViewSuidContext

	// IsAlterViewContext differentiates from other interfaces.
	IsAlterViewContext()
}

type AlterViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewContext() *AlterViewContext {
	var p = new(AlterViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterView
	return p
}

func InitEmptyAlterViewContext(p *AlterViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterView
}

func (*AlterViewContext) IsAlterViewContext() {}

func NewAlterViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewContext {
	var p = new(AlterViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterView

	return p
}

func (s *AlterViewContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *AlterViewContext) ViewRef() IViewRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefContext)
}

func (s *AlterViewContext) ViewTail() IViewTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewTailContext)
}

func (s *AlterViewContext) ViewAlgorithm() IViewAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewAlgorithmContext)
}

func (s *AlterViewContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *AlterViewContext) ViewSuid() IViewSuidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewSuidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewSuidContext)
}

func (s *AlterViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterView(s)
	}
}

func (s *AlterViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterView(s)
	}
}

func (s *AlterViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterView() (localctx IAlterViewContext) {
	localctx = NewAlterViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, MySQLParserRULE_alterView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserALGORITHM_SYMBOL {
		{
			p.SetState(1844)
			p.ViewAlgorithm()
		}

	}
	p.SetState(1848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(1847)
			p.DefinerClause()
		}

	}
	p.SetState(1851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSQL_SYMBOL {
		{
			p.SetState(1850)
			p.ViewSuid()
		}

	}
	{
		p.SetState(1853)
		p.Match(MySQLParserVIEW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1854)
		p.ViewRef()
	}
	{
		p.SetState(1855)
		p.ViewTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewTailContext is an interface to support dynamic dispatch.
type IViewTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	ViewSelect() IViewSelectContext
	ColumnInternalRefList() IColumnInternalRefListContext

	// IsViewTailContext differentiates from other interfaces.
	IsViewTailContext()
}

type ViewTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewTailContext() *ViewTailContext {
	var p = new(ViewTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewTail
	return p
}

func InitEmptyViewTailContext(p *ViewTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewTail
}

func (*ViewTailContext) IsViewTailContext() {}

func NewViewTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewTailContext {
	var p = new(ViewTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewTail

	return p
}

func (s *ViewTailContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewTailContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *ViewTailContext) ViewSelect() IViewSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewSelectContext)
}

func (s *ViewTailContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *ViewTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewTail(s)
	}
}

func (s *ViewTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewTail(s)
	}
}

func (s *ViewTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewTail() (localctx IViewTailContext) {
	localctx = NewViewTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, MySQLParserRULE_viewTail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1858)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(1857)
			p.ColumnInternalRefList()
		}

	}
	{
		p.SetState(1860)
		p.Match(MySQLParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1861)
		p.ViewSelect()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewSelectContext is an interface to support dynamic dispatch.
type IViewSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionOrParens() IQueryExpressionOrParensContext
	ViewCheckOption() IViewCheckOptionContext

	// IsViewSelectContext differentiates from other interfaces.
	IsViewSelectContext()
}

type ViewSelectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewSelectContext() *ViewSelectContext {
	var p = new(ViewSelectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewSelect
	return p
}

func InitEmptyViewSelectContext(p *ViewSelectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewSelect
}

func (*ViewSelectContext) IsViewSelectContext() {}

func NewViewSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewSelectContext {
	var p = new(ViewSelectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewSelect

	return p
}

func (s *ViewSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewSelectContext) QueryExpressionOrParens() IQueryExpressionOrParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionOrParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionOrParensContext)
}

func (s *ViewSelectContext) ViewCheckOption() IViewCheckOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewCheckOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewCheckOptionContext)
}

func (s *ViewSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewSelect(s)
	}
}

func (s *ViewSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewSelect(s)
	}
}

func (s *ViewSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewSelect() (localctx IViewSelectContext) {
	localctx = NewViewSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, MySQLParserRULE_viewSelect)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1863)
		p.QueryExpressionOrParens()
	}
	p.SetState(1865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserWITH_SYMBOL {
		{
			p.SetState(1864)
			p.ViewCheckOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewCheckOptionContext is an interface to support dynamic dispatch.
type IViewCheckOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	CHECK_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	CASCADED_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode

	// IsViewCheckOptionContext differentiates from other interfaces.
	IsViewCheckOptionContext()
}

type ViewCheckOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewCheckOptionContext() *ViewCheckOptionContext {
	var p = new(ViewCheckOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewCheckOption
	return p
}

func InitEmptyViewCheckOptionContext(p *ViewCheckOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewCheckOption
}

func (*ViewCheckOptionContext) IsViewCheckOptionContext() {}

func NewViewCheckOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewCheckOptionContext {
	var p = new(ViewCheckOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewCheckOption

	return p
}

func (s *ViewCheckOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewCheckOptionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *ViewCheckOptionContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECK_SYMBOL, 0)
}

func (s *ViewCheckOptionContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *ViewCheckOptionContext) CASCADED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADED_SYMBOL, 0)
}

func (s *ViewCheckOptionContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *ViewCheckOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewCheckOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewCheckOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewCheckOption(s)
	}
}

func (s *ViewCheckOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewCheckOption(s)
	}
}

func (s *ViewCheckOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewCheckOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewCheckOption() (localctx IViewCheckOptionContext) {
	localctx = NewViewCheckOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, MySQLParserRULE_viewCheckOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1867)
		p.Match(MySQLParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCASCADED_SYMBOL || _la == MySQLParserLOCAL_SYMBOL {
		{
			p.SetState(1868)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCASCADED_SYMBOL || _la == MySQLParserLOCAL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1871)
		p.Match(MySQLParserCHECK_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1872)
		p.Match(MySQLParserOPTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStatementContext is an interface to support dynamic dispatch.
type ICreateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	CreateDatabase() ICreateDatabaseContext
	CreateTable() ICreateTableContext
	CreateFunction() ICreateFunctionContext
	CreateProcedure() ICreateProcedureContext
	CreateUdf() ICreateUdfContext
	CreateLogfileGroup() ICreateLogfileGroupContext
	CreateView() ICreateViewContext
	CreateTrigger() ICreateTriggerContext
	CreateIndex() ICreateIndexContext
	CreateServer() ICreateServerContext
	CreateTablespace() ICreateTablespaceContext
	CreateEvent() ICreateEventContext
	CreateRole() ICreateRoleContext
	CreateSpatialReference() ICreateSpatialReferenceContext
	CreateUndoTablespace() ICreateUndoTablespaceContext

	// IsCreateStatementContext differentiates from other interfaces.
	IsCreateStatementContext()
}

type CreateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateStatementContext() *CreateStatementContext {
	var p = new(CreateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createStatement
	return p
}

func InitEmptyCreateStatementContext(p *CreateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createStatement
}

func (*CreateStatementContext) IsCreateStatementContext() {}

func NewCreateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStatementContext {
	var p = new(CreateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createStatement

	return p
}

func (s *CreateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStatementContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *CreateStatementContext) CreateDatabase() ICreateDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseContext)
}

func (s *CreateStatementContext) CreateTable() ICreateTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableContext)
}

func (s *CreateStatementContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *CreateStatementContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *CreateStatementContext) CreateUdf() ICreateUdfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfContext)
}

func (s *CreateStatementContext) CreateLogfileGroup() ICreateLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateLogfileGroupContext)
}

func (s *CreateStatementContext) CreateView() ICreateViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewContext)
}

func (s *CreateStatementContext) CreateTrigger() ICreateTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTriggerContext)
}

func (s *CreateStatementContext) CreateIndex() ICreateIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexContext)
}

func (s *CreateStatementContext) CreateServer() ICreateServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateServerContext)
}

func (s *CreateStatementContext) CreateTablespace() ICreateTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTablespaceContext)
}

func (s *CreateStatementContext) CreateEvent() ICreateEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateEventContext)
}

func (s *CreateStatementContext) CreateRole() ICreateRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleContext)
}

func (s *CreateStatementContext) CreateSpatialReference() ICreateSpatialReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSpatialReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSpatialReferenceContext)
}

func (s *CreateStatementContext) CreateUndoTablespace() ICreateUndoTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUndoTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUndoTablespaceContext)
}

func (s *CreateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateStatement(s)
	}
}

func (s *CreateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateStatement(s)
	}
}

func (s *CreateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateStatement() (localctx ICreateStatementContext) {
	localctx = NewCreateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, MySQLParserRULE_createStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1874)
		p.Match(MySQLParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1875)
			p.CreateDatabase()
		}

	case 2:
		{
			p.SetState(1876)
			p.CreateTable()
		}

	case 3:
		{
			p.SetState(1877)
			p.CreateFunction()
		}

	case 4:
		{
			p.SetState(1878)
			p.CreateProcedure()
		}

	case 5:
		{
			p.SetState(1879)
			p.CreateUdf()
		}

	case 6:
		{
			p.SetState(1880)
			p.CreateLogfileGroup()
		}

	case 7:
		{
			p.SetState(1881)
			p.CreateView()
		}

	case 8:
		{
			p.SetState(1882)
			p.CreateTrigger()
		}

	case 9:
		{
			p.SetState(1883)
			p.CreateIndex()
		}

	case 10:
		{
			p.SetState(1884)
			p.CreateServer()
		}

	case 11:
		{
			p.SetState(1885)
			p.CreateTablespace()
		}

	case 12:
		{
			p.SetState(1886)
			p.CreateEvent()
		}

	case 13:
		p.SetState(1887)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(1888)
			p.CreateRole()
		}

	case 14:
		p.SetState(1889)

		if !(serverVersion >= 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
			goto errorExit
		}
		{
			p.SetState(1890)
			p.CreateSpatialReference()
		}

	case 15:
		p.SetState(1891)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(1892)
			p.CreateUndoTablespace()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseContext is an interface to support dynamic dispatch.
type ICreateDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE_SYMBOL() antlr.TerminalNode
	SchemaName() ISchemaNameContext
	IfNotExists() IIfNotExistsContext
	AllCreateDatabaseOption() []ICreateDatabaseOptionContext
	CreateDatabaseOption(i int) ICreateDatabaseOptionContext

	// IsCreateDatabaseContext differentiates from other interfaces.
	IsCreateDatabaseContext()
}

type CreateDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseContext() *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createDatabase
	return p
}

func InitEmptyCreateDatabaseContext(p *CreateDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createDatabase
}

func (*CreateDatabaseContext) IsCreateDatabaseContext() {}

func NewCreateDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseContext {
	var p = new(CreateDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createDatabase

	return p
}

func (s *CreateDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *CreateDatabaseContext) SchemaName() ISchemaNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaNameContext)
}

func (s *CreateDatabaseContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateDatabaseContext) AllCreateDatabaseOption() []ICreateDatabaseOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateDatabaseOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateDatabaseOptionContext); ok {
			tst[i] = t.(ICreateDatabaseOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateDatabaseContext) CreateDatabaseOption(i int) ICreateDatabaseOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDatabaseOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDatabaseOptionContext)
}

func (s *CreateDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateDatabase(s)
	}
}

func (s *CreateDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateDatabase() (localctx ICreateDatabaseContext) {
	localctx = NewCreateDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, MySQLParserRULE_createDatabase)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1895)
		p.Match(MySQLParserDATABASE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1896)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1899)
		p.SchemaName()
	}
	p.SetState(1903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1900)
				p.CreateDatabaseOption()
			}

		}
		p.SetState(1905)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDatabaseOptionContext is an interface to support dynamic dispatch.
type ICreateDatabaseOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DefaultCharset() IDefaultCharsetContext
	DefaultCollation() IDefaultCollationContext
	DefaultEncryption() IDefaultEncryptionContext

	// IsCreateDatabaseOptionContext differentiates from other interfaces.
	IsCreateDatabaseOptionContext()
}

type CreateDatabaseOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDatabaseOptionContext() *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createDatabaseOption
	return p
}

func InitEmptyCreateDatabaseOptionContext(p *CreateDatabaseOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createDatabaseOption
}

func (*CreateDatabaseOptionContext) IsCreateDatabaseOptionContext() {}

func NewCreateDatabaseOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDatabaseOptionContext {
	var p = new(CreateDatabaseOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createDatabaseOption

	return p
}

func (s *CreateDatabaseOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDatabaseOptionContext) DefaultCharset() IDefaultCharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCharsetContext)
}

func (s *CreateDatabaseOptionContext) DefaultCollation() IDefaultCollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCollationContext)
}

func (s *CreateDatabaseOptionContext) DefaultEncryption() IDefaultEncryptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultEncryptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultEncryptionContext)
}

func (s *CreateDatabaseOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDatabaseOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDatabaseOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateDatabaseOption(s)
	}
}

func (s *CreateDatabaseOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateDatabaseOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateDatabaseOption() (localctx ICreateDatabaseOptionContext) {
	localctx = NewCreateDatabaseOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, MySQLParserRULE_createDatabaseOption)
	p.SetState(1910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1906)
			p.DefaultCharset()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1907)
			p.DefaultCollation()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1908)

		if !(serverVersion >= 80016) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80016", ""))
			goto errorExit
		}
		{
			p.SetState(1909)
			p.DefaultEncryption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableContext is an interface to support dynamic dispatch.
type ICreateTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableName() ITableNameContext
	LIKE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	TableElementList() ITableElementListContext
	CreateTableOptions() ICreateTableOptionsContext
	PartitionClause() IPartitionClauseContext
	DuplicateAsQueryExpression() IDuplicateAsQueryExpressionContext

	// IsCreateTableContext differentiates from other interfaces.
	IsCreateTableContext()
}

type CreateTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableContext() *CreateTableContext {
	var p = new(CreateTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTable
	return p
}

func InitEmptyCreateTableContext(p *CreateTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTable
}

func (*CreateTableContext) IsCreateTableContext() {}

func NewCreateTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableContext {
	var p = new(CreateTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTable

	return p
}

func (s *CreateTableContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *CreateTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *CreateTableContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIKE_SYMBOL, 0)
}

func (s *CreateTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *CreateTableContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CreateTableContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CreateTableContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPORARY_SYMBOL, 0)
}

func (s *CreateTableContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateTableContext) TableElementList() ITableElementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementListContext)
}

func (s *CreateTableContext) CreateTableOptions() ICreateTableOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionsContext)
}

func (s *CreateTableContext) PartitionClause() IPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionClauseContext)
}

func (s *CreateTableContext) DuplicateAsQueryExpression() IDuplicateAsQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDuplicateAsQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDuplicateAsQueryExpressionContext)
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

func (s *CreateTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTable() (localctx ICreateTableContext) {
	localctx = NewCreateTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, MySQLParserRULE_createTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1913)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserTEMPORARY_SYMBOL {
		{
			p.SetState(1912)
			p.Match(MySQLParserTEMPORARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1915)
		p.Match(MySQLParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1916)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1919)
		p.TableName()
	}
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1924)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1920)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1921)
				p.TableElementList()
			}
			{
				p.SetState(1922)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1927)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1926)
				p.CreateTableOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1930)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1929)
				p.PartitionClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1933)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1932)
				p.DuplicateAsQueryExpression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(1935)
			p.Match(MySQLParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1936)
			p.TableRef()
		}

	case 3:
		{
			p.SetState(1937)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1938)
			p.Match(MySQLParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1939)
			p.TableRef()
		}
		{
			p.SetState(1940)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementListContext is an interface to support dynamic dispatch.
type ITableElementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableElement() []ITableElementContext
	TableElement(i int) ITableElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableElementListContext differentiates from other interfaces.
	IsTableElementListContext()
}

type TableElementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementListContext() *TableElementListContext {
	var p = new(TableElementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableElementList
	return p
}

func InitEmptyTableElementListContext(p *TableElementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableElementList
}

func (*TableElementListContext) IsTableElementListContext() {}

func NewTableElementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementListContext {
	var p = new(TableElementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableElementList

	return p
}

func (s *TableElementListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementListContext) AllTableElement() []ITableElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableElementContext); ok {
			len++
		}
	}

	tst := make([]ITableElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableElementContext); ok {
			tst[i] = t.(ITableElementContext)
			i++
		}
	}

	return tst
}

func (s *TableElementListContext) TableElement(i int) ITableElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TableElementListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TableElementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableElementList(s)
	}
}

func (s *TableElementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableElementList(s)
	}
}

func (s *TableElementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableElementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableElementList() (localctx ITableElementListContext) {
	localctx = NewTableElementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, MySQLParserRULE_tableElementList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1944)
		p.TableElement()
	}
	p.SetState(1949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(1945)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1946)
			p.TableElement()
		}

		p.SetState(1951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnDefinition() IColumnDefinitionContext
	TableConstraintDef() ITableConstraintDefContext

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableElement
	return p
}

func InitEmptyTableElementContext(p *TableElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableElement
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) ColumnDefinition() IColumnDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefinitionContext)
}

func (s *TableElementContext) TableConstraintDef() ITableConstraintDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableConstraintDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableConstraintDefContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (s *TableElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, MySQLParserRULE_tableElement)
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1952)
			p.ColumnDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1953)
			p.TableConstraintDef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDuplicateAsQueryExpressionContext is an interface to support dynamic dispatch.
type IDuplicateAsQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionOrParens() IQueryExpressionOrParensContext
	AS_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsDuplicateAsQueryExpressionContext differentiates from other interfaces.
	IsDuplicateAsQueryExpressionContext()
}

type DuplicateAsQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDuplicateAsQueryExpressionContext() *DuplicateAsQueryExpressionContext {
	var p = new(DuplicateAsQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_duplicateAsQueryExpression
	return p
}

func InitEmptyDuplicateAsQueryExpressionContext(p *DuplicateAsQueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_duplicateAsQueryExpression
}

func (*DuplicateAsQueryExpressionContext) IsDuplicateAsQueryExpressionContext() {}

func NewDuplicateAsQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DuplicateAsQueryExpressionContext {
	var p = new(DuplicateAsQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_duplicateAsQueryExpression

	return p
}

func (s *DuplicateAsQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DuplicateAsQueryExpressionContext) QueryExpressionOrParens() IQueryExpressionOrParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionOrParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionOrParensContext)
}

func (s *DuplicateAsQueryExpressionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *DuplicateAsQueryExpressionContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *DuplicateAsQueryExpressionContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *DuplicateAsQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DuplicateAsQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DuplicateAsQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDuplicateAsQueryExpression(s)
	}
}

func (s *DuplicateAsQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDuplicateAsQueryExpression(s)
	}
}

func (s *DuplicateAsQueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDuplicateAsQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DuplicateAsQueryExpression() (localctx IDuplicateAsQueryExpressionContext) {
	localctx = NewDuplicateAsQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, MySQLParserRULE_duplicateAsQueryExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1957)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1956)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserREPLACE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1960)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1959)
			p.Match(MySQLParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1962)
		p.QueryExpressionOrParens()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionOrParensContext is an interface to support dynamic dispatch.
type IQueryExpressionOrParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpression() IQueryExpressionContext
	QueryExpressionParens() IQueryExpressionParensContext

	// IsQueryExpressionOrParensContext differentiates from other interfaces.
	IsQueryExpressionOrParensContext()
}

type QueryExpressionOrParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionOrParensContext() *QueryExpressionOrParensContext {
	var p = new(QueryExpressionOrParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionOrParens
	return p
}

func InitEmptyQueryExpressionOrParensContext(p *QueryExpressionOrParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionOrParens
}

func (*QueryExpressionOrParensContext) IsQueryExpressionOrParensContext() {}

func NewQueryExpressionOrParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionOrParensContext {
	var p = new(QueryExpressionOrParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_queryExpressionOrParens

	return p
}

func (s *QueryExpressionOrParensContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionOrParensContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionOrParensContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionOrParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionOrParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionOrParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQueryExpressionOrParens(s)
	}
}

func (s *QueryExpressionOrParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQueryExpressionOrParens(s)
	}
}

func (s *QueryExpressionOrParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQueryExpressionOrParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QueryExpressionOrParens() (localctx IQueryExpressionOrParensContext) {
	localctx = NewQueryExpressionOrParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, MySQLParserRULE_queryExpressionOrParens)
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1964)
			p.QueryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1965)
			p.QueryExpressionParens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineContext is an interface to support dynamic dispatch.
type ICreateRoutineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	EOF() antlr.TerminalNode
	CreateProcedure() ICreateProcedureContext
	CreateFunction() ICreateFunctionContext
	CreateUdf() ICreateUdfContext
	SEMICOLON_SYMBOL() antlr.TerminalNode

	// IsCreateRoutineContext differentiates from other interfaces.
	IsCreateRoutineContext()
}

type CreateRoutineContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoutineContext() *CreateRoutineContext {
	var p = new(CreateRoutineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createRoutine
	return p
}

func InitEmptyCreateRoutineContext(p *CreateRoutineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createRoutine
}

func (*CreateRoutineContext) IsCreateRoutineContext() {}

func NewCreateRoutineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineContext {
	var p = new(CreateRoutineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createRoutine

	return p
}

func (s *CreateRoutineContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *CreateRoutineContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySQLParserEOF, 0)
}

func (s *CreateRoutineContext) CreateProcedure() ICreateProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateProcedureContext)
}

func (s *CreateRoutineContext) CreateFunction() ICreateFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionContext)
}

func (s *CreateRoutineContext) CreateUdf() ICreateUdfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUdfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUdfContext)
}

func (s *CreateRoutineContext) SEMICOLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSEMICOLON_SYMBOL, 0)
}

func (s *CreateRoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateRoutine(s)
	}
}

func (s *CreateRoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateRoutine(s)
	}
}

func (s *CreateRoutineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateRoutine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateRoutine() (localctx ICreateRoutineContext) {
	localctx = NewCreateRoutineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, MySQLParserRULE_createRoutine)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1968)
		p.Match(MySQLParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1969)
			p.CreateProcedure()
		}

	case 2:
		{
			p.SetState(1970)
			p.CreateFunction()
		}

	case 3:
		{
			p.SetState(1971)
			p.CreateUdf()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSEMICOLON_SYMBOL {
		{
			p.SetState(1974)
			p.Match(MySQLParserSEMICOLON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1977)
		p.Match(MySQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateProcedureContext is an interface to support dynamic dispatch.
type ICreateProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_SYMBOL() antlr.TerminalNode
	ProcedureName() IProcedureNameContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	DefinerClause() IDefinerClauseContext
	AllProcedureParameter() []IProcedureParameterContext
	ProcedureParameter(i int) IProcedureParameterContext
	AllRoutineCreateOption() []IRoutineCreateOptionContext
	RoutineCreateOption(i int) IRoutineCreateOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateProcedureContext differentiates from other interfaces.
	IsCreateProcedureContext()
}

type CreateProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateProcedureContext() *CreateProcedureContext {
	var p = new(CreateProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createProcedure
	return p
}

func InitEmptyCreateProcedureContext(p *CreateProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createProcedure
}

func (*CreateProcedureContext) IsCreateProcedureContext() {}

func NewCreateProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateProcedureContext {
	var p = new(CreateProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createProcedure

	return p
}

func (s *CreateProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateProcedureContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *CreateProcedureContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *CreateProcedureContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CreateProcedureContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CreateProcedureContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CreateProcedureContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *CreateProcedureContext) AllProcedureParameter() []IProcedureParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureParameterContext); ok {
			tst[i] = t.(IProcedureParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) ProcedureParameter(i int) IProcedureParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureParameterContext)
}

func (s *CreateProcedureContext) AllRoutineCreateOption() []IRoutineCreateOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineCreateOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineCreateOptionContext); ok {
			tst[i] = t.(IRoutineCreateOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateProcedureContext) RoutineCreateOption(i int) IRoutineCreateOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCreateOptionContext)
}

func (s *CreateProcedureContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *CreateProcedureContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *CreateProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateProcedure(s)
	}
}

func (s *CreateProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateProcedure() (localctx ICreateProcedureContext) {
	localctx = NewCreateProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, MySQLParserRULE_createProcedure)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(1979)
			p.DefinerClause()
		}

	}
	{
		p.SetState(1982)
		p.Match(MySQLParserPROCEDURE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1983)
		p.ProcedureName()
	}
	{
		p.SetState(1984)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1993)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1985)
			p.ProcedureParameter()
		}
		p.SetState(1990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(1986)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1987)
				p.ProcedureParameter()
			}

			p.SetState(1992)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1995)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1996)
				p.RoutineCreateOption()
			}

		}
		p.SetState(2001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2002)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionContext is an interface to support dynamic dispatch.
type ICreateFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION_SYMBOL() antlr.TerminalNode
	FunctionName() IFunctionNameContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	TypeWithOptCollate() ITypeWithOptCollateContext
	CompoundStatement() ICompoundStatementContext
	DefinerClause() IDefinerClauseContext
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllRoutineCreateOption() []IRoutineCreateOptionContext
	RoutineCreateOption(i int) IRoutineCreateOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateFunctionContext differentiates from other interfaces.
	IsCreateFunctionContext()
}

type CreateFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateFunctionContext() *CreateFunctionContext {
	var p = new(CreateFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createFunction
	return p
}

func InitEmptyCreateFunctionContext(p *CreateFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createFunction
}

func (*CreateFunctionContext) IsCreateFunctionContext() {}

func NewCreateFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionContext {
	var p = new(CreateFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createFunction

	return p
}

func (s *CreateFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *CreateFunctionContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *CreateFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CreateFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CreateFunctionContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNS_SYMBOL, 0)
}

func (s *CreateFunctionContext) TypeWithOptCollate() ITypeWithOptCollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithOptCollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithOptCollateContext)
}

func (s *CreateFunctionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CreateFunctionContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *CreateFunctionContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *CreateFunctionContext) AllRoutineCreateOption() []IRoutineCreateOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineCreateOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineCreateOptionContext); ok {
			tst[i] = t.(IRoutineCreateOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateFunctionContext) RoutineCreateOption(i int) IRoutineCreateOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCreateOptionContext)
}

func (s *CreateFunctionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *CreateFunctionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *CreateFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateFunction(s)
	}
}

func (s *CreateFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateFunction(s)
	}
}

func (s *CreateFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateFunction() (localctx ICreateFunctionContext) {
	localctx = NewCreateFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, MySQLParserRULE_createFunction)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(2004)
			p.DefinerClause()
		}

	}
	{
		p.SetState(2007)
		p.Match(MySQLParserFUNCTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2008)
		p.FunctionName()
	}
	{
		p.SetState(2009)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2018)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2010)
			p.FunctionParameter()
		}
		p.SetState(2015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(2011)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2012)
				p.FunctionParameter()
			}

			p.SetState(2017)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2020)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2021)
		p.Match(MySQLParserRETURNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2022)
		p.TypeWithOptCollate()
	}
	p.SetState(2026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2023)
				p.RoutineCreateOption()
			}

		}
		p.SetState(2028)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 129, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(2029)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUdfContext is an interface to support dynamic dispatch.
type ICreateUdfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	FUNCTION_SYMBOL() antlr.TerminalNode
	UdfName() IUdfNameContext
	RETURNS_SYMBOL() antlr.TerminalNode
	SONAME_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	STRING_SYMBOL() antlr.TerminalNode
	INT_SYMBOL() antlr.TerminalNode
	REAL_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode

	// IsCreateUdfContext differentiates from other interfaces.
	IsCreateUdfContext()
}

type CreateUdfContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyCreateUdfContext() *CreateUdfContext {
	var p = new(CreateUdfContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUdf
	return p
}

func InitEmptyCreateUdfContext(p *CreateUdfContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUdf
}

func (*CreateUdfContext) IsCreateUdfContext() {}

func NewCreateUdfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUdfContext {
	var p = new(CreateUdfContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUdf

	return p
}

func (s *CreateUdfContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUdfContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateUdfContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateUdfContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *CreateUdfContext) UdfName() IUdfNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUdfNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUdfNameContext)
}

func (s *CreateUdfContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNS_SYMBOL, 0)
}

func (s *CreateUdfContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSONAME_SYMBOL, 0)
}

func (s *CreateUdfContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *CreateUdfContext) STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTRING_SYMBOL, 0)
}

func (s *CreateUdfContext) INT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_SYMBOL, 0)
}

func (s *CreateUdfContext) REAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAL_SYMBOL, 0)
}

func (s *CreateUdfContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_SYMBOL, 0)
}

func (s *CreateUdfContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGGREGATE_SYMBOL, 0)
}

func (s *CreateUdfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUdfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUdfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUdf(s)
	}
}

func (s *CreateUdfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUdf(s)
	}
}

func (s *CreateUdfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUdf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUdf() (localctx ICreateUdfContext) {
	localctx = NewCreateUdfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, MySQLParserRULE_createUdf)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserAGGREGATE_SYMBOL {
		{
			p.SetState(2031)
			p.Match(MySQLParserAGGREGATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2034)
		p.Match(MySQLParserFUNCTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2035)
		p.UdfName()
	}
	{
		p.SetState(2036)
		p.Match(MySQLParserRETURNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2037)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateUdfContext).type_ = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDECIMAL_SYMBOL || _la == MySQLParserINT_SYMBOL || _la == MySQLParserREAL_SYMBOL || _la == MySQLParserSTRING_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateUdfContext).type_ = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2038)
		p.Match(MySQLParserSONAME_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2039)
		p.TextLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineCreateOptionContext is an interface to support dynamic dispatch.
type IRoutineCreateOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoutineOption() IRoutineOptionContext
	DETERMINISTIC_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode

	// IsRoutineCreateOptionContext differentiates from other interfaces.
	IsRoutineCreateOptionContext()
}

type RoutineCreateOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineCreateOptionContext() *RoutineCreateOptionContext {
	var p = new(RoutineCreateOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineCreateOption
	return p
}

func InitEmptyRoutineCreateOptionContext(p *RoutineCreateOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineCreateOption
}

func (*RoutineCreateOptionContext) IsRoutineCreateOptionContext() {}

func NewRoutineCreateOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineCreateOptionContext {
	var p = new(RoutineCreateOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_routineCreateOption

	return p
}

func (s *RoutineCreateOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineCreateOptionContext) RoutineOption() IRoutineOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineOptionContext)
}

func (s *RoutineCreateOptionContext) DETERMINISTIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDETERMINISTIC_SYMBOL, 0)
}

func (s *RoutineCreateOptionContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *RoutineCreateOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineCreateOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineCreateOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoutineCreateOption(s)
	}
}

func (s *RoutineCreateOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoutineCreateOption(s)
	}
}

func (s *RoutineCreateOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoutineCreateOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoutineCreateOption() (localctx IRoutineCreateOptionContext) {
	localctx = NewRoutineCreateOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, MySQLParserRULE_routineCreateOption)
	var _la int

	p.SetState(2046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCOMMENT_SYMBOL, MySQLParserCONTAINS_SYMBOL, MySQLParserLANGUAGE_SYMBOL, MySQLParserMODIFIES_SYMBOL, MySQLParserNO_SYMBOL, MySQLParserREADS_SYMBOL, MySQLParserSQL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2041)
			p.RoutineOption()
		}

	case MySQLParserDETERMINISTIC_SYMBOL, MySQLParserNOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2043)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL {
			{
				p.SetState(2042)
				p.Match(MySQLParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2045)
			p.Match(MySQLParserDETERMINISTIC_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineAlterOptionsContext is an interface to support dynamic dispatch.
type IRoutineAlterOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRoutineCreateOption() []IRoutineCreateOptionContext
	RoutineCreateOption(i int) IRoutineCreateOptionContext

	// IsRoutineAlterOptionsContext differentiates from other interfaces.
	IsRoutineAlterOptionsContext()
}

type RoutineAlterOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineAlterOptionsContext() *RoutineAlterOptionsContext {
	var p = new(RoutineAlterOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineAlterOptions
	return p
}

func InitEmptyRoutineAlterOptionsContext(p *RoutineAlterOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineAlterOptions
}

func (*RoutineAlterOptionsContext) IsRoutineAlterOptionsContext() {}

func NewRoutineAlterOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineAlterOptionsContext {
	var p = new(RoutineAlterOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_routineAlterOptions

	return p
}

func (s *RoutineAlterOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineAlterOptionsContext) AllRoutineCreateOption() []IRoutineCreateOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			len++
		}
	}

	tst := make([]IRoutineCreateOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoutineCreateOptionContext); ok {
			tst[i] = t.(IRoutineCreateOptionContext)
			i++
		}
	}

	return tst
}

func (s *RoutineAlterOptionsContext) RoutineCreateOption(i int) IRoutineCreateOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoutineCreateOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoutineCreateOptionContext)
}

func (s *RoutineAlterOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineAlterOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineAlterOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoutineAlterOptions(s)
	}
}

func (s *RoutineAlterOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoutineAlterOptions(s)
	}
}

func (s *RoutineAlterOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoutineAlterOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoutineAlterOptions() (localctx IRoutineAlterOptionsContext) {
	localctx = NewRoutineAlterOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, MySQLParserRULE_routineAlterOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&4611686018427420673) != 0) || _la == MySQLParserLANGUAGE_SYMBOL || ((int64((_la-347)) & ^0x3f) == 0 && ((int64(1)<<(_la-347))&83886081) != 0) || _la == MySQLParserREADS_SYMBOL || _la == MySQLParserSQL_SYMBOL {
		{
			p.SetState(2048)
			p.RoutineCreateOption()
		}

		p.SetState(2051)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoutineOptionContext is an interface to support dynamic dispatch.
type IRoutineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// GetSecurity returns the security token.
	GetSecurity() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// SetSecurity sets the security token.
	SetSecurity(antlr.Token)

	// Getter signatures
	TextLiteral() ITextLiteralContext
	COMMENT_SYMBOL() antlr.TerminalNode
	SQL_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	READS_SYMBOL() antlr.TerminalNode
	MODIFIES_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode

	// IsRoutineOptionContext differentiates from other interfaces.
	IsRoutineOptionContext()
}

type RoutineOptionContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	option   antlr.Token
	security antlr.Token
}

func NewEmptyRoutineOptionContext() *RoutineOptionContext {
	var p = new(RoutineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineOption
	return p
}

func InitEmptyRoutineOptionContext(p *RoutineOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_routineOption
}

func (*RoutineOptionContext) IsRoutineOptionContext() {}

func NewRoutineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineOptionContext {
	var p = new(RoutineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_routineOption

	return p
}

func (s *RoutineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineOptionContext) GetOption() antlr.Token { return s.option }

func (s *RoutineOptionContext) GetSecurity() antlr.Token { return s.security }

func (s *RoutineOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *RoutineOptionContext) SetSecurity(v antlr.Token) { s.security = v }

func (s *RoutineOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *RoutineOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *RoutineOptionContext) SQL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_SYMBOL, 0)
}

func (s *RoutineOptionContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLANGUAGE_SYMBOL, 0)
}

func (s *RoutineOptionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *RoutineOptionContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTAINS_SYMBOL, 0)
}

func (s *RoutineOptionContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *RoutineOptionContext) READS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREADS_SYMBOL, 0)
}

func (s *RoutineOptionContext) MODIFIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODIFIES_SYMBOL, 0)
}

func (s *RoutineOptionContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECURITY_SYMBOL, 0)
}

func (s *RoutineOptionContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINER_SYMBOL, 0)
}

func (s *RoutineOptionContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVOKER_SYMBOL, 0)
}

func (s *RoutineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoutineOption(s)
	}
}

func (s *RoutineOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoutineOption(s)
	}
}

func (s *RoutineOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoutineOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoutineOption() (localctx IRoutineOptionContext) {
	localctx = NewRoutineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, MySQLParserRULE_routineOption)
	var _la int

	p.SetState(2070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2053)

			var _m = p.Match(MySQLParserCOMMENT_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2054)
			p.TextLiteral()
		}

	case MySQLParserLANGUAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2055)

			var _m = p.Match(MySQLParserLANGUAGE_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2056)
			p.Match(MySQLParserSQL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserNO_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2057)

			var _m = p.Match(MySQLParserNO_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2058)
			p.Match(MySQLParserSQL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCONTAINS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2059)

			var _m = p.Match(MySQLParserCONTAINS_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2060)
			p.Match(MySQLParserSQL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREADS_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2061)

			var _m = p.Match(MySQLParserREADS_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2062)
			p.Match(MySQLParserSQL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2063)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserMODIFIES_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2064)

			var _m = p.Match(MySQLParserMODIFIES_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2065)
			p.Match(MySQLParserSQL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2066)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserSQL_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2067)

			var _m = p.Match(MySQLParserSQL_SYMBOL)

			localctx.(*RoutineOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2068)
			p.Match(MySQLParserSECURITY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2069)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoutineOptionContext).security = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDEFINER_SYMBOL || _la == MySQLParserINVOKER_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoutineOptionContext).security = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexContext is an interface to support dynamic dispatch.
type ICreateIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	CreateIndexTarget() ICreateIndexTargetContext
	INDEX_SYMBOL() antlr.TerminalNode
	IndexName() IIndexNameContext
	OnlineOption() IOnlineOptionContext
	FULLTEXT_SYMBOL() antlr.TerminalNode
	SPATIAL_SYMBOL() antlr.TerminalNode
	IndexLockAndAlgorithm() IIndexLockAndAlgorithmContext
	UNIQUE_SYMBOL() antlr.TerminalNode
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	AllFulltextIndexOption() []IFulltextIndexOptionContext
	FulltextIndexOption(i int) IFulltextIndexOptionContext
	AllSpatialIndexOption() []ISpatialIndexOptionContext
	SpatialIndexOption(i int) ISpatialIndexOptionContext
	IndexTypeClause() IIndexTypeClauseContext
	IndexNameAndType() IIndexNameAndTypeContext

	// IsCreateIndexContext differentiates from other interfaces.
	IsCreateIndexContext()
}

type CreateIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyCreateIndexContext() *CreateIndexContext {
	var p = new(CreateIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createIndex
	return p
}

func InitEmptyCreateIndexContext(p *CreateIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createIndex
}

func (*CreateIndexContext) IsCreateIndexContext() {}

func NewCreateIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexContext {
	var p = new(CreateIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createIndex

	return p
}

func (s *CreateIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexContext) GetType_() antlr.Token { return s.type_ }

func (s *CreateIndexContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *CreateIndexContext) CreateIndexTarget() ICreateIndexTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexTargetContext)
}

func (s *CreateIndexContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *CreateIndexContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *CreateIndexContext) OnlineOption() IOnlineOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnlineOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnlineOptionContext)
}

func (s *CreateIndexContext) FULLTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULLTEXT_SYMBOL, 0)
}

func (s *CreateIndexContext) SPATIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSPATIAL_SYMBOL, 0)
}

func (s *CreateIndexContext) IndexLockAndAlgorithm() IIndexLockAndAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexLockAndAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexLockAndAlgorithmContext)
}

func (s *CreateIndexContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNIQUE_SYMBOL, 0)
}

func (s *CreateIndexContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *CreateIndexContext) AllFulltextIndexOption() []IFulltextIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFulltextIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IFulltextIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFulltextIndexOptionContext); ok {
			tst[i] = t.(IFulltextIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) FulltextIndexOption(i int) IFulltextIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFulltextIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFulltextIndexOptionContext)
}

func (s *CreateIndexContext) AllSpatialIndexOption() []ISpatialIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpatialIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]ISpatialIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpatialIndexOptionContext); ok {
			tst[i] = t.(ISpatialIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateIndexContext) SpatialIndexOption(i int) ISpatialIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpatialIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpatialIndexOptionContext)
}

func (s *CreateIndexContext) IndexTypeClause() IIndexTypeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeClauseContext)
}

func (s *CreateIndexContext) IndexNameAndType() IIndexNameAndTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameAndTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameAndTypeContext)
}

func (s *CreateIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateIndex(s)
	}
}

func (s *CreateIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateIndex(s)
	}
}

func (s *CreateIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateIndex() (localctx ICreateIndexContext) {
	localctx = NewCreateIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, MySQLParserRULE_createIndex)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOFFLINE_SYMBOL || _la == MySQLParserONLINE_SYMBOL {
		{
			p.SetState(2072)
			p.OnlineOption()
		}

	}
	p.SetState(2116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINDEX_SYMBOL, MySQLParserUNIQUE_SYMBOL:
		p.SetState(2076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserUNIQUE_SYMBOL {
			{
				p.SetState(2075)
				p.Match(MySQLParserUNIQUE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2078)

			var _m = p.Match(MySQLParserINDEX_SYMBOL)

			localctx.(*CreateIndexContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
		case 1:
			p.SetState(2079)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(2080)
				p.IndexName()
			}
			p.SetState(2082)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserTYPE_SYMBOL || _la == MySQLParserUSING_SYMBOL {
				{
					p.SetState(2081)
					p.IndexTypeClause()
				}

			}

		case 2:
			p.SetState(2085)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2084)
					p.IndexNameAndType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(2089)
			p.CreateIndexTarget()
		}
		p.SetState(2093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2090)
					p.IndexOption()
				}

			}
			p.SetState(2095)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserFULLTEXT_SYMBOL:
		{
			p.SetState(2096)

			var _m = p.Match(MySQLParserFULLTEXT_SYMBOL)

			localctx.(*CreateIndexContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			p.Match(MySQLParserINDEX_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2098)
			p.IndexName()
		}
		{
			p.SetState(2099)
			p.CreateIndexTarget()
		}
		p.SetState(2103)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2100)
					p.FulltextIndexOption()
				}

			}
			p.SetState(2105)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserSPATIAL_SYMBOL:
		{
			p.SetState(2106)

			var _m = p.Match(MySQLParserSPATIAL_SYMBOL)

			localctx.(*CreateIndexContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.Match(MySQLParserINDEX_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2108)
			p.IndexName()
		}
		{
			p.SetState(2109)
			p.CreateIndexTarget()
		}
		p.SetState(2113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2110)
					p.SpatialIndexOption()
				}

			}
			p.SetState(2115)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 142, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserALGORITHM_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
		{
			p.SetState(2118)
			p.IndexLockAndAlgorithm()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameAndTypeContext is an interface to support dynamic dispatch.
type IIndexNameAndTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexName() IIndexNameContext
	USING_SYMBOL() antlr.TerminalNode
	IndexType() IIndexTypeContext
	TYPE_SYMBOL() antlr.TerminalNode

	// IsIndexNameAndTypeContext differentiates from other interfaces.
	IsIndexNameAndTypeContext()
}

type IndexNameAndTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameAndTypeContext() *IndexNameAndTypeContext {
	var p = new(IndexNameAndTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexNameAndType
	return p
}

func InitEmptyIndexNameAndTypeContext(p *IndexNameAndTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexNameAndType
}

func (*IndexNameAndTypeContext) IsIndexNameAndTypeContext() {}

func NewIndexNameAndTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameAndTypeContext {
	var p = new(IndexNameAndTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexNameAndType

	return p
}

func (s *IndexNameAndTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameAndTypeContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *IndexNameAndTypeContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *IndexNameAndTypeContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexNameAndTypeContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPE_SYMBOL, 0)
}

func (s *IndexNameAndTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameAndTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameAndTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexNameAndType(s)
	}
}

func (s *IndexNameAndTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexNameAndType(s)
	}
}

func (s *IndexNameAndTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexNameAndType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexNameAndType() (localctx IIndexNameAndTypeContext) {
	localctx = NewIndexNameAndTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, MySQLParserRULE_indexNameAndType)
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2121)
			p.IndexName()
		}
		p.SetState(2124)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2122)
				p.Match(MySQLParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2123)
				p.IndexType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2126)
			p.IndexName()
		}
		{
			p.SetState(2127)
			p.Match(MySQLParserTYPE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2128)
			p.IndexType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexTargetContext is an interface to support dynamic dispatch.
type ICreateIndexTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	KeyListVariants() IKeyListVariantsContext

	// IsCreateIndexTargetContext differentiates from other interfaces.
	IsCreateIndexTargetContext()
}

type CreateIndexTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateIndexTargetContext() *CreateIndexTargetContext {
	var p = new(CreateIndexTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createIndexTarget
	return p
}

func InitEmptyCreateIndexTargetContext(p *CreateIndexTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createIndexTarget
}

func (*CreateIndexTargetContext) IsCreateIndexTargetContext() {}

func NewCreateIndexTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexTargetContext {
	var p = new(CreateIndexTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createIndexTarget

	return p
}

func (s *CreateIndexTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexTargetContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *CreateIndexTargetContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *CreateIndexTargetContext) KeyListVariants() IKeyListVariantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListVariantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListVariantsContext)
}

func (s *CreateIndexTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateIndexTarget(s)
	}
}

func (s *CreateIndexTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateIndexTarget(s)
	}
}

func (s *CreateIndexTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateIndexTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateIndexTarget() (localctx ICreateIndexTargetContext) {
	localctx = NewCreateIndexTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, MySQLParserRULE_createIndexTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2132)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2133)
		p.TableRef()
	}
	{
		p.SetState(2134)
		p.KeyListVariants()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateLogfileGroupContext is an interface to support dynamic dispatch.
type ICreateLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGFILE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	LogfileGroupName() ILogfileGroupNameContext
	ADD_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	UNDOFILE_SYMBOL() antlr.TerminalNode
	REDOFILE_SYMBOL() antlr.TerminalNode
	LogfileGroupOptions() ILogfileGroupOptionsContext

	// IsCreateLogfileGroupContext differentiates from other interfaces.
	IsCreateLogfileGroupContext()
}

type CreateLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateLogfileGroupContext() *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createLogfileGroup
	return p
}

func InitEmptyCreateLogfileGroupContext(p *CreateLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createLogfileGroup
}

func (*CreateLogfileGroupContext) IsCreateLogfileGroupContext() {}

func NewCreateLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateLogfileGroupContext {
	var p = new(CreateLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createLogfileGroup

	return p
}

func (s *CreateLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateLogfileGroupContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *CreateLogfileGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *CreateLogfileGroupContext) LogfileGroupName() ILogfileGroupNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupNameContext)
}

func (s *CreateLogfileGroupContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *CreateLogfileGroupContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *CreateLogfileGroupContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDOFILE_SYMBOL, 0)
}

func (s *CreateLogfileGroupContext) REDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDOFILE_SYMBOL, 0)
}

func (s *CreateLogfileGroupContext) LogfileGroupOptions() ILogfileGroupOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupOptionsContext)
}

func (s *CreateLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateLogfileGroup(s)
	}
}

func (s *CreateLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateLogfileGroup() (localctx ICreateLogfileGroupContext) {
	localctx = NewCreateLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, MySQLParserRULE_createLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)
		p.Match(MySQLParserLOGFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2137)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2138)
		p.LogfileGroupName()
	}
	{
		p.SetState(2139)
		p.Match(MySQLParserADD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2140)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserREDOFILE_SYMBOL || _la == MySQLParserUNDOFILE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2141)
		p.TextLiteral()
	}
	p.SetState(2143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOMMENT_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserNODEGROUP_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserREDO_BUFFER_SIZE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserUNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParserWAIT_SYMBOL {
		{
			p.SetState(2142)
			p.LogfileGroupOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupOptionsContext is an interface to support dynamic dispatch.
type ILogfileGroupOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLogfileGroupOption() []ILogfileGroupOptionContext
	LogfileGroupOption(i int) ILogfileGroupOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsLogfileGroupOptionsContext differentiates from other interfaces.
	IsLogfileGroupOptionsContext()
}

type LogfileGroupOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupOptionsContext() *LogfileGroupOptionsContext {
	var p = new(LogfileGroupOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupOptions
	return p
}

func InitEmptyLogfileGroupOptionsContext(p *LogfileGroupOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupOptions
}

func (*LogfileGroupOptionsContext) IsLogfileGroupOptionsContext() {}

func NewLogfileGroupOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupOptionsContext {
	var p = new(LogfileGroupOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_logfileGroupOptions

	return p
}

func (s *LogfileGroupOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupOptionsContext) AllLogfileGroupOption() []ILogfileGroupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogfileGroupOptionContext); ok {
			len++
		}
	}

	tst := make([]ILogfileGroupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogfileGroupOptionContext); ok {
			tst[i] = t.(ILogfileGroupOptionContext)
			i++
		}
	}

	return tst
}

func (s *LogfileGroupOptionsContext) LogfileGroupOption(i int) ILogfileGroupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupOptionContext)
}

func (s *LogfileGroupOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *LogfileGroupOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *LogfileGroupOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLogfileGroupOptions(s)
	}
}

func (s *LogfileGroupOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLogfileGroupOptions(s)
	}
}

func (s *LogfileGroupOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLogfileGroupOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LogfileGroupOptions() (localctx ILogfileGroupOptionsContext) {
	localctx = NewLogfileGroupOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, MySQLParserRULE_logfileGroupOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2145)
		p.LogfileGroupOption()
	}
	p.SetState(2152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMENT_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINITIAL_SIZE_SYMBOL || _la == MySQLParserNODEGROUP_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserREDO_BUFFER_SIZE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserUNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParserWAIT_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
		p.SetState(2147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(2146)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2149)
			p.LogfileGroupOption()
		}

		p.SetState(2154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupOptionContext is an interface to support dynamic dispatch.
type ILogfileGroupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TsOptionInitialSize() ITsOptionInitialSizeContext
	TsOptionUndoRedoBufferSize() ITsOptionUndoRedoBufferSizeContext
	TsOptionNodegroup() ITsOptionNodegroupContext
	TsOptionEngine() ITsOptionEngineContext
	TsOptionWait() ITsOptionWaitContext
	TsOptionComment() ITsOptionCommentContext

	// IsLogfileGroupOptionContext differentiates from other interfaces.
	IsLogfileGroupOptionContext()
}

type LogfileGroupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupOptionContext() *LogfileGroupOptionContext {
	var p = new(LogfileGroupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupOption
	return p
}

func InitEmptyLogfileGroupOptionContext(p *LogfileGroupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupOption
}

func (*LogfileGroupOptionContext) IsLogfileGroupOptionContext() {}

func NewLogfileGroupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupOptionContext {
	var p = new(LogfileGroupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_logfileGroupOption

	return p
}

func (s *LogfileGroupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupOptionContext) TsOptionInitialSize() ITsOptionInitialSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionInitialSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionInitialSizeContext)
}

func (s *LogfileGroupOptionContext) TsOptionUndoRedoBufferSize() ITsOptionUndoRedoBufferSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionUndoRedoBufferSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionUndoRedoBufferSizeContext)
}

func (s *LogfileGroupOptionContext) TsOptionNodegroup() ITsOptionNodegroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionNodegroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionNodegroupContext)
}

func (s *LogfileGroupOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *LogfileGroupOptionContext) TsOptionWait() ITsOptionWaitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionWaitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionWaitContext)
}

func (s *LogfileGroupOptionContext) TsOptionComment() ITsOptionCommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionCommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionCommentContext)
}

func (s *LogfileGroupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLogfileGroupOption(s)
	}
}

func (s *LogfileGroupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLogfileGroupOption(s)
	}
}

func (s *LogfileGroupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLogfileGroupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LogfileGroupOption() (localctx ILogfileGroupOptionContext) {
	localctx = NewLogfileGroupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, MySQLParserRULE_logfileGroupOption)
	p.SetState(2161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINITIAL_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2155)
			p.TsOptionInitialSize()
		}

	case MySQLParserREDO_BUFFER_SIZE_SYMBOL, MySQLParserUNDO_BUFFER_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2156)
			p.TsOptionUndoRedoBufferSize()
		}

	case MySQLParserNODEGROUP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2157)
			p.TsOptionNodegroup()
		}

	case MySQLParserENGINE_SYMBOL, MySQLParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2158)
			p.TsOptionEngine()
		}

	case MySQLParserNO_WAIT_SYMBOL, MySQLParserWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2159)
			p.TsOptionWait()
		}

	case MySQLParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2160)
			p.TsOptionComment()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateServerContext is an interface to support dynamic dispatch.
type ICreateServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SERVER_SYMBOL() antlr.TerminalNode
	ServerName() IServerNameContext
	FOREIGN_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	WRAPPER_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	ServerOptions() IServerOptionsContext

	// IsCreateServerContext differentiates from other interfaces.
	IsCreateServerContext()
}

type CreateServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateServerContext() *CreateServerContext {
	var p = new(CreateServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createServer
	return p
}

func InitEmptyCreateServerContext(p *CreateServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createServer
}

func (*CreateServerContext) IsCreateServerContext() {}

func NewCreateServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateServerContext {
	var p = new(CreateServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createServer

	return p
}

func (s *CreateServerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateServerContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERVER_SYMBOL, 0)
}

func (s *CreateServerContext) ServerName() IServerNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerNameContext)
}

func (s *CreateServerContext) FOREIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOREIGN_SYMBOL, 0)
}

func (s *CreateServerContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *CreateServerContext) WRAPPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRAPPER_SYMBOL, 0)
}

func (s *CreateServerContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CreateServerContext) ServerOptions() IServerOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionsContext)
}

func (s *CreateServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateServer(s)
	}
}

func (s *CreateServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateServer(s)
	}
}

func (s *CreateServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateServer() (localctx ICreateServerContext) {
	localctx = NewCreateServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, MySQLParserRULE_createServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2163)
		p.Match(MySQLParserSERVER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2164)
		p.ServerName()
	}
	{
		p.SetState(2165)
		p.Match(MySQLParserFOREIGN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2166)
		p.Match(MySQLParserDATA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2167)
		p.Match(MySQLParserWRAPPER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2168)
		p.TextOrIdentifier()
	}
	{
		p.SetState(2169)
		p.ServerOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerOptionsContext is an interface to support dynamic dispatch.
type IServerOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPTIONS_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllServerOption() []IServerOptionContext
	ServerOption(i int) IServerOptionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsServerOptionsContext differentiates from other interfaces.
	IsServerOptionsContext()
}

type ServerOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerOptionsContext() *ServerOptionsContext {
	var p = new(ServerOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverOptions
	return p
}

func InitEmptyServerOptionsContext(p *ServerOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverOptions
}

func (*ServerOptionsContext) IsServerOptionsContext() {}

func NewServerOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionsContext {
	var p = new(ServerOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_serverOptions

	return p
}

func (s *ServerOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionsContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONS_SYMBOL, 0)
}

func (s *ServerOptionsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ServerOptionsContext) AllServerOption() []IServerOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IServerOptionContext); ok {
			len++
		}
	}

	tst := make([]IServerOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IServerOptionContext); ok {
			tst[i] = t.(IServerOptionContext)
			i++
		}
	}

	return tst
}

func (s *ServerOptionsContext) ServerOption(i int) IServerOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerOptionContext)
}

func (s *ServerOptionsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ServerOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ServerOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ServerOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterServerOptions(s)
	}
}

func (s *ServerOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitServerOptions(s)
	}
}

func (s *ServerOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitServerOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ServerOptions() (localctx IServerOptionsContext) {
	localctx = NewServerOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, MySQLParserRULE_serverOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2171)
		p.Match(MySQLParserOPTIONS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2172)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2173)
		p.ServerOption()
	}
	p.SetState(2178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(2174)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2175)
			p.ServerOption()
		}

		p.SetState(2180)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2181)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerOptionContext is an interface to support dynamic dispatch.
type IServerOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	TextLiteral() ITextLiteralContext
	HOST_SYMBOL() antlr.TerminalNode
	DATABASE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	SOCKET_SYMBOL() antlr.TerminalNode
	OWNER_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	PORT_SYMBOL() antlr.TerminalNode

	// IsServerOptionContext differentiates from other interfaces.
	IsServerOptionContext()
}

type ServerOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyServerOptionContext() *ServerOptionContext {
	var p = new(ServerOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverOption
	return p
}

func InitEmptyServerOptionContext(p *ServerOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverOption
}

func (*ServerOptionContext) IsServerOptionContext() {}

func NewServerOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerOptionContext {
	var p = new(ServerOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_serverOption

	return p
}

func (s *ServerOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerOptionContext) GetOption() antlr.Token { return s.option }

func (s *ServerOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *ServerOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *ServerOptionContext) HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOST_SYMBOL, 0)
}

func (s *ServerOptionContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *ServerOptionContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *ServerOptionContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *ServerOptionContext) SOCKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOCKET_SYMBOL, 0)
}

func (s *ServerOptionContext) OWNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOWNER_SYMBOL, 0)
}

func (s *ServerOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *ServerOptionContext) PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPORT_SYMBOL, 0)
}

func (s *ServerOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterServerOption(s)
	}
}

func (s *ServerOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitServerOption(s)
	}
}

func (s *ServerOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitServerOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ServerOption() (localctx IServerOptionContext) {
	localctx = NewServerOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, MySQLParserRULE_serverOption)
	p.SetState(2197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserHOST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2183)

			var _m = p.Match(MySQLParserHOST_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2184)
			p.TextLiteral()
		}

	case MySQLParserDATABASE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2185)

			var _m = p.Match(MySQLParserDATABASE_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2186)
			p.TextLiteral()
		}

	case MySQLParserUSER_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2187)

			var _m = p.Match(MySQLParserUSER_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2188)
			p.TextLiteral()
		}

	case MySQLParserPASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2189)

			var _m = p.Match(MySQLParserPASSWORD_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2190)
			p.TextLiteral()
		}

	case MySQLParserSOCKET_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2191)

			var _m = p.Match(MySQLParserSOCKET_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2192)
			p.TextLiteral()
		}

	case MySQLParserOWNER_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2193)

			var _m = p.Match(MySQLParserOWNER_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2194)
			p.TextLiteral()
		}

	case MySQLParserPORT_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2195)

			var _m = p.Match(MySQLParserPORT_SYMBOL)

			localctx.(*ServerOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTablespaceContext is an interface to support dynamic dispatch.
type ICreateTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceName() ITablespaceNameContext
	TsDataFileName() ITsDataFileNameContext
	USE_SYMBOL() antlr.TerminalNode
	LOGFILE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	LogfileGroupRef() ILogfileGroupRefContext
	TablespaceOptions() ITablespaceOptionsContext

	// IsCreateTablespaceContext differentiates from other interfaces.
	IsCreateTablespaceContext()
}

type CreateTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTablespaceContext() *CreateTablespaceContext {
	var p = new(CreateTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTablespace
	return p
}

func InitEmptyCreateTablespaceContext(p *CreateTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTablespace
}

func (*CreateTablespaceContext) IsCreateTablespaceContext() {}

func NewCreateTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTablespaceContext {
	var p = new(CreateTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTablespace

	return p
}

func (s *CreateTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTablespaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *CreateTablespaceContext) TablespaceName() ITablespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceNameContext)
}

func (s *CreateTablespaceContext) TsDataFileName() ITsDataFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsDataFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsDataFileNameContext)
}

func (s *CreateTablespaceContext) USE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_SYMBOL, 0)
}

func (s *CreateTablespaceContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *CreateTablespaceContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *CreateTablespaceContext) LogfileGroupRef() ILogfileGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupRefContext)
}

func (s *CreateTablespaceContext) TablespaceOptions() ITablespaceOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceOptionsContext)
}

func (s *CreateTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTablespace(s)
	}
}

func (s *CreateTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTablespace(s)
	}
}

func (s *CreateTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTablespace() (localctx ICreateTablespaceContext) {
	localctx = NewCreateTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, MySQLParserRULE_createTablespace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2199)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2200)
		p.TablespaceName()
	}
	{
		p.SetState(2201)
		p.TsDataFileName()
	}
	p.SetState(2206)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 153, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2202)
			p.Match(MySQLParserUSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2203)
			p.Match(MySQLParserLOGFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2204)
			p.Match(MySQLParserGROUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2205)
			p.LogfileGroupRef()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2209)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 154, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2208)
			p.TablespaceOptions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUndoTablespaceContext is an interface to support dynamic dispatch.
type ICreateUndoTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDO_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceName() ITablespaceNameContext
	ADD_SYMBOL() antlr.TerminalNode
	TsDataFile() ITsDataFileContext
	UndoTableSpaceOptions() IUndoTableSpaceOptionsContext

	// IsCreateUndoTablespaceContext differentiates from other interfaces.
	IsCreateUndoTablespaceContext()
}

type CreateUndoTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUndoTablespaceContext() *CreateUndoTablespaceContext {
	var p = new(CreateUndoTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUndoTablespace
	return p
}

func InitEmptyCreateUndoTablespaceContext(p *CreateUndoTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUndoTablespace
}

func (*CreateUndoTablespaceContext) IsCreateUndoTablespaceContext() {}

func NewCreateUndoTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUndoTablespaceContext {
	var p = new(CreateUndoTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUndoTablespace

	return p
}

func (s *CreateUndoTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUndoTablespaceContext) UNDO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_SYMBOL, 0)
}

func (s *CreateUndoTablespaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *CreateUndoTablespaceContext) TablespaceName() ITablespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceNameContext)
}

func (s *CreateUndoTablespaceContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *CreateUndoTablespaceContext) TsDataFile() ITsDataFileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsDataFileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsDataFileContext)
}

func (s *CreateUndoTablespaceContext) UndoTableSpaceOptions() IUndoTableSpaceOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndoTableSpaceOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndoTableSpaceOptionsContext)
}

func (s *CreateUndoTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUndoTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUndoTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUndoTablespace(s)
	}
}

func (s *CreateUndoTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUndoTablespace(s)
	}
}

func (s *CreateUndoTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUndoTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUndoTablespace() (localctx ICreateUndoTablespaceContext) {
	localctx = NewCreateUndoTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, MySQLParserRULE_createUndoTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2211)
		p.Match(MySQLParserUNDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2212)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2213)
		p.TablespaceName()
	}
	{
		p.SetState(2214)
		p.Match(MySQLParserADD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2215)
		p.TsDataFile()
	}
	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL {
		{
			p.SetState(2216)
			p.UndoTableSpaceOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsDataFileNameContext is an interface to support dynamic dispatch.
type ITsDataFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD_SYMBOL() antlr.TerminalNode
	TsDataFile() ITsDataFileContext

	// IsTsDataFileNameContext differentiates from other interfaces.
	IsTsDataFileNameContext()
}

type TsDataFileNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsDataFileNameContext() *TsDataFileNameContext {
	var p = new(TsDataFileNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsDataFileName
	return p
}

func InitEmptyTsDataFileNameContext(p *TsDataFileNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsDataFileName
}

func (*TsDataFileNameContext) IsTsDataFileNameContext() {}

func NewTsDataFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsDataFileNameContext {
	var p = new(TsDataFileNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsDataFileName

	return p
}

func (s *TsDataFileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TsDataFileNameContext) ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADD_SYMBOL, 0)
}

func (s *TsDataFileNameContext) TsDataFile() ITsDataFileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsDataFileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsDataFileContext)
}

func (s *TsDataFileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsDataFileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsDataFileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsDataFileName(s)
	}
}

func (s *TsDataFileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsDataFileName(s)
	}
}

func (s *TsDataFileNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsDataFileName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsDataFileName() (localctx ITsDataFileNameContext) {
	localctx = NewTsDataFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, MySQLParserRULE_tsDataFileName)
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2219)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		p.SetState(2222)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2220)
				p.Match(MySQLParserADD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2221)
				p.TsDataFile()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2224)
			p.Match(MySQLParserADD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2225)
			p.TsDataFile()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsDataFileContext is an interface to support dynamic dispatch.
type ITsDataFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATAFILE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext

	// IsTsDataFileContext differentiates from other interfaces.
	IsTsDataFileContext()
}

type TsDataFileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsDataFileContext() *TsDataFileContext {
	var p = new(TsDataFileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsDataFile
	return p
}

func InitEmptyTsDataFileContext(p *TsDataFileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsDataFile
}

func (*TsDataFileContext) IsTsDataFileContext() {}

func NewTsDataFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsDataFileContext {
	var p = new(TsDataFileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsDataFile

	return p
}

func (s *TsDataFileContext) GetParser() antlr.Parser { return s.parser }

func (s *TsDataFileContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATAFILE_SYMBOL, 0)
}

func (s *TsDataFileContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *TsDataFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsDataFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsDataFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsDataFile(s)
	}
}

func (s *TsDataFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsDataFile(s)
	}
}

func (s *TsDataFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsDataFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsDataFile() (localctx ITsDataFileContext) {
	localctx = NewTsDataFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, MySQLParserRULE_tsDataFile)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.Match(MySQLParserDATAFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2229)
		p.TextLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceOptionsContext is an interface to support dynamic dispatch.
type ITablespaceOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTablespaceOption() []ITablespaceOptionContext
	TablespaceOption(i int) ITablespaceOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTablespaceOptionsContext differentiates from other interfaces.
	IsTablespaceOptionsContext()
}

type TablespaceOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceOptionsContext() *TablespaceOptionsContext {
	var p = new(TablespaceOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceOptions
	return p
}

func InitEmptyTablespaceOptionsContext(p *TablespaceOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceOptions
}

func (*TablespaceOptionsContext) IsTablespaceOptionsContext() {}

func NewTablespaceOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceOptionsContext {
	var p = new(TablespaceOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tablespaceOptions

	return p
}

func (s *TablespaceOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceOptionsContext) AllTablespaceOption() []ITablespaceOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITablespaceOptionContext); ok {
			len++
		}
	}

	tst := make([]ITablespaceOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITablespaceOptionContext); ok {
			tst[i] = t.(ITablespaceOptionContext)
			i++
		}
	}

	return tst
}

func (s *TablespaceOptionsContext) TablespaceOption(i int) ITablespaceOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceOptionContext)
}

func (s *TablespaceOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TablespaceOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TablespaceOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTablespaceOptions(s)
	}
}

func (s *TablespaceOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTablespaceOptions(s)
	}
}

func (s *TablespaceOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTablespaceOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TablespaceOptions() (localctx ITablespaceOptionsContext) {
	localctx = NewTablespaceOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, MySQLParserRULE_tablespaceOptions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2231)
		p.TablespaceOption()
	}
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2233)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2232)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2235)
				p.TablespaceOption()
			}

		}
		p.SetState(2240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceOptionContext is an interface to support dynamic dispatch.
type ITablespaceOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TsOptionInitialSize() ITsOptionInitialSizeContext
	TsOptionAutoextendSize() ITsOptionAutoextendSizeContext
	TsOptionMaxSize() ITsOptionMaxSizeContext
	TsOptionExtentSize() ITsOptionExtentSizeContext
	TsOptionNodegroup() ITsOptionNodegroupContext
	TsOptionEngine() ITsOptionEngineContext
	TsOptionWait() ITsOptionWaitContext
	TsOptionComment() ITsOptionCommentContext
	TsOptionFileblockSize() ITsOptionFileblockSizeContext
	TsOptionEncryption() ITsOptionEncryptionContext

	// IsTablespaceOptionContext differentiates from other interfaces.
	IsTablespaceOptionContext()
}

type TablespaceOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceOptionContext() *TablespaceOptionContext {
	var p = new(TablespaceOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceOption
	return p
}

func InitEmptyTablespaceOptionContext(p *TablespaceOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceOption
}

func (*TablespaceOptionContext) IsTablespaceOptionContext() {}

func NewTablespaceOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceOptionContext {
	var p = new(TablespaceOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tablespaceOption

	return p
}

func (s *TablespaceOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceOptionContext) TsOptionInitialSize() ITsOptionInitialSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionInitialSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionInitialSizeContext)
}

func (s *TablespaceOptionContext) TsOptionAutoextendSize() ITsOptionAutoextendSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionAutoextendSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionAutoextendSizeContext)
}

func (s *TablespaceOptionContext) TsOptionMaxSize() ITsOptionMaxSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionMaxSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionMaxSizeContext)
}

func (s *TablespaceOptionContext) TsOptionExtentSize() ITsOptionExtentSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionExtentSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionExtentSizeContext)
}

func (s *TablespaceOptionContext) TsOptionNodegroup() ITsOptionNodegroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionNodegroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionNodegroupContext)
}

func (s *TablespaceOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *TablespaceOptionContext) TsOptionWait() ITsOptionWaitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionWaitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionWaitContext)
}

func (s *TablespaceOptionContext) TsOptionComment() ITsOptionCommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionCommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionCommentContext)
}

func (s *TablespaceOptionContext) TsOptionFileblockSize() ITsOptionFileblockSizeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionFileblockSizeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionFileblockSizeContext)
}

func (s *TablespaceOptionContext) TsOptionEncryption() ITsOptionEncryptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEncryptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEncryptionContext)
}

func (s *TablespaceOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTablespaceOption(s)
	}
}

func (s *TablespaceOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTablespaceOption(s)
	}
}

func (s *TablespaceOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTablespaceOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TablespaceOption() (localctx ITablespaceOptionContext) {
	localctx = NewTablespaceOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, MySQLParserRULE_tablespaceOption)
	p.SetState(2253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 160, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2241)
			p.TsOptionInitialSize()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2242)
			p.TsOptionAutoextendSize()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2243)
			p.TsOptionMaxSize()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2244)
			p.TsOptionExtentSize()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2245)
			p.TsOptionNodegroup()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2246)
			p.TsOptionEngine()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2247)
			p.TsOptionWait()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2248)
			p.TsOptionComment()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(2249)

		if !(serverVersion >= 50707) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50707", ""))
			goto errorExit
		}
		{
			p.SetState(2250)
			p.TsOptionFileblockSize()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(2251)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(2252)
			p.TsOptionEncryption()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionInitialSizeContext is an interface to support dynamic dispatch.
type ITsOptionInitialSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionInitialSizeContext differentiates from other interfaces.
	IsTsOptionInitialSizeContext()
}

type TsOptionInitialSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionInitialSizeContext() *TsOptionInitialSizeContext {
	var p = new(TsOptionInitialSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionInitialSize
	return p
}

func InitEmptyTsOptionInitialSizeContext(p *TsOptionInitialSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionInitialSize
}

func (*TsOptionInitialSizeContext) IsTsOptionInitialSizeContext() {}

func NewTsOptionInitialSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionInitialSizeContext {
	var p = new(TsOptionInitialSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionInitialSize

	return p
}

func (s *TsOptionInitialSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionInitialSizeContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *TsOptionInitialSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionInitialSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionInitialSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionInitialSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionInitialSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionInitialSize(s)
	}
}

func (s *TsOptionInitialSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionInitialSize(s)
	}
}

func (s *TsOptionInitialSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionInitialSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionInitialSize() (localctx ITsOptionInitialSizeContext) {
	localctx = NewTsOptionInitialSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, MySQLParserRULE_tsOptionInitialSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2255)
		p.Match(MySQLParserINITIAL_SIZE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2257)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2256)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2259)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionUndoRedoBufferSizeContext is an interface to support dynamic dispatch.
type ITsOptionUndoRedoBufferSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SizeNumber() ISizeNumberContext
	UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionUndoRedoBufferSizeContext differentiates from other interfaces.
	IsTsOptionUndoRedoBufferSizeContext()
}

type TsOptionUndoRedoBufferSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionUndoRedoBufferSizeContext() *TsOptionUndoRedoBufferSizeContext {
	var p = new(TsOptionUndoRedoBufferSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionUndoRedoBufferSize
	return p
}

func InitEmptyTsOptionUndoRedoBufferSizeContext(p *TsOptionUndoRedoBufferSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionUndoRedoBufferSize
}

func (*TsOptionUndoRedoBufferSizeContext) IsTsOptionUndoRedoBufferSizeContext() {}

func NewTsOptionUndoRedoBufferSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionUndoRedoBufferSizeContext {
	var p = new(TsOptionUndoRedoBufferSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionUndoRedoBufferSize

	return p
}

func (s *TsOptionUndoRedoBufferSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionUndoRedoBufferSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionUndoRedoBufferSizeContext) UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *TsOptionUndoRedoBufferSizeContext) REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *TsOptionUndoRedoBufferSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionUndoRedoBufferSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionUndoRedoBufferSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionUndoRedoBufferSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionUndoRedoBufferSize(s)
	}
}

func (s *TsOptionUndoRedoBufferSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionUndoRedoBufferSize(s)
	}
}

func (s *TsOptionUndoRedoBufferSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionUndoRedoBufferSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionUndoRedoBufferSize() (localctx ITsOptionUndoRedoBufferSizeContext) {
	localctx = NewTsOptionUndoRedoBufferSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, MySQLParserRULE_tsOptionUndoRedoBufferSize)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2261)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserREDO_BUFFER_SIZE_SYMBOL || _la == MySQLParserUNDO_BUFFER_SIZE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2263)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2262)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2265)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionAutoextendSizeContext is an interface to support dynamic dispatch.
type ITsOptionAutoextendSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionAutoextendSizeContext differentiates from other interfaces.
	IsTsOptionAutoextendSizeContext()
}

type TsOptionAutoextendSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionAutoextendSizeContext() *TsOptionAutoextendSizeContext {
	var p = new(TsOptionAutoextendSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionAutoextendSize
	return p
}

func InitEmptyTsOptionAutoextendSizeContext(p *TsOptionAutoextendSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionAutoextendSize
}

func (*TsOptionAutoextendSizeContext) IsTsOptionAutoextendSizeContext() {}

func NewTsOptionAutoextendSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionAutoextendSizeContext {
	var p = new(TsOptionAutoextendSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionAutoextendSize

	return p
}

func (s *TsOptionAutoextendSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionAutoextendSizeContext) AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTOEXTEND_SIZE_SYMBOL, 0)
}

func (s *TsOptionAutoextendSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionAutoextendSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionAutoextendSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionAutoextendSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionAutoextendSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionAutoextendSize(s)
	}
}

func (s *TsOptionAutoextendSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionAutoextendSize(s)
	}
}

func (s *TsOptionAutoextendSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionAutoextendSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionAutoextendSize() (localctx ITsOptionAutoextendSizeContext) {
	localctx = NewTsOptionAutoextendSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, MySQLParserRULE_tsOptionAutoextendSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2267)
		p.Match(MySQLParserAUTOEXTEND_SIZE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2269)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 163, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2268)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2271)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionMaxSizeContext is an interface to support dynamic dispatch.
type ITsOptionMaxSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAX_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionMaxSizeContext differentiates from other interfaces.
	IsTsOptionMaxSizeContext()
}

type TsOptionMaxSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionMaxSizeContext() *TsOptionMaxSizeContext {
	var p = new(TsOptionMaxSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionMaxSize
	return p
}

func InitEmptyTsOptionMaxSizeContext(p *TsOptionMaxSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionMaxSize
}

func (*TsOptionMaxSizeContext) IsTsOptionMaxSizeContext() {}

func NewTsOptionMaxSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionMaxSizeContext {
	var p = new(TsOptionMaxSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionMaxSize

	return p
}

func (s *TsOptionMaxSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionMaxSizeContext) MAX_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_SIZE_SYMBOL, 0)
}

func (s *TsOptionMaxSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionMaxSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionMaxSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionMaxSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionMaxSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionMaxSize(s)
	}
}

func (s *TsOptionMaxSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionMaxSize(s)
	}
}

func (s *TsOptionMaxSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionMaxSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionMaxSize() (localctx ITsOptionMaxSizeContext) {
	localctx = NewTsOptionMaxSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, MySQLParserRULE_tsOptionMaxSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2273)
		p.Match(MySQLParserMAX_SIZE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2275)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 164, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2274)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2277)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionExtentSizeContext is an interface to support dynamic dispatch.
type ITsOptionExtentSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTENT_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionExtentSizeContext differentiates from other interfaces.
	IsTsOptionExtentSizeContext()
}

type TsOptionExtentSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionExtentSizeContext() *TsOptionExtentSizeContext {
	var p = new(TsOptionExtentSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionExtentSize
	return p
}

func InitEmptyTsOptionExtentSizeContext(p *TsOptionExtentSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionExtentSize
}

func (*TsOptionExtentSizeContext) IsTsOptionExtentSizeContext() {}

func NewTsOptionExtentSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionExtentSizeContext {
	var p = new(TsOptionExtentSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionExtentSize

	return p
}

func (s *TsOptionExtentSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionExtentSizeContext) EXTENT_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENT_SIZE_SYMBOL, 0)
}

func (s *TsOptionExtentSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionExtentSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionExtentSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionExtentSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionExtentSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionExtentSize(s)
	}
}

func (s *TsOptionExtentSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionExtentSize(s)
	}
}

func (s *TsOptionExtentSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionExtentSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionExtentSize() (localctx ITsOptionExtentSizeContext) {
	localctx = NewTsOptionExtentSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, MySQLParserRULE_tsOptionExtentSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2279)
		p.Match(MySQLParserEXTENT_SIZE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2281)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2280)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2283)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionNodegroupContext is an interface to support dynamic dispatch.
type ITsOptionNodegroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NODEGROUP_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionNodegroupContext differentiates from other interfaces.
	IsTsOptionNodegroupContext()
}

type TsOptionNodegroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionNodegroupContext() *TsOptionNodegroupContext {
	var p = new(TsOptionNodegroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionNodegroup
	return p
}

func InitEmptyTsOptionNodegroupContext(p *TsOptionNodegroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionNodegroup
}

func (*TsOptionNodegroupContext) IsTsOptionNodegroupContext() {}

func NewTsOptionNodegroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionNodegroupContext {
	var p = new(TsOptionNodegroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionNodegroup

	return p
}

func (s *TsOptionNodegroupContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionNodegroupContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNODEGROUP_SYMBOL, 0)
}

func (s *TsOptionNodegroupContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *TsOptionNodegroupContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionNodegroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionNodegroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionNodegroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionNodegroup(s)
	}
}

func (s *TsOptionNodegroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionNodegroup(s)
	}
}

func (s *TsOptionNodegroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionNodegroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionNodegroup() (localctx ITsOptionNodegroupContext) {
	localctx = NewTsOptionNodegroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, MySQLParserRULE_tsOptionNodegroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2285)
		p.Match(MySQLParserNODEGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserEQUAL_OPERATOR {
		{
			p.SetState(2286)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2289)
		p.Real_ulong_number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionEngineContext is an interface to support dynamic dispatch.
type ITsOptionEngineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE_SYMBOL() antlr.TerminalNode
	EngineRef() IEngineRefContext
	STORAGE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionEngineContext differentiates from other interfaces.
	IsTsOptionEngineContext()
}

type TsOptionEngineContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionEngineContext() *TsOptionEngineContext {
	var p = new(TsOptionEngineContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionEngine
	return p
}

func InitEmptyTsOptionEngineContext(p *TsOptionEngineContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionEngine
}

func (*TsOptionEngineContext) IsTsOptionEngineContext() {}

func NewTsOptionEngineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionEngineContext {
	var p = new(TsOptionEngineContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionEngine

	return p
}

func (s *TsOptionEngineContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionEngineContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *TsOptionEngineContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *TsOptionEngineContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *TsOptionEngineContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionEngineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionEngineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionEngineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionEngine(s)
	}
}

func (s *TsOptionEngineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionEngine(s)
	}
}

func (s *TsOptionEngineContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionEngine(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionEngine() (localctx ITsOptionEngineContext) {
	localctx = NewTsOptionEngineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, MySQLParserRULE_tsOptionEngine)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSTORAGE_SYMBOL {
		{
			p.SetState(2291)
			p.Match(MySQLParserSTORAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2294)
		p.Match(MySQLParserENGINE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2296)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2295)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2298)
		p.EngineRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionWaitContext is an interface to support dynamic dispatch.
type ITsOptionWaitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WAIT_SYMBOL() antlr.TerminalNode
	NO_WAIT_SYMBOL() antlr.TerminalNode

	// IsTsOptionWaitContext differentiates from other interfaces.
	IsTsOptionWaitContext()
}

type TsOptionWaitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionWaitContext() *TsOptionWaitContext {
	var p = new(TsOptionWaitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionWait
	return p
}

func InitEmptyTsOptionWaitContext(p *TsOptionWaitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionWait
}

func (*TsOptionWaitContext) IsTsOptionWaitContext() {}

func NewTsOptionWaitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionWaitContext {
	var p = new(TsOptionWaitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionWait

	return p
}

func (s *TsOptionWaitContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionWaitContext) WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWAIT_SYMBOL, 0)
}

func (s *TsOptionWaitContext) NO_WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_WAIT_SYMBOL, 0)
}

func (s *TsOptionWaitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionWaitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionWaitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionWait(s)
	}
}

func (s *TsOptionWaitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionWait(s)
	}
}

func (s *TsOptionWaitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionWait(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionWait() (localctx ITsOptionWaitContext) {
	localctx = NewTsOptionWaitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, MySQLParserRULE_tsOptionWait)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2300)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserWAIT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionCommentContext is an interface to support dynamic dispatch.
type ITsOptionCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionCommentContext differentiates from other interfaces.
	IsTsOptionCommentContext()
}

type TsOptionCommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionCommentContext() *TsOptionCommentContext {
	var p = new(TsOptionCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionComment
	return p
}

func InitEmptyTsOptionCommentContext(p *TsOptionCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionComment
}

func (*TsOptionCommentContext) IsTsOptionCommentContext() {}

func NewTsOptionCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionCommentContext {
	var p = new(TsOptionCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionComment

	return p
}

func (s *TsOptionCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionCommentContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *TsOptionCommentContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *TsOptionCommentContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionComment(s)
	}
}

func (s *TsOptionCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionComment(s)
	}
}

func (s *TsOptionCommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionComment() (localctx ITsOptionCommentContext) {
	localctx = NewTsOptionCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, MySQLParserRULE_tsOptionComment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2302)
		p.Match(MySQLParserCOMMENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2303)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2306)
		p.TextLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionFileblockSizeContext is an interface to support dynamic dispatch.
type ITsOptionFileblockSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	SizeNumber() ISizeNumberContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionFileblockSizeContext differentiates from other interfaces.
	IsTsOptionFileblockSizeContext()
}

type TsOptionFileblockSizeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionFileblockSizeContext() *TsOptionFileblockSizeContext {
	var p = new(TsOptionFileblockSizeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionFileblockSize
	return p
}

func InitEmptyTsOptionFileblockSizeContext(p *TsOptionFileblockSizeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionFileblockSize
}

func (*TsOptionFileblockSizeContext) IsTsOptionFileblockSizeContext() {}

func NewTsOptionFileblockSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionFileblockSizeContext {
	var p = new(TsOptionFileblockSizeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionFileblockSize

	return p
}

func (s *TsOptionFileblockSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionFileblockSizeContext) FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_BLOCK_SIZE_SYMBOL, 0)
}

func (s *TsOptionFileblockSizeContext) SizeNumber() ISizeNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISizeNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISizeNumberContext)
}

func (s *TsOptionFileblockSizeContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionFileblockSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionFileblockSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionFileblockSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionFileblockSize(s)
	}
}

func (s *TsOptionFileblockSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionFileblockSize(s)
	}
}

func (s *TsOptionFileblockSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionFileblockSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionFileblockSize() (localctx ITsOptionFileblockSizeContext) {
	localctx = NewTsOptionFileblockSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, MySQLParserRULE_tsOptionFileblockSize)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2308)
		p.Match(MySQLParserFILE_BLOCK_SIZE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2310)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2309)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2312)
		p.SizeNumber()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITsOptionEncryptionContext is an interface to support dynamic dispatch.
type ITsOptionEncryptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTsOptionEncryptionContext differentiates from other interfaces.
	IsTsOptionEncryptionContext()
}

type TsOptionEncryptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTsOptionEncryptionContext() *TsOptionEncryptionContext {
	var p = new(TsOptionEncryptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionEncryption
	return p
}

func InitEmptyTsOptionEncryptionContext(p *TsOptionEncryptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tsOptionEncryption
}

func (*TsOptionEncryptionContext) IsTsOptionEncryptionContext() {}

func NewTsOptionEncryptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TsOptionEncryptionContext {
	var p = new(TsOptionEncryptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tsOptionEncryption

	return p
}

func (s *TsOptionEncryptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TsOptionEncryptionContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCRYPTION_SYMBOL, 0)
}

func (s *TsOptionEncryptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TsOptionEncryptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TsOptionEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TsOptionEncryptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TsOptionEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTsOptionEncryption(s)
	}
}

func (s *TsOptionEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTsOptionEncryption(s)
	}
}

func (s *TsOptionEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTsOptionEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TsOptionEncryption() (localctx ITsOptionEncryptionContext) {
	localctx = NewTsOptionEncryptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, MySQLParserRULE_tsOptionEncryption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2314)
		p.Match(MySQLParserENCRYPTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2316)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2315)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2318)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewContext is an interface to support dynamic dispatch.
type ICreateViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VIEW_SYMBOL() antlr.TerminalNode
	ViewName() IViewNameContext
	ViewTail() IViewTailContext
	ViewReplaceOrAlgorithm() IViewReplaceOrAlgorithmContext
	DefinerClause() IDefinerClauseContext
	ViewSuid() IViewSuidContext

	// IsCreateViewContext differentiates from other interfaces.
	IsCreateViewContext()
}

type CreateViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewContext() *CreateViewContext {
	var p = new(CreateViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createView
	return p
}

func InitEmptyCreateViewContext(p *CreateViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createView
}

func (*CreateViewContext) IsCreateViewContext() {}

func NewCreateViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewContext {
	var p = new(CreateViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createView

	return p
}

func (s *CreateViewContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *CreateViewContext) ViewName() IViewNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewNameContext)
}

func (s *CreateViewContext) ViewTail() IViewTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewTailContext)
}

func (s *CreateViewContext) ViewReplaceOrAlgorithm() IViewReplaceOrAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewReplaceOrAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewReplaceOrAlgorithmContext)
}

func (s *CreateViewContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *CreateViewContext) ViewSuid() IViewSuidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewSuidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewSuidContext)
}

func (s *CreateViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateView(s)
	}
}

func (s *CreateViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateView(s)
	}
}

func (s *CreateViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateView() (localctx ICreateViewContext) {
	localctx = NewCreateViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, MySQLParserRULE_createView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2321)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserALGORITHM_SYMBOL || _la == MySQLParserOR_SYMBOL {
		{
			p.SetState(2320)
			p.ViewReplaceOrAlgorithm()
		}

	}
	p.SetState(2324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(2323)
			p.DefinerClause()
		}

	}
	p.SetState(2327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSQL_SYMBOL {
		{
			p.SetState(2326)
			p.ViewSuid()
		}

	}
	{
		p.SetState(2329)
		p.Match(MySQLParserVIEW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2330)
		p.ViewName()
	}
	{
		p.SetState(2331)
		p.ViewTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewReplaceOrAlgorithmContext is an interface to support dynamic dispatch.
type IViewReplaceOrAlgorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	ViewAlgorithm() IViewAlgorithmContext

	// IsViewReplaceOrAlgorithmContext differentiates from other interfaces.
	IsViewReplaceOrAlgorithmContext()
}

type ViewReplaceOrAlgorithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewReplaceOrAlgorithmContext() *ViewReplaceOrAlgorithmContext {
	var p = new(ViewReplaceOrAlgorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewReplaceOrAlgorithm
	return p
}

func InitEmptyViewReplaceOrAlgorithmContext(p *ViewReplaceOrAlgorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewReplaceOrAlgorithm
}

func (*ViewReplaceOrAlgorithmContext) IsViewReplaceOrAlgorithmContext() {}

func NewViewReplaceOrAlgorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewReplaceOrAlgorithmContext {
	var p = new(ViewReplaceOrAlgorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewReplaceOrAlgorithm

	return p
}

func (s *ViewReplaceOrAlgorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewReplaceOrAlgorithmContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOR_SYMBOL, 0)
}

func (s *ViewReplaceOrAlgorithmContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *ViewReplaceOrAlgorithmContext) ViewAlgorithm() IViewAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewAlgorithmContext)
}

func (s *ViewReplaceOrAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewReplaceOrAlgorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewReplaceOrAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewReplaceOrAlgorithm(s)
	}
}

func (s *ViewReplaceOrAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewReplaceOrAlgorithm(s)
	}
}

func (s *ViewReplaceOrAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewReplaceOrAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewReplaceOrAlgorithm() (localctx IViewReplaceOrAlgorithmContext) {
	localctx = NewViewReplaceOrAlgorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, MySQLParserRULE_viewReplaceOrAlgorithm)
	var _la int

	p.SetState(2339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2333)
			p.Match(MySQLParserOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2334)
			p.Match(MySQLParserREPLACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserALGORITHM_SYMBOL {
			{
				p.SetState(2335)
				p.ViewAlgorithm()
			}

		}

	case MySQLParserALGORITHM_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2338)
			p.ViewAlgorithm()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewAlgorithmContext is an interface to support dynamic dispatch.
type IViewAlgorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgorithm returns the algorithm token.
	GetAlgorithm() antlr.Token

	// SetAlgorithm sets the algorithm token.
	SetAlgorithm(antlr.Token)

	// Getter signatures
	ALGORITHM_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	UNDEFINED_SYMBOL() antlr.TerminalNode
	MERGE_SYMBOL() antlr.TerminalNode
	TEMPTABLE_SYMBOL() antlr.TerminalNode

	// IsViewAlgorithmContext differentiates from other interfaces.
	IsViewAlgorithmContext()
}

type ViewAlgorithmContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	algorithm antlr.Token
}

func NewEmptyViewAlgorithmContext() *ViewAlgorithmContext {
	var p = new(ViewAlgorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewAlgorithm
	return p
}

func InitEmptyViewAlgorithmContext(p *ViewAlgorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewAlgorithm
}

func (*ViewAlgorithmContext) IsViewAlgorithmContext() {}

func NewViewAlgorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewAlgorithmContext {
	var p = new(ViewAlgorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewAlgorithm

	return p
}

func (s *ViewAlgorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewAlgorithmContext) GetAlgorithm() antlr.Token { return s.algorithm }

func (s *ViewAlgorithmContext) SetAlgorithm(v antlr.Token) { s.algorithm = v }

func (s *ViewAlgorithmContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALGORITHM_SYMBOL, 0)
}

func (s *ViewAlgorithmContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *ViewAlgorithmContext) UNDEFINED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDEFINED_SYMBOL, 0)
}

func (s *ViewAlgorithmContext) MERGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMERGE_SYMBOL, 0)
}

func (s *ViewAlgorithmContext) TEMPTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPTABLE_SYMBOL, 0)
}

func (s *ViewAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewAlgorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewAlgorithm(s)
	}
}

func (s *ViewAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewAlgorithm(s)
	}
}

func (s *ViewAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewAlgorithm() (localctx IViewAlgorithmContext) {
	localctx = NewViewAlgorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, MySQLParserRULE_viewAlgorithm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2341)
		p.Match(MySQLParserALGORITHM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2342)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2343)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*ViewAlgorithmContext).algorithm = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserMERGE_SYMBOL || _la == MySQLParserTEMPTABLE_SYMBOL || _la == MySQLParserUNDEFINED_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*ViewAlgorithmContext).algorithm = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewSuidContext is an interface to support dynamic dispatch.
type IViewSuidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQL_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode

	// IsViewSuidContext differentiates from other interfaces.
	IsViewSuidContext()
}

type ViewSuidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewSuidContext() *ViewSuidContext {
	var p = new(ViewSuidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewSuid
	return p
}

func InitEmptyViewSuidContext(p *ViewSuidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewSuid
}

func (*ViewSuidContext) IsViewSuidContext() {}

func NewViewSuidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewSuidContext {
	var p = new(ViewSuidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewSuid

	return p
}

func (s *ViewSuidContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewSuidContext) SQL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_SYMBOL, 0)
}

func (s *ViewSuidContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECURITY_SYMBOL, 0)
}

func (s *ViewSuidContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINER_SYMBOL, 0)
}

func (s *ViewSuidContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVOKER_SYMBOL, 0)
}

func (s *ViewSuidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewSuidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewSuidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewSuid(s)
	}
}

func (s *ViewSuidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewSuid(s)
	}
}

func (s *ViewSuidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewSuid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewSuid() (localctx IViewSuidContext) {
	localctx = NewViewSuidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, MySQLParserRULE_viewSuid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2345)
		p.Match(MySQLParserSQL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2346)
		p.Match(MySQLParserSECURITY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2347)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDEFINER_SYMBOL || _la == MySQLParserINVOKER_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTriggerContext is an interface to support dynamic dispatch.
type ICreateTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTiming returns the timing token.
	GetTiming() antlr.Token

	// GetEvent returns the event token.
	GetEvent() antlr.Token

	// SetTiming sets the timing token.
	SetTiming(antlr.Token)

	// SetEvent sets the event token.
	SetEvent(antlr.Token)

	// Getter signatures
	TRIGGER_SYMBOL() antlr.TerminalNode
	TriggerName() ITriggerNameContext
	ON_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	FOR_SYMBOL() antlr.TerminalNode
	EACH_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	BEFORE_SYMBOL() antlr.TerminalNode
	AFTER_SYMBOL() antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	DefinerClause() IDefinerClauseContext
	TriggerFollowsPrecedesClause() ITriggerFollowsPrecedesClauseContext

	// IsCreateTriggerContext differentiates from other interfaces.
	IsCreateTriggerContext()
}

type CreateTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	timing antlr.Token
	event  antlr.Token
}

func NewEmptyCreateTriggerContext() *CreateTriggerContext {
	var p = new(CreateTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTrigger
	return p
}

func InitEmptyCreateTriggerContext(p *CreateTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTrigger
}

func (*CreateTriggerContext) IsCreateTriggerContext() {}

func NewCreateTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTriggerContext {
	var p = new(CreateTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTrigger

	return p
}

func (s *CreateTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTriggerContext) GetTiming() antlr.Token { return s.timing }

func (s *CreateTriggerContext) GetEvent() antlr.Token { return s.event }

func (s *CreateTriggerContext) SetTiming(v antlr.Token) { s.timing = v }

func (s *CreateTriggerContext) SetEvent(v antlr.Token) { s.event = v }

func (s *CreateTriggerContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGER_SYMBOL, 0)
}

func (s *CreateTriggerContext) TriggerName() ITriggerNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerNameContext)
}

func (s *CreateTriggerContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *CreateTriggerContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *CreateTriggerContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *CreateTriggerContext) EACH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEACH_SYMBOL, 0)
}

func (s *CreateTriggerContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *CreateTriggerContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CreateTriggerContext) BEFORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEFORE_SYMBOL, 0)
}

func (s *CreateTriggerContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAFTER_SYMBOL, 0)
}

func (s *CreateTriggerContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_SYMBOL, 0)
}

func (s *CreateTriggerContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *CreateTriggerContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELETE_SYMBOL, 0)
}

func (s *CreateTriggerContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *CreateTriggerContext) TriggerFollowsPrecedesClause() ITriggerFollowsPrecedesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerFollowsPrecedesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerFollowsPrecedesClauseContext)
}

func (s *CreateTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTrigger(s)
	}
}

func (s *CreateTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTrigger() (localctx ICreateTriggerContext) {
	localctx = NewCreateTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, MySQLParserRULE_createTrigger)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(2349)
			p.DefinerClause()
		}

	}
	{
		p.SetState(2352)
		p.Match(MySQLParserTRIGGER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2353)
		p.TriggerName()
	}
	{
		p.SetState(2354)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).timing = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserAFTER_SYMBOL || _la == MySQLParserBEFORE_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).timing = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2355)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*CreateTriggerContext).event = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDELETE_SYMBOL || _la == MySQLParserINSERT_SYMBOL || _la == MySQLParserUPDATE_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*CreateTriggerContext).event = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2356)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2357)
		p.TableRef()
	}
	{
		p.SetState(2358)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2359)
		p.Match(MySQLParserEACH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2360)
		p.Match(MySQLParserROW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2362)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 178, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2361)
			p.TriggerFollowsPrecedesClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2364)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerFollowsPrecedesClauseContext is an interface to support dynamic dispatch.
type ITriggerFollowsPrecedesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext
	FOLLOWS_SYMBOL() antlr.TerminalNode
	PRECEDES_SYMBOL() antlr.TerminalNode

	// IsTriggerFollowsPrecedesClauseContext differentiates from other interfaces.
	IsTriggerFollowsPrecedesClauseContext()
}

type TriggerFollowsPrecedesClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	ordering antlr.Token
}

func NewEmptyTriggerFollowsPrecedesClauseContext() *TriggerFollowsPrecedesClauseContext {
	var p = new(TriggerFollowsPrecedesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerFollowsPrecedesClause
	return p
}

func InitEmptyTriggerFollowsPrecedesClauseContext(p *TriggerFollowsPrecedesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerFollowsPrecedesClause
}

func (*TriggerFollowsPrecedesClauseContext) IsTriggerFollowsPrecedesClauseContext() {}

func NewTriggerFollowsPrecedesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerFollowsPrecedesClauseContext {
	var p = new(TriggerFollowsPrecedesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_triggerFollowsPrecedesClause

	return p
}

func (s *TriggerFollowsPrecedesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerFollowsPrecedesClauseContext) GetOrdering() antlr.Token { return s.ordering }

func (s *TriggerFollowsPrecedesClauseContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *TriggerFollowsPrecedesClauseContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *TriggerFollowsPrecedesClauseContext) FOLLOWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWS_SYMBOL, 0)
}

func (s *TriggerFollowsPrecedesClauseContext) PRECEDES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDES_SYMBOL, 0)
}

func (s *TriggerFollowsPrecedesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerFollowsPrecedesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerFollowsPrecedesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTriggerFollowsPrecedesClause(s)
	}
}

func (s *TriggerFollowsPrecedesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTriggerFollowsPrecedesClause(s)
	}
}

func (s *TriggerFollowsPrecedesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTriggerFollowsPrecedesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TriggerFollowsPrecedesClause() (localctx ITriggerFollowsPrecedesClauseContext) {
	localctx = NewTriggerFollowsPrecedesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, MySQLParserRULE_triggerFollowsPrecedesClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2366)

	if !(serverVersion >= 50700) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
		goto errorExit
	}
	{
		p.SetState(2367)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TriggerFollowsPrecedesClauseContext).ordering = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserFOLLOWS_SYMBOL || _la == MySQLParserPRECEDES_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TriggerFollowsPrecedesClauseContext).ordering = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2368)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateEventContext is an interface to support dynamic dispatch.
type ICreateEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENT_SYMBOL() antlr.TerminalNode
	EventName() IEventNameContext
	AllON_SYMBOL() []antlr.TerminalNode
	ON_SYMBOL(i int) antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	Schedule() IScheduleContext
	DO_SYMBOL() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	DefinerClause() IDefinerClauseContext
	IfNotExists() IIfNotExistsContext
	COMPLETION_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	NOT_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode

	// IsCreateEventContext differentiates from other interfaces.
	IsCreateEventContext()
}

type CreateEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateEventContext() *CreateEventContext {
	var p = new(CreateEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createEvent
	return p
}

func InitEmptyCreateEventContext(p *CreateEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createEvent
}

func (*CreateEventContext) IsCreateEventContext() {}

func NewCreateEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateEventContext {
	var p = new(CreateEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createEvent

	return p
}

func (s *CreateEventContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateEventContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *CreateEventContext) EventName() IEventNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventNameContext)
}

func (s *CreateEventContext) AllON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserON_SYMBOL)
}

func (s *CreateEventContext) ON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, i)
}

func (s *CreateEventContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEDULE_SYMBOL, 0)
}

func (s *CreateEventContext) Schedule() IScheduleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScheduleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScheduleContext)
}

func (s *CreateEventContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *CreateEventContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CreateEventContext) DefinerClause() IDefinerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinerClauseContext)
}

func (s *CreateEventContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateEventContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPLETION_SYMBOL, 0)
}

func (s *CreateEventContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRESERVE_SYMBOL, 0)
}

func (s *CreateEventContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *CreateEventContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *CreateEventContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *CreateEventContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *CreateEventContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *CreateEventContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *CreateEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateEvent(s)
	}
}

func (s *CreateEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateEvent(s)
	}
}

func (s *CreateEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateEvent() (localctx ICreateEventContext) {
	localctx = NewCreateEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, MySQLParserRULE_createEvent)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2371)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFINER_SYMBOL {
		{
			p.SetState(2370)
			p.DefinerClause()
		}

	}
	{
		p.SetState(2373)
		p.Match(MySQLParserEVENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2375)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 180, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2374)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2377)
		p.EventName()
	}
	{
		p.SetState(2378)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2379)
		p.Match(MySQLParserSCHEDULE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2380)
		p.Schedule()
	}
	p.SetState(2387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserON_SYMBOL {
		{
			p.SetState(2381)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2382)
			p.Match(MySQLParserCOMPLETION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2384)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL {
			{
				p.SetState(2383)
				p.Match(MySQLParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2386)
			p.Match(MySQLParserPRESERVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2395)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySQLParserENABLE_SYMBOL:
		{
			p.SetState(2389)
			p.Match(MySQLParserENABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserDISABLE_SYMBOL:
		{
			p.SetState(2390)
			p.Match(MySQLParserDISABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2393)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserON_SYMBOL {
			{
				p.SetState(2391)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2392)
				p.Match(MySQLParserSLAVE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserCOMMENT_SYMBOL, MySQLParserDO_SYMBOL:

	default:
	}
	p.SetState(2399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOMMENT_SYMBOL {
		{
			p.SetState(2397)
			p.Match(MySQLParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2398)
			p.TextLiteral()
		}

	}
	{
		p.SetState(2401)
		p.Match(MySQLParserDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2402)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleContext is an interface to support dynamic dispatch.
type ICreateRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	IfNotExists() IIfNotExistsContext

	// IsCreateRoleContext differentiates from other interfaces.
	IsCreateRoleContext()
}

type CreateRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleContext() *CreateRoleContext {
	var p = new(CreateRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createRole
	return p
}

func InitEmptyCreateRoleContext(p *CreateRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createRole
}

func (*CreateRoleContext) IsCreateRoleContext() {}

func NewCreateRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleContext {
	var p = new(CreateRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createRole

	return p
}

func (s *CreateRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *CreateRoleContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateRoleContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateRole(s)
	}
}

func (s *CreateRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateRole(s)
	}
}

func (s *CreateRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateRole() (localctx ICreateRoleContext) {
	localctx = NewCreateRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, MySQLParserRULE_createRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2404)
		p.Match(MySQLParserROLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2406)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 186, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2405)
			p.IfNotExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2408)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSpatialReferenceContext is an interface to support dynamic dispatch.
type ICreateSpatialReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	SPATIAL_SYMBOL() antlr.TerminalNode
	REFERENCE_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	AllSrsAttribute() []ISrsAttributeContext
	SrsAttribute(i int) ISrsAttributeContext
	IfNotExists() IIfNotExistsContext

	// IsCreateSpatialReferenceContext differentiates from other interfaces.
	IsCreateSpatialReferenceContext()
}

type CreateSpatialReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSpatialReferenceContext() *CreateSpatialReferenceContext {
	var p = new(CreateSpatialReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createSpatialReference
	return p
}

func InitEmptyCreateSpatialReferenceContext(p *CreateSpatialReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createSpatialReference
}

func (*CreateSpatialReferenceContext) IsCreateSpatialReferenceContext() {}

func NewCreateSpatialReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSpatialReferenceContext {
	var p = new(CreateSpatialReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createSpatialReference

	return p
}

func (s *CreateSpatialReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSpatialReferenceContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOR_SYMBOL, 0)
}

func (s *CreateSpatialReferenceContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *CreateSpatialReferenceContext) SPATIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSPATIAL_SYMBOL, 0)
}

func (s *CreateSpatialReferenceContext) REFERENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREFERENCE_SYMBOL, 0)
}

func (s *CreateSpatialReferenceContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSYSTEM_SYMBOL, 0)
}

func (s *CreateSpatialReferenceContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *CreateSpatialReferenceContext) AllSrsAttribute() []ISrsAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISrsAttributeContext); ok {
			len++
		}
	}

	tst := make([]ISrsAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISrsAttributeContext); ok {
			tst[i] = t.(ISrsAttributeContext)
			i++
		}
	}

	return tst
}

func (s *CreateSpatialReferenceContext) SrsAttribute(i int) ISrsAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISrsAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISrsAttributeContext)
}

func (s *CreateSpatialReferenceContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateSpatialReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSpatialReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSpatialReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateSpatialReference(s)
	}
}

func (s *CreateSpatialReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateSpatialReference(s)
	}
}

func (s *CreateSpatialReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateSpatialReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateSpatialReference() (localctx ICreateSpatialReferenceContext) {
	localctx = NewCreateSpatialReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, MySQLParserRULE_createSpatialReference)
	var _la int

	p.SetState(2435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2410)
			p.Match(MySQLParserOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2411)
			p.Match(MySQLParserREPLACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2412)
			p.Match(MySQLParserSPATIAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2413)
			p.Match(MySQLParserREFERENCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2414)
			p.Match(MySQLParserSYSTEM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2415)
			p.Real_ulonglong_number()
		}
		p.SetState(2419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserNAME_SYMBOL || ((int64((_la-715)) & ^0x3f) == 0 && ((int64(1)<<(_la-715))&7) != 0) {
			{
				p.SetState(2416)
				p.SrsAttribute()
			}

			p.SetState(2421)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MySQLParserSPATIAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2422)
			p.Match(MySQLParserSPATIAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2423)
			p.Match(MySQLParserREFERENCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2424)
			p.Match(MySQLParserSYSTEM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2426)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2425)
				p.IfNotExists()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2428)
			p.Real_ulonglong_number()
		}
		p.SetState(2432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserNAME_SYMBOL || ((int64((_la-715)) & ^0x3f) == 0 && ((int64(1)<<(_la-715))&7) != 0) {
			{
				p.SetState(2429)
				p.SrsAttribute()
			}

			p.SetState(2434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISrsAttributeContext is an interface to support dynamic dispatch.
type ISrsAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NAME_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	DEFINITION_SYMBOL() antlr.TerminalNode
	ORGANIZATION_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	DESCRIPTION_SYMBOL() antlr.TerminalNode

	// IsSrsAttributeContext differentiates from other interfaces.
	IsSrsAttributeContext()
}

type SrsAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySrsAttributeContext() *SrsAttributeContext {
	var p = new(SrsAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_srsAttribute
	return p
}

func InitEmptySrsAttributeContext(p *SrsAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_srsAttribute
}

func (*SrsAttributeContext) IsSrsAttributeContext() {}

func NewSrsAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SrsAttributeContext {
	var p = new(SrsAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_srsAttribute

	return p
}

func (s *SrsAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *SrsAttributeContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAME_SYMBOL, 0)
}

func (s *SrsAttributeContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEXT_SYMBOL, 0)
}

func (s *SrsAttributeContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *SrsAttributeContext) DEFINITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINITION_SYMBOL, 0)
}

func (s *SrsAttributeContext) ORGANIZATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORGANIZATION_SYMBOL, 0)
}

func (s *SrsAttributeContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *SrsAttributeContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *SrsAttributeContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *SrsAttributeContext) DESCRIPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESCRIPTION_SYMBOL, 0)
}

func (s *SrsAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SrsAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SrsAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSrsAttribute(s)
	}
}

func (s *SrsAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSrsAttribute(s)
	}
}

func (s *SrsAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSrsAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SrsAttribute() (localctx ISrsAttributeContext) {
	localctx = NewSrsAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, MySQLParserRULE_srsAttribute)
	p.SetState(2452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserNAME_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2437)
			p.Match(MySQLParserNAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2438)
			p.Match(MySQLParserTEXT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2439)
			p.TextStringNoLinebreak()
		}

	case MySQLParserDEFINITION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2440)
			p.Match(MySQLParserDEFINITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2441)
			p.Match(MySQLParserTEXT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2442)
			p.TextStringNoLinebreak()
		}

	case MySQLParserORGANIZATION_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2443)
			p.Match(MySQLParserORGANIZATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2444)
			p.TextStringNoLinebreak()
		}
		{
			p.SetState(2445)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2446)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2447)
			p.Real_ulonglong_number()
		}

	case MySQLParserDESCRIPTION_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2449)
			p.Match(MySQLParserDESCRIPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2450)
			p.Match(MySQLParserTEXT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2451)
			p.TextStringNoLinebreak()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatementContext is an interface to support dynamic dispatch.
type IDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP_SYMBOL() antlr.TerminalNode
	DropDatabase() IDropDatabaseContext
	DropEvent() IDropEventContext
	DropFunction() IDropFunctionContext
	DropProcedure() IDropProcedureContext
	DropIndex() IDropIndexContext
	DropLogfileGroup() IDropLogfileGroupContext
	DropServer() IDropServerContext
	DropTable() IDropTableContext
	DropTableSpace() IDropTableSpaceContext
	DropTrigger() IDropTriggerContext
	DropView() IDropViewContext
	DropRole() IDropRoleContext
	DropSpatialReference() IDropSpatialReferenceContext
	DropUndoTablespace() IDropUndoTablespaceContext

	// IsDropStatementContext differentiates from other interfaces.
	IsDropStatementContext()
}

type DropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatementContext() *DropStatementContext {
	var p = new(DropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropStatement
	return p
}

func InitEmptyDropStatementContext(p *DropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropStatement
}

func (*DropStatementContext) IsDropStatementContext() {}

func NewDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatementContext {
	var p = new(DropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropStatement

	return p
}

func (s *DropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatementContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *DropStatementContext) DropDatabase() IDropDatabaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDatabaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDatabaseContext)
}

func (s *DropStatementContext) DropEvent() IDropEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropEventContext)
}

func (s *DropStatementContext) DropFunction() IDropFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionContext)
}

func (s *DropStatementContext) DropProcedure() IDropProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropProcedureContext)
}

func (s *DropStatementContext) DropIndex() IDropIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexContext)
}

func (s *DropStatementContext) DropLogfileGroup() IDropLogfileGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupContext)
}

func (s *DropStatementContext) DropServer() IDropServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropServerContext)
}

func (s *DropStatementContext) DropTable() IDropTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableContext)
}

func (s *DropStatementContext) DropTableSpace() IDropTableSpaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableSpaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableSpaceContext)
}

func (s *DropStatementContext) DropTrigger() IDropTriggerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTriggerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTriggerContext)
}

func (s *DropStatementContext) DropView() IDropViewContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewContext)
}

func (s *DropStatementContext) DropRole() IDropRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleContext)
}

func (s *DropStatementContext) DropSpatialReference() IDropSpatialReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSpatialReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSpatialReferenceContext)
}

func (s *DropStatementContext) DropUndoTablespace() IDropUndoTablespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUndoTablespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUndoTablespaceContext)
}

func (s *DropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropStatement(s)
	}
}

func (s *DropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropStatement(s)
	}
}

func (s *DropStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropStatement() (localctx IDropStatementContext) {
	localctx = NewDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, MySQLParserRULE_dropStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2454)
		p.Match(MySQLParserDROP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2455)
			p.DropDatabase()
		}

	case 2:
		{
			p.SetState(2456)
			p.DropEvent()
		}

	case 3:
		{
			p.SetState(2457)
			p.DropFunction()
		}

	case 4:
		{
			p.SetState(2458)
			p.DropProcedure()
		}

	case 5:
		{
			p.SetState(2459)
			p.DropIndex()
		}

	case 6:
		{
			p.SetState(2460)
			p.DropLogfileGroup()
		}

	case 7:
		{
			p.SetState(2461)
			p.DropServer()
		}

	case 8:
		{
			p.SetState(2462)
			p.DropTable()
		}

	case 9:
		{
			p.SetState(2463)
			p.DropTableSpace()
		}

	case 10:
		{
			p.SetState(2464)
			p.DropTrigger()
		}

	case 11:
		{
			p.SetState(2465)
			p.DropView()
		}

	case 12:
		p.SetState(2466)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(2467)
			p.DropRole()
		}

	case 13:
		p.SetState(2468)

		if !(serverVersion >= 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
			goto errorExit
		}
		{
			p.SetState(2469)
			p.DropSpatialReference()
		}

	case 14:
		p.SetState(2470)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(2471)
			p.DropUndoTablespace()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDatabaseContext is an interface to support dynamic dispatch.
type IDropDatabaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATABASE_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	IfExists() IIfExistsContext

	// IsDropDatabaseContext differentiates from other interfaces.
	IsDropDatabaseContext()
}

type DropDatabaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDatabaseContext() *DropDatabaseContext {
	var p = new(DropDatabaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropDatabase
	return p
}

func InitEmptyDropDatabaseContext(p *DropDatabaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropDatabase
}

func (*DropDatabaseContext) IsDropDatabaseContext() {}

func NewDropDatabaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDatabaseContext {
	var p = new(DropDatabaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropDatabase

	return p
}

func (s *DropDatabaseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDatabaseContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *DropDatabaseContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *DropDatabaseContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropDatabaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDatabaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDatabaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropDatabase(s)
	}
}

func (s *DropDatabaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropDatabase(s)
	}
}

func (s *DropDatabaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropDatabase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropDatabase() (localctx IDropDatabaseContext) {
	localctx = NewDropDatabaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, MySQLParserRULE_dropDatabase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2474)
		p.Match(MySQLParserDATABASE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2476)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2475)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2478)
		p.SchemaRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropEventContext is an interface to support dynamic dispatch.
type IDropEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENT_SYMBOL() antlr.TerminalNode
	EventRef() IEventRefContext
	IfExists() IIfExistsContext

	// IsDropEventContext differentiates from other interfaces.
	IsDropEventContext()
}

type DropEventContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropEventContext() *DropEventContext {
	var p = new(DropEventContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropEvent
	return p
}

func InitEmptyDropEventContext(p *DropEventContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropEvent
}

func (*DropEventContext) IsDropEventContext() {}

func NewDropEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropEventContext {
	var p = new(DropEventContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropEvent

	return p
}

func (s *DropEventContext) GetParser() antlr.Parser { return s.parser }

func (s *DropEventContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *DropEventContext) EventRef() IEventRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventRefContext)
}

func (s *DropEventContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropEventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropEventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropEventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropEvent(s)
	}
}

func (s *DropEventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropEvent(s)
	}
}

func (s *DropEventContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropEvent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropEvent() (localctx IDropEventContext) {
	localctx = NewDropEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, MySQLParserRULE_dropEvent)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.Match(MySQLParserEVENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2482)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2481)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2484)
		p.EventRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionContext is an interface to support dynamic dispatch.
type IDropFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FUNCTION_SYMBOL() antlr.TerminalNode
	FunctionRef() IFunctionRefContext
	IfExists() IIfExistsContext

	// IsDropFunctionContext differentiates from other interfaces.
	IsDropFunctionContext()
}

type DropFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionContext() *DropFunctionContext {
	var p = new(DropFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropFunction
	return p
}

func InitEmptyDropFunctionContext(p *DropFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropFunction
}

func (*DropFunctionContext) IsDropFunctionContext() {}

func NewDropFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionContext {
	var p = new(DropFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropFunction

	return p
}

func (s *DropFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *DropFunctionContext) FunctionRef() IFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionRefContext)
}

func (s *DropFunctionContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropFunction(s)
	}
}

func (s *DropFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropFunction(s)
	}
}

func (s *DropFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropFunction() (localctx IDropFunctionContext) {
	localctx = NewDropFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, MySQLParserRULE_dropFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2486)
		p.Match(MySQLParserFUNCTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 195, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2487)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2490)
		p.FunctionRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropProcedureContext is an interface to support dynamic dispatch.
type IDropProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_SYMBOL() antlr.TerminalNode
	ProcedureRef() IProcedureRefContext
	IfExists() IIfExistsContext

	// IsDropProcedureContext differentiates from other interfaces.
	IsDropProcedureContext()
}

type DropProcedureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropProcedureContext() *DropProcedureContext {
	var p = new(DropProcedureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropProcedure
	return p
}

func InitEmptyDropProcedureContext(p *DropProcedureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropProcedure
}

func (*DropProcedureContext) IsDropProcedureContext() {}

func NewDropProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropProcedureContext {
	var p = new(DropProcedureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropProcedure

	return p
}

func (s *DropProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *DropProcedureContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *DropProcedureContext) ProcedureRef() IProcedureRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureRefContext)
}

func (s *DropProcedureContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropProcedure(s)
	}
}

func (s *DropProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropProcedure(s)
	}
}

func (s *DropProcedureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropProcedure(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropProcedure() (localctx IDropProcedureContext) {
	localctx = NewDropProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, MySQLParserRULE_dropProcedure)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2492)
		p.Match(MySQLParserPROCEDURE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2493)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2496)
		p.ProcedureRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexContext is an interface to support dynamic dispatch.
type IDropIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	IndexRef() IIndexRefContext
	ON_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	INDEX_SYMBOL() antlr.TerminalNode
	OnlineOption() IOnlineOptionContext
	IndexLockAndAlgorithm() IIndexLockAndAlgorithmContext

	// IsDropIndexContext differentiates from other interfaces.
	IsDropIndexContext()
}

type DropIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyDropIndexContext() *DropIndexContext {
	var p = new(DropIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropIndex
	return p
}

func InitEmptyDropIndexContext(p *DropIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropIndex
}

func (*DropIndexContext) IsDropIndexContext() {}

func NewDropIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexContext {
	var p = new(DropIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropIndex

	return p
}

func (s *DropIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexContext) GetType_() antlr.Token { return s.type_ }

func (s *DropIndexContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *DropIndexContext) IndexRef() IIndexRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexRefContext)
}

func (s *DropIndexContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *DropIndexContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *DropIndexContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *DropIndexContext) OnlineOption() IOnlineOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnlineOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnlineOptionContext)
}

func (s *DropIndexContext) IndexLockAndAlgorithm() IIndexLockAndAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexLockAndAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexLockAndAlgorithmContext)
}

func (s *DropIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropIndex(s)
	}
}

func (s *DropIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropIndex(s)
	}
}

func (s *DropIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropIndex() (localctx IDropIndexContext) {
	localctx = NewDropIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, MySQLParserRULE_dropIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2499)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOFFLINE_SYMBOL || _la == MySQLParserONLINE_SYMBOL {
		{
			p.SetState(2498)
			p.OnlineOption()
		}

	}
	{
		p.SetState(2501)

		var _m = p.Match(MySQLParserINDEX_SYMBOL)

		localctx.(*DropIndexContext).type_ = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2502)
		p.IndexRef()
	}
	{
		p.SetState(2503)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2504)
		p.TableRef()
	}
	p.SetState(2506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserALGORITHM_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
		{
			p.SetState(2505)
			p.IndexLockAndAlgorithm()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropLogfileGroupContext is an interface to support dynamic dispatch.
type IDropLogfileGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGFILE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	LogfileGroupRef() ILogfileGroupRefContext
	AllDropLogfileGroupOption() []IDropLogfileGroupOptionContext
	DropLogfileGroupOption(i int) IDropLogfileGroupOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsDropLogfileGroupContext differentiates from other interfaces.
	IsDropLogfileGroupContext()
}

type DropLogfileGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupContext() *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropLogfileGroup
	return p
}

func InitEmptyDropLogfileGroupContext(p *DropLogfileGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropLogfileGroup
}

func (*DropLogfileGroupContext) IsDropLogfileGroupContext() {}

func NewDropLogfileGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupContext {
	var p = new(DropLogfileGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropLogfileGroup

	return p
}

func (s *DropLogfileGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *DropLogfileGroupContext) LogfileGroupRef() ILogfileGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogfileGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogfileGroupRefContext)
}

func (s *DropLogfileGroupContext) AllDropLogfileGroupOption() []IDropLogfileGroupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			len++
		}
	}

	tst := make([]IDropLogfileGroupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			tst[i] = t.(IDropLogfileGroupOptionContext)
			i++
		}
	}

	return tst
}

func (s *DropLogfileGroupContext) DropLogfileGroupOption(i int) IDropLogfileGroupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupOptionContext)
}

func (s *DropLogfileGroupContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *DropLogfileGroupContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *DropLogfileGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLogfileGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropLogfileGroup(s)
	}
}

func (s *DropLogfileGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropLogfileGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropLogfileGroup() (localctx IDropLogfileGroupContext) {
	localctx = NewDropLogfileGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, MySQLParserRULE_dropLogfileGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2508)
		p.Match(MySQLParserLOGFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2509)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2510)
		p.LogfileGroupRef()
	}
	p.SetState(2521)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL {
		{
			p.SetState(2511)
			p.DropLogfileGroupOption()
		}
		p.SetState(2518)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
			p.SetState(2513)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserCOMMA_SYMBOL {
				{
					p.SetState(2512)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2515)
				p.DropLogfileGroupOption()
			}

			p.SetState(2520)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropLogfileGroupOptionContext is an interface to support dynamic dispatch.
type IDropLogfileGroupOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TsOptionWait() ITsOptionWaitContext
	TsOptionEngine() ITsOptionEngineContext

	// IsDropLogfileGroupOptionContext differentiates from other interfaces.
	IsDropLogfileGroupOptionContext()
}

type DropLogfileGroupOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropLogfileGroupOptionContext() *DropLogfileGroupOptionContext {
	var p = new(DropLogfileGroupOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropLogfileGroupOption
	return p
}

func InitEmptyDropLogfileGroupOptionContext(p *DropLogfileGroupOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropLogfileGroupOption
}

func (*DropLogfileGroupOptionContext) IsDropLogfileGroupOptionContext() {}

func NewDropLogfileGroupOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropLogfileGroupOptionContext {
	var p = new(DropLogfileGroupOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropLogfileGroupOption

	return p
}

func (s *DropLogfileGroupOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DropLogfileGroupOptionContext) TsOptionWait() ITsOptionWaitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionWaitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionWaitContext)
}

func (s *DropLogfileGroupOptionContext) TsOptionEngine() ITsOptionEngineContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITsOptionEngineContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITsOptionEngineContext)
}

func (s *DropLogfileGroupOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropLogfileGroupOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropLogfileGroupOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropLogfileGroupOption(s)
	}
}

func (s *DropLogfileGroupOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropLogfileGroupOption(s)
	}
}

func (s *DropLogfileGroupOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropLogfileGroupOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropLogfileGroupOption() (localctx IDropLogfileGroupOptionContext) {
	localctx = NewDropLogfileGroupOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, MySQLParserRULE_dropLogfileGroupOption)
	p.SetState(2525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserNO_WAIT_SYMBOL, MySQLParserWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2523)
			p.TsOptionWait()
		}

	case MySQLParserENGINE_SYMBOL, MySQLParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2524)
			p.TsOptionEngine()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropServerContext is an interface to support dynamic dispatch.
type IDropServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SERVER_SYMBOL() antlr.TerminalNode
	ServerRef() IServerRefContext
	IfExists() IIfExistsContext

	// IsDropServerContext differentiates from other interfaces.
	IsDropServerContext()
}

type DropServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropServerContext() *DropServerContext {
	var p = new(DropServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropServer
	return p
}

func InitEmptyDropServerContext(p *DropServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropServer
}

func (*DropServerContext) IsDropServerContext() {}

func NewDropServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropServerContext {
	var p = new(DropServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropServer

	return p
}

func (s *DropServerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropServerContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERVER_SYMBOL, 0)
}

func (s *DropServerContext) ServerRef() IServerRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerRefContext)
}

func (s *DropServerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropServer(s)
	}
}

func (s *DropServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropServer(s)
	}
}

func (s *DropServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropServer() (localctx IDropServerContext) {
	localctx = NewDropServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, MySQLParserRULE_dropServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2527)
		p.Match(MySQLParserSERVER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2529)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2528)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2531)
		p.ServerRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableContext is an interface to support dynamic dispatch.
type IDropTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TableRefList() ITableRefListContext
	TABLE_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	IfExists() IIfExistsContext
	RESTRICT_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode

	// IsDropTableContext differentiates from other interfaces.
	IsDropTableContext()
}

type DropTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyDropTableContext() *DropTableContext {
	var p = new(DropTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTable
	return p
}

func InitEmptyDropTableContext(p *DropTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTable
}

func (*DropTableContext) IsDropTableContext() {}

func NewDropTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableContext {
	var p = new(DropTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropTable

	return p
}

func (s *DropTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableContext) GetType_() antlr.Token { return s.type_ }

func (s *DropTableContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *DropTableContext) TableRefList() ITableRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefListContext)
}

func (s *DropTableContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *DropTableContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *DropTableContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPORARY_SYMBOL, 0)
}

func (s *DropTableContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTableContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTRICT_SYMBOL, 0)
}

func (s *DropTableContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADE_SYMBOL, 0)
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropTable(s)
	}
}

func (s *DropTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropTable() (localctx IDropTableContext) {
	localctx = NewDropTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, MySQLParserRULE_dropTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2534)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserTEMPORARY_SYMBOL {
		{
			p.SetState(2533)
			p.Match(MySQLParserTEMPORARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2536)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*DropTableContext).type_ = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserTABLES_SYMBOL || _la == MySQLParserTABLE_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*DropTableContext).type_ = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2538)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2537)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2540)
		p.TableRefList()
	}
	p.SetState(2542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL {
		{
			p.SetState(2541)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableSpaceContext is an interface to support dynamic dispatch.
type IDropTableSpaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceRef() ITablespaceRefContext
	AllDropLogfileGroupOption() []IDropLogfileGroupOptionContext
	DropLogfileGroupOption(i int) IDropLogfileGroupOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsDropTableSpaceContext differentiates from other interfaces.
	IsDropTableSpaceContext()
}

type DropTableSpaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableSpaceContext() *DropTableSpaceContext {
	var p = new(DropTableSpaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTableSpace
	return p
}

func InitEmptyDropTableSpaceContext(p *DropTableSpaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTableSpace
}

func (*DropTableSpaceContext) IsDropTableSpaceContext() {}

func NewDropTableSpaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableSpaceContext {
	var p = new(DropTableSpaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropTableSpace

	return p
}

func (s *DropTableSpaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableSpaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *DropTableSpaceContext) TablespaceRef() ITablespaceRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceRefContext)
}

func (s *DropTableSpaceContext) AllDropLogfileGroupOption() []IDropLogfileGroupOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			len++
		}
	}

	tst := make([]IDropLogfileGroupOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			tst[i] = t.(IDropLogfileGroupOptionContext)
			i++
		}
	}

	return tst
}

func (s *DropTableSpaceContext) DropLogfileGroupOption(i int) IDropLogfileGroupOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropLogfileGroupOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropLogfileGroupOptionContext)
}

func (s *DropTableSpaceContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *DropTableSpaceContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *DropTableSpaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableSpaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableSpaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropTableSpace(s)
	}
}

func (s *DropTableSpaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropTableSpace(s)
	}
}

func (s *DropTableSpaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropTableSpace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropTableSpace() (localctx IDropTableSpaceContext) {
	localctx = NewDropTableSpaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, MySQLParserRULE_dropTableSpace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2544)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2545)
		p.TablespaceRef()
	}
	p.SetState(2556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL {
		{
			p.SetState(2546)
			p.DropLogfileGroupOption()
		}
		p.SetState(2553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserNO_WAIT_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserWAIT_SYMBOL || _la == MySQLParserCOMMA_SYMBOL {
			p.SetState(2548)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserCOMMA_SYMBOL {
				{
					p.SetState(2547)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(2550)
				p.DropLogfileGroupOption()
			}

			p.SetState(2555)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTriggerContext is an interface to support dynamic dispatch.
type IDropTriggerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIGGER_SYMBOL() antlr.TerminalNode
	TriggerRef() ITriggerRefContext
	IfExists() IIfExistsContext

	// IsDropTriggerContext differentiates from other interfaces.
	IsDropTriggerContext()
}

type DropTriggerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTriggerContext() *DropTriggerContext {
	var p = new(DropTriggerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTrigger
	return p
}

func InitEmptyDropTriggerContext(p *DropTriggerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropTrigger
}

func (*DropTriggerContext) IsDropTriggerContext() {}

func NewDropTriggerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTriggerContext {
	var p = new(DropTriggerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropTrigger

	return p
}

func (s *DropTriggerContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTriggerContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGER_SYMBOL, 0)
}

func (s *DropTriggerContext) TriggerRef() ITriggerRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerRefContext)
}

func (s *DropTriggerContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropTriggerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTriggerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTriggerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropTrigger(s)
	}
}

func (s *DropTriggerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropTrigger(s)
	}
}

func (s *DropTriggerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropTrigger(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropTrigger() (localctx IDropTriggerContext) {
	localctx = NewDropTriggerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, MySQLParserRULE_dropTrigger)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2558)
		p.Match(MySQLParserTRIGGER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2560)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2559)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2562)
		p.TriggerRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewContext is an interface to support dynamic dispatch.
type IDropViewContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VIEW_SYMBOL() antlr.TerminalNode
	ViewRefList() IViewRefListContext
	IfExists() IIfExistsContext
	RESTRICT_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode

	// IsDropViewContext differentiates from other interfaces.
	IsDropViewContext()
}

type DropViewContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewContext() *DropViewContext {
	var p = new(DropViewContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropView
	return p
}

func InitEmptyDropViewContext(p *DropViewContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropView
}

func (*DropViewContext) IsDropViewContext() {}

func NewDropViewContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewContext {
	var p = new(DropViewContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropView

	return p
}

func (s *DropViewContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *DropViewContext) ViewRefList() IViewRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefListContext)
}

func (s *DropViewContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropViewContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTRICT_SYMBOL, 0)
}

func (s *DropViewContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADE_SYMBOL, 0)
}

func (s *DropViewContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropView(s)
	}
}

func (s *DropViewContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropView(s)
	}
}

func (s *DropViewContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropView(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropView() (localctx IDropViewContext) {
	localctx = NewDropViewContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, MySQLParserRULE_dropView)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2564)
		p.Match(MySQLParserVIEW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 211, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2565)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2568)
		p.ViewRefList()
	}
	p.SetState(2570)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL {
		{
			p.SetState(2569)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleContext is an interface to support dynamic dispatch.
type IDropRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	IfExists() IIfExistsContext

	// IsDropRoleContext differentiates from other interfaces.
	IsDropRoleContext()
}

type DropRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleContext() *DropRoleContext {
	var p = new(DropRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropRole
	return p
}

func InitEmptyDropRoleContext(p *DropRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropRole
}

func (*DropRoleContext) IsDropRoleContext() {}

func NewDropRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleContext {
	var p = new(DropRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropRole

	return p
}

func (s *DropRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *DropRoleContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DropRoleContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropRole(s)
	}
}

func (s *DropRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropRole(s)
	}
}

func (s *DropRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropRole() (localctx IDropRoleContext) {
	localctx = NewDropRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, MySQLParserRULE_dropRole)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2572)
		p.Match(MySQLParserROLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 213, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2573)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2576)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSpatialReferenceContext is an interface to support dynamic dispatch.
type IDropSpatialReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SPATIAL_SYMBOL() antlr.TerminalNode
	REFERENCE_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	IfExists() IIfExistsContext

	// IsDropSpatialReferenceContext differentiates from other interfaces.
	IsDropSpatialReferenceContext()
}

type DropSpatialReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSpatialReferenceContext() *DropSpatialReferenceContext {
	var p = new(DropSpatialReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropSpatialReference
	return p
}

func InitEmptyDropSpatialReferenceContext(p *DropSpatialReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropSpatialReference
}

func (*DropSpatialReferenceContext) IsDropSpatialReferenceContext() {}

func NewDropSpatialReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSpatialReferenceContext {
	var p = new(DropSpatialReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropSpatialReference

	return p
}

func (s *DropSpatialReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSpatialReferenceContext) SPATIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSPATIAL_SYMBOL, 0)
}

func (s *DropSpatialReferenceContext) REFERENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREFERENCE_SYMBOL, 0)
}

func (s *DropSpatialReferenceContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSYSTEM_SYMBOL, 0)
}

func (s *DropSpatialReferenceContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *DropSpatialReferenceContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropSpatialReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSpatialReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSpatialReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropSpatialReference(s)
	}
}

func (s *DropSpatialReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropSpatialReference(s)
	}
}

func (s *DropSpatialReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropSpatialReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropSpatialReference() (localctx IDropSpatialReferenceContext) {
	localctx = NewDropSpatialReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, MySQLParserRULE_dropSpatialReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2578)
		p.Match(MySQLParserSPATIAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2579)
		p.Match(MySQLParserREFERENCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2580)
		p.Match(MySQLParserSYSTEM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2582)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2581)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2584)
		p.Real_ulonglong_number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUndoTablespaceContext is an interface to support dynamic dispatch.
type IDropUndoTablespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNDO_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TablespaceRef() ITablespaceRefContext
	UndoTableSpaceOptions() IUndoTableSpaceOptionsContext

	// IsDropUndoTablespaceContext differentiates from other interfaces.
	IsDropUndoTablespaceContext()
}

type DropUndoTablespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUndoTablespaceContext() *DropUndoTablespaceContext {
	var p = new(DropUndoTablespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropUndoTablespace
	return p
}

func InitEmptyDropUndoTablespaceContext(p *DropUndoTablespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropUndoTablespace
}

func (*DropUndoTablespaceContext) IsDropUndoTablespaceContext() {}

func NewDropUndoTablespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUndoTablespaceContext {
	var p = new(DropUndoTablespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropUndoTablespace

	return p
}

func (s *DropUndoTablespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUndoTablespaceContext) UNDO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_SYMBOL, 0)
}

func (s *DropUndoTablespaceContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *DropUndoTablespaceContext) TablespaceRef() ITablespaceRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablespaceRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablespaceRefContext)
}

func (s *DropUndoTablespaceContext) UndoTableSpaceOptions() IUndoTableSpaceOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUndoTableSpaceOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUndoTableSpaceOptionsContext)
}

func (s *DropUndoTablespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUndoTablespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUndoTablespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropUndoTablespace(s)
	}
}

func (s *DropUndoTablespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropUndoTablespace(s)
	}
}

func (s *DropUndoTablespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropUndoTablespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropUndoTablespace() (localctx IDropUndoTablespaceContext) {
	localctx = NewDropUndoTablespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, MySQLParserRULE_dropUndoTablespace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2586)
		p.Match(MySQLParserUNDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2587)
		p.Match(MySQLParserTABLESPACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2588)
		p.TablespaceRef()
	}
	p.SetState(2590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserSTORAGE_SYMBOL {
		{
			p.SetState(2589)
			p.UndoTableSpaceOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameTableStatementContext is an interface to support dynamic dispatch.
type IRenameTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME_SYMBOL() antlr.TerminalNode
	AllRenamePair() []IRenamePairContext
	RenamePair(i int) IRenamePairContext
	TABLE_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRenameTableStatementContext differentiates from other interfaces.
	IsRenameTableStatementContext()
}

type RenameTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameTableStatementContext() *RenameTableStatementContext {
	var p = new(RenameTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renameTableStatement
	return p
}

func InitEmptyRenameTableStatementContext(p *RenameTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renameTableStatement
}

func (*RenameTableStatementContext) IsRenameTableStatementContext() {}

func NewRenameTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameTableStatementContext {
	var p = new(RenameTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_renameTableStatement

	return p
}

func (s *RenameTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameTableStatementContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRENAME_SYMBOL, 0)
}

func (s *RenameTableStatementContext) AllRenamePair() []IRenamePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenamePairContext); ok {
			len++
		}
	}

	tst := make([]IRenamePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenamePairContext); ok {
			tst[i] = t.(IRenamePairContext)
			i++
		}
	}

	return tst
}

func (s *RenameTableStatementContext) RenamePair(i int) IRenamePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenamePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenamePairContext)
}

func (s *RenameTableStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *RenameTableStatementContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *RenameTableStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *RenameTableStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *RenameTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRenameTableStatement(s)
	}
}

func (s *RenameTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRenameTableStatement(s)
	}
}

func (s *RenameTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRenameTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RenameTableStatement() (localctx IRenameTableStatementContext) {
	localctx = NewRenameTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, MySQLParserRULE_renameTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2592)
		p.Match(MySQLParserRENAME_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2593)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserTABLES_SYMBOL || _la == MySQLParserTABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2594)
		p.RenamePair()
	}
	p.SetState(2599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(2595)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2596)
			p.RenamePair()
		}

		p.SetState(2601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenamePairContext is an interface to support dynamic dispatch.
type IRenamePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	TO_SYMBOL() antlr.TerminalNode
	TableName() ITableNameContext

	// IsRenamePairContext differentiates from other interfaces.
	IsRenamePairContext()
}

type RenamePairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenamePairContext() *RenamePairContext {
	var p = new(RenamePairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renamePair
	return p
}

func InitEmptyRenamePairContext(p *RenamePairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renamePair
}

func (*RenamePairContext) IsRenamePairContext() {}

func NewRenamePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenamePairContext {
	var p = new(RenamePairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_renamePair

	return p
}

func (s *RenamePairContext) GetParser() antlr.Parser { return s.parser }

func (s *RenamePairContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *RenamePairContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *RenamePairContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *RenamePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenamePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenamePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRenamePair(s)
	}
}

func (s *RenamePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRenamePair(s)
	}
}

func (s *RenamePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRenamePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RenamePair() (localctx IRenamePairContext) {
	localctx = NewRenamePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, MySQLParserRULE_renamePair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2602)
		p.TableRef()
	}
	{
		p.SetState(2603)
		p.Match(MySQLParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2604)
		p.TableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	TABLE_SYMBOL() antlr.TerminalNode

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUNCATE_SYMBOL, 0)
}

func (s *TruncateTableStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *TruncateTableStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTruncateTableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, MySQLParserRULE_truncateTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2606)
		p.Match(MySQLParserTRUNCATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2607)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2610)
		p.TableRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IMPORT_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	TextStringLiteralList() ITextStringLiteralListContext

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *ImportStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *ImportStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *ImportStatementContext) TextStringLiteralList() ITextStringLiteralListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralListContext)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, MySQLParserRULE_importStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2612)
		p.Match(MySQLParserIMPORT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2613)
		p.Match(MySQLParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2614)
		p.Match(MySQLParserFROM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2615)
		p.TextStringLiteralList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CALL_SYMBOL() antlr.TerminalNode
	ProcedureRef() IProcedureRefContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_callStatement
	return p
}

func InitEmptyCallStatementContext(p *CallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_callStatement
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCALL_SYMBOL, 0)
}

func (s *CallStatementContext) ProcedureRef() IProcedureRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureRefContext)
}

func (s *CallStatementContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CallStatementContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CallStatementContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CallStatement() (localctx ICallStatementContext) {
	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, MySQLParserRULE_callStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2617)
		p.Match(MySQLParserCALL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2618)
		p.ProcedureRef()
	}
	p.SetState(2624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(2619)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2621)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 218, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2620)
				p.ExprList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2623)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	TableAliasRefList() ITableAliasRefListContext
	TableReferenceList() ITableReferenceListContext
	WithClause() IWithClauseContext
	AllDeleteStatementOption() []IDeleteStatementOptionContext
	DeleteStatementOption(i int) IDeleteStatementOptionContext
	USING_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	WhereClause() IWhereClauseContext
	TableAlias() ITableAliasContext
	PartitionDelete() IPartitionDeleteContext
	OrderClause() IOrderClauseContext
	SimpleLimitClause() ISimpleLimitClauseContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELETE_SYMBOL, 0)
}

func (s *DeleteStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *DeleteStatementContext) TableAliasRefList() ITableAliasRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasRefListContext)
}

func (s *DeleteStatementContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *DeleteStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteStatementContext) AllDeleteStatementOption() []IDeleteStatementOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteStatementOptionContext); ok {
			len++
		}
	}

	tst := make([]IDeleteStatementOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteStatementOptionContext); ok {
			tst[i] = t.(IDeleteStatementOptionContext)
			i++
		}
	}

	return tst
}

func (s *DeleteStatementContext) DeleteStatementOption(i int) IDeleteStatementOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementOptionContext)
}

func (s *DeleteStatementContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *DeleteStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *DeleteStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *DeleteStatementContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DeleteStatementContext) PartitionDelete() IPartitionDeleteContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDeleteContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDeleteContext)
}

func (s *DeleteStatementContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *DeleteStatementContext) SimpleLimitClause() ISimpleLimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLimitClauseContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, MySQLParserRULE_deleteStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2628)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 220, p.GetParserRuleContext()) == 1 {
		p.SetState(2626)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(2627)
			p.WithClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2630)
		p.Match(MySQLParserDELETE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2631)
				p.DeleteStatementOption()
			}

		}
		p.SetState(2636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 221, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 230, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2637)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2661)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 228, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2638)
				p.TableAliasRefList()
			}
			{
				p.SetState(2639)
				p.Match(MySQLParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2640)
				p.TableReferenceList()
			}
			p.SetState(2642)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserWHERE_SYMBOL {
				{
					p.SetState(2641)
					p.WhereClause()
				}

			}

		case 2:
			{
				p.SetState(2644)
				p.TableRef()
			}
			p.SetState(2647)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 223, p.GetParserRuleContext()) == 1 {
				p.SetState(2645)

				if !(serverVersion >= 80017) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
					goto errorExit
				}
				{
					p.SetState(2646)
					p.TableAlias()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(2650)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 224, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2649)
					p.PartitionDelete()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(2653)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserWHERE_SYMBOL {
				{
					p.SetState(2652)
					p.WhereClause()
				}

			}
			p.SetState(2656)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserORDER_SYMBOL {
				{
					p.SetState(2655)
					p.OrderClause()
				}

			}
			p.SetState(2659)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserLIMIT_SYMBOL {
				{
					p.SetState(2658)
					p.SimpleLimitClause()
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		{
			p.SetState(2663)
			p.TableAliasRefList()
		}
		{
			p.SetState(2664)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2665)
			p.TableReferenceList()
		}
		p.SetState(2667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(2666)
				p.WhereClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDeleteContext is an interface to support dynamic dispatch.
type IPartitionDeleteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsPartitionDeleteContext differentiates from other interfaces.
	IsPartitionDeleteContext()
}

type PartitionDeleteContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDeleteContext() *PartitionDeleteContext {
	var p = new(PartitionDeleteContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDelete
	return p
}

func InitEmptyPartitionDeleteContext(p *PartitionDeleteContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDelete
}

func (*PartitionDeleteContext) IsPartitionDeleteContext() {}

func NewPartitionDeleteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDeleteContext {
	var p = new(PartitionDeleteContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionDelete

	return p
}

func (s *PartitionDeleteContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDeleteContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *PartitionDeleteContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDeleteContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDeleteContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDeleteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDeleteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDeleteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDelete(s)
	}
}

func (s *PartitionDeleteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDelete(s)
	}
}

func (s *PartitionDeleteContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDelete(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionDelete() (localctx IPartitionDeleteContext) {
	localctx = NewPartitionDeleteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, MySQLParserRULE_partitionDelete)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2671)

	if !(serverVersion >= 50602) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50602", ""))
		goto errorExit
	}
	{
		p.SetState(2672)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2673)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2674)
		p.IdentifierList()
	}
	{
		p.SetState(2675)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementOptionContext is an interface to support dynamic dispatch.
type IDeleteStatementOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUICK_SYMBOL() antlr.TerminalNode
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsDeleteStatementOptionContext differentiates from other interfaces.
	IsDeleteStatementOptionContext()
}

type DeleteStatementOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementOptionContext() *DeleteStatementOptionContext {
	var p = new(DeleteStatementOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteStatementOption
	return p
}

func InitEmptyDeleteStatementOptionContext(p *DeleteStatementOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteStatementOption
}

func (*DeleteStatementOptionContext) IsDeleteStatementOptionContext() {}

func NewDeleteStatementOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementOptionContext {
	var p = new(DeleteStatementOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_deleteStatementOption

	return p
}

func (s *DeleteStatementOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementOptionContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *DeleteStatementOptionContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *DeleteStatementOptionContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *DeleteStatementOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDeleteStatementOption(s)
	}
}

func (s *DeleteStatementOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDeleteStatementOption(s)
	}
}

func (s *DeleteStatementOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDeleteStatementOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DeleteStatementOption() (localctx IDeleteStatementOptionContext) {
	localctx = NewDeleteStatementOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, MySQLParserRULE_deleteStatementOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2677)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserLOW_PRIORITY_SYMBOL || _la == MySQLParserQUICK_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoStatementContext is an interface to support dynamic dispatch.
type IDoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DO_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	SelectItemList() ISelectItemListContext

	// IsDoStatementContext differentiates from other interfaces.
	IsDoStatementContext()
}

type DoStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoStatementContext() *DoStatementContext {
	var p = new(DoStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_doStatement
	return p
}

func InitEmptyDoStatementContext(p *DoStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_doStatement
}

func (*DoStatementContext) IsDoStatementContext() {}

func NewDoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoStatementContext {
	var p = new(DoStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_doStatement

	return p
}

func (s *DoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoStatementContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *DoStatementContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *DoStatementContext) SelectItemList() ISelectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemListContext)
}

func (s *DoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDoStatement(s)
	}
}

func (s *DoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDoStatement(s)
	}
}

func (s *DoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DoStatement() (localctx IDoStatementContext) {
	localctx = NewDoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, MySQLParserRULE_doStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2679)
		p.Match(MySQLParserDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 231, p.GetParserRuleContext()) {
	case 1:
		p.SetState(2680)

		if !(serverVersion < 50709) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50709", ""))
			goto errorExit
		}
		{
			p.SetState(2681)
			p.ExprList()
		}

	case 2:
		p.SetState(2682)

		if !(serverVersion >= 50709) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50709", ""))
			goto errorExit
		}
		{
			p.SetState(2683)
			p.SelectItemList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerStatementContext is an interface to support dynamic dispatch.
type IHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HANDLER_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	OPEN_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	CLOSE_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	HandlerReadOrScan() IHandlerReadOrScanContext
	TableAlias() ITableAliasContext
	WhereClause() IWhereClauseContext
	LimitClause() ILimitClauseContext

	// IsHandlerStatementContext differentiates from other interfaces.
	IsHandlerStatementContext()
}

type HandlerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerStatementContext() *HandlerStatementContext {
	var p = new(HandlerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerStatement
	return p
}

func InitEmptyHandlerStatementContext(p *HandlerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerStatement
}

func (*HandlerStatementContext) IsHandlerStatementContext() {}

func NewHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerStatementContext {
	var p = new(HandlerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_handlerStatement

	return p
}

func (s *HandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerStatementContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHANDLER_SYMBOL, 0)
}

func (s *HandlerStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *HandlerStatementContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_SYMBOL, 0)
}

func (s *HandlerStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HandlerStatementContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_SYMBOL, 0)
}

func (s *HandlerStatementContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *HandlerStatementContext) HandlerReadOrScan() IHandlerReadOrScanContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerReadOrScanContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerReadOrScanContext)
}

func (s *HandlerStatementContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *HandlerStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *HandlerStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *HandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHandlerStatement(s)
	}
}

func (s *HandlerStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHandlerStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HandlerStatement() (localctx IHandlerStatementContext) {
	localctx = NewHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, MySQLParserRULE_handlerStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2686)
		p.Match(MySQLParserHANDLER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 236, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2687)
			p.TableRef()
		}
		{
			p.SetState(2688)
			p.Match(MySQLParserOPEN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2689)
				p.TableAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(2692)
			p.Identifier()
		}
		p.SetState(2702)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserCLOSE_SYMBOL:
			{
				p.SetState(2693)
				p.Match(MySQLParserCLOSE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySQLParserREAD_SYMBOL:
			{
				p.SetState(2694)
				p.Match(MySQLParserREAD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2695)
				p.HandlerReadOrScan()
			}
			p.SetState(2697)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserWHERE_SYMBOL {
				{
					p.SetState(2696)
					p.WhereClause()
				}

			}
			p.SetState(2700)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserLIMIT_SYMBOL {
				{
					p.SetState(2699)
					p.LimitClause()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerReadOrScanContext is an interface to support dynamic dispatch.
type IHandlerReadOrScanContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIRST_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Values() IValuesContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	PREV_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	LESS_THAN_OPERATOR() antlr.TerminalNode
	GREATER_THAN_OPERATOR() antlr.TerminalNode
	LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode
	GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode

	// IsHandlerReadOrScanContext differentiates from other interfaces.
	IsHandlerReadOrScanContext()
}

type HandlerReadOrScanContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerReadOrScanContext() *HandlerReadOrScanContext {
	var p = new(HandlerReadOrScanContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerReadOrScan
	return p
}

func InitEmptyHandlerReadOrScanContext(p *HandlerReadOrScanContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerReadOrScan
}

func (*HandlerReadOrScanContext) IsHandlerReadOrScanContext() {}

func NewHandlerReadOrScanContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerReadOrScanContext {
	var p = new(HandlerReadOrScanContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_handlerReadOrScan

	return p
}

func (s *HandlerReadOrScanContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerReadOrScanContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEXT_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HandlerReadOrScanContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *HandlerReadOrScanContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) PREV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREV_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_SYMBOL, 0)
}

func (s *HandlerReadOrScanContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *HandlerReadOrScanContext) LESS_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_THAN_OPERATOR, 0)
}

func (s *HandlerReadOrScanContext) GREATER_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserGREATER_THAN_OPERATOR, 0)
}

func (s *HandlerReadOrScanContext) LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_OR_EQUAL_OPERATOR, 0)
}

func (s *HandlerReadOrScanContext) GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserGREATER_OR_EQUAL_OPERATOR, 0)
}

func (s *HandlerReadOrScanContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerReadOrScanContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerReadOrScanContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHandlerReadOrScan(s)
	}
}

func (s *HandlerReadOrScanContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHandlerReadOrScan(s)
	}
}

func (s *HandlerReadOrScanContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHandlerReadOrScan(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HandlerReadOrScan() (localctx IHandlerReadOrScanContext) {
	localctx = NewHandlerReadOrScanContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, MySQLParserRULE_handlerReadOrScan)
	var _la int

	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 238, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2706)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserFIRST_SYMBOL || _la == MySQLParserNEXT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2707)
			p.Identifier()
		}
		p.SetState(2714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserFIRST_SYMBOL, MySQLParserLAST_SYMBOL, MySQLParserNEXT_SYMBOL, MySQLParserPREV_SYMBOL:
			{
				p.SetState(2708)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserFIRST_SYMBOL || _la == MySQLParserLAST_SYMBOL || _la == MySQLParserNEXT_SYMBOL || _la == MySQLParserPREV_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case MySQLParserEQUAL_OPERATOR, MySQLParserGREATER_OR_EQUAL_OPERATOR, MySQLParserGREATER_THAN_OPERATOR, MySQLParserLESS_OR_EQUAL_OPERATOR, MySQLParserLESS_THAN_OPERATOR:
			{
				p.SetState(2709)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-750)) & ^0x3f) == 0 && ((int64(1)<<(_la-750))&121) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(2710)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2711)
				p.Values()
			}
			{
				p.SetState(2712)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	InsertFromConstructor() IInsertFromConstructorContext
	SET_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext
	InsertQueryExpression() IInsertQueryExpressionContext
	InsertLockOption() IInsertLockOptionContext
	IGNORE_SYMBOL() antlr.TerminalNode
	INTO_SYMBOL() antlr.TerminalNode
	UsePartition() IUsePartitionContext
	InsertUpdateList() IInsertUpdateListContext
	ValuesReference() IValuesReferenceContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_SYMBOL, 0)
}

func (s *InsertStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *InsertStatementContext) InsertFromConstructor() IInsertFromConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertFromConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertFromConstructorContext)
}

func (s *InsertStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *InsertStatementContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *InsertStatementContext) InsertQueryExpression() IInsertQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertQueryExpressionContext)
}

func (s *InsertStatementContext) InsertLockOption() IInsertLockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertLockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertLockOptionContext)
}

func (s *InsertStatementContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *InsertStatementContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *InsertStatementContext) UsePartition() IUsePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsePartitionContext)
}

func (s *InsertStatementContext) InsertUpdateList() IInsertUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertUpdateListContext)
}

func (s *InsertStatementContext) ValuesReference() IValuesReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesReferenceContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (s *InsertStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, MySQLParserRULE_insertStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2718)
		p.Match(MySQLParserINSERT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2720)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 239, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2719)
			p.InsertLockOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2722)
			p.Match(MySQLParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2726)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 241, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2725)
			p.Match(MySQLParserINTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2728)
		p.TableRef()
	}
	p.SetState(2730)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 242, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2729)
			p.UsePartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2744)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 245, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2732)
			p.InsertFromConstructor()
		}
		p.SetState(2735)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 243, p.GetParserRuleContext()) == 1 {
			p.SetState(2733)

			if !(serverVersion >= 80018) {
				p.SetError(antlr.NewFailedPredicateException(p, " serverVersion >= 80018", ""))
				goto errorExit
			}
			{
				p.SetState(2734)
				p.ValuesReference()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(2737)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2738)
			p.UpdateList()
		}
		p.SetState(2741)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 244, p.GetParserRuleContext()) == 1 {
			p.SetState(2739)

			if !(serverVersion >= 80018) {
				p.SetError(antlr.NewFailedPredicateException(p, " serverVersion >= 80018", ""))
				goto errorExit
			}
			{
				p.SetState(2740)
				p.ValuesReference()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(2743)
			p.InsertQueryExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserON_SYMBOL {
		{
			p.SetState(2746)
			p.InsertUpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertLockOptionContext is an interface to support dynamic dispatch.
type IInsertLockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	DELAYED_SYMBOL() antlr.TerminalNode
	HIGH_PRIORITY_SYMBOL() antlr.TerminalNode

	// IsInsertLockOptionContext differentiates from other interfaces.
	IsInsertLockOptionContext()
}

type InsertLockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertLockOptionContext() *InsertLockOptionContext {
	var p = new(InsertLockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertLockOption
	return p
}

func InitEmptyInsertLockOptionContext(p *InsertLockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertLockOption
}

func (*InsertLockOptionContext) IsInsertLockOptionContext() {}

func NewInsertLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertLockOptionContext {
	var p = new(InsertLockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertLockOption

	return p
}

func (s *InsertLockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertLockOptionContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *InsertLockOptionContext) DELAYED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELAYED_SYMBOL, 0)
}

func (s *InsertLockOptionContext) HIGH_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHIGH_PRIORITY_SYMBOL, 0)
}

func (s *InsertLockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertLockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertLockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertLockOption(s)
	}
}

func (s *InsertLockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertLockOption(s)
	}
}

func (s *InsertLockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertLockOption() (localctx IInsertLockOptionContext) {
	localctx = NewInsertLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, MySQLParserRULE_insertLockOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2749)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDELAYED_SYMBOL || _la == MySQLParserHIGH_PRIORITY_SYMBOL || _la == MySQLParserLOW_PRIORITY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertFromConstructorContext is an interface to support dynamic dispatch.
type IInsertFromConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InsertValues() IInsertValuesContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Fields() IFieldsContext

	// IsInsertFromConstructorContext differentiates from other interfaces.
	IsInsertFromConstructorContext()
}

type InsertFromConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertFromConstructorContext() *InsertFromConstructorContext {
	var p = new(InsertFromConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertFromConstructor
	return p
}

func InitEmptyInsertFromConstructorContext(p *InsertFromConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertFromConstructor
}

func (*InsertFromConstructorContext) IsInsertFromConstructorContext() {}

func NewInsertFromConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertFromConstructorContext {
	var p = new(InsertFromConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertFromConstructor

	return p
}

func (s *InsertFromConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertFromConstructorContext) InsertValues() IInsertValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertValuesContext)
}

func (s *InsertFromConstructorContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *InsertFromConstructorContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *InsertFromConstructorContext) Fields() IFieldsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsContext)
}

func (s *InsertFromConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertFromConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertFromConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertFromConstructor(s)
	}
}

func (s *InsertFromConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertFromConstructor(s)
	}
}

func (s *InsertFromConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertFromConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertFromConstructor() (localctx IInsertFromConstructorContext) {
	localctx = NewInsertFromConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, MySQLParserRULE_insertFromConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(2751)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 247, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2752)
				p.Fields()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2755)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2758)
		p.InsertValues()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldsContext is an interface to support dynamic dispatch.
type IFieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInsertIdentifier() []IInsertIdentifierContext
	InsertIdentifier(i int) IInsertIdentifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFieldsContext differentiates from other interfaces.
	IsFieldsContext()
}

type FieldsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsContext() *FieldsContext {
	var p = new(FieldsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fields
	return p
}

func InitEmptyFieldsContext(p *FieldsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fields
}

func (*FieldsContext) IsFieldsContext() {}

func NewFieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsContext {
	var p = new(FieldsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fields

	return p
}

func (s *FieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsContext) AllInsertIdentifier() []IInsertIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IInsertIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertIdentifierContext); ok {
			tst[i] = t.(IInsertIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *FieldsContext) InsertIdentifier(i int) IInsertIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertIdentifierContext)
}

func (s *FieldsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FieldsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFields(s)
	}
}

func (s *FieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFields(s)
	}
}

func (s *FieldsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFields(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Fields() (localctx IFieldsContext) {
	localctx = NewFieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, MySQLParserRULE_fields)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2760)
		p.InsertIdentifier()
	}
	p.SetState(2765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(2761)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2762)
			p.InsertIdentifier()
		}

		p.SetState(2767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertValuesContext is an interface to support dynamic dispatch.
type IInsertValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ValueList() IValueListContext
	VALUES_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode

	// IsInsertValuesContext differentiates from other interfaces.
	IsInsertValuesContext()
}

type InsertValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertValuesContext() *InsertValuesContext {
	var p = new(InsertValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertValues
	return p
}

func InitEmptyInsertValuesContext(p *InsertValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertValues
}

func (*InsertValuesContext) IsInsertValuesContext() {}

func NewInsertValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertValuesContext {
	var p = new(InsertValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertValues

	return p
}

func (s *InsertValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertValuesContext) ValueList() IValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueListContext)
}

func (s *InsertValuesContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUES_SYMBOL, 0)
}

func (s *InsertValuesContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUE_SYMBOL, 0)
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

func (s *InsertValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertValues() (localctx IInsertValuesContext) {
	localctx = NewInsertValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, MySQLParserRULE_insertValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2768)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserVALUES_SYMBOL || _la == MySQLParserVALUE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2769)
		p.ValueList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertQueryExpressionContext is an interface to support dynamic dispatch.
type IInsertQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionOrParens() IQueryExpressionOrParensContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Fields() IFieldsContext

	// IsInsertQueryExpressionContext differentiates from other interfaces.
	IsInsertQueryExpressionContext()
}

type InsertQueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertQueryExpressionContext() *InsertQueryExpressionContext {
	var p = new(InsertQueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertQueryExpression
	return p
}

func InitEmptyInsertQueryExpressionContext(p *InsertQueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertQueryExpression
}

func (*InsertQueryExpressionContext) IsInsertQueryExpressionContext() {}

func NewInsertQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertQueryExpressionContext {
	var p = new(InsertQueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertQueryExpression

	return p
}

func (s *InsertQueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertQueryExpressionContext) QueryExpressionOrParens() IQueryExpressionOrParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionOrParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionOrParensContext)
}

func (s *InsertQueryExpressionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *InsertQueryExpressionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *InsertQueryExpressionContext) Fields() IFieldsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsContext)
}

func (s *InsertQueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertQueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertQueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertQueryExpression(s)
	}
}

func (s *InsertQueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertQueryExpression(s)
	}
}

func (s *InsertQueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertQueryExpression() (localctx IInsertQueryExpressionContext) {
	localctx = NewInsertQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, MySQLParserRULE_insertQueryExpression)
	p.SetState(2778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2771)
			p.QueryExpressionOrParens()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2772)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2774)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2773)
				p.Fields()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2776)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2777)
			p.QueryExpressionOrParens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueListContext is an interface to support dynamic dispatch.
type IValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOPEN_PAR_SYMBOL() []antlr.TerminalNode
	OPEN_PAR_SYMBOL(i int) antlr.TerminalNode
	AllCLOSE_PAR_SYMBOL() []antlr.TerminalNode
	CLOSE_PAR_SYMBOL(i int) antlr.TerminalNode
	AllValues() []IValuesContext
	Values(i int) IValuesContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsValueListContext differentiates from other interfaces.
	IsValueListContext()
}

type ValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueListContext() *ValueListContext {
	var p = new(ValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_valueList
	return p
}

func InitEmptyValueListContext(p *ValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_valueList
}

func (*ValueListContext) IsValueListContext() {}

func NewValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueListContext {
	var p = new(ValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_valueList

	return p
}

func (s *ValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueListContext) AllOPEN_PAR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserOPEN_PAR_SYMBOL)
}

func (s *ValueListContext) OPEN_PAR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, i)
}

func (s *ValueListContext) AllCLOSE_PAR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCLOSE_PAR_SYMBOL)
}

func (s *ValueListContext) CLOSE_PAR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, i)
}

func (s *ValueListContext) AllValues() []IValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValuesContext); ok {
			len++
		}
	}

	tst := make([]IValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValuesContext); ok {
			tst[i] = t.(IValuesContext)
			i++
		}
	}

	return tst
}

func (s *ValueListContext) Values(i int) IValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *ValueListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ValueListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterValueList(s)
	}
}

func (s *ValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitValueList(s)
	}
}

func (s *ValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ValueList() (localctx IValueListContext) {
	localctx = NewValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, MySQLParserRULE_valueList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2780)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2781)
			p.Values()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2784)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2785)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2786)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2788)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 253, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2787)
					p.Values()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2790)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllDEFAULT_SYMBOL() []antlr.TerminalNode
	DEFAULT_SYMBOL(i int) antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_values
	return p
}

func InitEmptyValuesContext(p *ValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_values
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ValuesContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ValuesContext) AllDEFAULT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserDEFAULT_SYMBOL)
}

func (s *ValuesContext) DEFAULT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, i)
}

func (s *ValuesContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ValuesContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitValues(s)
	}
}

func (s *ValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Values() (localctx IValuesContext) {
	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, MySQLParserRULE_values)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2798)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 255, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2796)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(2797)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2807)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(2800)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2803)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 256, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2801)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(2802)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesReferenceContext is an interface to support dynamic dispatch.
type IValuesReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	ColumnInternalRefList() IColumnInternalRefListContext

	// IsValuesReferenceContext differentiates from other interfaces.
	IsValuesReferenceContext()
}

type ValuesReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesReferenceContext() *ValuesReferenceContext {
	var p = new(ValuesReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_valuesReference
	return p
}

func InitEmptyValuesReferenceContext(p *ValuesReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_valuesReference
}

func (*ValuesReferenceContext) IsValuesReferenceContext() {}

func NewValuesReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesReferenceContext {
	var p = new(ValuesReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_valuesReference

	return p
}

func (s *ValuesReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesReferenceContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *ValuesReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ValuesReferenceContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *ValuesReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterValuesReference(s)
	}
}

func (s *ValuesReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitValuesReference(s)
	}
}

func (s *ValuesReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitValuesReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ValuesReference() (localctx IValuesReferenceContext) {
	localctx = NewValuesReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, MySQLParserRULE_valuesReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2810)
		p.Match(MySQLParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2811)
		p.Identifier()
	}
	p.SetState(2813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(2812)
			p.ColumnInternalRefList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertUpdateListContext is an interface to support dynamic dispatch.
type IInsertUpdateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	DUPLICATE_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext

	// IsInsertUpdateListContext differentiates from other interfaces.
	IsInsertUpdateListContext()
}

type InsertUpdateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertUpdateListContext() *InsertUpdateListContext {
	var p = new(InsertUpdateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertUpdateList
	return p
}

func InitEmptyInsertUpdateListContext(p *InsertUpdateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertUpdateList
}

func (*InsertUpdateListContext) IsInsertUpdateListContext() {}

func NewInsertUpdateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertUpdateListContext {
	var p = new(InsertUpdateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertUpdateList

	return p
}

func (s *InsertUpdateListContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertUpdateListContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *InsertUpdateListContext) DUPLICATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUPLICATE_SYMBOL, 0)
}

func (s *InsertUpdateListContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *InsertUpdateListContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *InsertUpdateListContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *InsertUpdateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertUpdateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertUpdateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertUpdateList(s)
	}
}

func (s *InsertUpdateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertUpdateList(s)
	}
}

func (s *InsertUpdateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertUpdateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertUpdateList() (localctx IInsertUpdateListContext) {
	localctx = NewInsertUpdateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, MySQLParserRULE_insertUpdateList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2815)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2816)
		p.Match(MySQLParserDUPLICATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2817)
		p.Match(MySQLParserKEY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2818)
		p.Match(MySQLParserUPDATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2819)
		p.UpdateList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD_SYMBOL() antlr.TerminalNode
	DataOrXml() IDataOrXmlContext
	INFILE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	INTO_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	LoadDataFileTail() ILoadDataFileTailContext
	LOCAL_SYMBOL() antlr.TerminalNode
	UsePartition() IUsePartitionContext
	CharsetClause() ICharsetClauseContext
	XmlRowsIdentifiedBy() IXmlRowsIdentifiedByContext
	FieldsClause() IFieldsClauseContext
	LinesClause() ILinesClauseContext
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	CONCURRENT_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOAD_SYMBOL, 0)
}

func (s *LoadStatementContext) DataOrXml() IDataOrXmlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataOrXmlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataOrXmlContext)
}

func (s *LoadStatementContext) INFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINFILE_SYMBOL, 0)
}

func (s *LoadStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *LoadStatementContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *LoadStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *LoadStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *LoadStatementContext) LoadDataFileTail() ILoadDataFileTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataFileTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataFileTailContext)
}

func (s *LoadStatementContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *LoadStatementContext) UsePartition() IUsePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsePartitionContext)
}

func (s *LoadStatementContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *LoadStatementContext) XmlRowsIdentifiedBy() IXmlRowsIdentifiedByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXmlRowsIdentifiedByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXmlRowsIdentifiedByContext)
}

func (s *LoadStatementContext) FieldsClause() IFieldsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsClauseContext)
}

func (s *LoadStatementContext) LinesClause() ILinesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinesClauseContext)
}

func (s *LoadStatementContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *LoadStatementContext) CONCURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONCURRENT_SYMBOL, 0)
}

func (s *LoadStatementContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *LoadStatementContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (s *LoadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLoadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, MySQLParserRULE_loadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2821)
		p.Match(MySQLParserLOAD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2822)
		p.DataOrXml()
	}
	p.SetState(2824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCONCURRENT_SYMBOL || _la == MySQLParserLOW_PRIORITY_SYMBOL {
		{
			p.SetState(2823)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCONCURRENT_SYMBOL || _la == MySQLParserLOW_PRIORITY_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserLOCAL_SYMBOL {
		{
			p.SetState(2826)
			p.Match(MySQLParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2829)
		p.Match(MySQLParserINFILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2830)
		p.TextLiteral()
	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserREPLACE_SYMBOL {
		{
			p.SetState(2831)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserREPLACE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2834)
		p.Match(MySQLParserINTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2835)
		p.Match(MySQLParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2836)
		p.TableRef()
	}
	p.SetState(2838)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2837)
			p.UsePartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCHARSET_SYMBOL || _la == MySQLParserCHAR_SYMBOL {
		{
			p.SetState(2840)
			p.CharsetClause()
		}

	}
	p.SetState(2844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserROWS_SYMBOL {
		{
			p.SetState(2843)
			p.XmlRowsIdentifiedBy()
		}

	}
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOLUMNS_SYMBOL {
		{
			p.SetState(2846)
			p.FieldsClause()
		}

	}
	p.SetState(2850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserLINES_SYMBOL {
		{
			p.SetState(2849)
			p.LinesClause()
		}

	}
	{
		p.SetState(2852)
		p.LoadDataFileTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataOrXmlContext is an interface to support dynamic dispatch.
type IDataOrXmlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATA_SYMBOL() antlr.TerminalNode
	XML_SYMBOL() antlr.TerminalNode

	// IsDataOrXmlContext differentiates from other interfaces.
	IsDataOrXmlContext()
}

type DataOrXmlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOrXmlContext() *DataOrXmlContext {
	var p = new(DataOrXmlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataOrXml
	return p
}

func InitEmptyDataOrXmlContext(p *DataOrXmlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataOrXml
}

func (*DataOrXmlContext) IsDataOrXmlContext() {}

func NewDataOrXmlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOrXmlContext {
	var p = new(DataOrXmlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dataOrXml

	return p
}

func (s *DataOrXmlContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOrXmlContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *DataOrXmlContext) XML_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXML_SYMBOL, 0)
}

func (s *DataOrXmlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOrXmlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOrXmlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDataOrXml(s)
	}
}

func (s *DataOrXmlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDataOrXml(s)
	}
}

func (s *DataOrXmlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDataOrXml(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DataOrXml() (localctx IDataOrXmlContext) {
	localctx = NewDataOrXmlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, MySQLParserRULE_dataOrXml)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2854)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDATA_SYMBOL || _la == MySQLParserXML_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXmlRowsIdentifiedByContext is an interface to support dynamic dispatch.
type IXmlRowsIdentifiedByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext

	// IsXmlRowsIdentifiedByContext differentiates from other interfaces.
	IsXmlRowsIdentifiedByContext()
}

type XmlRowsIdentifiedByContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXmlRowsIdentifiedByContext() *XmlRowsIdentifiedByContext {
	var p = new(XmlRowsIdentifiedByContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xmlRowsIdentifiedBy
	return p
}

func InitEmptyXmlRowsIdentifiedByContext(p *XmlRowsIdentifiedByContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xmlRowsIdentifiedBy
}

func (*XmlRowsIdentifiedByContext) IsXmlRowsIdentifiedByContext() {}

func NewXmlRowsIdentifiedByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XmlRowsIdentifiedByContext {
	var p = new(XmlRowsIdentifiedByContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_xmlRowsIdentifiedBy

	return p
}

func (s *XmlRowsIdentifiedByContext) GetParser() antlr.Parser { return s.parser }

func (s *XmlRowsIdentifiedByContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROWS_SYMBOL, 0)
}

func (s *XmlRowsIdentifiedByContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *XmlRowsIdentifiedByContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *XmlRowsIdentifiedByContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *XmlRowsIdentifiedByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XmlRowsIdentifiedByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XmlRowsIdentifiedByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterXmlRowsIdentifiedBy(s)
	}
}

func (s *XmlRowsIdentifiedByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitXmlRowsIdentifiedBy(s)
	}
}

func (s *XmlRowsIdentifiedByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitXmlRowsIdentifiedBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) XmlRowsIdentifiedBy() (localctx IXmlRowsIdentifiedByContext) {
	localctx = NewXmlRowsIdentifiedByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, MySQLParserRULE_xmlRowsIdentifiedBy)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2856)
		p.Match(MySQLParserROWS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2857)
		p.Match(MySQLParserIDENTIFIED_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2858)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2859)
		p.TextString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadDataFileTailContext is an interface to support dynamic dispatch.
type ILoadDataFileTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	LoadDataFileTargetList() ILoadDataFileTargetListContext
	SET_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext
	LINES_SYMBOL() antlr.TerminalNode
	ROWS_SYMBOL() antlr.TerminalNode

	// IsLoadDataFileTailContext differentiates from other interfaces.
	IsLoadDataFileTailContext()
}

type LoadDataFileTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadDataFileTailContext() *LoadDataFileTailContext {
	var p = new(LoadDataFileTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadDataFileTail
	return p
}

func InitEmptyLoadDataFileTailContext(p *LoadDataFileTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadDataFileTail
}

func (*LoadDataFileTailContext) IsLoadDataFileTailContext() {}

func NewLoadDataFileTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataFileTailContext {
	var p = new(LoadDataFileTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_loadDataFileTail

	return p
}

func (s *LoadDataFileTailContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataFileTailContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *LoadDataFileTailContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *LoadDataFileTailContext) LoadDataFileTargetList() ILoadDataFileTargetListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadDataFileTargetListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadDataFileTargetListContext)
}

func (s *LoadDataFileTailContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *LoadDataFileTailContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *LoadDataFileTailContext) LINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINES_SYMBOL, 0)
}

func (s *LoadDataFileTailContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROWS_SYMBOL, 0)
}

func (s *LoadDataFileTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataFileTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadDataFileTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLoadDataFileTail(s)
	}
}

func (s *LoadDataFileTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLoadDataFileTail(s)
	}
}

func (s *LoadDataFileTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLoadDataFileTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LoadDataFileTail() (localctx ILoadDataFileTailContext) {
	localctx = NewLoadDataFileTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, MySQLParserRULE_loadDataFileTail)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserIGNORE_SYMBOL {
		{
			p.SetState(2861)
			p.Match(MySQLParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2862)
			p.Match(MySQLParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2863)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLINES_SYMBOL || _la == MySQLParserROWS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(2866)
			p.LoadDataFileTargetList()
		}

	}
	p.SetState(2871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSET_SYMBOL {
		{
			p.SetState(2869)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2870)
			p.UpdateList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadDataFileTargetListContext is an interface to support dynamic dispatch.
type ILoadDataFileTargetListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FieldOrVariableList() IFieldOrVariableListContext

	// IsLoadDataFileTargetListContext differentiates from other interfaces.
	IsLoadDataFileTargetListContext()
}

type LoadDataFileTargetListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadDataFileTargetListContext() *LoadDataFileTargetListContext {
	var p = new(LoadDataFileTargetListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadDataFileTargetList
	return p
}

func InitEmptyLoadDataFileTargetListContext(p *LoadDataFileTargetListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loadDataFileTargetList
}

func (*LoadDataFileTargetListContext) IsLoadDataFileTargetListContext() {}

func NewLoadDataFileTargetListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadDataFileTargetListContext {
	var p = new(LoadDataFileTargetListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_loadDataFileTargetList

	return p
}

func (s *LoadDataFileTargetListContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadDataFileTargetListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *LoadDataFileTargetListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *LoadDataFileTargetListContext) FieldOrVariableList() IFieldOrVariableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOrVariableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOrVariableListContext)
}

func (s *LoadDataFileTargetListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadDataFileTargetListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadDataFileTargetListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLoadDataFileTargetList(s)
	}
}

func (s *LoadDataFileTargetListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLoadDataFileTargetList(s)
	}
}

func (s *LoadDataFileTargetListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLoadDataFileTargetList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LoadDataFileTargetList() (localctx ILoadDataFileTargetListContext) {
	localctx = NewLoadDataFileTargetListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, MySQLParserRULE_loadDataFileTargetList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2873)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2875)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2874)
			p.FieldOrVariableList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2877)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOrVariableListContext is an interface to support dynamic dispatch.
type IFieldOrVariableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnRef() []IColumnRefContext
	ColumnRef(i int) IColumnRefContext
	AllUserVariable() []IUserVariableContext
	UserVariable(i int) IUserVariableContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFieldOrVariableListContext differentiates from other interfaces.
	IsFieldOrVariableListContext()
}

type FieldOrVariableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOrVariableListContext() *FieldOrVariableListContext {
	var p = new(FieldOrVariableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldOrVariableList
	return p
}

func InitEmptyFieldOrVariableListContext(p *FieldOrVariableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldOrVariableList
}

func (*FieldOrVariableListContext) IsFieldOrVariableListContext() {}

func NewFieldOrVariableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOrVariableListContext {
	var p = new(FieldOrVariableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldOrVariableList

	return p
}

func (s *FieldOrVariableListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOrVariableListContext) AllColumnRef() []IColumnRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnRefContext); ok {
			tst[i] = t.(IColumnRefContext)
			i++
		}
	}

	return tst
}

func (s *FieldOrVariableListContext) ColumnRef(i int) IColumnRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *FieldOrVariableListContext) AllUserVariable() []IUserVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserVariableContext); ok {
			len++
		}
	}

	tst := make([]IUserVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserVariableContext); ok {
			tst[i] = t.(IUserVariableContext)
			i++
		}
	}

	return tst
}

func (s *FieldOrVariableListContext) UserVariable(i int) IUserVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *FieldOrVariableListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FieldOrVariableListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FieldOrVariableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOrVariableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOrVariableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldOrVariableList(s)
	}
}

func (s *FieldOrVariableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldOrVariableList(s)
	}
}

func (s *FieldOrVariableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldOrVariableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldOrVariableList() (localctx IFieldOrVariableListContext) {
	localctx = NewFieldOrVariableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, MySQLParserRULE_fieldOrVariableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2881)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2879)
			p.ColumnRef()
		}

	case 2:
		{
			p.SetState(2880)
			p.UserVariable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(2883)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2884)
				p.ColumnRef()
			}

		case 2:
			{
				p.SetState(2885)
				p.UserVariable()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(2892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplaceStatementContext is an interface to support dynamic dispatch.
type IReplaceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	InsertFromConstructor() IInsertFromConstructorContext
	SET_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext
	InsertQueryExpression() IInsertQueryExpressionContext
	INTO_SYMBOL() antlr.TerminalNode
	UsePartition() IUsePartitionContext
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	DELAYED_SYMBOL() antlr.TerminalNode

	// IsReplaceStatementContext differentiates from other interfaces.
	IsReplaceStatementContext()
}

type ReplaceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplaceStatementContext() *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replaceStatement
	return p
}

func InitEmptyReplaceStatementContext(p *ReplaceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replaceStatement
}

func (*ReplaceStatementContext) IsReplaceStatementContext() {}

func NewReplaceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplaceStatementContext {
	var p = new(ReplaceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_replaceStatement

	return p
}

func (s *ReplaceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplaceStatementContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *ReplaceStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ReplaceStatementContext) InsertFromConstructor() IInsertFromConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertFromConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertFromConstructorContext)
}

func (s *ReplaceStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *ReplaceStatementContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *ReplaceStatementContext) InsertQueryExpression() IInsertQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertQueryExpressionContext)
}

func (s *ReplaceStatementContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *ReplaceStatementContext) UsePartition() IUsePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsePartitionContext)
}

func (s *ReplaceStatementContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *ReplaceStatementContext) DELAYED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELAYED_SYMBOL, 0)
}

func (s *ReplaceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplaceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplaceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReplaceStatement(s)
	}
}

func (s *ReplaceStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReplaceStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ReplaceStatement() (localctx IReplaceStatementContext) {
	localctx = NewReplaceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, MySQLParserRULE_replaceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2893)
		p.Match(MySQLParserREPLACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2895)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 274, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2894)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDELAYED_SYMBOL || _la == MySQLParserLOW_PRIORITY_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2898)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2897)
			p.Match(MySQLParserINTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2900)
		p.TableRef()
	}
	p.SetState(2902)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2901)
			p.UsePartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2908)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2904)
			p.InsertFromConstructor()
		}

	case 2:
		{
			p.SetState(2905)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2906)
			p.UpdateList()
		}

	case 3:
		{
			p.SetState(2907)
			p.InsertQueryExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpression() IQueryExpressionContext
	LockingClauseList() ILockingClauseListContext
	QueryExpressionParens() IQueryExpressionParensContext
	SelectStatementWithInto() ISelectStatementWithIntoContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *SelectStatementContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *SelectStatementContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *SelectStatementContext) SelectStatementWithInto() ISelectStatementWithIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithIntoContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (s *SelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, MySQLParserRULE_selectStatement)
	var _la int

	p.SetState(2916)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2910)
			p.QueryExpression()
		}
		p.SetState(2912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
			{
				p.SetState(2911)
				p.LockingClauseList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2914)
			p.QueryExpressionParens()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2915)
			p.SelectStatementWithInto()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementWithIntoContext is an interface to support dynamic dispatch.
type ISelectStatementWithIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	SelectStatementWithInto() ISelectStatementWithIntoContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext
	IntoClause() IIntoClauseContext
	LockingClauseList() ILockingClauseListContext

	// IsSelectStatementWithIntoContext differentiates from other interfaces.
	IsSelectStatementWithIntoContext()
}

type SelectStatementWithIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementWithIntoContext() *SelectStatementWithIntoContext {
	var p = new(SelectStatementWithIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectStatementWithInto
	return p
}

func InitEmptySelectStatementWithIntoContext(p *SelectStatementWithIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectStatementWithInto
}

func (*SelectStatementWithIntoContext) IsSelectStatementWithIntoContext() {}

func NewSelectStatementWithIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementWithIntoContext {
	var p = new(SelectStatementWithIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectStatementWithInto

	return p
}

func (s *SelectStatementWithIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementWithIntoContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SelectStatementWithIntoContext) SelectStatementWithInto() ISelectStatementWithIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithIntoContext)
}

func (s *SelectStatementWithIntoContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SelectStatementWithIntoContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *SelectStatementWithIntoContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *SelectStatementWithIntoContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *SelectStatementWithIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementWithIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementWithIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectStatementWithInto(s)
	}
}

func (s *SelectStatementWithIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectStatementWithInto(s)
	}
}

func (s *SelectStatementWithIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectStatementWithInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectStatementWithInto() (localctx ISelectStatementWithIntoContext) {
	localctx = NewSelectStatementWithIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, MySQLParserRULE_selectStatementWithInto)
	var _la int

	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 281, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2918)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2919)
			p.SelectStatementWithInto()
		}
		{
			p.SetState(2920)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2922)
			p.QueryExpression()
		}
		{
			p.SetState(2923)
			p.IntoClause()
		}
		p.SetState(2925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
			{
				p.SetState(2924)
				p.LockingClauseList()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2927)
			p.LockingClauseList()
		}
		{
			p.SetState(2928)
			p.IntoClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionBody() IQueryExpressionBodyContext
	QueryExpressionParens() IQueryExpressionParensContext
	WithClause() IWithClauseContext
	ProcedureAnalyseClause() IProcedureAnalyseClauseContext
	OrderClause() IOrderClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) QueryExpressionBody() IQueryExpressionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionBodyContext)
}

func (s *QueryExpressionContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryExpressionContext) ProcedureAnalyseClause() IProcedureAnalyseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureAnalyseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureAnalyseClauseContext)
}

func (s *QueryExpressionContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *QueryExpressionContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, MySQLParserRULE_queryExpression)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(2934)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
		p.SetState(2932)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(2933)
			p.WithClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2936)
			p.QueryExpressionBody()
		}
		p.SetState(2938)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 283, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2937)
				p.OrderClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 284, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2940)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(2943)
			p.QueryExpressionParens()
		}
		p.SetState(2945)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 285, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2944)
				p.OrderClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2948)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2947)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) == 1 {
		p.SetState(2952)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(2953)
			p.ProcedureAnalyseClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionBodyContext is an interface to support dynamic dispatch.
type IQueryExpressionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQueryPrimary() []IQueryPrimaryContext
	QueryPrimary(i int) IQueryPrimaryContext
	AllQueryExpressionParens() []IQueryExpressionParensContext
	QueryExpressionParens(i int) IQueryExpressionParensContext
	AllUNION_SYMBOL() []antlr.TerminalNode
	UNION_SYMBOL(i int) antlr.TerminalNode
	AllUnionOption() []IUnionOptionContext
	UnionOption(i int) IUnionOptionContext

	// IsQueryExpressionBodyContext differentiates from other interfaces.
	IsQueryExpressionBodyContext()
}

type QueryExpressionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionBodyContext() *QueryExpressionBodyContext {
	var p = new(QueryExpressionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionBody
	return p
}

func InitEmptyQueryExpressionBodyContext(p *QueryExpressionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionBody
}

func (*QueryExpressionBodyContext) IsQueryExpressionBodyContext() {}

func NewQueryExpressionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionBodyContext {
	var p = new(QueryExpressionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_queryExpressionBody

	return p
}

func (s *QueryExpressionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionBodyContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryExpressionBodyContext) AllQueryExpressionParens() []IQueryExpressionParensContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			len++
		}
	}

	tst := make([]IQueryExpressionParensContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryExpressionParensContext); ok {
			tst[i] = t.(IQueryExpressionParensContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) QueryExpressionParens(i int) IQueryExpressionParensContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionBodyContext) AllUNION_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserUNION_SYMBOL)
}

func (s *QueryExpressionBodyContext) UNION_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserUNION_SYMBOL, i)
}

func (s *QueryExpressionBodyContext) AllUnionOption() []IUnionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionOptionContext); ok {
			len++
		}
	}

	tst := make([]IUnionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionOptionContext); ok {
			tst[i] = t.(IUnionOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) UnionOption(i int) IUnionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOptionContext)
}

func (s *QueryExpressionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQueryExpressionBody(s)
	}
}

func (s *QueryExpressionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQueryExpressionBody(s)
	}
}

func (s *QueryExpressionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQueryExpressionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QueryExpressionBody() (localctx IQueryExpressionBodyContext) {
	localctx = NewQueryExpressionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, MySQLParserRULE_queryExpressionBody)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2956)
			p.QueryPrimary()
		}

	case 2:
		{
			p.SetState(2957)
			p.QueryExpressionParens()
		}
		{
			p.SetState(2958)
			p.Match(MySQLParserUNION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2960)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2959)
				p.UnionOption()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(2964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2962)
				p.QueryPrimary()
			}

		case 2:
			{
				p.SetState(2963)
				p.QueryExpressionParens()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(2978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2968)
				p.Match(MySQLParserUNION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2970)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2969)
					p.UnionOption()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(2974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2972)
					p.QueryPrimary()
				}

			case 2:
				{
					p.SetState(2973)
					p.QueryExpressionParens()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(2980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 294, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionParensContext is an interface to support dynamic dispatch.
type IQueryExpressionParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	QueryExpressionParens() IQueryExpressionParensContext
	QueryExpression() IQueryExpressionContext
	LockingClauseList() ILockingClauseListContext

	// IsQueryExpressionParensContext differentiates from other interfaces.
	IsQueryExpressionParensContext()
}

type QueryExpressionParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionParensContext() *QueryExpressionParensContext {
	var p = new(QueryExpressionParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionParens
	return p
}

func InitEmptyQueryExpressionParensContext(p *QueryExpressionParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryExpressionParens
}

func (*QueryExpressionParensContext) IsQueryExpressionParensContext() {}

func NewQueryExpressionParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionParensContext {
	var p = new(QueryExpressionParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_queryExpressionParens

	return p
}

func (s *QueryExpressionParensContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *QueryExpressionParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *QueryExpressionParensContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionParensContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionParensContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *QueryExpressionParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQueryExpressionParens(s)
	}
}

func (s *QueryExpressionParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQueryExpressionParens(s)
	}
}

func (s *QueryExpressionParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQueryExpressionParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QueryExpressionParens() (localctx IQueryExpressionParensContext) {
	localctx = NewQueryExpressionParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, MySQLParserRULE_queryExpressionParens)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2981)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2987)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2982)
			p.QueryExpressionParens()
		}

	case 2:
		{
			p.SetState(2983)
			p.QueryExpression()
		}
		p.SetState(2985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
			{
				p.SetState(2984)
				p.LockingClauseList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(2989)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySpecification() IQuerySpecificationContext
	TableValueConstructor() ITableValueConstructorContext
	ExplicitTable() IExplicitTableContext

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryContext) TableValueConstructor() ITableValueConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableValueConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableValueConstructorContext)
}

func (s *QueryPrimaryContext) ExplicitTable() IExplicitTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitTableContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQueryPrimary(s)
	}
}

func (s *QueryPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQueryPrimary(s)
	}
}

func (s *QueryPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQueryPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, MySQLParserRULE_queryPrimary)
	p.SetState(2996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 297, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2991)
			p.QuerySpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2992)

		if !(serverVersion >= 80019) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
			goto errorExit
		}
		{
			p.SetState(2993)
			p.TableValueConstructor()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(2994)

		if !(serverVersion >= 80019) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
			goto errorExit
		}
		{
			p.SetState(2995)
			p.ExplicitTable()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT_SYMBOL() antlr.TerminalNode
	SelectItemList() ISelectItemListContext
	AllSelectOption() []ISelectOptionContext
	SelectOption(i int) ISelectOptionContext
	IntoClause() IIntoClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSELECT_SYMBOL, 0)
}

func (s *QuerySpecificationContext) SelectItemList() ISelectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemListContext)
}

func (s *QuerySpecificationContext) AllSelectOption() []ISelectOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectOptionContext); ok {
			len++
		}
	}

	tst := make([]ISelectOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectOptionContext); ok {
			tst[i] = t.(ISelectOptionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectOption(i int) ISelectOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectOptionContext)
}

func (s *QuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, MySQLParserRULE_querySpecification)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2998)
		p.Match(MySQLParserSELECT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2999)
				p.SelectOption()
			}

		}
		p.SetState(3004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 298, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(3005)
		p.SelectItemList()
	}
	p.SetState(3007)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 299, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3006)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3010)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3009)
			p.FromClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 301, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3012)
			p.WhereClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3016)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 302, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3015)
			p.GroupByClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3019)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 303, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3018)
			p.HavingClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3023)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 304, p.GetParserRuleContext()) == 1 {
		p.SetState(3021)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3022)
			p.WindowClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionParens() IQueryExpressionParensContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, MySQLParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3025)
		p.QueryExpressionParens()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecOptionContext is an interface to support dynamic dispatch.
type IQuerySpecOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode
	HIGH_PRIORITY_SYMBOL() antlr.TerminalNode
	SQL_SMALL_RESULT_SYMBOL() antlr.TerminalNode
	SQL_BIG_RESULT_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS_SYMBOL() antlr.TerminalNode

	// IsQuerySpecOptionContext differentiates from other interfaces.
	IsQuerySpecOptionContext()
}

type QuerySpecOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecOptionContext() *QuerySpecOptionContext {
	var p = new(QuerySpecOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_querySpecOption
	return p
}

func InitEmptyQuerySpecOptionContext(p *QuerySpecOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_querySpecOption
}

func (*QuerySpecOptionContext) IsQuerySpecOptionContext() {}

func NewQuerySpecOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecOptionContext {
	var p = new(QuerySpecOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_querySpecOption

	return p
}

func (s *QuerySpecOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISTINCT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTRAIGHT_JOIN_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) HIGH_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHIGH_PRIORITY_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_SMALL_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_SMALL_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_BIG_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BIG_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_CALC_FOUND_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_CALC_FOUND_ROWS_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQuerySpecOption(s)
	}
}

func (s *QuerySpecOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQuerySpecOption(s)
	}
}

func (s *QuerySpecOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQuerySpecOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QuerySpecOption() (localctx IQuerySpecOptionContext) {
	localctx = NewQuerySpecOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, MySQLParserRULE_querySpecOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserALL_SYMBOL || _la == MySQLParserDISTINCT_SYMBOL || _la == MySQLParserHIGH_PRIORITY_SYMBOL || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&16777259) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	LimitOptions() ILimitOptionsContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIMIT_SYMBOL, 0)
}

func (s *LimitClauseContext) LimitOptions() ILimitOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionsContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, MySQLParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3029)
		p.Match(MySQLParserLIMIT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3030)
		p.LimitOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLimitClauseContext is an interface to support dynamic dispatch.
type ISimpleLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	LimitOption() ILimitOptionContext

	// IsSimpleLimitClauseContext differentiates from other interfaces.
	IsSimpleLimitClauseContext()
}

type SimpleLimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLimitClauseContext() *SimpleLimitClauseContext {
	var p = new(SimpleLimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleLimitClause
	return p
}

func InitEmptySimpleLimitClauseContext(p *SimpleLimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleLimitClause
}

func (*SimpleLimitClauseContext) IsSimpleLimitClauseContext() {}

func NewSimpleLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLimitClauseContext {
	var p = new(SimpleLimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_simpleLimitClause

	return p
}

func (s *SimpleLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLimitClauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIMIT_SYMBOL, 0)
}

func (s *SimpleLimitClauseContext) LimitOption() ILimitOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionContext)
}

func (s *SimpleLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleLimitClause(s)
	}
}

func (s *SimpleLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleLimitClause(s)
	}
}

func (s *SimpleLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SimpleLimitClause() (localctx ISimpleLimitClauseContext) {
	localctx = NewSimpleLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, MySQLParserRULE_simpleLimitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3032)
		p.Match(MySQLParserLIMIT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.LimitOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitOptionsContext is an interface to support dynamic dispatch.
type ILimitOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLimitOption() []ILimitOptionContext
	LimitOption(i int) ILimitOptionContext
	COMMA_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode

	// IsLimitOptionsContext differentiates from other interfaces.
	IsLimitOptionsContext()
}

type LimitOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitOptionsContext() *LimitOptionsContext {
	var p = new(LimitOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitOptions
	return p
}

func InitEmptyLimitOptionsContext(p *LimitOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitOptions
}

func (*LimitOptionsContext) IsLimitOptionsContext() {}

func NewLimitOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitOptionsContext {
	var p = new(LimitOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_limitOptions

	return p
}

func (s *LimitOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitOptionsContext) AllLimitOption() []ILimitOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitOptionContext); ok {
			len++
		}
	}

	tst := make([]ILimitOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitOptionContext); ok {
			tst[i] = t.(ILimitOptionContext)
			i++
		}
	}

	return tst
}

func (s *LimitOptionsContext) LimitOption(i int) ILimitOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionContext)
}

func (s *LimitOptionsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *LimitOptionsContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFFSET_SYMBOL, 0)
}

func (s *LimitOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLimitOptions(s)
	}
}

func (s *LimitOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLimitOptions(s)
	}
}

func (s *LimitOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLimitOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LimitOptions() (localctx ILimitOptionsContext) {
	localctx = NewLimitOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, MySQLParserRULE_limitOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.LimitOption()
	}
	p.SetState(3038)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 305, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3036)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserOFFSET_SYMBOL || _la == MySQLParserCOMMA_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3037)
			p.LimitOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitOptionContext is an interface to support dynamic dispatch.
type ILimitOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	PARAM_MARKER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode

	// IsLimitOptionContext differentiates from other interfaces.
	IsLimitOptionContext()
}

type LimitOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitOptionContext() *LimitOptionContext {
	var p = new(LimitOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitOption
	return p
}

func InitEmptyLimitOptionContext(p *LimitOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_limitOption
}

func (*LimitOptionContext) IsLimitOptionContext() {}

func NewLimitOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitOptionContext {
	var p = new(LimitOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_limitOption

	return p
}

func (s *LimitOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LimitOptionContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARAM_MARKER, 0)
}

func (s *LimitOptionContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *LimitOptionContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *LimitOptionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *LimitOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLimitOption(s)
	}
}

func (s *LimitOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLimitOption(s)
	}
}

func (s *LimitOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLimitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LimitOption() (localctx ILimitOptionContext) {
	localctx = NewLimitOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, MySQLParserRULE_limitOption)
	var _la int

	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 306, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3040)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3041)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&1099511627783) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO_SYMBOL() antlr.TerminalNode
	OUTFILE_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	DUMPFILE_SYMBOL() antlr.TerminalNode
	AllTextOrIdentifier() []ITextOrIdentifierContext
	TextOrIdentifier(i int) ITextOrIdentifierContext
	AllUserVariable() []IUserVariableContext
	UserVariable(i int) IUserVariableContext
	CharsetClause() ICharsetClauseContext
	FieldsClause() IFieldsClauseContext
	LinesClause() ILinesClauseContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *IntoClauseContext) OUTFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOUTFILE_SYMBOL, 0)
}

func (s *IntoClauseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *IntoClauseContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUMPFILE_SYMBOL, 0)
}

func (s *IntoClauseContext) AllTextOrIdentifier() []ITextOrIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITextOrIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextOrIdentifierContext); ok {
			tst[i] = t.(ITextOrIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TextOrIdentifier(i int) ITextOrIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *IntoClauseContext) AllUserVariable() []IUserVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserVariableContext); ok {
			len++
		}
	}

	tst := make([]IUserVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserVariableContext); ok {
			tst[i] = t.(IUserVariableContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) UserVariable(i int) IUserVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *IntoClauseContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *IntoClauseContext) FieldsClause() IFieldsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsClauseContext)
}

func (s *IntoClauseContext) LinesClause() ILinesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinesClauseContext)
}

func (s *IntoClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *IntoClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIntoClause(s)
	}
}

func (s *IntoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIntoClause(s)
	}
}

func (s *IntoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIntoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, MySQLParserRULE_intoClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3044)
		p.Match(MySQLParserINTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3072)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 313, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3045)
			p.Match(MySQLParserOUTFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3046)
			p.TextStringLiteral()
		}
		p.SetState(3048)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 307, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3047)
				p.CharsetClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3051)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 308, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3050)
				p.FieldsClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3054)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 309, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3053)
				p.LinesClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		{
			p.SetState(3056)
			p.Match(MySQLParserDUMPFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3057)
			p.TextStringLiteral()
		}

	case 3:
		p.SetState(3060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3058)
				p.TextOrIdentifier()
			}

		case 2:
			{
				p.SetState(3059)
				p.UserVariable()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3062)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3065)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 311, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(3063)
						p.TextOrIdentifier()
					}

				case 2:
					{
						p.SetState(3064)
						p.UserVariable()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(3071)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 312, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureAnalyseClauseContext is an interface to support dynamic dispatch.
type IProcedureAnalyseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_SYMBOL() antlr.TerminalNode
	ANALYSE_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsProcedureAnalyseClauseContext differentiates from other interfaces.
	IsProcedureAnalyseClauseContext()
}

type ProcedureAnalyseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureAnalyseClauseContext() *ProcedureAnalyseClauseContext {
	var p = new(ProcedureAnalyseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureAnalyseClause
	return p
}

func InitEmptyProcedureAnalyseClauseContext(p *ProcedureAnalyseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureAnalyseClause
}

func (*ProcedureAnalyseClauseContext) IsProcedureAnalyseClauseContext() {}

func NewProcedureAnalyseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureAnalyseClauseContext {
	var p = new(ProcedureAnalyseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_procedureAnalyseClause

	return p
}

func (s *ProcedureAnalyseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureAnalyseClauseContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) ANALYSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANALYSE_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserINT_NUMBER)
}

func (s *ProcedureAnalyseClauseContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, i)
}

func (s *ProcedureAnalyseClauseContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureAnalyseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureAnalyseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterProcedureAnalyseClause(s)
	}
}

func (s *ProcedureAnalyseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitProcedureAnalyseClause(s)
	}
}

func (s *ProcedureAnalyseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitProcedureAnalyseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ProcedureAnalyseClause() (localctx IProcedureAnalyseClauseContext) {
	localctx = NewProcedureAnalyseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, MySQLParserRULE_procedureAnalyseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3074)
		p.Match(MySQLParserPROCEDURE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3075)
		p.Match(MySQLParserANALYSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3076)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3082)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserINT_NUMBER {
		{
			p.SetState(3077)
			p.Match(MySQLParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3080)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(3078)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3079)
				p.Match(MySQLParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(3084)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHAVING_SYMBOL, 0)
}

func (s *HavingClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, MySQLParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3086)
		p.Match(MySQLParserHAVING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3087)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW_SYMBOL() antlr.TerminalNode
	AllWindowDefinition() []IWindowDefinitionContext
	WindowDefinition(i int) IWindowDefinitionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWINDOW_SYMBOL, 0)
}

func (s *WindowClauseContext) AllWindowDefinition() []IWindowDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IWindowDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowDefinitionContext); ok {
			tst[i] = t.(IWindowDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowDefinition(i int) IWindowDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowDefinitionContext)
}

func (s *WindowClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *WindowClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, MySQLParserRULE_windowClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3089)
		p.Match(MySQLParserWINDOW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3090)
		p.WindowDefinition()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3091)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3092)
				p.WindowDefinition()
			}

		}
		p.SetState(3097)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 316, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowDefinitionContext is an interface to support dynamic dispatch.
type IWindowDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	AS_SYMBOL() antlr.TerminalNode
	WindowSpec() IWindowSpecContext

	// IsWindowDefinitionContext differentiates from other interfaces.
	IsWindowDefinitionContext()
}

type WindowDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowDefinitionContext() *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowDefinition
	return p
}

func InitEmptyWindowDefinitionContext(p *WindowDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowDefinition
}

func (*WindowDefinitionContext) IsWindowDefinitionContext() {}

func NewWindowDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowDefinition

	return p
}

func (s *WindowDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowDefinitionContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowDefinitionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *WindowDefinitionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowDefinition() (localctx IWindowDefinitionContext) {
	localctx = NewWindowDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, MySQLParserRULE_windowDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3098)
		p.WindowName()
	}
	{
		p.SetState(3099)
		p.Match(MySQLParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3100)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	WindowSpecDetails() IWindowSpecDetailsContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *WindowSpecContext) WindowSpecDetails() IWindowSpecDetailsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecDetailsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecDetailsContext)
}

func (s *WindowSpecContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, MySQLParserRULE_windowSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3102)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3103)
		p.WindowSpecDetails()
	}
	{
		p.SetState(3104)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecDetailsContext is an interface to support dynamic dispatch.
type IWindowSpecDetailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext
	OrderClause() IOrderClauseContext
	WindowFrameClause() IWindowFrameClauseContext

	// IsWindowSpecDetailsContext differentiates from other interfaces.
	IsWindowSpecDetailsContext()
}

type WindowSpecDetailsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecDetailsContext() *WindowSpecDetailsContext {
	var p = new(WindowSpecDetailsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowSpecDetails
	return p
}

func InitEmptyWindowSpecDetailsContext(p *WindowSpecDetailsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowSpecDetails
}

func (*WindowSpecDetailsContext) IsWindowSpecDetailsContext() {}

func NewWindowSpecDetailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecDetailsContext {
	var p = new(WindowSpecDetailsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowSpecDetails

	return p
}

func (s *WindowSpecDetailsContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecDetailsContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecDetailsContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *WindowSpecDetailsContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *WindowSpecDetailsContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *WindowSpecDetailsContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *WindowSpecDetailsContext) WindowFrameClause() IWindowFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameClauseContext)
}

func (s *WindowSpecDetailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecDetailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecDetailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowSpecDetails(s)
	}
}

func (s *WindowSpecDetailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowSpecDetails(s)
	}
}

func (s *WindowSpecDetailsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowSpecDetails(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowSpecDetails() (localctx IWindowSpecDetailsContext) {
	localctx = NewWindowSpecDetailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, MySQLParserRULE_windowSpecDetails)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3107)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 317, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3106)
			p.WindowName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserPARTITION_SYMBOL {
		{
			p.SetState(3109)
			p.Match(MySQLParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3110)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3111)
			p.OrderList()
		}

	}
	p.SetState(3115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserORDER_SYMBOL {
		{
			p.SetState(3114)
			p.OrderClause()
		}

	}
	p.SetState(3118)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserRANGE_SYMBOL || _la == MySQLParserROWS_SYMBOL || _la == MySQLParserGROUPS_SYMBOL {
		{
			p.SetState(3117)
			p.WindowFrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameClauseContext is an interface to support dynamic dispatch.
type IWindowFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameUnits() IWindowFrameUnitsContext
	WindowFrameExtent() IWindowFrameExtentContext
	WindowFrameExclusion() IWindowFrameExclusionContext

	// IsWindowFrameClauseContext differentiates from other interfaces.
	IsWindowFrameClauseContext()
}

type WindowFrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameClauseContext() *WindowFrameClauseContext {
	var p = new(WindowFrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameClause
	return p
}

func InitEmptyWindowFrameClauseContext(p *WindowFrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameClause
}

func (*WindowFrameClauseContext) IsWindowFrameClauseContext() {}

func NewWindowFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameClauseContext {
	var p = new(WindowFrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameClause

	return p
}

func (s *WindowFrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameClauseContext) WindowFrameUnits() IWindowFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameUnitsContext)
}

func (s *WindowFrameClauseContext) WindowFrameExtent() IWindowFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameExtentContext)
}

func (s *WindowFrameClauseContext) WindowFrameExclusion() IWindowFrameExclusionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameExclusionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameExclusionContext)
}

func (s *WindowFrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameClause(s)
	}
}

func (s *WindowFrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameClause(s)
	}
}

func (s *WindowFrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameClause() (localctx IWindowFrameClauseContext) {
	localctx = NewWindowFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, MySQLParserRULE_windowFrameClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3120)
		p.WindowFrameUnits()
	}
	{
		p.SetState(3121)
		p.WindowFrameExtent()
	}
	p.SetState(3123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserEXCLUDE_SYMBOL {
		{
			p.SetState(3122)
			p.WindowFrameExclusion()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameUnitsContext is an interface to support dynamic dispatch.
type IWindowFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS_SYMBOL() antlr.TerminalNode
	RANGE_SYMBOL() antlr.TerminalNode
	GROUPS_SYMBOL() antlr.TerminalNode

	// IsWindowFrameUnitsContext differentiates from other interfaces.
	IsWindowFrameUnitsContext()
}

type WindowFrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameUnitsContext() *WindowFrameUnitsContext {
	var p = new(WindowFrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameUnits
	return p
}

func InitEmptyWindowFrameUnitsContext(p *WindowFrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameUnits
}

func (*WindowFrameUnitsContext) IsWindowFrameUnitsContext() {}

func NewWindowFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameUnitsContext {
	var p = new(WindowFrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameUnits

	return p
}

func (s *WindowFrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameUnitsContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROWS_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANGE_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) GROUPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUPS_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameUnits(s)
	}
}

func (s *WindowFrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameUnits(s)
	}
}

func (s *WindowFrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameUnits() (localctx IWindowFrameUnitsContext) {
	localctx = NewWindowFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, MySQLParserRULE_windowFrameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3125)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserRANGE_SYMBOL || _la == MySQLParserROWS_SYMBOL || _la == MySQLParserGROUPS_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameExtentContext is an interface to support dynamic dispatch.
type IWindowFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameStart() IWindowFrameStartContext
	WindowFrameBetween() IWindowFrameBetweenContext

	// IsWindowFrameExtentContext differentiates from other interfaces.
	IsWindowFrameExtentContext()
}

type WindowFrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameExtentContext() *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameExtent
	return p
}

func InitEmptyWindowFrameExtentContext(p *WindowFrameExtentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameExtent
}

func (*WindowFrameExtentContext) IsWindowFrameExtentContext() {}

func NewWindowFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameExtent

	return p
}

func (s *WindowFrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameExtentContext) WindowFrameStart() IWindowFrameStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameStartContext)
}

func (s *WindowFrameExtentContext) WindowFrameBetween() IWindowFrameBetweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBetweenContext)
}

func (s *WindowFrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameExtent() (localctx IWindowFrameExtentContext) {
	localctx = NewWindowFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, MySQLParserRULE_windowFrameExtent)
	p.SetState(3129)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCURRENT_SYMBOL, MySQLParserINTERVAL_SYMBOL, MySQLParserUNBOUNDED_SYMBOL, MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserPARAM_MARKER, MySQLParserDECIMAL_NUMBER, MySQLParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3127)
			p.WindowFrameStart()
		}

	case MySQLParserBETWEEN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3128)
			p.WindowFrameBetween()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameStartContext is an interface to support dynamic dispatch.
type IWindowFrameStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext
	CURRENT_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode

	// IsWindowFrameStartContext differentiates from other interfaces.
	IsWindowFrameStartContext()
}

type WindowFrameStartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameStartContext() *WindowFrameStartContext {
	var p = new(WindowFrameStartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameStart
	return p
}

func InitEmptyWindowFrameStartContext(p *WindowFrameStartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameStart
}

func (*WindowFrameStartContext) IsWindowFrameStartContext() {}

func NewWindowFrameStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameStartContext {
	var p = new(WindowFrameStartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameStart

	return p
}

func (s *WindowFrameStartContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameStartContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *WindowFrameStartContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDING_SYMBOL, 0)
}

func (s *WindowFrameStartContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *WindowFrameStartContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARAM_MARKER, 0)
}

func (s *WindowFrameStartContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *WindowFrameStartContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFrameStartContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *WindowFrameStartContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *WindowFrameStartContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *WindowFrameStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameStart(s)
	}
}

func (s *WindowFrameStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameStart(s)
	}
}

func (s *WindowFrameStartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameStart() (localctx IWindowFrameStartContext) {
	localctx = NewWindowFrameStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, MySQLParserRULE_windowFrameStart)
	p.SetState(3145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserUNBOUNDED_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3131)
			p.Match(MySQLParserUNBOUNDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3132)
			p.Match(MySQLParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserDECIMAL_NUMBER, MySQLParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3133)
			p.Ulonglong_number()
		}
		{
			p.SetState(3134)
			p.Match(MySQLParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserPARAM_MARKER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3136)
			p.Match(MySQLParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3137)
			p.Match(MySQLParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserINTERVAL_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3138)
			p.Match(MySQLParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3139)
			p.expr(0)
		}
		{
			p.SetState(3140)
			p.Interval()
		}
		{
			p.SetState(3141)
			p.Match(MySQLParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCURRENT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3143)
			p.Match(MySQLParserCURRENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3144)
			p.Match(MySQLParserROW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameBetweenContext is an interface to support dynamic dispatch.
type IWindowFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN_SYMBOL() antlr.TerminalNode
	AllWindowFrameBound() []IWindowFrameBoundContext
	WindowFrameBound(i int) IWindowFrameBoundContext
	AND_SYMBOL() antlr.TerminalNode

	// IsWindowFrameBetweenContext differentiates from other interfaces.
	IsWindowFrameBetweenContext()
}

type WindowFrameBetweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBetweenContext() *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameBetween
	return p
}

func InitEmptyWindowFrameBetweenContext(p *WindowFrameBetweenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameBetween
}

func (*WindowFrameBetweenContext) IsWindowFrameBetweenContext() {}

func NewWindowFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameBetween

	return p
}

func (s *WindowFrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBetweenContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBETWEEN_SYMBOL, 0)
}

func (s *WindowFrameBetweenContext) AllWindowFrameBound() []IWindowFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IWindowFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowFrameBoundContext); ok {
			tst[i] = t.(IWindowFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameBetweenContext) WindowFrameBound(i int) IWindowFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBoundContext)
}

func (s *WindowFrameBetweenContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, 0)
}

func (s *WindowFrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameBetween() (localctx IWindowFrameBetweenContext) {
	localctx = NewWindowFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, MySQLParserRULE_windowFrameBetween)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3147)
		p.Match(MySQLParserBETWEEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3148)
		p.WindowFrameBound()
	}
	{
		p.SetState(3149)
		p.Match(MySQLParserAND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3150)
		p.WindowFrameBound()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameBoundContext is an interface to support dynamic dispatch.
type IWindowFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameStart() IWindowFrameStartContext
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext

	// IsWindowFrameBoundContext differentiates from other interfaces.
	IsWindowFrameBoundContext()
}

type WindowFrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBoundContext() *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameBound
	return p
}

func InitEmptyWindowFrameBoundContext(p *WindowFrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameBound
}

func (*WindowFrameBoundContext) IsWindowFrameBoundContext() {}

func NewWindowFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameBound

	return p
}

func (s *WindowFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBoundContext) WindowFrameStart() IWindowFrameStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameStartContext)
}

func (s *WindowFrameBoundContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWING_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *WindowFrameBoundContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARAM_MARKER, 0)
}

func (s *WindowFrameBoundContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFrameBoundContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *WindowFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameBound() (localctx IWindowFrameBoundContext) {
	localctx = NewWindowFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, MySQLParserRULE_windowFrameBound)
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3152)
			p.WindowFrameStart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3153)
			p.Match(MySQLParserUNBOUNDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3154)
			p.Match(MySQLParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3155)
			p.Ulonglong_number()
		}
		{
			p.SetState(3156)
			p.Match(MySQLParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3158)
			p.Match(MySQLParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3159)
			p.Match(MySQLParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3160)
			p.Match(MySQLParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3161)
			p.expr(0)
		}
		{
			p.SetState(3162)
			p.Interval()
		}
		{
			p.SetState(3163)
			p.Match(MySQLParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameExclusionContext is an interface to support dynamic dispatch.
type IWindowFrameExclusionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLUDE_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode

	// IsWindowFrameExclusionContext differentiates from other interfaces.
	IsWindowFrameExclusionContext()
}

type WindowFrameExclusionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameExclusionContext() *WindowFrameExclusionContext {
	var p = new(WindowFrameExclusionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameExclusion
	return p
}

func InitEmptyWindowFrameExclusionContext(p *WindowFrameExclusionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFrameExclusion
}

func (*WindowFrameExclusionContext) IsWindowFrameExclusionContext() {}

func NewWindowFrameExclusionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameExclusionContext {
	var p = new(WindowFrameExclusionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFrameExclusion

	return p
}

func (s *WindowFrameExclusionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameExclusionContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCLUDE_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIES_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOTHERS_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameExclusionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameExclusionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFrameExclusion(s)
	}
}

func (s *WindowFrameExclusionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFrameExclusion(s)
	}
}

func (s *WindowFrameExclusionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFrameExclusion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFrameExclusion() (localctx IWindowFrameExclusionContext) {
	localctx = NewWindowFrameExclusionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, MySQLParserRULE_windowFrameExclusion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3167)
		p.Match(MySQLParserEXCLUDE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCURRENT_SYMBOL:
		{
			p.SetState(3168)
			p.Match(MySQLParserCURRENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.Match(MySQLParserROW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserGROUP_SYMBOL:
		{
			p.SetState(3170)
			p.Match(MySQLParserGROUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserTIES_SYMBOL:
		{
			p.SetState(3171)
			p.Match(MySQLParserTIES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserNO_SYMBOL:
		{
			p.SetState(3172)
			p.Match(MySQLParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3173)
			p.Match(MySQLParserOTHERS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext
	RECURSIVE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) RECURSIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRECURSIVE_SYMBOL, 0)
}

func (s *WithClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *WithClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, MySQLParserRULE_withClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3176)
		p.Match(MySQLParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3178)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3177)
			p.Match(MySQLParserRECURSIVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3180)
		p.CommonTableExpression()
	}
	p.SetState(3185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3181)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3182)
				p.CommonTableExpression()
			}

		}
		p.SetState(3187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 327, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	Subquery() ISubqueryContext
	ColumnInternalRefList() IColumnInternalRefListContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *CommonTableExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *CommonTableExpressionContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCommonTableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, MySQLParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3188)
		p.Identifier()
	}
	p.SetState(3190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(3189)
			p.ColumnInternalRefList()
		}

	}
	{
		p.SetState(3192)
		p.Match(MySQLParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3193)
		p.Subquery()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext
	OlapOption() IOlapOptionContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *GroupByClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *GroupByClauseContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *GroupByClauseContext) OlapOption() IOlapOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOlapOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOlapOptionContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, MySQLParserRULE_groupByClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3196)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3197)
		p.OrderList()
	}
	p.SetState(3199)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 329, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3198)
			p.OlapOption()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOlapOptionContext is an interface to support dynamic dispatch.
type IOlapOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	CUBE_SYMBOL() antlr.TerminalNode

	// IsOlapOptionContext differentiates from other interfaces.
	IsOlapOptionContext()
}

type OlapOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOlapOptionContext() *OlapOptionContext {
	var p = new(OlapOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_olapOption
	return p
}

func InitEmptyOlapOptionContext(p *OlapOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_olapOption
}

func (*OlapOptionContext) IsOlapOptionContext() {}

func NewOlapOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OlapOptionContext {
	var p = new(OlapOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_olapOption

	return p
}

func (s *OlapOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OlapOptionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *OlapOptionContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLUP_SYMBOL, 0)
}

func (s *OlapOptionContext) CUBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCUBE_SYMBOL, 0)
}

func (s *OlapOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OlapOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OlapOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOlapOption(s)
	}
}

func (s *OlapOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOlapOption(s)
	}
}

func (s *OlapOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOlapOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OlapOption() (localctx IOlapOptionContext) {
	localctx = NewOlapOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, MySQLParserRULE_olapOption)
	p.SetState(3206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 330, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3201)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3202)
			p.Match(MySQLParserROLLUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3203)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3204)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3205)
			p.Match(MySQLParserCUBE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderClauseContext is an interface to support dynamic dispatch.
type IOrderClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext

	// IsOrderClauseContext differentiates from other interfaces.
	IsOrderClauseContext()
}

type OrderClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderClauseContext() *OrderClauseContext {
	var p = new(OrderClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderClause
	return p
}

func InitEmptyOrderClauseContext(p *OrderClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderClause
}

func (*OrderClauseContext) IsOrderClauseContext() {}

func NewOrderClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderClauseContext {
	var p = new(OrderClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_orderClause

	return p
}

func (s *OrderClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderClauseContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDER_SYMBOL, 0)
}

func (s *OrderClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *OrderClauseContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *OrderClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOrderClause(s)
	}
}

func (s *OrderClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOrderClause(s)
	}
}

func (s *OrderClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOrderClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OrderClause() (localctx IOrderClauseContext) {
	localctx = NewOrderClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, MySQLParserRULE_orderClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3208)
		p.Match(MySQLParserORDER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3209)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3210)
		p.OrderList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectionContext is an interface to support dynamic dispatch.
type IDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsDirectionContext differentiates from other interfaces.
	IsDirectionContext()
}

type DirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectionContext() *DirectionContext {
	var p = new(DirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_direction
	return p
}

func InitEmptyDirectionContext(p *DirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_direction
}

func (*DirectionContext) IsDirectionContext() {}

func NewDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionContext {
	var p = new(DirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_direction

	return p
}

func (s *DirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASC_SYMBOL, 0)
}

func (s *DirectionContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESC_SYMBOL, 0)
}

func (s *DirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDirection(s)
	}
}

func (s *DirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDirection(s)
	}
}

func (s *DirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDirection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Direction() (localctx IDirectionContext) {
	localctx = NewDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, MySQLParserRULE_direction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3212)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM_SYMBOL() antlr.TerminalNode
	DUAL_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *FromClauseContext) DUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUAL_SYMBOL, 0)
}

func (s *FromClauseContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, MySQLParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3214)
		p.Match(MySQLParserFROM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 331, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3215)
			p.Match(MySQLParserDUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(3216)
			p.TableReferenceList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceListContext is an interface to support dynamic dispatch.
type ITableReferenceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableReference() []ITableReferenceContext
	TableReference(i int) ITableReferenceContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableReferenceListContext differentiates from other interfaces.
	IsTableReferenceListContext()
}

type TableReferenceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceListContext() *TableReferenceListContext {
	var p = new(TableReferenceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReferenceList
	return p
}

func InitEmptyTableReferenceListContext(p *TableReferenceListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReferenceList
}

func (*TableReferenceListContext) IsTableReferenceListContext() {}

func NewTableReferenceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceListContext {
	var p = new(TableReferenceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableReferenceList

	return p
}

func (s *TableReferenceListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceListContext) AllTableReference() []ITableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableReferenceContext); ok {
			tst[i] = t.(ITableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *TableReferenceListContext) TableReference(i int) ITableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *TableReferenceListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TableReferenceListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TableReferenceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableReferenceList(s)
	}
}

func (s *TableReferenceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableReferenceList(s)
	}
}

func (s *TableReferenceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableReferenceList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableReferenceList() (localctx ITableReferenceListContext) {
	localctx = NewTableReferenceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, MySQLParserRULE_tableReferenceList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3219)
		p.TableReference()
	}
	p.SetState(3224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3220)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3221)
				p.TableReference()
			}

		}
		p.SetState(3226)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableValueConstructorContext is an interface to support dynamic dispatch.
type ITableValueConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES_SYMBOL() antlr.TerminalNode
	AllRowValueExplicit() []IRowValueExplicitContext
	RowValueExplicit(i int) IRowValueExplicitContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableValueConstructorContext differentiates from other interfaces.
	IsTableValueConstructorContext()
}

type TableValueConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableValueConstructorContext() *TableValueConstructorContext {
	var p = new(TableValueConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableValueConstructor
	return p
}

func InitEmptyTableValueConstructorContext(p *TableValueConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableValueConstructor
}

func (*TableValueConstructorContext) IsTableValueConstructorContext() {}

func NewTableValueConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableValueConstructorContext {
	var p = new(TableValueConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableValueConstructor

	return p
}

func (s *TableValueConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableValueConstructorContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUES_SYMBOL, 0)
}

func (s *TableValueConstructorContext) AllRowValueExplicit() []IRowValueExplicitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowValueExplicitContext); ok {
			len++
		}
	}

	tst := make([]IRowValueExplicitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowValueExplicitContext); ok {
			tst[i] = t.(IRowValueExplicitContext)
			i++
		}
	}

	return tst
}

func (s *TableValueConstructorContext) RowValueExplicit(i int) IRowValueExplicitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowValueExplicitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowValueExplicitContext)
}

func (s *TableValueConstructorContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TableValueConstructorContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TableValueConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValueConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableValueConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableValueConstructor(s)
	}
}

func (s *TableValueConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableValueConstructor(s)
	}
}

func (s *TableValueConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableValueConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableValueConstructor() (localctx ITableValueConstructorContext) {
	localctx = NewTableValueConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, MySQLParserRULE_tableValueConstructor)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		p.Match(MySQLParserVALUES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3228)
		p.RowValueExplicit()
	}
	p.SetState(3233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3229)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3230)
				p.RowValueExplicit()
			}

		}
		p.SetState(3235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitTableContext is an interface to support dynamic dispatch.
type IExplicitTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext

	// IsExplicitTableContext differentiates from other interfaces.
	IsExplicitTableContext()
}

type ExplicitTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitTableContext() *ExplicitTableContext {
	var p = new(ExplicitTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explicitTable
	return p
}

func InitEmptyExplicitTableContext(p *ExplicitTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explicitTable
}

func (*ExplicitTableContext) IsExplicitTableContext() {}

func NewExplicitTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitTableContext {
	var p = new(ExplicitTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_explicitTable

	return p
}

func (s *ExplicitTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitTableContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *ExplicitTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ExplicitTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExplicitTable(s)
	}
}

func (s *ExplicitTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExplicitTable(s)
	}
}

func (s *ExplicitTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExplicitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExplicitTable() (localctx IExplicitTableContext) {
	localctx = NewExplicitTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, MySQLParserRULE_explicitTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3236)
		p.Match(MySQLParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3237)
		p.TableRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowValueExplicitContext is an interface to support dynamic dispatch.
type IRowValueExplicitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROW_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Values() IValuesContext

	// IsRowValueExplicitContext differentiates from other interfaces.
	IsRowValueExplicitContext()
}

type RowValueExplicitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowValueExplicitContext() *RowValueExplicitContext {
	var p = new(RowValueExplicitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_rowValueExplicit
	return p
}

func InitEmptyRowValueExplicitContext(p *RowValueExplicitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_rowValueExplicit
}

func (*RowValueExplicitContext) IsRowValueExplicitContext() {}

func NewRowValueExplicitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowValueExplicitContext {
	var p = new(RowValueExplicitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_rowValueExplicit

	return p
}

func (s *RowValueExplicitContext) GetParser() antlr.Parser { return s.parser }

func (s *RowValueExplicitContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *RowValueExplicitContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *RowValueExplicitContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *RowValueExplicitContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *RowValueExplicitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowValueExplicitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowValueExplicitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRowValueExplicit(s)
	}
}

func (s *RowValueExplicitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRowValueExplicit(s)
	}
}

func (s *RowValueExplicitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRowValueExplicit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RowValueExplicit() (localctx IRowValueExplicitContext) {
	localctx = NewRowValueExplicitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, MySQLParserRULE_rowValueExplicit)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3239)
		p.Match(MySQLParserROW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3240)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3242)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3241)
			p.Values()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3244)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectOptionContext is an interface to support dynamic dispatch.
type ISelectOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySpecOption() IQuerySpecOptionContext
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_CACHE_SYMBOL() antlr.TerminalNode
	MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext

	// IsSelectOptionContext differentiates from other interfaces.
	IsSelectOptionContext()
}

type SelectOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectOptionContext() *SelectOptionContext {
	var p = new(SelectOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectOption
	return p
}

func InitEmptySelectOptionContext(p *SelectOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectOption
}

func (*SelectOptionContext) IsSelectOptionContext() {}

func NewSelectOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectOptionContext {
	var p = new(SelectOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectOption

	return p
}

func (s *SelectOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectOptionContext) QuerySpecOption() IQuerySpecOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecOptionContext)
}

func (s *SelectOptionContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *SelectOptionContext) SQL_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_CACHE_SYMBOL, 0)
}

func (s *SelectOptionContext) MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_STATEMENT_TIME_SYMBOL, 0)
}

func (s *SelectOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *SelectOptionContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *SelectOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectOption(s)
	}
}

func (s *SelectOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectOption(s)
	}
}

func (s *SelectOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectOption() (localctx ISelectOptionContext) {
	localctx = NewSelectOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, MySQLParserRULE_selectOption)
	p.SetState(3254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3246)
			p.QuerySpecOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3247)
			p.Match(MySQLParserSQL_NO_CACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(3248)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3249)
			p.Match(MySQLParserSQL_CACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3250)

		if !(serverVersion >= 50704 && serverVersion < 50708) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50704 && serverVersion < 50708", ""))
			goto errorExit
		}
		{
			p.SetState(3251)
			p.Match(MySQLParserMAX_STATEMENT_TIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3252)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3253)
			p.Real_ulong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockingClauseListContext is an interface to support dynamic dispatch.
type ILockingClauseListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLockingClause() []ILockingClauseContext
	LockingClause(i int) ILockingClauseContext

	// IsLockingClauseListContext differentiates from other interfaces.
	IsLockingClauseListContext()
}

type LockingClauseListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockingClauseListContext() *LockingClauseListContext {
	var p = new(LockingClauseListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockingClauseList
	return p
}

func InitEmptyLockingClauseListContext(p *LockingClauseListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockingClauseList
}

func (*LockingClauseListContext) IsLockingClauseListContext() {}

func NewLockingClauseListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockingClauseListContext {
	var p = new(LockingClauseListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockingClauseList

	return p
}

func (s *LockingClauseListContext) GetParser() antlr.Parser { return s.parser }

func (s *LockingClauseListContext) AllLockingClause() []ILockingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockingClauseContext); ok {
			len++
		}
	}

	tst := make([]ILockingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockingClauseContext); ok {
			tst[i] = t.(ILockingClauseContext)
			i++
		}
	}

	return tst
}

func (s *LockingClauseListContext) LockingClause(i int) ILockingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseContext)
}

func (s *LockingClauseListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockingClauseListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockingClauseListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockingClauseList(s)
	}
}

func (s *LockingClauseListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockingClauseList(s)
	}
}

func (s *LockingClauseListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockingClauseList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockingClauseList() (localctx ILockingClauseListContext) {
	localctx = NewLockingClauseListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, MySQLParserRULE_lockingClauseList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySQLParserFOR_SYMBOL || _la == MySQLParserLOCK_SYMBOL {
		{
			p.SetState(3256)
			p.LockingClause()
		}

		p.SetState(3259)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockingClauseContext is an interface to support dynamic dispatch.
type ILockingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	LockStrengh() ILockStrenghContext
	OF_SYMBOL() antlr.TerminalNode
	TableAliasRefList() ITableAliasRefListContext
	LockedRowAction() ILockedRowActionContext
	LOCK_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode

	// IsLockingClauseContext differentiates from other interfaces.
	IsLockingClauseContext()
}

type LockingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockingClauseContext() *LockingClauseContext {
	var p = new(LockingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockingClause
	return p
}

func InitEmptyLockingClauseContext(p *LockingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockingClause
}

func (*LockingClauseContext) IsLockingClauseContext() {}

func NewLockingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockingClauseContext {
	var p = new(LockingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockingClause

	return p
}

func (s *LockingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockingClauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *LockingClauseContext) LockStrengh() ILockStrenghContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockStrenghContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockStrenghContext)
}

func (s *LockingClauseContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOF_SYMBOL, 0)
}

func (s *LockingClauseContext) TableAliasRefList() ITableAliasRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasRefListContext)
}

func (s *LockingClauseContext) LockedRowAction() ILockedRowActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockedRowActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockedRowActionContext)
}

func (s *LockingClauseContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *LockingClauseContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *LockingClauseContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHARE_SYMBOL, 0)
}

func (s *LockingClauseContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODE_SYMBOL, 0)
}

func (s *LockingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockingClause(s)
	}
}

func (s *LockingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockingClause(s)
	}
}

func (s *LockingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockingClause() (localctx ILockingClauseContext) {
	localctx = NewLockingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, MySQLParserRULE_lockingClause)
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserFOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3261)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3262)
			p.LockStrengh()
		}
		p.SetState(3266)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) == 1 {
			p.SetState(3263)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(3264)
				p.Match(MySQLParserOF_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3265)
				p.TableAliasRefList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3270)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
			p.SetState(3268)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(3269)
				p.LockedRowAction()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3272)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3273)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3274)
			p.Match(MySQLParserSHARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3275)
			p.Match(MySQLParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockStrenghContext is an interface to support dynamic dispatch.
type ILockStrenghContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode

	// IsLockStrenghContext differentiates from other interfaces.
	IsLockStrenghContext()
}

type LockStrenghContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStrenghContext() *LockStrenghContext {
	var p = new(LockStrenghContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockStrengh
	return p
}

func InitEmptyLockStrenghContext(p *LockStrenghContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockStrengh
}

func (*LockStrenghContext) IsLockStrenghContext() {}

func NewLockStrenghContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStrenghContext {
	var p = new(LockStrenghContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockStrengh

	return p
}

func (s *LockStrenghContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStrenghContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *LockStrenghContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHARE_SYMBOL, 0)
}

func (s *LockStrenghContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStrenghContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockStrenghContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockStrengh(s)
	}
}

func (s *LockStrenghContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockStrengh(s)
	}
}

func (s *LockStrenghContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockStrengh(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockStrengh() (localctx ILockStrenghContext) {
	localctx = NewLockStrenghContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, MySQLParserRULE_lockStrengh)
	p.SetState(3281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 340, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3278)
			p.Match(MySQLParserUPDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3279)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3280)
			p.Match(MySQLParserSHARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockedRowActionContext is an interface to support dynamic dispatch.
type ILockedRowActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKIP_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode

	// IsLockedRowActionContext differentiates from other interfaces.
	IsLockedRowActionContext()
}

type LockedRowActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockedRowActionContext() *LockedRowActionContext {
	var p = new(LockedRowActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockedRowAction
	return p
}

func InitEmptyLockedRowActionContext(p *LockedRowActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockedRowAction
}

func (*LockedRowActionContext) IsLockedRowActionContext() {}

func NewLockedRowActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockedRowActionContext {
	var p = new(LockedRowActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockedRowAction

	return p
}

func (s *LockedRowActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockedRowActionContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSKIP_SYMBOL, 0)
}

func (s *LockedRowActionContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCKED_SYMBOL, 0)
}

func (s *LockedRowActionContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOWAIT_SYMBOL, 0)
}

func (s *LockedRowActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockedRowActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockedRowActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockedRowAction(s)
	}
}

func (s *LockedRowActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockedRowAction(s)
	}
}

func (s *LockedRowActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockedRowAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockedRowAction() (localctx ILockedRowActionContext) {
	localctx = NewLockedRowActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, MySQLParserRULE_lockedRowAction)
	p.SetState(3286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserSKIP_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3283)
			p.Match(MySQLParserSKIP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3284)
			p.Match(MySQLParserLOCKED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserNOWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3285)
			p.Match(MySQLParserNOWAIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemListContext is an interface to support dynamic dispatch.
type ISelectItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	MULT_OPERATOR() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSelectItemListContext differentiates from other interfaces.
	IsSelectItemListContext()
}

type SelectItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemListContext() *SelectItemListContext {
	var p = new(SelectItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectItemList
	return p
}

func InitEmptySelectItemListContext(p *SelectItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectItemList
}

func (*SelectItemListContext) IsSelectItemListContext() {}

func NewSelectItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemListContext {
	var p = new(SelectItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectItemList

	return p
}

func (s *SelectItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemListContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *SelectItemListContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *SelectItemListContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *SelectItemListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *SelectItemListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *SelectItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectItemList(s)
	}
}

func (s *SelectItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectItemList(s)
	}
}

func (s *SelectItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectItemList() (localctx ISelectItemListContext) {
	localctx = NewSelectItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, MySQLParserRULE_selectItemList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 342, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3288)
			p.SelectItem()
		}

	case 2:
		{
			p.SetState(3289)
			p.Match(MySQLParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3292)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3293)
				p.SelectItem()
			}

		}
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 343, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableWild() ITableWildContext
	Expr() IExprContext
	SelectAlias() ISelectAliasContext

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) TableWild() ITableWildContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableWildContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableWildContext)
}

func (s *SelectItemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SelectItemContext) SelectAlias() ISelectAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectAliasContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectItem(s)
	}
}

func (s *SelectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectItem(s)
	}
}

func (s *SelectItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, MySQLParserRULE_selectItem)
	p.SetState(3304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 345, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3299)
			p.TableWild()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3300)
			p.expr(0)
		}
		p.SetState(3302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 344, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3301)
				p.SelectAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectAliasContext is an interface to support dynamic dispatch.
type ISelectAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	TextStringLiteral() ITextStringLiteralContext
	AS_SYMBOL() antlr.TerminalNode

	// IsSelectAliasContext differentiates from other interfaces.
	IsSelectAliasContext()
}

type SelectAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectAliasContext() *SelectAliasContext {
	var p = new(SelectAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectAlias
	return p
}

func InitEmptySelectAliasContext(p *SelectAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_selectAlias
}

func (*SelectAliasContext) IsSelectAliasContext() {}

func NewSelectAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectAliasContext {
	var p = new(SelectAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_selectAlias

	return p
}

func (s *SelectAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAliasContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *SelectAliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *SelectAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSelectAlias(s)
	}
}

func (s *SelectAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSelectAlias(s)
	}
}

func (s *SelectAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSelectAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SelectAlias() (localctx ISelectAliasContext) {
	localctx = NewSelectAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, MySQLParserRULE_selectAlias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3307)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3306)
			p.Match(MySQLParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3311)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 347, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3309)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3310)
			p.TextStringLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWHERE_SYMBOL, 0)
}

func (s *WhereClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, MySQLParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3313)
		p.Match(MySQLParserWHERE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3314)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFactor() ITableFactorContext
	OPEN_CURLY_SYMBOL() antlr.TerminalNode
	EscapedTableReference() IEscapedTableReferenceContext
	CLOSE_CURLY_SYMBOL() antlr.TerminalNode
	AllJoinedTable() []IJoinedTableContext
	JoinedTable(i int) IJoinedTableContext
	Identifier() IIdentifierContext
	OJ_SYMBOL() antlr.TerminalNode

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReference
	return p
}

func InitEmptyTableReferenceContext(p *TableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReference
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *TableReferenceContext) OPEN_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_CURLY_SYMBOL, 0)
}

func (s *TableReferenceContext) EscapedTableReference() IEscapedTableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEscapedTableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEscapedTableReferenceContext)
}

func (s *TableReferenceContext) CLOSE_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_CURLY_SYMBOL, 0)
}

func (s *TableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedTableContext); ok {
			len++
		}
	}

	tst := make([]IJoinedTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedTableContext); ok {
			tst[i] = t.(IJoinedTableContext)
			i++
		}
	}

	return tst
}

func (s *TableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *TableReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableReferenceContext) OJ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOJ_SYMBOL, 0)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (s *TableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableReference() (localctx ITableReferenceContext) {
	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, MySQLParserRULE_tableReference)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3316)
			p.TableFactor()
		}

	case 2:
		{
			p.SetState(3317)
			p.Match(MySQLParserOPEN_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 348, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3318)

			if !(serverVersion < 80017) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
				goto errorExit
			}
			{
				p.SetState(3319)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3320)
				p.Match(MySQLParserOJ_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3323)
			p.EscapedTableReference()
		}
		{
			p.SetState(3324)
			p.Match(MySQLParserCLOSE_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3328)
				p.JoinedTable()
			}

		}
		p.SetState(3333)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 350, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEscapedTableReferenceContext is an interface to support dynamic dispatch.
type IEscapedTableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFactor() ITableFactorContext
	AllJoinedTable() []IJoinedTableContext
	JoinedTable(i int) IJoinedTableContext

	// IsEscapedTableReferenceContext differentiates from other interfaces.
	IsEscapedTableReferenceContext()
}

type EscapedTableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedTableReferenceContext() *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_escapedTableReference
	return p
}

func InitEmptyEscapedTableReferenceContext(p *EscapedTableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_escapedTableReference
}

func (*EscapedTableReferenceContext) IsEscapedTableReferenceContext() {}

func NewEscapedTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_escapedTableReference

	return p
}

func (s *EscapedTableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedTableReferenceContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *EscapedTableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedTableContext); ok {
			len++
		}
	}

	tst := make([]IJoinedTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedTableContext); ok {
			tst[i] = t.(IJoinedTableContext)
			i++
		}
	}

	return tst
}

func (s *EscapedTableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *EscapedTableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedTableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedTableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitEscapedTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) EscapedTableReference() (localctx IEscapedTableReferenceContext) {
	localctx = NewEscapedTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, MySQLParserRULE_escapedTableReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.TableFactor()
	}
	p.SetState(3338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCROSS_SYMBOL || ((int64((_la-239)) & ^0x3f) == 0 && ((int64(1)<<(_la-239))&8594128897) != 0) || _la == MySQLParserNATURAL_SYMBOL || _la == MySQLParserRIGHT_SYMBOL || _la == MySQLParserSTRAIGHT_JOIN_SYMBOL {
		{
			p.SetState(3335)
			p.JoinedTable()
		}

		p.SetState(3340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinedTableContext is an interface to support dynamic dispatch.
type IJoinedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InnerJoinType() IInnerJoinTypeContext
	TableReference() ITableReferenceContext
	ON_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	USING_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	OuterJoinType() IOuterJoinTypeContext
	NaturalJoinType() INaturalJoinTypeContext
	TableFactor() ITableFactorContext

	// IsJoinedTableContext differentiates from other interfaces.
	IsJoinedTableContext()
}

type JoinedTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedTableContext() *JoinedTableContext {
	var p = new(JoinedTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_joinedTable
	return p
}

func InitEmptyJoinedTableContext(p *JoinedTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_joinedTable
}

func (*JoinedTableContext) IsJoinedTableContext() {}

func NewJoinedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedTableContext {
	var p = new(JoinedTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_joinedTable

	return p
}

func (s *JoinedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedTableContext) InnerJoinType() IInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerJoinTypeContext)
}

func (s *JoinedTableContext) TableReference() ITableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *JoinedTableContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *JoinedTableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JoinedTableContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *JoinedTableContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *JoinedTableContext) OuterJoinType() IOuterJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterJoinTypeContext)
}

func (s *JoinedTableContext) NaturalJoinType() INaturalJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INaturalJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INaturalJoinTypeContext)
}

func (s *JoinedTableContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *JoinedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterJoinedTable(s)
	}
}

func (s *JoinedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitJoinedTable(s)
	}
}

func (s *JoinedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitJoinedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) JoinedTable() (localctx IJoinedTableContext) {
	localctx = NewJoinedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, MySQLParserRULE_joinedTable)
	p.SetState(3360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCROSS_SYMBOL, MySQLParserINNER_SYMBOL, MySQLParserJOIN_SYMBOL, MySQLParserSTRAIGHT_JOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3341)
			p.InnerJoinType()
		}
		{
			p.SetState(3342)
			p.TableReference()
		}
		p.SetState(3347)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3343)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3344)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 352, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3345)
				p.Match(MySQLParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3346)
				p.IdentifierListWithParentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserLEFT_SYMBOL, MySQLParserRIGHT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3349)
			p.OuterJoinType()
		}
		{
			p.SetState(3350)
			p.TableReference()
		}
		p.SetState(3355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserON_SYMBOL:
			{
				p.SetState(3351)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3352)
				p.expr(0)
			}

		case MySQLParserUSING_SYMBOL:
			{
				p.SetState(3353)
				p.Match(MySQLParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3354)
				p.IdentifierListWithParentheses()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySQLParserNATURAL_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3357)
			p.NaturalJoinType()
		}
		{
			p.SetState(3358)
			p.TableFactor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INaturalJoinTypeContext is an interface to support dynamic dispatch.
type INaturalJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NATURAL_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	INNER_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	OUTER_SYMBOL() antlr.TerminalNode

	// IsNaturalJoinTypeContext differentiates from other interfaces.
	IsNaturalJoinTypeContext()
}

type NaturalJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNaturalJoinTypeContext() *NaturalJoinTypeContext {
	var p = new(NaturalJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_naturalJoinType
	return p
}

func InitEmptyNaturalJoinTypeContext(p *NaturalJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_naturalJoinType
}

func (*NaturalJoinTypeContext) IsNaturalJoinTypeContext() {}

func NewNaturalJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NaturalJoinTypeContext {
	var p = new(NaturalJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_naturalJoinType

	return p
}

func (s *NaturalJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NaturalJoinTypeContext) NATURAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATURAL_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJOIN_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINNER_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEFT_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRIGHT_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOUTER_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NaturalJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNaturalJoinType(s)
	}
}

func (s *NaturalJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNaturalJoinType(s)
	}
}

func (s *NaturalJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNaturalJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NaturalJoinType() (localctx INaturalJoinTypeContext) {
	localctx = NewNaturalJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, MySQLParserRULE_naturalJoinType)
	var _la int

	p.SetState(3373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 357, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3362)
			p.Match(MySQLParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3364)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserINNER_SYMBOL {
			{
				p.SetState(3363)
				p.Match(MySQLParserINNER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3366)
			p.Match(MySQLParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3367)
			p.Match(MySQLParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3368)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLEFT_SYMBOL || _la == MySQLParserRIGHT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3370)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserOUTER_SYMBOL {
			{
				p.SetState(3369)
				p.Match(MySQLParserOUTER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3372)
			p.Match(MySQLParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInnerJoinTypeContext is an interface to support dynamic dispatch.
type IInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	JOIN_SYMBOL() antlr.TerminalNode
	INNER_SYMBOL() antlr.TerminalNode
	CROSS_SYMBOL() antlr.TerminalNode
	STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode

	// IsInnerJoinTypeContext differentiates from other interfaces.
	IsInnerJoinTypeContext()
}

type InnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyInnerJoinTypeContext() *InnerJoinTypeContext {
	var p = new(InnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_innerJoinType
	return p
}

func InitEmptyInnerJoinTypeContext(p *InnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_innerJoinType
}

func (*InnerJoinTypeContext) IsInnerJoinTypeContext() {}

func NewInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerJoinTypeContext {
	var p = new(InnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_innerJoinType

	return p
}

func (s *InnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerJoinTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *InnerJoinTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *InnerJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJOIN_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINNER_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) CROSS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCROSS_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTRAIGHT_JOIN_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInnerJoinType(s)
	}
}

func (s *InnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInnerJoinType(s)
	}
}

func (s *InnerJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInnerJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InnerJoinType() (localctx IInnerJoinTypeContext) {
	localctx = NewInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, MySQLParserRULE_innerJoinType)
	var _la int

	p.SetState(3380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCROSS_SYMBOL, MySQLParserINNER_SYMBOL, MySQLParserJOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3376)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCROSS_SYMBOL || _la == MySQLParserINNER_SYMBOL {
			{
				p.SetState(3375)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*InnerJoinTypeContext).type_ = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserCROSS_SYMBOL || _la == MySQLParserINNER_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*InnerJoinTypeContext).type_ = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3378)
			p.Match(MySQLParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserSTRAIGHT_JOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3379)

			var _m = p.Match(MySQLParserSTRAIGHT_JOIN_SYMBOL)

			localctx.(*InnerJoinTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterJoinTypeContext is an interface to support dynamic dispatch.
type IOuterJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	JOIN_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	OUTER_SYMBOL() antlr.TerminalNode

	// IsOuterJoinTypeContext differentiates from other interfaces.
	IsOuterJoinTypeContext()
}

type OuterJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyOuterJoinTypeContext() *OuterJoinTypeContext {
	var p = new(OuterJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_outerJoinType
	return p
}

func InitEmptyOuterJoinTypeContext(p *OuterJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_outerJoinType
}

func (*OuterJoinTypeContext) IsOuterJoinTypeContext() {}

func NewOuterJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterJoinTypeContext {
	var p = new(OuterJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_outerJoinType

	return p
}

func (s *OuterJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterJoinTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *OuterJoinTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *OuterJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJOIN_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEFT_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRIGHT_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOUTER_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOuterJoinType(s)
	}
}

func (s *OuterJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOuterJoinType(s)
	}
}

func (s *OuterJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOuterJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OuterJoinType() (localctx IOuterJoinTypeContext) {
	localctx = NewOuterJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, MySQLParserRULE_outerJoinType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3382)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*OuterJoinTypeContext).type_ = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserLEFT_SYMBOL || _la == MySQLParserRIGHT_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*OuterJoinTypeContext).type_ = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOUTER_SYMBOL {
		{
			p.SetState(3383)
			p.Match(MySQLParserOUTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3386)
		p.Match(MySQLParserJOIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFactorContext is an interface to support dynamic dispatch.
type ITableFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleTable() ISingleTableContext
	SingleTableParens() ISingleTableParensContext
	DerivedTable() IDerivedTableContext
	TableReferenceListParens() ITableReferenceListParensContext
	TableFunction() ITableFunctionContext

	// IsTableFactorContext differentiates from other interfaces.
	IsTableFactorContext()
}

type TableFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFactorContext() *TableFactorContext {
	var p = new(TableFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableFactor
	return p
}

func InitEmptyTableFactorContext(p *TableFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableFactor
}

func (*TableFactorContext) IsTableFactorContext() {}

func NewTableFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFactorContext {
	var p = new(TableFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableFactor

	return p
}

func (s *TableFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFactorContext) SingleTable() ISingleTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableContext)
}

func (s *TableFactorContext) SingleTableParens() ISingleTableParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableParensContext)
}

func (s *TableFactorContext) DerivedTable() IDerivedTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDerivedTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDerivedTableContext)
}

func (s *TableFactorContext) TableReferenceListParens() ITableReferenceListParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListParensContext)
}

func (s *TableFactorContext) TableFunction() ITableFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionContext)
}

func (s *TableFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableFactor(s)
	}
}

func (s *TableFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableFactor(s)
	}
}

func (s *TableFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableFactor() (localctx ITableFactorContext) {
	localctx = NewTableFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, MySQLParserRULE_tableFactor)
	p.SetState(3394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 361, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3388)
			p.SingleTable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3389)
			p.SingleTableParens()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3390)
			p.DerivedTable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3391)
			p.TableReferenceListParens()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(3392)

		if !(serverVersion >= 80004) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80004", ""))
			goto errorExit
		}
		{
			p.SetState(3393)
			p.TableFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableContext is an interface to support dynamic dispatch.
type ISingleTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	UsePartition() IUsePartitionContext
	TableAlias() ITableAliasContext
	IndexHintList() IIndexHintListContext

	// IsSingleTableContext differentiates from other interfaces.
	IsSingleTableContext()
}

type SingleTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableContext() *SingleTableContext {
	var p = new(SingleTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_singleTable
	return p
}

func InitEmptySingleTableContext(p *SingleTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_singleTable
}

func (*SingleTableContext) IsSingleTableContext() {}

func NewSingleTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableContext {
	var p = new(SingleTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_singleTable

	return p
}

func (s *SingleTableContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *SingleTableContext) UsePartition() IUsePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsePartitionContext)
}

func (s *SingleTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *SingleTableContext) IndexHintList() IIndexHintListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintListContext)
}

func (s *SingleTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSingleTable(s)
	}
}

func (s *SingleTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSingleTable(s)
	}
}

func (s *SingleTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSingleTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SingleTable() (localctx ISingleTableContext) {
	localctx = NewSingleTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, MySQLParserRULE_singleTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3396)
		p.TableRef()
	}
	p.SetState(3398)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 362, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3397)
			p.UsePartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3401)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 363, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3400)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3404)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 364, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3403)
			p.IndexHintList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableParensContext is an interface to support dynamic dispatch.
type ISingleTableParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	SingleTable() ISingleTableContext
	SingleTableParens() ISingleTableParensContext

	// IsSingleTableParensContext differentiates from other interfaces.
	IsSingleTableParensContext()
}

type SingleTableParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableParensContext() *SingleTableParensContext {
	var p = new(SingleTableParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_singleTableParens
	return p
}

func InitEmptySingleTableParensContext(p *SingleTableParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_singleTableParens
}

func (*SingleTableParensContext) IsSingleTableParensContext() {}

func NewSingleTableParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableParensContext {
	var p = new(SingleTableParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_singleTableParens

	return p
}

func (s *SingleTableParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SingleTableParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SingleTableParensContext) SingleTable() ISingleTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableContext)
}

func (s *SingleTableParensContext) SingleTableParens() ISingleTableParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableParensContext)
}

func (s *SingleTableParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSingleTableParens(s)
	}
}

func (s *SingleTableParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSingleTableParens(s)
	}
}

func (s *SingleTableParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSingleTableParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SingleTableParens() (localctx ISingleTableParensContext) {
	localctx = NewSingleTableParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, MySQLParserRULE_singleTableParens)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3406)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 365, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3407)
			p.SingleTable()
		}

	case 2:
		{
			p.SetState(3408)
			p.SingleTableParens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3411)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDerivedTableContext is an interface to support dynamic dispatch.
type IDerivedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Subquery() ISubqueryContext
	TableAlias() ITableAliasContext
	ColumnInternalRefList() IColumnInternalRefListContext
	LATERAL_SYMBOL() antlr.TerminalNode

	// IsDerivedTableContext differentiates from other interfaces.
	IsDerivedTableContext()
}

type DerivedTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDerivedTableContext() *DerivedTableContext {
	var p = new(DerivedTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_derivedTable
	return p
}

func InitEmptyDerivedTableContext(p *DerivedTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_derivedTable
}

func (*DerivedTableContext) IsDerivedTableContext() {}

func NewDerivedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DerivedTableContext {
	var p = new(DerivedTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_derivedTable

	return p
}

func (s *DerivedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DerivedTableContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *DerivedTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DerivedTableContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *DerivedTableContext) LATERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLATERAL_SYMBOL, 0)
}

func (s *DerivedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DerivedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DerivedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDerivedTable(s)
	}
}

func (s *DerivedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDerivedTable(s)
	}
}

func (s *DerivedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDerivedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DerivedTable() (localctx IDerivedTableContext) {
	localctx = NewDerivedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, MySQLParserRULE_derivedTable)
	p.SetState(3430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 370, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3413)
			p.Subquery()
		}
		p.SetState(3415)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 366, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3414)
				p.TableAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3419)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) == 1 {
			p.SetState(3417)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(3418)
				p.ColumnInternalRefList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3421)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(3422)
			p.Match(MySQLParserLATERAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3423)
			p.Subquery()
		}
		p.SetState(3425)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3424)
				p.TableAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3428)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 369, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3427)
				p.ColumnInternalRefList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceListParensContext is an interface to support dynamic dispatch.
type ITableReferenceListParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext
	TableReferenceListParens() ITableReferenceListParensContext

	// IsTableReferenceListParensContext differentiates from other interfaces.
	IsTableReferenceListParensContext()
}

type TableReferenceListParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceListParensContext() *TableReferenceListParensContext {
	var p = new(TableReferenceListParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReferenceListParens
	return p
}

func InitEmptyTableReferenceListParensContext(p *TableReferenceListParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableReferenceListParens
}

func (*TableReferenceListParensContext) IsTableReferenceListParensContext() {}

func NewTableReferenceListParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceListParensContext {
	var p = new(TableReferenceListParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableReferenceListParens

	return p
}

func (s *TableReferenceListParensContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceListParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *TableReferenceListParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TableReferenceListParensContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *TableReferenceListParensContext) TableReferenceListParens() ITableReferenceListParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListParensContext)
}

func (s *TableReferenceListParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceListParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceListParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableReferenceListParens(s)
	}
}

func (s *TableReferenceListParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableReferenceListParens(s)
	}
}

func (s *TableReferenceListParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableReferenceListParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableReferenceListParens() (localctx ITableReferenceListParensContext) {
	localctx = NewTableReferenceListParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, MySQLParserRULE_tableReferenceListParens)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3432)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 371, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3433)
			p.TableReferenceList()
		}

	case 2:
		{
			p.SetState(3434)
			p.TableReferenceListParens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(3437)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionContext is an interface to support dynamic dispatch.
type ITableFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	COMMA_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	ColumnsClause() IColumnsClauseContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	TableAlias() ITableAliasContext

	// IsTableFunctionContext differentiates from other interfaces.
	IsTableFunctionContext()
}

type TableFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionContext() *TableFunctionContext {
	var p = new(TableFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableFunction
	return p
}

func InitEmptyTableFunctionContext(p *TableFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableFunction
}

func (*TableFunctionContext) IsTableFunctionContext() {}

func NewTableFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionContext {
	var p = new(TableFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableFunction

	return p
}

func (s *TableFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionContext) JSON_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_TABLE_SYMBOL, 0)
}

func (s *TableFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *TableFunctionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TableFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *TableFunctionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TableFunctionContext) ColumnsClause() IColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *TableFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TableFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

func (s *TableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableFunction() (localctx ITableFunctionContext) {
	localctx = NewTableFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, MySQLParserRULE_tableFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3439)
		p.Match(MySQLParserJSON_TABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3440)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3441)
		p.expr(0)
	}
	{
		p.SetState(3442)
		p.Match(MySQLParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3443)
		p.TextStringLiteral()
	}
	{
		p.SetState(3444)
		p.ColumnsClause()
	}
	{
		p.SetState(3445)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3447)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 372, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3446)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsClauseContext is an interface to support dynamic dispatch.
type IColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllJtColumn() []IJtColumnContext
	JtColumn(i int) IJtColumnContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumnsClauseContext differentiates from other interfaces.
	IsColumnsClauseContext()
}

type ColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsClauseContext() *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnsClause
	return p
}

func InitEmptyColumnsClauseContext(p *ColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnsClause
}

func (*ColumnsClauseContext) IsColumnsClauseContext() {}

func NewColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnsClause

	return p
}

func (s *ColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsClauseContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *ColumnsClauseContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ColumnsClauseContext) AllJtColumn() []IJtColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJtColumnContext); ok {
			len++
		}
	}

	tst := make([]IJtColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJtColumnContext); ok {
			tst[i] = t.(IJtColumnContext)
			i++
		}
	}

	return tst
}

func (s *ColumnsClauseContext) JtColumn(i int) IJtColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtColumnContext)
}

func (s *ColumnsClauseContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ColumnsClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ColumnsClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnsClause() (localctx IColumnsClauseContext) {
	localctx = NewColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, MySQLParserRULE_columnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3449)
		p.Match(MySQLParserCOLUMNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3450)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3451)
		p.JtColumn()
	}
	p.SetState(3456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(3452)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3453)
			p.JtColumn()
		}

		p.SetState(3458)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3459)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJtColumnContext is an interface to support dynamic dispatch.
type IJtColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FOR_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	Collate() ICollateContext
	EXISTS_SYMBOL() antlr.TerminalNode
	OnEmptyOrError() IOnEmptyOrErrorContext
	NESTED_SYMBOL() antlr.TerminalNode
	ColumnsClause() IColumnsClauseContext

	// IsJtColumnContext differentiates from other interfaces.
	IsJtColumnContext()
}

type JtColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJtColumnContext() *JtColumnContext {
	var p = new(JtColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jtColumn
	return p
}

func InitEmptyJtColumnContext(p *JtColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jtColumn
}

func (*JtColumnContext) IsJtColumnContext() {}

func NewJtColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JtColumnContext {
	var p = new(JtColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_jtColumn

	return p
}

func (s *JtColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JtColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JtColumnContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *JtColumnContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDINALITY_SYMBOL, 0)
}

func (s *JtColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JtColumnContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPATH_SYMBOL, 0)
}

func (s *JtColumnContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JtColumnContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *JtColumnContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXISTS_SYMBOL, 0)
}

func (s *JtColumnContext) OnEmptyOrError() IOnEmptyOrErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnEmptyOrErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnEmptyOrErrorContext)
}

func (s *JtColumnContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNESTED_SYMBOL, 0)
}

func (s *JtColumnContext) ColumnsClause() IColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *JtColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JtColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JtColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterJtColumn(s)
	}
}

func (s *JtColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitJtColumn(s)
	}
}

func (s *JtColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitJtColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) JtColumn() (localctx IJtColumnContext) {
	localctx = NewJtColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, MySQLParserRULE_jtColumn)
	var _la int

	p.SetState(3484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 377, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3461)
			p.Identifier()
		}
		{
			p.SetState(3462)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3463)
			p.Match(MySQLParserORDINALITY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3465)
			p.Identifier()
		}
		{
			p.SetState(3466)
			p.DataType()
		}
		p.SetState(3469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 374, p.GetParserRuleContext()) == 1 {
			p.SetState(3467)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(3468)
				p.Collate()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3472)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEXISTS_SYMBOL {
			{
				p.SetState(3471)
				p.Match(MySQLParserEXISTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3474)
			p.Match(MySQLParserPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3475)
			p.TextStringLiteral()
		}
		p.SetState(3477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserERROR_SYMBOL || _la == MySQLParserNULL_SYMBOL {
			{
				p.SetState(3476)
				p.OnEmptyOrError()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3479)
			p.Match(MySQLParserNESTED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3480)
			p.Match(MySQLParserPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3481)
			p.TextStringLiteral()
		}
		{
			p.SetState(3482)
			p.ColumnsClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnEmptyOrErrorContext is an interface to support dynamic dispatch.
type IOnEmptyOrErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OnEmpty() IOnEmptyContext
	OnError() IOnErrorContext

	// IsOnEmptyOrErrorContext differentiates from other interfaces.
	IsOnEmptyOrErrorContext()
}

type OnEmptyOrErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnEmptyOrErrorContext() *OnEmptyOrErrorContext {
	var p = new(OnEmptyOrErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onEmptyOrError
	return p
}

func InitEmptyOnEmptyOrErrorContext(p *OnEmptyOrErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onEmptyOrError
}

func (*OnEmptyOrErrorContext) IsOnEmptyOrErrorContext() {}

func NewOnEmptyOrErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnEmptyOrErrorContext {
	var p = new(OnEmptyOrErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_onEmptyOrError

	return p
}

func (s *OnEmptyOrErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *OnEmptyOrErrorContext) OnEmpty() IOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnEmptyContext)
}

func (s *OnEmptyOrErrorContext) OnError() IOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnErrorContext)
}

func (s *OnEmptyOrErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnEmptyOrErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnEmptyOrErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOnEmptyOrError(s)
	}
}

func (s *OnEmptyOrErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOnEmptyOrError(s)
	}
}

func (s *OnEmptyOrErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOnEmptyOrError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OnEmptyOrError() (localctx IOnEmptyOrErrorContext) {
	localctx = NewOnEmptyOrErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, MySQLParserRULE_onEmptyOrError)
	var _la int

	p.SetState(3494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 380, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3486)
			p.OnEmpty()
		}
		p.SetState(3488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserERROR_SYMBOL || _la == MySQLParserNULL_SYMBOL {
			{
				p.SetState(3487)
				p.OnError()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3490)
			p.OnError()
		}
		p.SetState(3492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserERROR_SYMBOL || _la == MySQLParserNULL_SYMBOL {
			{
				p.SetState(3491)
				p.OnEmpty()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnEmptyContext is an interface to support dynamic dispatch.
type IOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JtOnResponse() IJtOnResponseContext
	ON_SYMBOL() antlr.TerminalNode
	EMPTY_SYMBOL() antlr.TerminalNode

	// IsOnEmptyContext differentiates from other interfaces.
	IsOnEmptyContext()
}

type OnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnEmptyContext() *OnEmptyContext {
	var p = new(OnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onEmpty
	return p
}

func InitEmptyOnEmptyContext(p *OnEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onEmpty
}

func (*OnEmptyContext) IsOnEmptyContext() {}

func NewOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnEmptyContext {
	var p = new(OnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_onEmpty

	return p
}

func (s *OnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *OnEmptyContext) JtOnResponse() IJtOnResponseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtOnResponseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtOnResponseContext)
}

func (s *OnEmptyContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *OnEmptyContext) EMPTY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEMPTY_SYMBOL, 0)
}

func (s *OnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOnEmpty(s)
	}
}

func (s *OnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOnEmpty(s)
	}
}

func (s *OnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OnEmpty() (localctx IOnEmptyContext) {
	localctx = NewOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, MySQLParserRULE_onEmpty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3496)
		p.JtOnResponse()
	}
	{
		p.SetState(3497)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3498)
		p.Match(MySQLParserEMPTY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnErrorContext is an interface to support dynamic dispatch.
type IOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JtOnResponse() IJtOnResponseContext
	ON_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode

	// IsOnErrorContext differentiates from other interfaces.
	IsOnErrorContext()
}

type OnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnErrorContext() *OnErrorContext {
	var p = new(OnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onError
	return p
}

func InitEmptyOnErrorContext(p *OnErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onError
}

func (*OnErrorContext) IsOnErrorContext() {}

func NewOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnErrorContext {
	var p = new(OnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_onError

	return p
}

func (s *OnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *OnErrorContext) JtOnResponse() IJtOnResponseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtOnResponseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtOnResponseContext)
}

func (s *OnErrorContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *OnErrorContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERROR_SYMBOL, 0)
}

func (s *OnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOnError(s)
	}
}

func (s *OnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOnError(s)
	}
}

func (s *OnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOnError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OnError() (localctx IOnErrorContext) {
	localctx = NewOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, MySQLParserRULE_onError)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3500)
		p.JtOnResponse()
	}
	{
		p.SetState(3501)
		p.Match(MySQLParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3502)
		p.Match(MySQLParserERROR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJtOnResponseContext is an interface to support dynamic dispatch.
type IJtOnResponseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR_SYMBOL() antlr.TerminalNode
	NULL_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext

	// IsJtOnResponseContext differentiates from other interfaces.
	IsJtOnResponseContext()
}

type JtOnResponseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJtOnResponseContext() *JtOnResponseContext {
	var p = new(JtOnResponseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jtOnResponse
	return p
}

func InitEmptyJtOnResponseContext(p *JtOnResponseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jtOnResponse
}

func (*JtOnResponseContext) IsJtOnResponseContext() {}

func NewJtOnResponseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JtOnResponseContext {
	var p = new(JtOnResponseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_jtOnResponse

	return p
}

func (s *JtOnResponseContext) GetParser() antlr.Parser { return s.parser }

func (s *JtOnResponseContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERROR_SYMBOL, 0)
}

func (s *JtOnResponseContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *JtOnResponseContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *JtOnResponseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JtOnResponseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JtOnResponseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JtOnResponseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterJtOnResponse(s)
	}
}

func (s *JtOnResponseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitJtOnResponse(s)
	}
}

func (s *JtOnResponseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitJtOnResponse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) JtOnResponse() (localctx IJtOnResponseContext) {
	localctx = NewJtOnResponseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, MySQLParserRULE_jtOnResponse)
	p.SetState(3508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserERROR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3504)
			p.Match(MySQLParserERROR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserNULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3505)
			p.Match(MySQLParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3506)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3507)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionOptionContext is an interface to support dynamic dispatch.
type IUnionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode

	// IsUnionOptionContext differentiates from other interfaces.
	IsUnionOptionContext()
}

type UnionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionOptionContext() *UnionOptionContext {
	var p = new(UnionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unionOption
	return p
}

func InitEmptyUnionOptionContext(p *UnionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unionOption
}

func (*UnionOptionContext) IsUnionOptionContext() {}

func NewUnionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionOptionContext {
	var p = new(UnionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_unionOption

	return p
}

func (s *UnionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionOptionContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISTINCT_SYMBOL, 0)
}

func (s *UnionOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *UnionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUnionOption(s)
	}
}

func (s *UnionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUnionOption(s)
	}
}

func (s *UnionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUnionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UnionOption() (localctx IUnionOptionContext) {
	localctx = NewUnionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, MySQLParserRULE_unionOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3510)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserALL_SYMBOL || _la == MySQLParserDISTINCT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *TableAliasContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (s *TableAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, MySQLParserRULE_tableAlias)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3512)
			p.Match(MySQLParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 382, p.GetParserRuleContext()) == 2 {
		p.SetState(3513)

		if !(serverVersion < 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
			goto errorExit
		}
		{
			p.SetState(3514)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3517)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintListContext is an interface to support dynamic dispatch.
type IIndexHintListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexHint() []IIndexHintContext
	IndexHint(i int) IIndexHintContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIndexHintListContext differentiates from other interfaces.
	IsIndexHintListContext()
}

type IndexHintListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintListContext() *IndexHintListContext {
	var p = new(IndexHintListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintList
	return p
}

func InitEmptyIndexHintListContext(p *IndexHintListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintList
}

func (*IndexHintListContext) IsIndexHintListContext() {}

func NewIndexHintListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintListContext {
	var p = new(IndexHintListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexHintList

	return p
}

func (s *IndexHintListContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintListContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *IndexHintListContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *IndexHintListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *IndexHintListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *IndexHintListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexHintList(s)
	}
}

func (s *IndexHintListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexHintList(s)
	}
}

func (s *IndexHintListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexHintList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexHintList() (localctx IIndexHintListContext) {
	localctx = NewIndexHintListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, MySQLParserRULE_indexHintList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3519)
		p.IndexHint()
	}
	p.SetState(3524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3520)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3521)
				p.IndexHint()
			}

		}
		p.SetState(3526)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexHintType() IIndexHintTypeContext
	KeyOrIndex() IKeyOrIndexContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	IndexList() IIndexListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	IndexHintClause() IIndexHintClauseContext
	USE_SYMBOL() antlr.TerminalNode

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHint
	return p
}

func InitEmptyIndexHintContext(p *IndexHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHint
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *IndexHintContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *IndexHintContext) IndexList() IIndexListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexListContext)
}

func (s *IndexHintContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IndexHintContext) IndexHintClause() IIndexHintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintClauseContext)
}

func (s *IndexHintContext) USE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_SYMBOL, 0)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, MySQLParserRULE_indexHint)
	var _la int

	p.SetState(3547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserFORCE_SYMBOL, MySQLParserIGNORE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3527)
			p.IndexHintType()
		}
		{
			p.SetState(3528)
			p.KeyOrIndex()
		}
		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(3529)
				p.IndexHintClause()
			}

		}
		{
			p.SetState(3532)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3533)
			p.IndexList()
		}
		{
			p.SetState(3534)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserUSE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3536)
			p.Match(MySQLParserUSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3537)
			p.KeyOrIndex()
		}
		p.SetState(3539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(3538)
				p.IndexHintClause()
			}

		}
		{
			p.SetState(3541)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3543)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 386, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3542)
				p.IndexList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3545)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORCE_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintType
	return p
}

func InitEmptyIndexHintTypeContext(p *IndexHintTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintType
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORCE_SYMBOL, 0)
}

func (s *IndexHintTypeContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, MySQLParserRULE_indexHintType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3549)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserFORCE_SYMBOL || _la == MySQLParserIGNORE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyOrIndexContext is an interface to support dynamic dispatch.
type IKeyOrIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode

	// IsKeyOrIndexContext differentiates from other interfaces.
	IsKeyOrIndexContext()
}

type KeyOrIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyOrIndexContext() *KeyOrIndexContext {
	var p = new(KeyOrIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyOrIndex
	return p
}

func InitEmptyKeyOrIndexContext(p *KeyOrIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyOrIndex
}

func (*KeyOrIndexContext) IsKeyOrIndexContext() {}

func NewKeyOrIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyOrIndexContext {
	var p = new(KeyOrIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyOrIndex

	return p
}

func (s *KeyOrIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyOrIndexContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *KeyOrIndexContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *KeyOrIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyOrIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyOrIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyOrIndex(s)
	}
}

func (s *KeyOrIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyOrIndex(s)
	}
}

func (s *KeyOrIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyOrIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyOrIndex() (localctx IKeyOrIndexContext) {
	localctx = NewKeyOrIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, MySQLParserRULE_keyOrIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3551)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintKeyTypeContext is an interface to support dynamic dispatch.
type IConstraintKeyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	KeyOrIndex() IKeyOrIndexContext

	// IsConstraintKeyTypeContext differentiates from other interfaces.
	IsConstraintKeyTypeContext()
}

type ConstraintKeyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintKeyTypeContext() *ConstraintKeyTypeContext {
	var p = new(ConstraintKeyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintKeyType
	return p
}

func InitEmptyConstraintKeyTypeContext(p *ConstraintKeyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintKeyType
}

func (*ConstraintKeyTypeContext) IsConstraintKeyTypeContext() {}

func NewConstraintKeyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintKeyTypeContext {
	var p = new(ConstraintKeyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_constraintKeyType

	return p
}

func (s *ConstraintKeyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintKeyTypeContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNIQUE_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *ConstraintKeyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintKeyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintKeyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConstraintKeyType(s)
	}
}

func (s *ConstraintKeyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConstraintKeyType(s)
	}
}

func (s *ConstraintKeyTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConstraintKeyType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConstraintKeyType() (localctx IConstraintKeyTypeContext) {
	localctx = NewConstraintKeyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, MySQLParserRULE_constraintKeyType)
	var _la int

	p.SetState(3559)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3553)
			p.Match(MySQLParserPRIMARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3554)
			p.Match(MySQLParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3555)
			p.Match(MySQLParserUNIQUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL {
			{
				p.SetState(3556)
				p.KeyOrIndex()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintClauseContext is an interface to support dynamic dispatch.
type IIndexHintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode

	// IsIndexHintClauseContext differentiates from other interfaces.
	IsIndexHintClauseContext()
}

type IndexHintClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintClauseContext() *IndexHintClauseContext {
	var p = new(IndexHintClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintClause
	return p
}

func InitEmptyIndexHintClauseContext(p *IndexHintClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexHintClause
}

func (*IndexHintClauseContext) IsIndexHintClauseContext() {}

func NewIndexHintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintClauseContext {
	var p = new(IndexHintClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexHintClause

	return p
}

func (s *IndexHintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintClauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *IndexHintClauseContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJOIN_SYMBOL, 0)
}

func (s *IndexHintClauseContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDER_SYMBOL, 0)
}

func (s *IndexHintClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *IndexHintClauseContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *IndexHintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexHintClause(s)
	}
}

func (s *IndexHintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexHintClause(s)
	}
}

func (s *IndexHintClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexHintClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexHintClause() (localctx IIndexHintClauseContext) {
	localctx = NewIndexHintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, MySQLParserRULE_indexHintClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3561)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserJOIN_SYMBOL:
		{
			p.SetState(3562)
			p.Match(MySQLParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserORDER_SYMBOL:
		{
			p.SetState(3563)
			p.Match(MySQLParserORDER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3564)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserGROUP_SYMBOL:
		{
			p.SetState(3565)
			p.Match(MySQLParserGROUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3566)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexListContext is an interface to support dynamic dispatch.
type IIndexListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexListElement() []IIndexListElementContext
	IndexListElement(i int) IIndexListElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIndexListContext differentiates from other interfaces.
	IsIndexListContext()
}

type IndexListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexListContext() *IndexListContext {
	var p = new(IndexListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexList
	return p
}

func InitEmptyIndexListContext(p *IndexListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexList
}

func (*IndexListContext) IsIndexListContext() {}

func NewIndexListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexListContext {
	var p = new(IndexListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexList

	return p
}

func (s *IndexListContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexListContext) AllIndexListElement() []IIndexListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexListElementContext); ok {
			len++
		}
	}

	tst := make([]IIndexListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexListElementContext); ok {
			tst[i] = t.(IIndexListElementContext)
			i++
		}
	}

	return tst
}

func (s *IndexListContext) IndexListElement(i int) IIndexListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexListElementContext)
}

func (s *IndexListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *IndexListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *IndexListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexList(s)
	}
}

func (s *IndexListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexList(s)
	}
}

func (s *IndexListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexList() (localctx IIndexListContext) {
	localctx = NewIndexListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, MySQLParserRULE_indexList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3569)
		p.IndexListElement()
	}
	p.SetState(3574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(3570)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3571)
			p.IndexListElement()
		}

		p.SetState(3576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexListElementContext is an interface to support dynamic dispatch.
type IIndexListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	PRIMARY_SYMBOL() antlr.TerminalNode

	// IsIndexListElementContext differentiates from other interfaces.
	IsIndexListElementContext()
}

type IndexListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexListElementContext() *IndexListElementContext {
	var p = new(IndexListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexListElement
	return p
}

func InitEmptyIndexListElementContext(p *IndexListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexListElement
}

func (*IndexListElementContext) IsIndexListElementContext() {}

func NewIndexListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexListElementContext {
	var p = new(IndexListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexListElement

	return p
}

func (s *IndexListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexListElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexListElementContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *IndexListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexListElement(s)
	}
}

func (s *IndexListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexListElement(s)
	}
}

func (s *IndexListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexListElement() (localctx IIndexListElementContext) {
	localctx = NewIndexListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, MySQLParserRULE_indexListElement)
	p.SetState(3579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 392, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3577)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3578)
			p.Match(MySQLParserPRIMARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext
	SET_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext
	WithClause() IWithClauseContext
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	OrderClause() IOrderClauseContext
	SimpleLimitClause() ISimpleLimitClauseContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *UpdateStatementContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *UpdateStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *UpdateStatementContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *UpdateStatementContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *UpdateStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateStatementContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *UpdateStatementContext) SimpleLimitClause() ISimpleLimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLimitClauseContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, MySQLParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 393, p.GetParserRuleContext()) == 1 {
		p.SetState(3581)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3582)
			p.WithClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3585)
		p.Match(MySQLParserUPDATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 394, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3586)
			p.Match(MySQLParserLOW_PRIORITY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3590)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 395, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3589)
			p.Match(MySQLParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3592)
		p.TableReferenceList()
	}
	{
		p.SetState(3593)
		p.Match(MySQLParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3594)
		p.UpdateList()
	}
	p.SetState(3596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserWHERE_SYMBOL {
		{
			p.SetState(3595)
			p.WhereClause()
		}

	}
	p.SetState(3599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserORDER_SYMBOL {
		{
			p.SetState(3598)
			p.OrderClause()
		}

	}
	p.SetState(3602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserLIMIT_SYMBOL {
		{
			p.SetState(3601)
			p.SimpleLimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionOrLockingStatementContext is an interface to support dynamic dispatch.
type ITransactionOrLockingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransactionStatement() ITransactionStatementContext
	SavepointStatement() ISavepointStatementContext
	LockStatement() ILockStatementContext
	XaStatement() IXaStatementContext

	// IsTransactionOrLockingStatementContext differentiates from other interfaces.
	IsTransactionOrLockingStatementContext()
}

type TransactionOrLockingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOrLockingStatementContext() *TransactionOrLockingStatementContext {
	var p = new(TransactionOrLockingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionOrLockingStatement
	return p
}

func InitEmptyTransactionOrLockingStatementContext(p *TransactionOrLockingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionOrLockingStatement
}

func (*TransactionOrLockingStatementContext) IsTransactionOrLockingStatementContext() {}

func NewTransactionOrLockingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOrLockingStatementContext {
	var p = new(TransactionOrLockingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_transactionOrLockingStatement

	return p
}

func (s *TransactionOrLockingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOrLockingStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *TransactionOrLockingStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionOrLockingStatementContext) LockStatement() ILockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockStatementContext)
}

func (s *TransactionOrLockingStatementContext) XaStatement() IXaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStatementContext)
}

func (s *TransactionOrLockingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOrLockingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOrLockingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTransactionOrLockingStatement(s)
	}
}

func (s *TransactionOrLockingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTransactionOrLockingStatement(s)
	}
}

func (s *TransactionOrLockingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTransactionOrLockingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TransactionOrLockingStatement() (localctx ITransactionOrLockingStatementContext) {
	localctx = NewTransactionOrLockingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, MySQLParserRULE_transactionOrLockingStatement)
	p.SetState(3608)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 399, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3604)
			p.TransactionStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3605)
			p.SavepointStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3606)
			p.LockStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3607)
			p.XaStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	AllTransactionCharacteristic() []ITransactionCharacteristicContext
	TransactionCharacteristic(i int) ITransactionCharacteristicContext
	COMMIT_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	AND_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	RELEASE_SYMBOL() antlr.TerminalNode
	AllNO_SYMBOL() []antlr.TerminalNode
	NO_SYMBOL(i int) antlr.TerminalNode

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionStatement
	return p
}

func InitEmptyTransactionStatementContext(p *TransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionStatement
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *TransactionStatementContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRANSACTION_SYMBOL, 0)
}

func (s *TransactionStatementContext) AllTransactionCharacteristic() []ITransactionCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]ITransactionCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionCharacteristicContext); ok {
			tst[i] = t.(ITransactionCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *TransactionStatementContext) TransactionCharacteristic(i int) ITransactionCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicContext)
}

func (s *TransactionStatementContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMIT_SYMBOL, 0)
}

func (s *TransactionStatementContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWORK_SYMBOL, 0)
}

func (s *TransactionStatementContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, 0)
}

func (s *TransactionStatementContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAIN_SYMBOL, 0)
}

func (s *TransactionStatementContext) RELEASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELEASE_SYMBOL, 0)
}

func (s *TransactionStatementContext) AllNO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserNO_SYMBOL)
}

func (s *TransactionStatementContext) NO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, i)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TransactionStatement() (localctx ITransactionStatementContext) {
	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, MySQLParserRULE_transactionStatement)
	var _la int

	var _alt int

	p.SetState(3635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserSTART_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3610)
			p.Match(MySQLParserSTART_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3611)
			p.Match(MySQLParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(3612)
					p.TransactionCharacteristic()
				}

			}
			p.SetState(3617)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 400, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserCOMMIT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3618)
			p.Match(MySQLParserCOMMIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3620)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWORK_SYMBOL {
			{
				p.SetState(3619)
				p.Match(MySQLParserWORK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3627)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserAND_SYMBOL {
			{
				p.SetState(3622)
				p.Match(MySQLParserAND_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3624)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserNO_SYMBOL {
				{
					p.SetState(3623)
					p.Match(MySQLParserNO_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3626)
				p.Match(MySQLParserCHAIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNO_SYMBOL || _la == MySQLParserRELEASE_SYMBOL {
			p.SetState(3630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserNO_SYMBOL {
				{
					p.SetState(3629)
					p.Match(MySQLParserNO_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3632)
				p.Match(MySQLParserRELEASE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_beginWork
	return p
}

func InitEmptyBeginWorkContext(p *BeginWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_beginWork
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEGIN_SYMBOL, 0)
}

func (s *BeginWorkContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWORK_SYMBOL, 0)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (s *BeginWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitBeginWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) BeginWork() (localctx IBeginWorkContext) {
	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, MySQLParserRULE_beginWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3637)
		p.Match(MySQLParserBEGIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserWORK_SYMBOL {
		{
			p.SetState(3638)
			p.Match(MySQLParserWORK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCharacteristicContext is an interface to support dynamic dispatch.
type ITransactionCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode

	// IsTransactionCharacteristicContext differentiates from other interfaces.
	IsTransactionCharacteristicContext()
}

type TransactionCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCharacteristicContext() *TransactionCharacteristicContext {
	var p = new(TransactionCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionCharacteristic
	return p
}

func InitEmptyTransactionCharacteristicContext(p *TransactionCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionCharacteristic
}

func (*TransactionCharacteristicContext) IsTransactionCharacteristicContext() {}

func NewTransactionCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCharacteristicContext {
	var p = new(TransactionCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_transactionCharacteristic

	return p
}

func (s *TransactionCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCharacteristicContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSISTENT_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSNAPSHOT_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRITE_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONLY_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTransactionCharacteristic(s)
	}
}

func (s *TransactionCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTransactionCharacteristic(s)
	}
}

func (s *TransactionCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTransactionCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TransactionCharacteristic() (localctx ITransactionCharacteristicContext) {
	localctx = NewTransactionCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, MySQLParserRULE_transactionCharacteristic)
	var _la int

	p.SetState(3647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3641)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3642)
			p.Match(MySQLParserCONSISTENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3643)
			p.Match(MySQLParserSNAPSHOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3644)

		if !(serverVersion >= 50605) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50605", ""))
			goto errorExit
		}
		{
			p.SetState(3645)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3646)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserONLY_SYMBOL || _la == MySQLParserWRITE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	ROLLBACK_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	AND_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	RELEASE_SYMBOL() antlr.TerminalNode
	AllNO_SYMBOL() []antlr.TerminalNode
	NO_SYMBOL(i int) antlr.TerminalNode

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_savepointStatement
	return p
}

func InitEmptySavepointStatementContext(p *SavepointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_savepointStatement
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSAVEPOINT_SYMBOL, 0)
}

func (s *SavepointStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SavepointStatementContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLBACK_SYMBOL, 0)
}

func (s *SavepointStatementContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *SavepointStatementContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWORK_SYMBOL, 0)
}

func (s *SavepointStatementContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, 0)
}

func (s *SavepointStatementContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAIN_SYMBOL, 0)
}

func (s *SavepointStatementContext) RELEASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELEASE_SYMBOL, 0)
}

func (s *SavepointStatementContext) AllNO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserNO_SYMBOL)
}

func (s *SavepointStatementContext) NO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, i)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSavepointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SavepointStatement() (localctx ISavepointStatementContext) {
	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, MySQLParserRULE_savepointStatement)
	var _la int

	p.SetState(3678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserSAVEPOINT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3649)
			p.Match(MySQLParserSAVEPOINT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3650)
			p.Identifier()
		}

	case MySQLParserROLLBACK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3651)
			p.Match(MySQLParserROLLBACK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3653)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWORK_SYMBOL {
			{
				p.SetState(3652)
				p.Match(MySQLParserWORK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3673)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserTO_SYMBOL:
			{
				p.SetState(3655)
				p.Match(MySQLParserTO_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3657)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 410, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3656)
					p.Match(MySQLParserSAVEPOINT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(3659)
				p.Identifier()
			}

		case MySQLParserEOF, MySQLParserAND_SYMBOL, MySQLParserNO_SYMBOL, MySQLParserRELEASE_SYMBOL, MySQLParserSEMICOLON_SYMBOL:
			p.SetState(3665)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserAND_SYMBOL {
				{
					p.SetState(3660)
					p.Match(MySQLParserAND_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3662)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySQLParserNO_SYMBOL {
					{
						p.SetState(3661)
						p.Match(MySQLParserNO_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3664)
					p.Match(MySQLParserCHAIN_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(3671)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserNO_SYMBOL || _la == MySQLParserRELEASE_SYMBOL {
				p.SetState(3668)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySQLParserNO_SYMBOL {
					{
						p.SetState(3667)
						p.Match(MySQLParserNO_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(3670)
					p.Match(MySQLParserRELEASE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case MySQLParserRELEASE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3675)
			p.Match(MySQLParserRELEASE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3676)
			p.Match(MySQLParserSAVEPOINT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3677)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockStatementContext is an interface to support dynamic dispatch.
type ILockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK_SYMBOL() antlr.TerminalNode
	AllLockItem() []ILockItemContext
	LockItem(i int) ILockItemContext
	TABLES_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	UNLOCK_SYMBOL() antlr.TerminalNode

	// IsLockStatementContext differentiates from other interfaces.
	IsLockStatementContext()
}

type LockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStatementContext() *LockStatementContext {
	var p = new(LockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockStatement
	return p
}

func InitEmptyLockStatementContext(p *LockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockStatement
}

func (*LockStatementContext) IsLockStatementContext() {}

func NewLockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStatementContext {
	var p = new(LockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockStatement

	return p
}

func (s *LockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStatementContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *LockStatementContext) AllLockItem() []ILockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockItemContext); ok {
			len++
		}
	}

	tst := make([]ILockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockItemContext); ok {
			tst[i] = t.(ILockItemContext)
			i++
		}
	}

	return tst
}

func (s *LockStatementContext) LockItem(i int) ILockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockItemContext)
}

func (s *LockStatementContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *LockStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *LockStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *LockStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *LockStatementContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTANCE_SYMBOL, 0)
}

func (s *LockStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *LockStatementContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBACKUP_SYMBOL, 0)
}

func (s *LockStatementContext) UNLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNLOCK_SYMBOL, 0)
}

func (s *LockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockStatement(s)
	}
}

func (s *LockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockStatement(s)
	}
}

func (s *LockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockStatement() (localctx ILockStatementContext) {
	localctx = NewLockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, MySQLParserRULE_lockStatement)
	var _la int

	p.SetState(3702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3680)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3681)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserTABLES_SYMBOL || _la == MySQLParserTABLE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3682)
			p.LockItem()
		}
		p.SetState(3687)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(3683)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3684)
				p.LockItem()
			}

			p.SetState(3689)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3690)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3691)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3692)
			p.Match(MySQLParserINSTANCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3693)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3694)
			p.Match(MySQLParserBACKUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3695)
			p.Match(MySQLParserUNLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 418, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3696)
				p.Match(MySQLParserTABLES_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3697)
				p.Match(MySQLParserTABLE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			p.SetState(3698)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(3699)
				p.Match(MySQLParserINSTANCE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockItemContext is an interface to support dynamic dispatch.
type ILockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	LockOption() ILockOptionContext
	TableAlias() ITableAliasContext

	// IsLockItemContext differentiates from other interfaces.
	IsLockItemContext()
}

type LockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockItemContext() *LockItemContext {
	var p = new(LockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockItem
	return p
}

func InitEmptyLockItemContext(p *LockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockItem
}

func (*LockItemContext) IsLockItemContext() {}

func NewLockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockItemContext {
	var p = new(LockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockItem

	return p
}

func (s *LockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LockItemContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *LockItemContext) LockOption() ILockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockOptionContext)
}

func (s *LockItemContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *LockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockItem(s)
	}
}

func (s *LockItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockItem(s)
	}
}

func (s *LockItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockItem() (localctx ILockItemContext) {
	localctx = NewLockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, MySQLParserRULE_lockItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3704)
		p.TableRef()
	}
	p.SetState(3706)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3705)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3708)
		p.LockOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockOptionContext is an interface to support dynamic dispatch.
type ILockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode

	// IsLockOptionContext differentiates from other interfaces.
	IsLockOptionContext()
}

type LockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockOptionContext() *LockOptionContext {
	var p = new(LockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockOption
	return p
}

func InitEmptyLockOptionContext(p *LockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lockOption
}

func (*LockOptionContext) IsLockOptionContext() {}

func NewLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockOptionContext {
	var p = new(LockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lockOption

	return p
}

func (s *LockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockOptionContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *LockOptionContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *LockOptionContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRITE_SYMBOL, 0)
}

func (s *LockOptionContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *LockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLockOption(s)
	}
}

func (s *LockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLockOption(s)
	}
}

func (s *LockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LockOption() (localctx ILockOptionContext) {
	localctx = NewLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, MySQLParserRULE_lockOption)
	var _la int

	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREAD_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3710)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL {
			{
				p.SetState(3711)
				p.Match(MySQLParserLOCAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserLOW_PRIORITY_SYMBOL, MySQLParserWRITE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3715)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOW_PRIORITY_SYMBOL {
			{
				p.SetState(3714)
				p.Match(MySQLParserLOW_PRIORITY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3717)
			p.Match(MySQLParserWRITE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaStatementContext is an interface to support dynamic dispatch.
type IXaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA_SYMBOL() antlr.TerminalNode
	Xid() IXidContext
	END_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	XaConvert() IXaConvertContext
	START_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode

	// IsXaStatementContext differentiates from other interfaces.
	IsXaStatementContext()
}

type XaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaStatementContext() *XaStatementContext {
	var p = new(XaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xaStatement
	return p
}

func InitEmptyXaStatementContext(p *XaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xaStatement
}

func (*XaStatementContext) IsXaStatementContext() {}

func NewXaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStatementContext {
	var p = new(XaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_xaStatement

	return p
}

func (s *XaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStatementContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXA_SYMBOL, 0)
}

func (s *XaStatementContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStatementContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *XaStatementContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREPARE_SYMBOL, 0)
}

func (s *XaStatementContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMIT_SYMBOL, 0)
}

func (s *XaStatementContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLBACK_SYMBOL, 0)
}

func (s *XaStatementContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRECOVER_SYMBOL, 0)
}

func (s *XaStatementContext) XaConvert() IXaConvertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaConvertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaConvertContext)
}

func (s *XaStatementContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *XaStatementContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEGIN_SYMBOL, 0)
}

func (s *XaStatementContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUSPEND_SYMBOL, 0)
}

func (s *XaStatementContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONE_SYMBOL, 0)
}

func (s *XaStatementContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPHASE_SYMBOL, 0)
}

func (s *XaStatementContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJOIN_SYMBOL, 0)
}

func (s *XaStatementContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESUME_SYMBOL, 0)
}

func (s *XaStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *XaStatementContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIGRATE_SYMBOL, 0)
}

func (s *XaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterXaStatement(s)
	}
}

func (s *XaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitXaStatement(s)
	}
}

func (s *XaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitXaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) XaStatement() (localctx IXaStatementContext) {
	localctx = NewXaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, MySQLParserRULE_xaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3720)
		p.Match(MySQLParserXA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserBEGIN_SYMBOL, MySQLParserSTART_SYMBOL:
		{
			p.SetState(3721)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBEGIN_SYMBOL || _la == MySQLParserSTART_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3722)
			p.Xid()
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserJOIN_SYMBOL || _la == MySQLParserRESUME_SYMBOL {
			{
				p.SetState(3723)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserJOIN_SYMBOL || _la == MySQLParserRESUME_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case MySQLParserEND_SYMBOL:
		{
			p.SetState(3726)
			p.Match(MySQLParserEND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3727)
			p.Xid()
		}
		p.SetState(3733)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserSUSPEND_SYMBOL {
			{
				p.SetState(3728)
				p.Match(MySQLParserSUSPEND_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserFOR_SYMBOL {
				{
					p.SetState(3729)
					p.Match(MySQLParserFOR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3730)
					p.Match(MySQLParserMIGRATE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	case MySQLParserPREPARE_SYMBOL:
		{
			p.SetState(3735)
			p.Match(MySQLParserPREPARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3736)
			p.Xid()
		}

	case MySQLParserCOMMIT_SYMBOL:
		{
			p.SetState(3737)
			p.Match(MySQLParserCOMMIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3738)
			p.Xid()
		}
		p.SetState(3741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserONE_SYMBOL {
			{
				p.SetState(3739)
				p.Match(MySQLParserONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3740)
				p.Match(MySQLParserPHASE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserROLLBACK_SYMBOL:
		{
			p.SetState(3743)
			p.Match(MySQLParserROLLBACK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3744)
			p.Xid()
		}

	case MySQLParserRECOVER_SYMBOL:
		{
			p.SetState(3745)
			p.Match(MySQLParserRECOVER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3746)
			p.XaConvert()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaConvertContext is an interface to support dynamic dispatch.
type IXaConvertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONVERT_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode

	// IsXaConvertContext differentiates from other interfaces.
	IsXaConvertContext()
}

type XaConvertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaConvertContext() *XaConvertContext {
	var p = new(XaConvertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xaConvert
	return p
}

func InitEmptyXaConvertContext(p *XaConvertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xaConvert
}

func (*XaConvertContext) IsXaConvertContext() {}

func NewXaConvertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaConvertContext {
	var p = new(XaConvertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_xaConvert

	return p
}

func (s *XaConvertContext) GetParser() antlr.Parser { return s.parser }

func (s *XaConvertContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONVERT_SYMBOL, 0)
}

func (s *XaConvertContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXID_SYMBOL, 0)
}

func (s *XaConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaConvertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterXaConvert(s)
	}
}

func (s *XaConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitXaConvert(s)
	}
}

func (s *XaConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitXaConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) XaConvert() (localctx IXaConvertContext) {
	localctx = NewXaConvertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, MySQLParserRULE_xaConvert)
	var _la int

	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3749)

		if !(serverVersion >= 50704) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50704", ""))
			goto errorExit
		}
		p.SetState(3752)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCONVERT_SYMBOL {
			{
				p.SetState(3750)
				p.Match(MySQLParserCONVERT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3751)
				p.Match(MySQLParserXID_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Ulong_number() IUlong_numberContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xid
	return p
}

func InitEmptyXidContext(p *XidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_xid
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *XidContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *XidContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *XidContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (s *XidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitXid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Xid() (localctx IXidContext) {
	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, MySQLParserRULE_xid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3757)
		p.TextString()
	}
	p.SetState(3764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(3758)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3759)
			p.TextString()
		}
		p.SetState(3762)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(3760)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3761)
				p.Ulong_number()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PURGE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	BEFORE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	ChangeMaster() IChangeMasterContext
	RESET_SYMBOL() antlr.TerminalNode
	AllResetOption() []IResetOptionContext
	ResetOption(i int) IResetOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	PERSIST_SYMBOL() antlr.TerminalNode
	IfExists() IIfExistsContext
	Identifier() IIdentifierContext
	Slave() ISlaveContext
	ChangeReplication() IChangeReplicationContext
	ReplicationLoad() IReplicationLoadContext
	GroupReplication() IGroupReplicationContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replicationStatement
	return p
}

func InitEmptyReplicationStatementContext(p *ReplicationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replicationStatement
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) PURGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPURGE_SYMBOL, 0)
}

func (s *ReplicationStatementContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGS_SYMBOL, 0)
}

func (s *ReplicationStatementContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *ReplicationStatementContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *ReplicationStatementContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *ReplicationStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *ReplicationStatementContext) BEFORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEFORE_SYMBOL, 0)
}

func (s *ReplicationStatementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESET_SYMBOL, 0)
}

func (s *ReplicationStatementContext) AllResetOption() []IResetOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResetOptionContext); ok {
			len++
		}
	}

	tst := make([]IResetOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResetOptionContext); ok {
			tst[i] = t.(IResetOptionContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationStatementContext) ResetOption(i int) IResetOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetOptionContext)
}

func (s *ReplicationStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ReplicationStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ReplicationStatementContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_SYMBOL, 0)
}

func (s *ReplicationStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *ReplicationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplicationStatementContext) Slave() ISlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveContext)
}

func (s *ReplicationStatementContext) ChangeReplication() IChangeReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationContext)
}

func (s *ReplicationStatementContext) ReplicationLoad() IReplicationLoadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationLoadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationLoadContext)
}

func (s *ReplicationStatementContext) GroupReplication() IGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupReplicationContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReplicationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, MySQLParserRULE_replicationStatement)
	var _la int

	p.SetState(3799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3766)
			p.Match(MySQLParserPURGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3767)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBINARY_SYMBOL || _la == MySQLParserMASTER_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3768)
			p.Match(MySQLParserLOGS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserTO_SYMBOL:
			{
				p.SetState(3769)
				p.Match(MySQLParserTO_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3770)
				p.TextLiteral()
			}

		case MySQLParserBEFORE_SYMBOL:
			{
				p.SetState(3771)
				p.Match(MySQLParserBEFORE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3772)
				p.expr(0)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3775)
			p.ChangeMaster()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3776)
			p.Match(MySQLParserRESET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3777)
			p.ResetOption()
		}
		p.SetState(3782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(3778)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3779)
				p.ResetOption()
			}

			p.SetState(3784)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(3785)

		if !(serverVersion > 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion > 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3786)
			p.Match(MySQLParserRESET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3787)
			p.Match(MySQLParserPERSIST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIF_SYMBOL {
			{
				p.SetState(3788)
				p.IfExists()
			}
			{
				p.SetState(3789)
				p.Identifier()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3793)
			p.Slave()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(3794)

		if !(serverVersion >= 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
			goto errorExit
		}
		{
			p.SetState(3795)
			p.ChangeReplication()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3796)
			p.ReplicationLoad()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(3797)

		if !(serverVersion > 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion > 50706", ""))
			goto errorExit
		}
		{
			p.SetState(3798)
			p.GroupReplication()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetOptionContext is an interface to support dynamic dispatch.
type IResetOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	MASTER_SYMBOL() antlr.TerminalNode
	MasterResetOptions() IMasterResetOptionsContext
	CACHE_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	Channel() IChannelContext

	// IsResetOptionContext differentiates from other interfaces.
	IsResetOptionContext()
}

type ResetOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyResetOptionContext() *ResetOptionContext {
	var p = new(ResetOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resetOption
	return p
}

func InitEmptyResetOptionContext(p *ResetOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resetOption
}

func (*ResetOptionContext) IsResetOptionContext() {}

func NewResetOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetOptionContext {
	var p = new(ResetOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resetOption

	return p
}

func (s *ResetOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetOptionContext) GetOption() antlr.Token { return s.option }

func (s *ResetOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *ResetOptionContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *ResetOptionContext) MasterResetOptions() IMasterResetOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterResetOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterResetOptionsContext)
}

func (s *ResetOptionContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCACHE_SYMBOL, 0)
}

func (s *ResetOptionContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *ResetOptionContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *ResetOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *ResetOptionContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ResetOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResetOption(s)
	}
}

func (s *ResetOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResetOption(s)
	}
}

func (s *ResetOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResetOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResetOption() (localctx IResetOptionContext) {
	localctx = NewResetOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, MySQLParserRULE_resetOption)
	p.SetState(3815)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3801)

			var _m = p.Match(MySQLParserMASTER_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 437, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3802)
				p.MasterResetOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(3805)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3806)

			var _m = p.Match(MySQLParserQUERY_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3807)
			p.Match(MySQLParserCACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3808)

			var _m = p.Match(MySQLParserSLAVE_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3810)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3809)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(3813)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 439, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3812)
				p.Channel()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterResetOptionsContext is an interface to support dynamic dispatch.
type IMasterResetOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	Real_ulonglong_number() IReal_ulonglong_numberContext

	// IsMasterResetOptionsContext differentiates from other interfaces.
	IsMasterResetOptionsContext()
}

type MasterResetOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterResetOptionsContext() *MasterResetOptionsContext {
	var p = new(MasterResetOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterResetOptions
	return p
}

func InitEmptyMasterResetOptionsContext(p *MasterResetOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterResetOptions
}

func (*MasterResetOptionsContext) IsMasterResetOptionsContext() {}

func NewMasterResetOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterResetOptionsContext {
	var p = new(MasterResetOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_masterResetOptions

	return p
}

func (s *MasterResetOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterResetOptionsContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *MasterResetOptionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *MasterResetOptionsContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *MasterResetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterResetOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterResetOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterMasterResetOptions(s)
	}
}

func (s *MasterResetOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitMasterResetOptions(s)
	}
}

func (s *MasterResetOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitMasterResetOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) MasterResetOptions() (localctx IMasterResetOptionsContext) {
	localctx = NewMasterResetOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, MySQLParserRULE_masterResetOptions)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(3817)

	if !(serverVersion >= 80000) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
		goto errorExit
	}
	{
		p.SetState(3818)
		p.Match(MySQLParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3819)

		if !(serverVersion < 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
			goto errorExit
		}
		{
			p.SetState(3820)
			p.Real_ulong_number()
		}

	case 2:
		p.SetState(3821)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(3822)
			p.Real_ulonglong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationLoadContext is an interface to support dynamic dispatch.
type IReplicationLoadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext

	// IsReplicationLoadContext differentiates from other interfaces.
	IsReplicationLoadContext()
}

type ReplicationLoadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationLoadContext() *ReplicationLoadContext {
	var p = new(ReplicationLoadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replicationLoad
	return p
}

func InitEmptyReplicationLoadContext(p *ReplicationLoadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replicationLoad
}

func (*ReplicationLoadContext) IsReplicationLoadContext() {}

func NewReplicationLoadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationLoadContext {
	var p = new(ReplicationLoadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_replicationLoad

	return p
}

func (s *ReplicationLoadContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationLoadContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOAD_SYMBOL, 0)
}

func (s *ReplicationLoadContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *ReplicationLoadContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *ReplicationLoadContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *ReplicationLoadContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *ReplicationLoadContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ReplicationLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationLoadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReplicationLoad(s)
	}
}

func (s *ReplicationLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReplicationLoad(s)
	}
}

func (s *ReplicationLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReplicationLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ReplicationLoad() (localctx IReplicationLoadContext) {
	localctx = NewReplicationLoadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, MySQLParserRULE_replicationLoad)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3825)
		p.Match(MySQLParserLOAD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3829)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserDATA_SYMBOL:
		{
			p.SetState(3826)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserTABLE_SYMBOL:
		{
			p.SetState(3827)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3828)
			p.TableRef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(3831)
		p.Match(MySQLParserFROM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3832)
		p.Match(MySQLParserMASTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	ChangeMasterOptions() IChangeMasterOptionsContext
	Channel() IChannelContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeMaster
	return p
}

func InitEmptyChangeMasterContext(p *ChangeMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeMaster
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGE_SYMBOL, 0)
}

func (s *ChangeMasterContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *ChangeMasterContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *ChangeMasterContext) ChangeMasterOptions() IChangeMasterOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterOptionsContext)
}

func (s *ChangeMasterContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (s *ChangeMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitChangeMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ChangeMaster() (localctx IChangeMasterContext) {
	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, MySQLParserRULE_changeMaster)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3834)
		p.Match(MySQLParserCHANGE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3835)
		p.Match(MySQLParserMASTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3836)
		p.Match(MySQLParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3837)
		p.ChangeMasterOptions()
	}
	p.SetState(3839)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3838)
			p.Channel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterOptionsContext is an interface to support dynamic dispatch.
type IChangeMasterOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsChangeMasterOptionsContext differentiates from other interfaces.
	IsChangeMasterOptionsContext()
}

type ChangeMasterOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterOptionsContext() *ChangeMasterOptionsContext {
	var p = new(ChangeMasterOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeMasterOptions
	return p
}

func InitEmptyChangeMasterOptionsContext(p *ChangeMasterOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeMasterOptions
}

func (*ChangeMasterOptionsContext) IsChangeMasterOptionsContext() {}

func NewChangeMasterOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterOptionsContext {
	var p = new(ChangeMasterOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_changeMasterOptions

	return p
}

func (s *ChangeMasterOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterOptionsContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterOptionsContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ChangeMasterOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ChangeMasterOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterChangeMasterOptions(s)
	}
}

func (s *ChangeMasterOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitChangeMasterOptions(s)
	}
}

func (s *ChangeMasterOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitChangeMasterOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ChangeMasterOptions() (localctx IChangeMasterOptionsContext) {
	localctx = NewChangeMasterOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, MySQLParserRULE_changeMasterOptions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3841)
		p.MasterOption()
	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3842)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3843)
				p.MasterOption()
			}

		}
		p.SetState(3848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 444, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode
	MASTER_BIND_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode
	MasterTlsCiphersuitesDef() IMasterTlsCiphersuitesDefContext
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	ServerIdList() IServerIdListContext
	MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode
	PrivilegeCheckDef() IPrivilegeCheckDefContext
	REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode
	REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode
	TablePrimaryKeyCheckDef() ITablePrimaryKeyCheckDefContext
	MasterFileDef() IMasterFileDefContext

	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterOption
	return p
}

func InitEmptyMasterOptionContext(p *MasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterOption
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HOST_SYMBOL, 0)
}

func (s *MasterOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *MasterOptionContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterOptionContext) NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNETWORK_NAMESPACE_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_BIND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_BIND_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_USER_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PORT_SYMBOL, 0)
}

func (s *MasterOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *MasterOptionContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_DELAY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_TLS_CIPHERSUITES_SYMBOL, 0)
}

func (s *MasterOptionContext) MasterTlsCiphersuitesDef() IMasterTlsCiphersuitesDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterTlsCiphersuitesDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterTlsCiphersuitesDefContext)
}

func (s *MasterOptionContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *MasterOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *MasterOptionContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *MasterOptionContext) GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_MASTER_PUBLIC_KEY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *MasterOptionContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *MasterOptionContext) ServerIdList() IServerIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerIdListContext)
}

func (s *MasterOptionContext) MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)
}

func (s *MasterOptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *MasterOptionContext) MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *MasterOptionContext) PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGE_CHECKS_USER_SYMBOL, 0)
}

func (s *MasterOptionContext) PrivilegeCheckDef() IPrivilegeCheckDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeCheckDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeCheckDefContext)
}

func (s *MasterOptionContext) REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_ROW_FORMAT_SYMBOL, 0)
}

func (s *MasterOptionContext) REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)
}

func (s *MasterOptionContext) TablePrimaryKeyCheckDef() ITablePrimaryKeyCheckDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePrimaryKeyCheckDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePrimaryKeyCheckDefContext)
}

func (s *MasterOptionContext) MasterFileDef() IMasterFileDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterFileDefContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterMasterOption(s)
	}
}

func (s *MasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitMasterOption(s)
	}
}

func (s *MasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) MasterOption() (localctx IMasterOptionContext) {
	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, MySQLParserRULE_masterOption)
	p.SetState(3940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserMASTER_HOST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3849)
			p.Match(MySQLParserMASTER_HOST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3850)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3851)
			p.TextStringNoLinebreak()
		}

	case MySQLParserNETWORK_NAMESPACE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3852)
			p.Match(MySQLParserNETWORK_NAMESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3853)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3854)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_BIND_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3855)
			p.Match(MySQLParserMASTER_BIND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3856)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3857)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3858)
			p.Match(MySQLParserMASTER_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3859)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3860)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_PASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3861)
			p.Match(MySQLParserMASTER_PASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3862)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3863)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_PORT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3864)
			p.Match(MySQLParserMASTER_PORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3865)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3866)
			p.Ulong_number()
		}

	case MySQLParserMASTER_CONNECT_RETRY_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3867)
			p.Match(MySQLParserMASTER_CONNECT_RETRY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3868)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3869)
			p.Ulong_number()
		}

	case MySQLParserMASTER_RETRY_COUNT_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3870)
			p.Match(MySQLParserMASTER_RETRY_COUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3871)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3872)
			p.Ulong_number()
		}

	case MySQLParserMASTER_DELAY_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3873)
			p.Match(MySQLParserMASTER_DELAY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3874)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3875)
			p.Ulong_number()
		}

	case MySQLParserMASTER_SSL_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3876)
			p.Match(MySQLParserMASTER_SSL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3877)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3878)
			p.Ulong_number()
		}

	case MySQLParserMASTER_SSL_CA_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3879)
			p.Match(MySQLParserMASTER_SSL_CA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3880)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3881)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_SSL_CAPATH_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3882)
			p.Match(MySQLParserMASTER_SSL_CAPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3883)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3884)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_TLS_VERSION_SYMBOL:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3885)
			p.Match(MySQLParserMASTER_TLS_VERSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3886)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3887)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_SSL_CERT_SYMBOL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3888)
			p.Match(MySQLParserMASTER_SSL_CERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3889)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3890)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_TLS_CIPHERSUITES_SYMBOL:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3891)
			p.Match(MySQLParserMASTER_TLS_CIPHERSUITES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3892)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3893)
			p.MasterTlsCiphersuitesDef()
		}

	case MySQLParserMASTER_SSL_CIPHER_SYMBOL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3894)
			p.Match(MySQLParserMASTER_SSL_CIPHER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3895)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3896)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_SSL_KEY_SYMBOL:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3897)
			p.Match(MySQLParserMASTER_SSL_KEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3899)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3900)
			p.Match(MySQLParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3902)
			p.Ulong_number()
		}

	case MySQLParserMASTER_SSL_CRL_SYMBOL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3903)
			p.Match(MySQLParserMASTER_SSL_CRL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3904)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3905)
			p.TextLiteral()
		}

	case MySQLParserMASTER_SSL_CRLPATH_SYMBOL:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3906)
			p.Match(MySQLParserMASTER_SSL_CRLPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3907)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3908)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3909)
			p.Match(MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3910)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3911)
			p.TextStringNoLinebreak()
		}

	case MySQLParserGET_MASTER_PUBLIC_KEY_SYMBOL:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3912)
			p.Match(MySQLParserGET_MASTER_PUBLIC_KEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3913)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3914)
			p.Ulong_number()
		}

	case MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3915)
			p.Match(MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3916)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3917)
			p.Ulong_number()
		}

	case MySQLParserIGNORE_SERVER_IDS_SYMBOL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3918)
			p.Match(MySQLParserIGNORE_SERVER_IDS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3919)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3920)
			p.ServerIdList()
		}

	case MySQLParserMASTER_COMPRESSION_ALGORITHM_SYMBOL:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3921)
			p.Match(MySQLParserMASTER_COMPRESSION_ALGORITHM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3922)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3923)
			p.TextStringLiteral()
		}

	case MySQLParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3924)
			p.Match(MySQLParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3925)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3926)
			p.Ulong_number()
		}

	case MySQLParserMASTER_AUTO_POSITION_SYMBOL:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3927)
			p.Match(MySQLParserMASTER_AUTO_POSITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3928)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3929)
			p.Ulong_number()
		}

	case MySQLParserPRIVILEGE_CHECKS_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3930)
			p.Match(MySQLParserPRIVILEGE_CHECKS_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3931)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3932)
			p.PrivilegeCheckDef()
		}

	case MySQLParserREQUIRE_ROW_FORMAT_SYMBOL:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3933)
			p.Match(MySQLParserREQUIRE_ROW_FORMAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3934)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3935)
			p.Ulong_number()
		}

	case MySQLParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3936)
			p.Match(MySQLParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3937)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3938)
			p.TablePrimaryKeyCheckDef()
		}

	case MySQLParserMASTER_LOG_FILE_SYMBOL, MySQLParserMASTER_LOG_POS_SYMBOL, MySQLParserRELAY_LOG_FILE_SYMBOL, MySQLParserRELAY_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3939)
			p.MasterFileDef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeCheckDefContext is an interface to support dynamic dispatch.
type IPrivilegeCheckDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentifierOrText() IUserIdentifierOrTextContext
	NULL_SYMBOL() antlr.TerminalNode

	// IsPrivilegeCheckDefContext differentiates from other interfaces.
	IsPrivilegeCheckDefContext()
}

type PrivilegeCheckDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeCheckDefContext() *PrivilegeCheckDefContext {
	var p = new(PrivilegeCheckDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_privilegeCheckDef
	return p
}

func InitEmptyPrivilegeCheckDefContext(p *PrivilegeCheckDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_privilegeCheckDef
}

func (*PrivilegeCheckDefContext) IsPrivilegeCheckDefContext() {}

func NewPrivilegeCheckDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeCheckDefContext {
	var p = new(PrivilegeCheckDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_privilegeCheckDef

	return p
}

func (s *PrivilegeCheckDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeCheckDefContext) UserIdentifierOrText() IUserIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifierOrTextContext)
}

func (s *PrivilegeCheckDefContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *PrivilegeCheckDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeCheckDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeCheckDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrivilegeCheckDef(s)
	}
}

func (s *PrivilegeCheckDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrivilegeCheckDef(s)
	}
}

func (s *PrivilegeCheckDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrivilegeCheckDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PrivilegeCheckDef() (localctx IPrivilegeCheckDefContext) {
	localctx = NewPrivilegeCheckDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, MySQLParserRULE_privilegeCheckDef)
	p.SetState(3944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3942)
			p.UserIdentifierOrText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3943)
			p.Match(MySQLParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePrimaryKeyCheckDefContext is an interface to support dynamic dispatch.
type ITablePrimaryKeyCheckDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAM_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	OFF_SYMBOL() antlr.TerminalNode

	// IsTablePrimaryKeyCheckDefContext differentiates from other interfaces.
	IsTablePrimaryKeyCheckDefContext()
}

type TablePrimaryKeyCheckDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePrimaryKeyCheckDefContext() *TablePrimaryKeyCheckDefContext {
	var p = new(TablePrimaryKeyCheckDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablePrimaryKeyCheckDef
	return p
}

func InitEmptyTablePrimaryKeyCheckDefContext(p *TablePrimaryKeyCheckDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablePrimaryKeyCheckDef
}

func (*TablePrimaryKeyCheckDefContext) IsTablePrimaryKeyCheckDefContext() {}

func NewTablePrimaryKeyCheckDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePrimaryKeyCheckDefContext {
	var p = new(TablePrimaryKeyCheckDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tablePrimaryKeyCheckDef

	return p
}

func (s *TablePrimaryKeyCheckDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePrimaryKeyCheckDefContext) STREAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTREAM_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) OFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFF_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePrimaryKeyCheckDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePrimaryKeyCheckDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTablePrimaryKeyCheckDef(s)
	}
}

func (s *TablePrimaryKeyCheckDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTablePrimaryKeyCheckDef(s)
	}
}

func (s *TablePrimaryKeyCheckDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTablePrimaryKeyCheckDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TablePrimaryKeyCheckDef() (localctx ITablePrimaryKeyCheckDefContext) {
	localctx = NewTablePrimaryKeyCheckDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, MySQLParserRULE_tablePrimaryKeyCheckDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3946)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserON_SYMBOL || _la == MySQLParserSTREAM_SYMBOL || _la == MySQLParserOFF_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterTlsCiphersuitesDefContext is an interface to support dynamic dispatch.
type IMasterTlsCiphersuitesDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	NULL_SYMBOL() antlr.TerminalNode

	// IsMasterTlsCiphersuitesDefContext differentiates from other interfaces.
	IsMasterTlsCiphersuitesDefContext()
}

type MasterTlsCiphersuitesDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterTlsCiphersuitesDefContext() *MasterTlsCiphersuitesDefContext {
	var p = new(MasterTlsCiphersuitesDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterTlsCiphersuitesDef
	return p
}

func InitEmptyMasterTlsCiphersuitesDefContext(p *MasterTlsCiphersuitesDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterTlsCiphersuitesDef
}

func (*MasterTlsCiphersuitesDefContext) IsMasterTlsCiphersuitesDefContext() {}

func NewMasterTlsCiphersuitesDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterTlsCiphersuitesDefContext {
	var p = new(MasterTlsCiphersuitesDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_masterTlsCiphersuitesDef

	return p
}

func (s *MasterTlsCiphersuitesDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterTlsCiphersuitesDefContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterTlsCiphersuitesDefContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *MasterTlsCiphersuitesDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterTlsCiphersuitesDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterTlsCiphersuitesDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterMasterTlsCiphersuitesDef(s)
	}
}

func (s *MasterTlsCiphersuitesDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitMasterTlsCiphersuitesDef(s)
	}
}

func (s *MasterTlsCiphersuitesDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitMasterTlsCiphersuitesDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) MasterTlsCiphersuitesDef() (localctx IMasterTlsCiphersuitesDefContext) {
	localctx = NewMasterTlsCiphersuitesDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, MySQLParserRULE_masterTlsCiphersuitesDef)
	p.SetState(3950)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 447, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3948)
			p.TextStringNoLinebreak()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3949)
			p.Match(MySQLParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterFileDefContext is an interface to support dynamic dispatch.
type IMasterFileDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext

	// IsMasterFileDefContext differentiates from other interfaces.
	IsMasterFileDefContext()
}

type MasterFileDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterFileDefContext() *MasterFileDefContext {
	var p = new(MasterFileDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterFileDef
	return p
}

func InitEmptyMasterFileDefContext(p *MasterFileDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_masterFileDef
}

func (*MasterFileDefContext) IsMasterFileDefContext() {}

func NewMasterFileDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterFileDefContext {
	var p = new(MasterFileDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_masterFileDef

	return p
}

func (s *MasterFileDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterFileDefContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *MasterFileDefContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *MasterFileDefContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterFileDefContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *MasterFileDefContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *MasterFileDefContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *MasterFileDefContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *MasterFileDefContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *MasterFileDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterFileDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterFileDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterMasterFileDef(s)
	}
}

func (s *MasterFileDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitMasterFileDef(s)
	}
}

func (s *MasterFileDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitMasterFileDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) MasterFileDef() (localctx IMasterFileDefContext) {
	localctx = NewMasterFileDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, MySQLParserRULE_masterFileDef)
	p.SetState(3964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserMASTER_LOG_FILE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3952)
			p.Match(MySQLParserMASTER_LOG_FILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3953)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3954)
			p.TextStringNoLinebreak()
		}

	case MySQLParserMASTER_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3955)
			p.Match(MySQLParserMASTER_LOG_POS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3956)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3957)
			p.Ulonglong_number()
		}

	case MySQLParserRELAY_LOG_FILE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3958)
			p.Match(MySQLParserRELAY_LOG_FILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3959)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3960)
			p.TextStringNoLinebreak()
		}

	case MySQLParserRELAY_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3961)
			p.Match(MySQLParserRELAY_LOG_POS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3962)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerIdListContext is an interface to support dynamic dispatch.
type IServerIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsServerIdListContext differentiates from other interfaces.
	IsServerIdListContext()
}

type ServerIdListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerIdListContext() *ServerIdListContext {
	var p = new(ServerIdListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverIdList
	return p
}

func InitEmptyServerIdListContext(p *ServerIdListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverIdList
}

func (*ServerIdListContext) IsServerIdListContext() {}

func NewServerIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerIdListContext {
	var p = new(ServerIdListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_serverIdList

	return p
}

func (s *ServerIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerIdListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ServerIdListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ServerIdListContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ServerIdListContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *ServerIdListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ServerIdListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ServerIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterServerIdList(s)
	}
}

func (s *ServerIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitServerIdList(s)
	}
}

func (s *ServerIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitServerIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ServerIdList() (localctx IServerIdListContext) {
	localctx = NewServerIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, MySQLParserRULE_serverIdList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3966)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3975)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&28587302322183) != 0 {
		{
			p.SetState(3967)
			p.Ulong_number()
		}
		p.SetState(3972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(3968)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3969)
				p.Ulong_number()
			}

			p.SetState(3974)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3977)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeReplicationContext is an interface to support dynamic dispatch.
type IChangeReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	AllFilterDefinition() []IFilterDefinitionContext
	FilterDefinition(i int) IFilterDefinitionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Channel() IChannelContext

	// IsChangeReplicationContext differentiates from other interfaces.
	IsChangeReplicationContext()
}

type ChangeReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationContext() *ChangeReplicationContext {
	var p = new(ChangeReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeReplication
	return p
}

func InitEmptyChangeReplicationContext(p *ChangeReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_changeReplication
}

func (*ChangeReplicationContext) IsChangeReplicationContext() {}

func NewChangeReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationContext {
	var p = new(ChangeReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_changeReplication

	return p
}

func (s *ChangeReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGE_SYMBOL, 0)
}

func (s *ChangeReplicationContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATION_SYMBOL, 0)
}

func (s *ChangeReplicationContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILTER_SYMBOL, 0)
}

func (s *ChangeReplicationContext) AllFilterDefinition() []IFilterDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFilterDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterDefinitionContext); ok {
			tst[i] = t.(IFilterDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationContext) FilterDefinition(i int) IFilterDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDefinitionContext)
}

func (s *ChangeReplicationContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ChangeReplicationContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ChangeReplicationContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ChangeReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterChangeReplication(s)
	}
}

func (s *ChangeReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitChangeReplication(s)
	}
}

func (s *ChangeReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitChangeReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ChangeReplication() (localctx IChangeReplicationContext) {
	localctx = NewChangeReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, MySQLParserRULE_changeReplication)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3979)
		p.Match(MySQLParserCHANGE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3980)
		p.Match(MySQLParserREPLICATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3981)
		p.Match(MySQLParserFILTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3982)
		p.FilterDefinition()
	}
	p.SetState(3987)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3983)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3984)
				p.FilterDefinition()
			}

		}
		p.SetState(3989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 452, p.GetParserRuleContext()) == 1 {
		p.SetState(3990)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(3991)
			p.Channel()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDefinitionContext is an interface to support dynamic dispatch.
type IFilterDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FilterDbList() IFilterDbListContext
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	FilterTableList() IFilterTableListContext
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	FilterStringList() IFilterStringListContext
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	FilterDbPairList() IFilterDbPairListContext

	// IsFilterDefinitionContext differentiates from other interfaces.
	IsFilterDefinitionContext()
}

type FilterDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDefinitionContext() *FilterDefinitionContext {
	var p = new(FilterDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDefinition
	return p
}

func InitEmptyFilterDefinitionContext(p *FilterDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDefinition
}

func (*FilterDefinitionContext) IsFilterDefinitionContext() {}

func NewFilterDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDefinitionContext {
	var p = new(FilterDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterDefinition

	return p
}

func (s *FilterDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDefinitionContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *FilterDefinitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *FilterDefinitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterDbList() IFilterDbListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDbListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDbListContext)
}

func (s *FilterDefinitionContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterTableList() IFilterTableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterTableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterTableListContext)
}

func (s *FilterDefinitionContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterStringList() IFilterStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterStringListContext)
}

func (s *FilterDefinitionContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterDbPairList() IFilterDbPairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDbPairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDbPairListContext)
}

func (s *FilterDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterDefinition(s)
	}
}

func (s *FilterDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterDefinition(s)
	}
}

func (s *FilterDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterDefinition() (localctx IFilterDefinitionContext) {
	localctx = NewFilterDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, MySQLParserRULE_filterDefinition)
	var _la int

	p.SetState(4043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREPLICATE_DO_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3994)
			p.Match(MySQLParserREPLICATE_DO_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3995)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3996)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3998)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 453, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3997)
				p.FilterDbList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4000)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_IGNORE_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4001)
			p.Match(MySQLParserREPLICATE_IGNORE_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4002)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4003)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4005)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 454, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4004)
				p.FilterDbList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4007)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_DO_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4008)
			p.Match(MySQLParserREPLICATE_DO_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4009)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4012)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4011)
				p.FilterTableList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4014)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4015)
			p.Match(MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4016)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4017)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4019)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4018)
				p.FilterTableList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4021)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4022)
			p.Match(MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4023)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4026)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 457, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4025)
				p.FilterStringList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4028)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4029)
			p.Match(MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4030)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4031)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 458, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4032)
				p.FilterStringList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4035)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREPLICATE_REWRITE_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4036)
			p.Match(MySQLParserREPLICATE_REWRITE_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4037)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4038)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4040)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4039)
				p.FilterDbPairList()
			}

		}
		{
			p.SetState(4042)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDbListContext is an interface to support dynamic dispatch.
type IFilterDbListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSchemaRef() []ISchemaRefContext
	SchemaRef(i int) ISchemaRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterDbListContext differentiates from other interfaces.
	IsFilterDbListContext()
}

type FilterDbListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDbListContext() *FilterDbListContext {
	var p = new(FilterDbListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDbList
	return p
}

func InitEmptyFilterDbListContext(p *FilterDbListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDbList
}

func (*FilterDbListContext) IsFilterDbListContext() {}

func NewFilterDbListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDbListContext {
	var p = new(FilterDbListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterDbList

	return p
}

func (s *FilterDbListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDbListContext) AllSchemaRef() []ISchemaRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaRefContext); ok {
			len++
		}
	}

	tst := make([]ISchemaRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaRefContext); ok {
			tst[i] = t.(ISchemaRefContext)
			i++
		}
	}

	return tst
}

func (s *FilterDbListContext) SchemaRef(i int) ISchemaRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *FilterDbListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FilterDbListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FilterDbListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDbListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDbListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterDbList(s)
	}
}

func (s *FilterDbListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterDbList(s)
	}
}

func (s *FilterDbListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterDbList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterDbList() (localctx IFilterDbListContext) {
	localctx = NewFilterDbListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, MySQLParserRULE_filterDbList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4045)
		p.SchemaRef()
	}
	p.SetState(4050)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4046)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4047)
			p.SchemaRef()
		}

		p.SetState(4052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterTableListContext is an interface to support dynamic dispatch.
type IFilterTableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFilterTableRef() []IFilterTableRefContext
	FilterTableRef(i int) IFilterTableRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterTableListContext differentiates from other interfaces.
	IsFilterTableListContext()
}

type FilterTableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterTableListContext() *FilterTableListContext {
	var p = new(FilterTableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterTableList
	return p
}

func InitEmptyFilterTableListContext(p *FilterTableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterTableList
}

func (*FilterTableListContext) IsFilterTableListContext() {}

func NewFilterTableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterTableListContext {
	var p = new(FilterTableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterTableList

	return p
}

func (s *FilterTableListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterTableListContext) AllFilterTableRef() []IFilterTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterTableRefContext); ok {
			len++
		}
	}

	tst := make([]IFilterTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterTableRefContext); ok {
			tst[i] = t.(IFilterTableRefContext)
			i++
		}
	}

	return tst
}

func (s *FilterTableListContext) FilterTableRef(i int) IFilterTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterTableRefContext)
}

func (s *FilterTableListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FilterTableListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FilterTableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterTableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterTableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterTableList(s)
	}
}

func (s *FilterTableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterTableList(s)
	}
}

func (s *FilterTableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterTableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterTableList() (localctx IFilterTableListContext) {
	localctx = NewFilterTableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, MySQLParserRULE_filterTableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4053)
		p.FilterTableRef()
	}
	p.SetState(4058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4054)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4055)
			p.FilterTableRef()
		}

		p.SetState(4060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterStringListContext is an interface to support dynamic dispatch.
type IFilterStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFilterWildDbTableString() []IFilterWildDbTableStringContext
	FilterWildDbTableString(i int) IFilterWildDbTableStringContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterStringListContext differentiates from other interfaces.
	IsFilterStringListContext()
}

type FilterStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterStringListContext() *FilterStringListContext {
	var p = new(FilterStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterStringList
	return p
}

func InitEmptyFilterStringListContext(p *FilterStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterStringList
}

func (*FilterStringListContext) IsFilterStringListContext() {}

func NewFilterStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterStringListContext {
	var p = new(FilterStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterStringList

	return p
}

func (s *FilterStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterStringListContext) AllFilterWildDbTableString() []IFilterWildDbTableStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterWildDbTableStringContext); ok {
			len++
		}
	}

	tst := make([]IFilterWildDbTableStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterWildDbTableStringContext); ok {
			tst[i] = t.(IFilterWildDbTableStringContext)
			i++
		}
	}

	return tst
}

func (s *FilterStringListContext) FilterWildDbTableString(i int) IFilterWildDbTableStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterWildDbTableStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterWildDbTableStringContext)
}

func (s *FilterStringListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FilterStringListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FilterStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterStringList(s)
	}
}

func (s *FilterStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterStringList(s)
	}
}

func (s *FilterStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterStringList() (localctx IFilterStringListContext) {
	localctx = NewFilterStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, MySQLParserRULE_filterStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4061)
		p.FilterWildDbTableString()
	}
	p.SetState(4066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4062)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4063)
			p.FilterWildDbTableString()
		}

		p.SetState(4068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterWildDbTableStringContext is an interface to support dynamic dispatch.
type IFilterWildDbTableStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringNoLinebreak() ITextStringNoLinebreakContext

	// IsFilterWildDbTableStringContext differentiates from other interfaces.
	IsFilterWildDbTableStringContext()
}

type FilterWildDbTableStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterWildDbTableStringContext() *FilterWildDbTableStringContext {
	var p = new(FilterWildDbTableStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterWildDbTableString
	return p
}

func InitEmptyFilterWildDbTableStringContext(p *FilterWildDbTableStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterWildDbTableString
}

func (*FilterWildDbTableStringContext) IsFilterWildDbTableStringContext() {}

func NewFilterWildDbTableStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterWildDbTableStringContext {
	var p = new(FilterWildDbTableStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterWildDbTableString

	return p
}

func (s *FilterWildDbTableStringContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterWildDbTableStringContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *FilterWildDbTableStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterWildDbTableStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterWildDbTableStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterWildDbTableString(s)
	}
}

func (s *FilterWildDbTableStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterWildDbTableString(s)
	}
}

func (s *FilterWildDbTableStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterWildDbTableString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterWildDbTableString() (localctx IFilterWildDbTableStringContext) {
	localctx = NewFilterWildDbTableStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, MySQLParserRULE_filterWildDbTableString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4069)
		p.TextStringNoLinebreak()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDbPairListContext is an interface to support dynamic dispatch.
type IFilterDbPairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSchemaIdentifierPair() []ISchemaIdentifierPairContext
	SchemaIdentifierPair(i int) ISchemaIdentifierPairContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterDbPairListContext differentiates from other interfaces.
	IsFilterDbPairListContext()
}

type FilterDbPairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDbPairListContext() *FilterDbPairListContext {
	var p = new(FilterDbPairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDbPairList
	return p
}

func InitEmptyFilterDbPairListContext(p *FilterDbPairListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterDbPairList
}

func (*FilterDbPairListContext) IsFilterDbPairListContext() {}

func NewFilterDbPairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDbPairListContext {
	var p = new(FilterDbPairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterDbPairList

	return p
}

func (s *FilterDbPairListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDbPairListContext) AllSchemaIdentifierPair() []ISchemaIdentifierPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaIdentifierPairContext); ok {
			len++
		}
	}

	tst := make([]ISchemaIdentifierPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaIdentifierPairContext); ok {
			tst[i] = t.(ISchemaIdentifierPairContext)
			i++
		}
	}

	return tst
}

func (s *FilterDbPairListContext) SchemaIdentifierPair(i int) ISchemaIdentifierPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaIdentifierPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaIdentifierPairContext)
}

func (s *FilterDbPairListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *FilterDbPairListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *FilterDbPairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDbPairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDbPairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterDbPairList(s)
	}
}

func (s *FilterDbPairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterDbPairList(s)
	}
}

func (s *FilterDbPairListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterDbPairList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterDbPairList() (localctx IFilterDbPairListContext) {
	localctx = NewFilterDbPairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, MySQLParserRULE_filterDbPairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4071)
		p.SchemaIdentifierPair()
	}
	p.SetState(4076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4072)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4073)
			p.SchemaIdentifierPair()
		}

		p.SetState(4078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveContext is an interface to support dynamic dispatch.
type ISlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	SlaveConnectionOptions() ISlaveConnectionOptionsContext
	SlaveThreadOptions() ISlaveThreadOptionsContext
	UNTIL_SYMBOL() antlr.TerminalNode
	SlaveUntilOptions() ISlaveUntilOptionsContext
	Channel() IChannelContext
	STOP_SYMBOL() antlr.TerminalNode

	// IsSlaveContext differentiates from other interfaces.
	IsSlaveContext()
}

type SlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveContext() *SlaveContext {
	var p = new(SlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slave
	return p
}

func InitEmptySlaveContext(p *SlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slave
}

func (*SlaveContext) IsSlaveContext() {}

func NewSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveContext {
	var p = new(SlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_slave

	return p
}

func (s *SlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *SlaveContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *SlaveContext) SlaveConnectionOptions() ISlaveConnectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveConnectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveConnectionOptionsContext)
}

func (s *SlaveContext) SlaveThreadOptions() ISlaveThreadOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveThreadOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveThreadOptionsContext)
}

func (s *SlaveContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNTIL_SYMBOL, 0)
}

func (s *SlaveContext) SlaveUntilOptions() ISlaveUntilOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveUntilOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveUntilOptionsContext)
}

func (s *SlaveContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *SlaveContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTOP_SYMBOL, 0)
}

func (s *SlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSlave(s)
	}
}

func (s *SlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSlave(s)
	}
}

func (s *SlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Slave() (localctx ISlaveContext) {
	localctx = NewSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, MySQLParserRULE_slave)
	p.SetState(4100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserSTART_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4079)
			p.Match(MySQLParserSTART_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4080)
			p.Match(MySQLParserSLAVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4082)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4081)
				p.SlaveThreadOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4086)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4084)
				p.Match(MySQLParserUNTIL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4085)
				p.SlaveUntilOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4088)
			p.SlaveConnectionOptions()
		}
		p.SetState(4090)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4089)
				p.Channel()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserSTOP_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4092)
			p.Match(MySQLParserSTOP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4093)
			p.Match(MySQLParserSLAVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4095)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4094)
				p.SlaveThreadOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4098)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 469, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4097)
				p.Channel()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveUntilOptionsContext is an interface to support dynamic dispatch.
type ISlaveUntilOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMasterFileDef() []IMasterFileDefContext
	MasterFileDef(i int) IMasterFileDefContext
	EQUAL_OPERATOR() antlr.TerminalNode
	TextString() ITextStringContext
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSlaveUntilOptionsContext differentiates from other interfaces.
	IsSlaveUntilOptionsContext()
}

type SlaveUntilOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveUntilOptionsContext() *SlaveUntilOptionsContext {
	var p = new(SlaveUntilOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveUntilOptions
	return p
}

func InitEmptySlaveUntilOptionsContext(p *SlaveUntilOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveUntilOptions
}

func (*SlaveUntilOptionsContext) IsSlaveUntilOptionsContext() {}

func NewSlaveUntilOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveUntilOptionsContext {
	var p = new(SlaveUntilOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_slaveUntilOptions

	return p
}

func (s *SlaveUntilOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveUntilOptionsContext) AllMasterFileDef() []IMasterFileDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			len++
		}
	}

	tst := make([]IMasterFileDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterFileDefContext); ok {
			tst[i] = t.(IMasterFileDefContext)
			i++
		}
	}

	return tst
}

func (s *SlaveUntilOptionsContext) MasterFileDef(i int) IMasterFileDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterFileDefContext)
}

func (s *SlaveUntilOptionsContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *SlaveUntilOptionsContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SlaveUntilOptionsContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *SlaveUntilOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *SlaveUntilOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveUntilOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveUntilOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSlaveUntilOptions(s)
	}
}

func (s *SlaveUntilOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSlaveUntilOptions(s)
	}
}

func (s *SlaveUntilOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSlaveUntilOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SlaveUntilOptions() (localctx ISlaveUntilOptionsContext) {
	localctx = NewSlaveUntilOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, MySQLParserRULE_slaveUntilOptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 471, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4102)
			p.MasterFileDef()
		}

	case 2:
		p.SetState(4103)

		if !(serverVersion >= 50606) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50606", ""))
			goto errorExit
		}
		{
			p.SetState(4104)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserSQL_AFTER_GTIDS_SYMBOL || _la == MySQLParserSQL_BEFORE_GTIDS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4105)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4106)
			p.TextString()
		}

	case 3:
		p.SetState(4107)

		if !(serverVersion >= 50606) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50606", ""))
			goto errorExit
		}
		{
			p.SetState(4108)
			p.Match(MySQLParserSQL_AFTER_MTS_GAPS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(4115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4111)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4112)
				p.MasterFileDef()
			}

		}
		p.SetState(4117)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 472, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveConnectionOptionsContext is an interface to support dynamic dispatch.
type ISlaveConnectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_SYMBOL() antlr.TerminalNode
	AllEQUAL_OPERATOR() []antlr.TerminalNode
	EQUAL_OPERATOR(i int) antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	PASSWORD_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode

	// IsSlaveConnectionOptionsContext differentiates from other interfaces.
	IsSlaveConnectionOptionsContext()
}

type SlaveConnectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveConnectionOptionsContext() *SlaveConnectionOptionsContext {
	var p = new(SlaveConnectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveConnectionOptions
	return p
}

func InitEmptySlaveConnectionOptionsContext(p *SlaveConnectionOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveConnectionOptions
}

func (*SlaveConnectionOptionsContext) IsSlaveConnectionOptionsContext() {}

func NewSlaveConnectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveConnectionOptionsContext {
	var p = new(SlaveConnectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_slaveConnectionOptions

	return p
}

func (s *SlaveConnectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveConnectionOptionsContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) AllEQUAL_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserEQUAL_OPERATOR)
}

func (s *SlaveConnectionOptionsContext) EQUAL_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, i)
}

func (s *SlaveConnectionOptionsContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *SlaveConnectionOptionsContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SlaveConnectionOptionsContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveConnectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveConnectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSlaveConnectionOptions(s)
	}
}

func (s *SlaveConnectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSlaveConnectionOptions(s)
	}
}

func (s *SlaveConnectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSlaveConnectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SlaveConnectionOptions() (localctx ISlaveConnectionOptionsContext) {
	localctx = NewSlaveConnectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, MySQLParserRULE_slaveConnectionOptions)
	p.SetState(4140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 477, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4118)

		if !(serverVersion >= 50604) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50604", ""))
			goto errorExit
		}
		p.SetState(4122)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 473, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4119)
				p.Match(MySQLParserUSER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4120)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4121)
				p.TextString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4127)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 474, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4124)
				p.Match(MySQLParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4125)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4126)
				p.TextString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4132)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4129)
				p.Match(MySQLParserDEFAULT_AUTH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4130)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4131)
				p.TextString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4137)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 476, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4134)
				p.Match(MySQLParserPLUGIN_DIR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4135)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4136)
				p.TextString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveThreadOptionsContext is an interface to support dynamic dispatch.
type ISlaveThreadOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSlaveThreadOption() []ISlaveThreadOptionContext
	SlaveThreadOption(i int) ISlaveThreadOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSlaveThreadOptionsContext differentiates from other interfaces.
	IsSlaveThreadOptionsContext()
}

type SlaveThreadOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveThreadOptionsContext() *SlaveThreadOptionsContext {
	var p = new(SlaveThreadOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveThreadOptions
	return p
}

func InitEmptySlaveThreadOptionsContext(p *SlaveThreadOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveThreadOptions
}

func (*SlaveThreadOptionsContext) IsSlaveThreadOptionsContext() {}

func NewSlaveThreadOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveThreadOptionsContext {
	var p = new(SlaveThreadOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_slaveThreadOptions

	return p
}

func (s *SlaveThreadOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveThreadOptionsContext) AllSlaveThreadOption() []ISlaveThreadOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISlaveThreadOptionContext); ok {
			len++
		}
	}

	tst := make([]ISlaveThreadOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISlaveThreadOptionContext); ok {
			tst[i] = t.(ISlaveThreadOptionContext)
			i++
		}
	}

	return tst
}

func (s *SlaveThreadOptionsContext) SlaveThreadOption(i int) ISlaveThreadOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveThreadOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveThreadOptionContext)
}

func (s *SlaveThreadOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *SlaveThreadOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *SlaveThreadOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveThreadOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveThreadOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSlaveThreadOptions(s)
	}
}

func (s *SlaveThreadOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSlaveThreadOptions(s)
	}
}

func (s *SlaveThreadOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSlaveThreadOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SlaveThreadOptions() (localctx ISlaveThreadOptionsContext) {
	localctx = NewSlaveThreadOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, MySQLParserRULE_slaveThreadOptions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4142)
		p.SlaveThreadOption()
	}
	p.SetState(4147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4143)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4144)
				p.SlaveThreadOption()
			}

		}
		p.SetState(4149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveThreadOptionContext is an interface to support dynamic dispatch.
type ISlaveThreadOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode

	// IsSlaveThreadOptionContext differentiates from other interfaces.
	IsSlaveThreadOptionContext()
}

type SlaveThreadOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveThreadOptionContext() *SlaveThreadOptionContext {
	var p = new(SlaveThreadOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveThreadOption
	return p
}

func InitEmptySlaveThreadOptionContext(p *SlaveThreadOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_slaveThreadOption
}

func (*SlaveThreadOptionContext) IsSlaveThreadOptionContext() {}

func NewSlaveThreadOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveThreadOptionContext {
	var p = new(SlaveThreadOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_slaveThreadOption

	return p
}

func (s *SlaveThreadOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveThreadOptionContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_THREAD_SYMBOL, 0)
}

func (s *SlaveThreadOptionContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_THREAD_SYMBOL, 0)
}

func (s *SlaveThreadOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveThreadOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveThreadOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSlaveThreadOption(s)
	}
}

func (s *SlaveThreadOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSlaveThreadOption(s)
	}
}

func (s *SlaveThreadOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSlaveThreadOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SlaveThreadOption() (localctx ISlaveThreadOptionContext) {
	localctx = NewSlaveThreadOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, MySQLParserRULE_slaveThreadOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4150)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserRELAY_THREAD_SYMBOL || _la == MySQLParserSQL_THREAD_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupReplicationContext is an interface to support dynamic dispatch.
type IGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode

	// IsGroupReplicationContext differentiates from other interfaces.
	IsGroupReplicationContext()
}

type GroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupReplicationContext() *GroupReplicationContext {
	var p = new(GroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupReplication
	return p
}

func InitEmptyGroupReplicationContext(p *GroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupReplication
}

func (*GroupReplicationContext) IsGroupReplicationContext() {}

func NewGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupReplicationContext {
	var p = new(GroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_groupReplication

	return p
}

func (s *GroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupReplicationContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *GroupReplicationContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *GroupReplicationContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTOP_SYMBOL, 0)
}

func (s *GroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGroupReplication(s)
	}
}

func (s *GroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGroupReplication(s)
	}
}

func (s *GroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GroupReplication() (localctx IGroupReplicationContext) {
	localctx = NewGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, MySQLParserRULE_groupReplication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4152)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserSTART_SYMBOL || _la == MySQLParserSTOP_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4153)
		p.Match(MySQLParserGROUP_REPLICATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	FROM_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	UserVariable() IUserVariableContext
	ExecuteStatement() IExecuteStatementContext
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preparedStatement
	return p
}

func InitEmptyPreparedStatementContext(p *PreparedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preparedStatement
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) GetType_() antlr.Token { return s.type_ }

func (s *PreparedStatementContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PreparedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PreparedStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *PreparedStatementContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREPARE_SYMBOL, 0)
}

func (s *PreparedStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *PreparedStatementContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEALLOCATE_SYMBOL, 0)
}

func (s *PreparedStatementContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPreparedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PreparedStatement() (localctx IPreparedStatementContext) {
	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, MySQLParserRULE_preparedStatement)
	var _la int

	p.SetState(4166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserPREPARE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4155)

			var _m = p.Match(MySQLParserPREPARE_SYMBOL)

			localctx.(*PreparedStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4156)
			p.Identifier()
		}
		{
			p.SetState(4157)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4160)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4158)
				p.TextLiteral()
			}

		case 2:
			{
				p.SetState(4159)
				p.UserVariable()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case MySQLParserEXECUTE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4162)
			p.ExecuteStatement()
		}

	case MySQLParserDEALLOCATE_SYMBOL, MySQLParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4163)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PreparedStatementContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDEALLOCATE_SYMBOL || _la == MySQLParserDROP_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PreparedStatementContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4164)
			p.Match(MySQLParserPREPARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4165)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING_SYMBOL() antlr.TerminalNode
	ExecuteVarList() IExecuteVarListContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXECUTE_SYMBOL, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *ExecuteStatementContext) ExecuteVarList() IExecuteVarListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteVarListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteVarListContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, MySQLParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4168)
		p.Match(MySQLParserEXECUTE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4169)
		p.Identifier()
	}
	p.SetState(4172)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserUSING_SYMBOL {
		{
			p.SetState(4170)
			p.Match(MySQLParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4171)
			p.ExecuteVarList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteVarListContext is an interface to support dynamic dispatch.
type IExecuteVarListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUserVariable() []IUserVariableContext
	UserVariable(i int) IUserVariableContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsExecuteVarListContext differentiates from other interfaces.
	IsExecuteVarListContext()
}

type ExecuteVarListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteVarListContext() *ExecuteVarListContext {
	var p = new(ExecuteVarListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_executeVarList
	return p
}

func InitEmptyExecuteVarListContext(p *ExecuteVarListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_executeVarList
}

func (*ExecuteVarListContext) IsExecuteVarListContext() {}

func NewExecuteVarListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteVarListContext {
	var p = new(ExecuteVarListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_executeVarList

	return p
}

func (s *ExecuteVarListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteVarListContext) AllUserVariable() []IUserVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserVariableContext); ok {
			len++
		}
	}

	tst := make([]IUserVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserVariableContext); ok {
			tst[i] = t.(IUserVariableContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteVarListContext) UserVariable(i int) IUserVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *ExecuteVarListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ExecuteVarListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ExecuteVarListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteVarListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteVarListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExecuteVarList(s)
	}
}

func (s *ExecuteVarListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExecuteVarList(s)
	}
}

func (s *ExecuteVarListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExecuteVarList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExecuteVarList() (localctx IExecuteVarListContext) {
	localctx = NewExecuteVarListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, MySQLParserRULE_executeVarList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4174)
		p.UserVariable()
	}
	p.SetState(4179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4175)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4176)
			p.UserVariable()
		}

		p.SetState(4181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICloneStatementContext is an interface to support dynamic dispatch.
type ICloneStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLONE_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	REMOTE_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	User() IUserContext
	COLON_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	Equal() IEqualContext
	FOR_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	DataDirSSL() IDataDirSSLContext

	// IsCloneStatementContext differentiates from other interfaces.
	IsCloneStatementContext()
}

type CloneStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloneStatementContext() *CloneStatementContext {
	var p = new(CloneStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cloneStatement
	return p
}

func InitEmptyCloneStatementContext(p *CloneStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cloneStatement
}

func (*CloneStatementContext) IsCloneStatementContext() {}

func NewCloneStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloneStatementContext {
	var p = new(CloneStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cloneStatement

	return p
}

func (s *CloneStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloneStatementContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLONE_SYMBOL, 0)
}

func (s *CloneStatementContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *CloneStatementContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *CloneStatementContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *CloneStatementContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *CloneStatementContext) REMOTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREMOTE_SYMBOL, 0)
}

func (s *CloneStatementContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTANCE_SYMBOL, 0)
}

func (s *CloneStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *CloneStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CloneStatementContext) COLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLON_SYMBOL, 0)
}

func (s *CloneStatementContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CloneStatementContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *CloneStatementContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *CloneStatementContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CloneStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *CloneStatementContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATION_SYMBOL, 0)
}

func (s *CloneStatementContext) DataDirSSL() IDataDirSSLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDirSSLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDirSSLContext)
}

func (s *CloneStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloneStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloneStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCloneStatement(s)
	}
}

func (s *CloneStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCloneStatement(s)
	}
}

func (s *CloneStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCloneStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CloneStatement() (localctx ICloneStatementContext) {
	localctx = NewCloneStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, MySQLParserRULE_cloneStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4182)
		p.Match(MySQLParserCLONE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 486, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4183)
			p.Match(MySQLParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4184)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4185)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4187)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4186)
				p.Equal()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4189)
			p.TextStringLiteral()
		}

	case 2:
		{
			p.SetState(4190)
			p.Match(MySQLParserREMOTE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(4191)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4192)
				p.Match(MySQLParserREPLICATION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.SetState(4195)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(4196)
			p.Match(MySQLParserINSTANCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4197)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4198)
			p.User()
		}
		{
			p.SetState(4199)
			p.Match(MySQLParserCOLON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4200)
			p.Ulong_number()
		}
		{
			p.SetState(4201)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4202)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4203)
			p.TextStringLiteral()
		}
		p.SetState(4205)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDATA_SYMBOL || _la == MySQLParserREQUIRE_SYMBOL {
			{
				p.SetState(4204)
				p.DataDirSSL()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDirSSLContext is an interface to support dynamic dispatch.
type IDataDirSSLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ssl() ISslContext
	DATA_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	Equal() IEqualContext

	// IsDataDirSSLContext differentiates from other interfaces.
	IsDataDirSSLContext()
}

type DataDirSSLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDirSSLContext() *DataDirSSLContext {
	var p = new(DataDirSSLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataDirSSL
	return p
}

func InitEmptyDataDirSSLContext(p *DataDirSSLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataDirSSL
}

func (*DataDirSSLContext) IsDataDirSSLContext() {}

func NewDataDirSSLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDirSSLContext {
	var p = new(DataDirSSLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dataDirSSL

	return p
}

func (s *DataDirSSLContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDirSSLContext) Ssl() ISslContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISslContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISslContext)
}

func (s *DataDirSSLContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *DataDirSSLContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *DataDirSSLContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *DataDirSSLContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *DataDirSSLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDirSSLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDirSSLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDataDirSSL(s)
	}
}

func (s *DataDirSSLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDataDirSSL(s)
	}
}

func (s *DataDirSSLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDataDirSSL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DataDirSSL() (localctx IDataDirSSLContext) {
	localctx = NewDataDirSSLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, MySQLParserRULE_dataDirSSL)
	var _la int

	p.SetState(4219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREQUIRE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4209)
			p.Ssl()
		}

	case MySQLParserDATA_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4210)
			p.Match(MySQLParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4211)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 487, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4212)
				p.Equal()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4215)
			p.TextStringLiteral()
		}
		p.SetState(4217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserREQUIRE_SYMBOL {
			{
				p.SetState(4216)
				p.Ssl()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISslContext is an interface to support dynamic dispatch.
type ISslContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRE_SYMBOL() antlr.TerminalNode
	SSL_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode

	// IsSslContext differentiates from other interfaces.
	IsSslContext()
}

type SslContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySslContext() *SslContext {
	var p = new(SslContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ssl
	return p
}

func InitEmptySslContext(p *SslContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ssl
}

func (*SslContext) IsSslContext() {}

func NewSslContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SslContext {
	var p = new(SslContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ssl

	return p
}

func (s *SslContext) GetParser() antlr.Parser { return s.parser }

func (s *SslContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_SYMBOL, 0)
}

func (s *SslContext) SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSSL_SYMBOL, 0)
}

func (s *SslContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *SslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SslContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSsl(s)
	}
}

func (s *SslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSsl(s)
	}
}

func (s *SslContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSsl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Ssl() (localctx ISslContext) {
	localctx = NewSslContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, MySQLParserRULE_ssl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4221)
		p.Match(MySQLParserREQUIRE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserNO_SYMBOL {
		{
			p.SetState(4222)
			p.Match(MySQLParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4225)
		p.Match(MySQLParserSSL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccountManagementStatementContext is an interface to support dynamic dispatch.
type IAccountManagementStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	Grant() IGrantContext
	RenameUser() IRenameUserContext
	Revoke() IRevokeContext
	SetRole() ISetRoleContext

	// IsAccountManagementStatementContext differentiates from other interfaces.
	IsAccountManagementStatementContext()
}

type AccountManagementStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccountManagementStatementContext() *AccountManagementStatementContext {
	var p = new(AccountManagementStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_accountManagementStatement
	return p
}

func InitEmptyAccountManagementStatementContext(p *AccountManagementStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_accountManagementStatement
}

func (*AccountManagementStatementContext) IsAccountManagementStatementContext() {}

func NewAccountManagementStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccountManagementStatementContext {
	var p = new(AccountManagementStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_accountManagementStatement

	return p
}

func (s *AccountManagementStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AccountManagementStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AccountManagementStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AccountManagementStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AccountManagementStatementContext) Grant() IGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *AccountManagementStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AccountManagementStatementContext) Revoke() IRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *AccountManagementStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *AccountManagementStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccountManagementStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccountManagementStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAccountManagementStatement(s)
	}
}

func (s *AccountManagementStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAccountManagementStatement(s)
	}
}

func (s *AccountManagementStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAccountManagementStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AccountManagementStatement() (localctx IAccountManagementStatementContext) {
	localctx = NewAccountManagementStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, MySQLParserRULE_accountManagementStatement)
	p.SetState(4236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4227)

		if !(serverVersion >= 50606) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50606", ""))
			goto errorExit
		}
		{
			p.SetState(4228)
			p.AlterUser()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4229)
			p.CreateUser()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4230)
			p.DropUser()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4231)
			p.Grant()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4232)
			p.RenameUser()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4233)
			p.Revoke()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(4234)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4235)
			p.SetRole()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	AlterUserTail() IAlterUserTailContext
	IfExists() IIfExistsContext

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALTER_SYMBOL, 0)
}

func (s *AlterUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *AlterUserContext) AlterUserTail() IAlterUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserTailContext)
}

func (s *AlterUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (s *AlterUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, MySQLParserRULE_alterUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4238)
		p.Match(MySQLParserALTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4239)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4242)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 492, p.GetParserRuleContext()) == 1 {
		p.SetState(4240)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		{
			p.SetState(4241)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4244)
		p.AlterUserTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserTailContext is an interface to support dynamic dispatch.
type IAlterUserTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateUserTail() ICreateUserTailContext
	CreateUserList() ICreateUserListContext
	AlterUserList() IAlterUserListContext
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	ReplacePassword() IReplacePasswordContext
	RetainCurrentPassword() IRetainCurrentPasswordContext
	DiscardOldPassword() IDiscardOldPasswordContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	RANDOM_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode

	// IsAlterUserTailContext differentiates from other interfaces.
	IsAlterUserTailContext()
}

type AlterUserTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserTailContext() *AlterUserTailContext {
	var p = new(AlterUserTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserTail
	return p
}

func InitEmptyAlterUserTailContext(p *AlterUserTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserTail
}

func (*AlterUserTailContext) IsAlterUserTailContext() {}

func NewAlterUserTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserTailContext {
	var p = new(AlterUserTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterUserTail

	return p
}

func (s *AlterUserTailContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserTailContext) CreateUserTail() ICreateUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserTailContext)
}

func (s *AlterUserTailContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *AlterUserTailContext) AlterUserList() IAlterUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserListContext)
}

func (s *AlterUserTailContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserTailContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *AlterUserTailContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *AlterUserTailContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *AlterUserTailContext) ReplacePassword() IReplacePasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePasswordContext)
}

func (s *AlterUserTailContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *AlterUserTailContext) DiscardOldPassword() IDiscardOldPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiscardOldPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiscardOldPasswordContext)
}

func (s *AlterUserTailContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *AlterUserTailContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *AlterUserTailContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *AlterUserTailContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *AlterUserTailContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserTailContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANDOM_SYMBOL, 0)
}

func (s *AlterUserTailContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *AlterUserTailContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *AlterUserTailContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *AlterUserTailContext) FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAILED_LOGIN_ATTEMPTS_SYMBOL, 0)
}

func (s *AlterUserTailContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *AlterUserTailContext) PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_LOCK_TIME_SYMBOL, 0)
}

func (s *AlterUserTailContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *AlterUserTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterUserTail(s)
	}
}

func (s *AlterUserTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterUserTail(s)
	}
}

func (s *AlterUserTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterUserTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterUserTail() (localctx IAlterUserTailContext) {
	localctx = NewAlterUserTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, MySQLParserRULE_alterUserTail)
	var _la int

	p.SetState(4300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 500, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4246)

			if !(serverVersion < 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4247)
				p.CreateUserList()
			}

		case 2:
			p.SetState(4248)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4249)
				p.AlterUserList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4252)
			p.CreateUserTail()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4254)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		{
			p.SetState(4255)
			p.User()
		}
		{
			p.SetState(4256)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4257)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4258)
			p.TextString()
		}
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
			p.SetState(4259)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4260)
				p.ReplacePassword()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4265)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 495, p.GetParserRuleContext()) == 1 {
			p.SetState(4263)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4264)
				p.RetainCurrentPassword()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4267)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(4268)
			p.User()
		}
		{
			p.SetState(4269)
			p.DiscardOldPassword()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4271)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4272)
			p.User()
		}
		{
			p.SetState(4273)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4274)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4275)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4276)
				p.Match(MySQLParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4277)
				p.RoleList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(4280)

		if !(serverVersion >= 80018) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80018", ""))
			goto errorExit
		}
		{
			p.SetState(4281)
			p.User()
		}
		{
			p.SetState(4282)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(4283)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4284)
				p.TextOrIdentifier()
			}

		}
		{
			p.SetState(4287)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4288)
			p.Match(MySQLParserRANDOM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4289)
			p.Match(MySQLParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4291)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserRETAIN_SYMBOL {
			{
				p.SetState(4290)
				p.RetainCurrentPassword()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4293)
			p.Match(MySQLParserFAILED_LOGIN_ATTEMPTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)
			p.Real_ulong_number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4295)
			p.Match(MySQLParserPASSWORD_LOCK_TIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserHEX_NUMBER:
			{
				p.SetState(4296)
				p.Real_ulong_number()
			}

		case MySQLParserUNBOUNDED_SYMBOL:
			{
				p.SetState(4297)
				p.Match(MySQLParserUNBOUNDED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserFunctionContext is an interface to support dynamic dispatch.
type IUserFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext

	// IsUserFunctionContext differentiates from other interfaces.
	IsUserFunctionContext()
}

type UserFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserFunctionContext() *UserFunctionContext {
	var p = new(UserFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userFunction
	return p
}

func InitEmptyUserFunctionContext(p *UserFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userFunction
}

func (*UserFunctionContext) IsUserFunctionContext() {}

func NewUserFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserFunctionContext {
	var p = new(UserFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_userFunction

	return p
}

func (s *UserFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserFunctionContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *UserFunctionContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *UserFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUserFunction(s)
	}
}

func (s *UserFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUserFunction(s)
	}
}

func (s *UserFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUserFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UserFunction() (localctx IUserFunctionContext) {
	localctx = NewUserFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, MySQLParserRULE_userFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4302)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4303)
		p.Parentheses()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	CreateUserList() ICreateUserListContext
	DefaultRoleClause() IDefaultRoleClauseContext
	CreateUserTail() ICreateUserTailContext
	IfNotExists() IIfNotExistsContext

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *CreateUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *CreateUserContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *CreateUserContext) DefaultRoleClause() IDefaultRoleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultRoleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultRoleClauseContext)
}

func (s *CreateUserContext) CreateUserTail() ICreateUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserTailContext)
}

func (s *CreateUserContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (s *CreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, MySQLParserRULE_createUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4305)
		p.Match(MySQLParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4306)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 501, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4307)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		{
			p.SetState(4308)
			p.IfNotExists()
		}

	case 2:

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4312)
		p.CreateUserList()
	}
	{
		p.SetState(4313)
		p.DefaultRoleClause()
	}
	{
		p.SetState(4314)
		p.CreateUserTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserTailContext is an interface to support dynamic dispatch.
type ICreateUserTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RequireClause() IRequireClauseContext
	ConnectOptions() IConnectOptionsContext
	AllAccountLockPasswordExpireOptions() []IAccountLockPasswordExpireOptionsContext
	AccountLockPasswordExpireOptions(i int) IAccountLockPasswordExpireOptionsContext

	// IsCreateUserTailContext differentiates from other interfaces.
	IsCreateUserTailContext()
}

type CreateUserTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserTailContext() *CreateUserTailContext {
	var p = new(CreateUserTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserTail
	return p
}

func InitEmptyCreateUserTailContext(p *CreateUserTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserTail
}

func (*CreateUserTailContext) IsCreateUserTailContext() {}

func NewCreateUserTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserTailContext {
	var p = new(CreateUserTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUserTail

	return p
}

func (s *CreateUserTailContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserTailContext) RequireClause() IRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireClauseContext)
}

func (s *CreateUserTailContext) ConnectOptions() IConnectOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectOptionsContext)
}

func (s *CreateUserTailContext) AllAccountLockPasswordExpireOptions() []IAccountLockPasswordExpireOptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			len++
		}
	}

	tst := make([]IAccountLockPasswordExpireOptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			tst[i] = t.(IAccountLockPasswordExpireOptionsContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserTailContext) AccountLockPasswordExpireOptions(i int) IAccountLockPasswordExpireOptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccountLockPasswordExpireOptionsContext)
}

func (s *CreateUserTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUserTail(s)
	}
}

func (s *CreateUserTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUserTail(s)
	}
}

func (s *CreateUserTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUserTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUserTail() (localctx ICreateUserTailContext) {
	localctx = NewCreateUserTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, MySQLParserRULE_createUserTail)
	var _la int

	p.SetState(4330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 505, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4316)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		p.SetState(4318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserREQUIRE_SYMBOL {
			{
				p.SetState(4317)
				p.RequireClause()
			}

		}
		p.SetState(4321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(4320)
				p.ConnectOptions()
			}

		}
		p.SetState(4326)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserACCOUNT_SYMBOL || _la == MySQLParserPASSWORD_SYMBOL {
			{
				p.SetState(4323)
				p.AccountLockPasswordExpireOptions()
			}

			p.SetState(4328)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultRoleClauseContext is an interface to support dynamic dispatch.
type IDefaultRoleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsDefaultRoleClauseContext differentiates from other interfaces.
	IsDefaultRoleClauseContext()
}

type DefaultRoleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultRoleClauseContext() *DefaultRoleClauseContext {
	var p = new(DefaultRoleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultRoleClause
	return p
}

func InitEmptyDefaultRoleClauseContext(p *DefaultRoleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultRoleClause
}

func (*DefaultRoleClauseContext) IsDefaultRoleClauseContext() {}

func NewDefaultRoleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultRoleClauseContext {
	var p = new(DefaultRoleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_defaultRoleClause

	return p
}

func (s *DefaultRoleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultRoleClauseContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultRoleClauseContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *DefaultRoleClauseContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DefaultRoleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultRoleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultRoleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDefaultRoleClause(s)
	}
}

func (s *DefaultRoleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDefaultRoleClause(s)
	}
}

func (s *DefaultRoleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDefaultRoleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DefaultRoleClause() (localctx IDefaultRoleClauseContext) {
	localctx = NewDefaultRoleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, MySQLParserRULE_defaultRoleClause)
	p.SetState(4339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 507, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4332)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		p.SetState(4336)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4333)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4334)
				p.Match(MySQLParserROLE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4335)
				p.RoleList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireClauseContext is an interface to support dynamic dispatch.
type IRequireClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	REQUIRE_SYMBOL() antlr.TerminalNode
	RequireList() IRequireListContext
	SSL_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode

	// IsRequireClauseContext differentiates from other interfaces.
	IsRequireClauseContext()
}

type RequireClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyRequireClauseContext() *RequireClauseContext {
	var p = new(RequireClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireClause
	return p
}

func InitEmptyRequireClauseContext(p *RequireClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireClause
}

func (*RequireClauseContext) IsRequireClauseContext() {}

func NewRequireClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireClauseContext {
	var p = new(RequireClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_requireClause

	return p
}

func (s *RequireClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireClauseContext) GetOption() antlr.Token { return s.option }

func (s *RequireClauseContext) SetOption(v antlr.Token) { s.option = v }

func (s *RequireClauseContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_SYMBOL, 0)
}

func (s *RequireClauseContext) RequireList() IRequireListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireListContext)
}

func (s *RequireClauseContext) SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSSL_SYMBOL, 0)
}

func (s *RequireClauseContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserX509_SYMBOL, 0)
}

func (s *RequireClauseContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *RequireClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRequireClause(s)
	}
}

func (s *RequireClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRequireClause(s)
	}
}

func (s *RequireClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRequireClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RequireClause() (localctx IRequireClauseContext) {
	localctx = NewRequireClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, MySQLParserRULE_requireClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4341)
		p.Match(MySQLParserREQUIRE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCIPHER_SYMBOL, MySQLParserISSUER_SYMBOL, MySQLParserSUBJECT_SYMBOL:
		{
			p.SetState(4342)
			p.RequireList()
		}

	case MySQLParserNONE_SYMBOL, MySQLParserSSL_SYMBOL, MySQLParserX509_SYMBOL:
		{
			p.SetState(4343)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RequireClauseContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserNONE_SYMBOL || _la == MySQLParserSSL_SYMBOL || _la == MySQLParserX509_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RequireClauseContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectOptionsContext is an interface to support dynamic dispatch.
type IConnectOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllMAX_QUERIES_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	AllMAX_UPDATES_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllMAX_CONNECTIONS_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllMAX_USER_CONNECTIONS_SYMBOL() []antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL(i int) antlr.TerminalNode

	// IsConnectOptionsContext differentiates from other interfaces.
	IsConnectOptionsContext()
}

type ConnectOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectOptionsContext() *ConnectOptionsContext {
	var p = new(ConnectOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_connectOptions
	return p
}

func InitEmptyConnectOptionsContext(p *ConnectOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_connectOptions
}

func (*ConnectOptionsContext) IsConnectOptionsContext() {}

func NewConnectOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectOptionsContext {
	var p = new(ConnectOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_connectOptions

	return p
}

func (s *ConnectOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *ConnectOptionsContext) AllMAX_QUERIES_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_QUERIES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ConnectOptionsContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *ConnectOptionsContext) AllMAX_UPDATES_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_UPDATES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllMAX_CONNECTIONS_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllMAX_USER_CONNECTIONS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserMAX_USER_CONNECTIONS_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_USER_CONNECTIONS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_USER_CONNECTIONS_SYMBOL, i)
}

func (s *ConnectOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConnectOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConnectOptions(s)
	}
}

func (s *ConnectOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConnectOptions(s)
	}
}

func (s *ConnectOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConnectOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConnectOptions() (localctx IConnectOptionsContext) {
	localctx = NewConnectOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, MySQLParserRULE_connectOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4346)
		p.Match(MySQLParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&195) != 0) {
		p.SetState(4355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL:
			{
				p.SetState(4347)
				p.Match(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4348)
				p.Ulong_number()
			}

		case MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL:
			{
				p.SetState(4349)
				p.Match(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4350)
				p.Ulong_number()
			}

		case MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL:
			{
				p.SetState(4351)
				p.Match(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4352)
				p.Ulong_number()
			}

		case MySQLParserMAX_USER_CONNECTIONS_SYMBOL:
			{
				p.SetState(4353)
				p.Match(MySQLParserMAX_USER_CONNECTIONS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4354)
				p.Ulong_number()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(4357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccountLockPasswordExpireOptionsContext is an interface to support dynamic dispatch.
type IAccountLockPasswordExpireOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode
	UNLOCK_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	REQUIRE_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode

	// IsAccountLockPasswordExpireOptionsContext differentiates from other interfaces.
	IsAccountLockPasswordExpireOptionsContext()
}

type AccountLockPasswordExpireOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccountLockPasswordExpireOptionsContext() *AccountLockPasswordExpireOptionsContext {
	var p = new(AccountLockPasswordExpireOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_accountLockPasswordExpireOptions
	return p
}

func InitEmptyAccountLockPasswordExpireOptionsContext(p *AccountLockPasswordExpireOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_accountLockPasswordExpireOptions
}

func (*AccountLockPasswordExpireOptionsContext) IsAccountLockPasswordExpireOptionsContext() {}

func NewAccountLockPasswordExpireOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccountLockPasswordExpireOptionsContext {
	var p = new(AccountLockPasswordExpireOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_accountLockPasswordExpireOptions

	return p
}

func (s *AccountLockPasswordExpireOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AccountLockPasswordExpireOptionsContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACCOUNT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) UNLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNLOCK_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPIRE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTORY_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREUSE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *AccountLockPasswordExpireOptionsContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEVER_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONAL_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccountLockPasswordExpireOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccountLockPasswordExpireOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAccountLockPasswordExpireOptions(s)
	}
}

func (s *AccountLockPasswordExpireOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAccountLockPasswordExpireOptions(s)
	}
}

func (s *AccountLockPasswordExpireOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAccountLockPasswordExpireOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AccountLockPasswordExpireOptions() (localctx IAccountLockPasswordExpireOptionsContext) {
	localctx = NewAccountLockPasswordExpireOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, MySQLParserRULE_accountLockPasswordExpireOptions)
	var _la int

	p.SetState(4392)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserACCOUNT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4359)
			p.Match(MySQLParserACCOUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4360)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLOCK_SYMBOL || _la == MySQLParserUNLOCK_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySQLParserPASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4361)
			p.Match(MySQLParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4362)
				p.Match(MySQLParserEXPIRE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4369)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case MySQLParserINTERVAL_SYMBOL:
				{
					p.SetState(4363)
					p.Match(MySQLParserINTERVAL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4364)
					p.Real_ulong_number()
				}
				{
					p.SetState(4365)
					p.Match(MySQLParserDAY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserNEVER_SYMBOL:
				{
					p.SetState(4367)
					p.Match(MySQLParserNEVER_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserDEFAULT_SYMBOL:
				{
					p.SetState(4368)
					p.Match(MySQLParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserEOF, MySQLParserACCOUNT_SYMBOL, MySQLParserPASSWORD_SYMBOL, MySQLParserSEMICOLON_SYMBOL:

			default:
			}

		case 2:
			{
				p.SetState(4371)
				p.Match(MySQLParserHISTORY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4374)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserHEX_NUMBER:
				{
					p.SetState(4372)
					p.Real_ulong_number()
				}

			case MySQLParserDEFAULT_SYMBOL:
				{
					p.SetState(4373)
					p.Match(MySQLParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case 3:
			{
				p.SetState(4376)
				p.Match(MySQLParserREUSE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4377)
				p.Match(MySQLParserINTERVAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4382)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserHEX_NUMBER:
				{
					p.SetState(4378)
					p.Real_ulong_number()
				}
				{
					p.SetState(4379)
					p.Match(MySQLParserDAY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserDEFAULT_SYMBOL:
				{
					p.SetState(4381)
					p.Match(MySQLParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case 4:
			p.SetState(4384)

			if !(serverVersion >= 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4385)
				p.Match(MySQLParserREQUIRE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4386)
				p.Match(MySQLParserCURRENT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4388)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserOPTIONAL_SYMBOL {
				{
					p.SetState(4387)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserOPTIONAL_SYMBOL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	IfExists() IIfExistsContext

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *DropUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *DropUserContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, MySQLParserRULE_dropUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4394)
		p.Match(MySQLParserDROP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4395)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4398)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) == 1 {
		p.SetState(4396)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		{
			p.SetState(4397)
			p.IfExists()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4400)
		p.UserList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGRANT_SYMBOL() []antlr.TerminalNode
	GRANT_SYMBOL(i int) antlr.TerminalNode
	RoleOrPrivilegesList() IRoleOrPrivilegesListContext
	TO_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	ON_SYMBOL() antlr.TerminalNode
	GrantIdentifier() IGrantIdentifierContext
	GrantTargetList() IGrantTargetListContext
	PROXY_SYMBOL() antlr.TerminalNode
	User() IUserContext
	ALL_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	AclType() IAclTypeContext
	VersionedRequireClause() IVersionedRequireClauseContext
	GrantOptions() IGrantOptionsContext
	GrantAs() IGrantAsContext
	PRIVILEGES_SYMBOL() antlr.TerminalNode

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grant
	return p
}

func InitEmptyGrantContext(p *GrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grant
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) AllGRANT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserGRANT_SYMBOL)
}

func (s *GrantContext) GRANT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANT_SYMBOL, i)
}

func (s *GrantContext) RoleOrPrivilegesList() IRoleOrPrivilegesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegesListContext)
}

func (s *GrantContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *GrantContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *GrantContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *GrantContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *GrantContext) GrantTargetList() IGrantTargetListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTargetListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTargetListContext)
}

func (s *GrantContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROXY_SYMBOL, 0)
}

func (s *GrantContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *GrantContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *GrantContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADMIN_SYMBOL, 0)
}

func (s *GrantContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *GrantContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *GrantContext) VersionedRequireClause() IVersionedRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionedRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionedRequireClauseContext)
}

func (s *GrantContext) GrantOptions() IGrantOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantOptionsContext)
}

func (s *GrantContext) GrantAs() IGrantAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantAsContext)
}

func (s *GrantContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Grant() (localctx IGrantContext) {
	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, MySQLParserRULE_grant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4402)
		p.Match(MySQLParserGRANT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 526, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4403)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4404)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(4405)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4406)
			p.UserList()
		}
		p.SetState(4410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(4407)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4408)
				p.Match(MySQLParserADMIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4409)
				p.Match(MySQLParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.SetState(4417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4412)
				p.RoleOrPrivilegesList()
			}

		case 2:
			{
				p.SetState(4413)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4415)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserPRIVILEGES_SYMBOL {
				{
					p.SetState(4414)
					p.Match(MySQLParserPRIVILEGES_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4419)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4421)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4420)
				p.AclType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4423)
			p.GrantIdentifier()
		}
		{
			p.SetState(4424)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4425)
			p.GrantTargetList()
		}
		p.SetState(4427)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 522, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4426)
				p.VersionedRequireClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4430)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4429)
				p.GrantOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4433)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserAS_SYMBOL {
			{
				p.SetState(4432)
				p.GrantAs()
			}

		}

	case 3:
		{
			p.SetState(4435)
			p.Match(MySQLParserPROXY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4436)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4437)
			p.User()
		}
		{
			p.SetState(4438)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.GrantTargetList()
		}
		p.SetState(4443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(4440)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4441)
				p.Match(MySQLParserGRANT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4442)
				p.Match(MySQLParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTargetListContext is an interface to support dynamic dispatch.
type IGrantTargetListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateUserList() ICreateUserListContext
	UserList() IUserListContext

	// IsGrantTargetListContext differentiates from other interfaces.
	IsGrantTargetListContext()
}

type GrantTargetListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTargetListContext() *GrantTargetListContext {
	var p = new(GrantTargetListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantTargetList
	return p
}

func InitEmptyGrantTargetListContext(p *GrantTargetListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantTargetList
}

func (*GrantTargetListContext) IsGrantTargetListContext() {}

func NewGrantTargetListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTargetListContext {
	var p = new(GrantTargetListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grantTargetList

	return p
}

func (s *GrantTargetListContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTargetListContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *GrantTargetListContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *GrantTargetListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTargetListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTargetListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrantTargetList(s)
	}
}

func (s *GrantTargetListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrantTargetList(s)
	}
}

func (s *GrantTargetListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrantTargetList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GrantTargetList() (localctx IGrantTargetListContext) {
	localctx = NewGrantTargetListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, MySQLParserRULE_grantTargetList)
	p.SetState(4451)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 527, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4447)

		if !(serverVersion < 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
			goto errorExit
		}
		{
			p.SetState(4448)
			p.CreateUserList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4449)

		if !(serverVersion >= 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
			goto errorExit
		}
		{
			p.SetState(4450)
			p.UserList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantOptionsContext is an interface to support dynamic dispatch.
type IGrantOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllGrantOption() []IGrantOptionContext
	GrantOption(i int) IGrantOptionContext
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode

	// IsGrantOptionsContext differentiates from other interfaces.
	IsGrantOptionsContext()
}

type GrantOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantOptionsContext() *GrantOptionsContext {
	var p = new(GrantOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantOptions
	return p
}

func InitEmptyGrantOptionsContext(p *GrantOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantOptions
}

func (*GrantOptionsContext) IsGrantOptionsContext() {}

func NewGrantOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantOptionsContext {
	var p = new(GrantOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grantOptions

	return p
}

func (s *GrantOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *GrantOptionsContext) AllGrantOption() []IGrantOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrantOptionContext); ok {
			len++
		}
	}

	tst := make([]IGrantOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrantOptionContext); ok {
			tst[i] = t.(IGrantOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantOptionsContext) GrantOption(i int) IGrantOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantOptionContext)
}

func (s *GrantOptionsContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANT_SYMBOL, 0)
}

func (s *GrantOptionsContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *GrantOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrantOptions(s)
	}
}

func (s *GrantOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrantOptions(s)
	}
}

func (s *GrantOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrantOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GrantOptions() (localctx IGrantOptionsContext) {
	localctx = NewGrantOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, MySQLParserRULE_grantOptions)
	var _la int

	p.SetState(4464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 529, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4453)

		if !(serverVersion < 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
			goto errorExit
		}
		{
			p.SetState(4454)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySQLParserGRANT_SYMBOL || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&195) != 0) {
			{
				p.SetState(4455)
				p.GrantOption()
			}

			p.SetState(4458)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4460)

		if !(serverVersion >= 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
			goto errorExit
		}
		{
			p.SetState(4461)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4462)
			p.Match(MySQLParserGRANT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4463)
			p.Match(MySQLParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptRoleListContext is an interface to support dynamic dispatch.
type IExceptRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsExceptRoleListContext differentiates from other interfaces.
	IsExceptRoleListContext()
}

type ExceptRoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptRoleListContext() *ExceptRoleListContext {
	var p = new(ExceptRoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exceptRoleList
	return p
}

func InitEmptyExceptRoleListContext(p *ExceptRoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exceptRoleList
}

func (*ExceptRoleListContext) IsExceptRoleListContext() {}

func NewExceptRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptRoleListContext {
	var p = new(ExceptRoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_exceptRoleList

	return p
}

func (s *ExceptRoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptRoleListContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCEPT_SYMBOL, 0)
}

func (s *ExceptRoleListContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *ExceptRoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptRoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptRoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExceptRoleList(s)
	}
}

func (s *ExceptRoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExceptRoleList(s)
	}
}

func (s *ExceptRoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExceptRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExceptRoleList() (localctx IExceptRoleListContext) {
	localctx = NewExceptRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, MySQLParserRULE_exceptRoleList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4466)
		p.Match(MySQLParserEXCEPT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4467)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRolesContext is an interface to support dynamic dispatch.
type IWithRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	ALL_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	ExceptRoleList() IExceptRoleListContext

	// IsWithRolesContext differentiates from other interfaces.
	IsWithRolesContext()
}

type WithRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithRolesContext() *WithRolesContext {
	var p = new(WithRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withRoles
	return p
}

func InitEmptyWithRolesContext(p *WithRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_withRoles
}

func (*WithRolesContext) IsWithRolesContext() {}

func NewWithRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRolesContext {
	var p = new(WithRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_withRoles

	return p
}

func (s *WithRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRolesContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *WithRolesContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *WithRolesContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *WithRolesContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *WithRolesContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *WithRolesContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *WithRolesContext) ExceptRoleList() IExceptRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptRoleListContext)
}

func (s *WithRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWithRoles(s)
	}
}

func (s *WithRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWithRoles(s)
	}
}

func (s *WithRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWithRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WithRoles() (localctx IWithRolesContext) {
	localctx = NewWithRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, MySQLParserRULE_withRoles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4469)
		p.Match(MySQLParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4470)
		p.Match(MySQLParserROLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 531, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4471)
			p.RoleList()
		}

	case 2:
		{
			p.SetState(4472)
			p.Match(MySQLParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEXCEPT_SYMBOL {
			{
				p.SetState(4473)
				p.ExceptRoleList()
			}

		}

	case 3:
		{
			p.SetState(4476)
			p.Match(MySQLParserNONE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(4477)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantAsContext is an interface to support dynamic dispatch.
type IGrantAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	WithRoles() IWithRolesContext

	// IsGrantAsContext differentiates from other interfaces.
	IsGrantAsContext()
}

type GrantAsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantAsContext() *GrantAsContext {
	var p = new(GrantAsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantAs
	return p
}

func InitEmptyGrantAsContext(p *GrantAsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantAs
}

func (*GrantAsContext) IsGrantAsContext() {}

func NewGrantAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantAsContext {
	var p = new(GrantAsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grantAs

	return p
}

func (s *GrantAsContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantAsContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *GrantAsContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *GrantAsContext) WithRoles() IWithRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRolesContext)
}

func (s *GrantAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantAsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrantAs(s)
	}
}

func (s *GrantAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrantAs(s)
	}
}

func (s *GrantAsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrantAs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GrantAs() (localctx IGrantAsContext) {
	localctx = NewGrantAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, MySQLParserRULE_grantAs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4480)
		p.Match(MySQLParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4481)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserWITH_SYMBOL {
		{
			p.SetState(4482)
			p.WithRoles()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionedRequireClauseContext is an interface to support dynamic dispatch.
type IVersionedRequireClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RequireClause() IRequireClauseContext

	// IsVersionedRequireClauseContext differentiates from other interfaces.
	IsVersionedRequireClauseContext()
}

type VersionedRequireClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionedRequireClauseContext() *VersionedRequireClauseContext {
	var p = new(VersionedRequireClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_versionedRequireClause
	return p
}

func InitEmptyVersionedRequireClauseContext(p *VersionedRequireClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_versionedRequireClause
}

func (*VersionedRequireClauseContext) IsVersionedRequireClauseContext() {}

func NewVersionedRequireClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionedRequireClauseContext {
	var p = new(VersionedRequireClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_versionedRequireClause

	return p
}

func (s *VersionedRequireClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionedRequireClauseContext) RequireClause() IRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireClauseContext)
}

func (s *VersionedRequireClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionedRequireClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionedRequireClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVersionedRequireClause(s)
	}
}

func (s *VersionedRequireClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVersionedRequireClause(s)
	}
}

func (s *VersionedRequireClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVersionedRequireClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) VersionedRequireClause() (localctx IVersionedRequireClauseContext) {
	localctx = NewVersionedRequireClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, MySQLParserRULE_versionedRequireClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4485)

	if !(serverVersion < 80011) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
		goto errorExit
	}
	{
		p.SetState(4486)
		p.RequireClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	AllUser() []IUserContext
	User(i int) IUserContext
	AllTO_SYMBOL() []antlr.TerminalNode
	TO_SYMBOL(i int) antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renameUser
	return p
}

func InitEmptyRenameUserContext(p *RenameUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_renameUser
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRENAME_SYMBOL, 0)
}

func (s *RenameUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *RenameUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RenameUserContext) AllTO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserTO_SYMBOL)
}

func (s *RenameUserContext) TO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, i)
}

func (s *RenameUserContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *RenameUserContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (s *RenameUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRenameUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RenameUser() (localctx IRenameUserContext) {
	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, MySQLParserRULE_renameUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4488)
		p.Match(MySQLParserRENAME_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4489)
		p.Match(MySQLParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4490)
		p.User()
	}
	{
		p.SetState(4491)
		p.Match(MySQLParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4492)
		p.User()
	}
	p.SetState(4500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4493)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4494)
			p.User()
		}
		{
			p.SetState(4495)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4496)
			p.User()
		}

		p.SetState(4502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REVOKE_SYMBOL() antlr.TerminalNode
	RoleOrPrivilegesList() IRoleOrPrivilegesListContext
	FROM_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	OnTypeTo() IOnTypeToContext
	ALL_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	User() IUserContext
	GrantIdentifier() IGrantIdentifierContext
	COMMA_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	AclType() IAclTypeContext

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_revoke
	return p
}

func InitEmptyRevokeContext(p *RevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_revoke
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) REVOKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREVOKE_SYMBOL, 0)
}

func (s *RevokeContext) RoleOrPrivilegesList() IRoleOrPrivilegesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegesListContext)
}

func (s *RevokeContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *RevokeContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *RevokeContext) OnTypeTo() IOnTypeToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnTypeToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnTypeToContext)
}

func (s *RevokeContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *RevokeContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROXY_SYMBOL, 0)
}

func (s *RevokeContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *RevokeContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *RevokeContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *RevokeContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANT_SYMBOL, 0)
}

func (s *RevokeContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *RevokeContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *RevokeContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Revoke() (localctx IRevokeContext) {
	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, MySQLParserRULE_revoke)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4503)
		p.Match(MySQLParserREVOKE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 537, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4504)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4505)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(4506)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4507)
			p.UserList()
		}

	case 2:
		{
			p.SetState(4509)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(4510)
			p.OnTypeTo()
		}
		{
			p.SetState(4511)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4512)
			p.UserList()
		}

	case 3:
		{
			p.SetState(4514)
			p.Match(MySQLParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4516)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 534, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4515)
				p.Match(MySQLParserPRIVILEGES_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4529)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4518)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(4519)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4521)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4520)
					p.AclType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(4523)
				p.GrantIdentifier()
			}

		case 2:
			{
				p.SetState(4524)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4525)
				p.Match(MySQLParserGRANT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4526)
				p.Match(MySQLParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4527)
				p.Match(MySQLParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4528)
				p.UserList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 4:
		{
			p.SetState(4531)
			p.Match(MySQLParserPROXY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4532)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4533)
			p.User()
		}
		{
			p.SetState(4534)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4535)
			p.UserList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnTypeToContext is an interface to support dynamic dispatch.
type IOnTypeToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	GrantIdentifier() IGrantIdentifierContext
	AclType() IAclTypeContext

	// IsOnTypeToContext differentiates from other interfaces.
	IsOnTypeToContext()
}

type OnTypeToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnTypeToContext() *OnTypeToContext {
	var p = new(OnTypeToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onTypeTo
	return p
}

func InitEmptyOnTypeToContext(p *OnTypeToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onTypeTo
}

func (*OnTypeToContext) IsOnTypeToContext() {}

func NewOnTypeToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnTypeToContext {
	var p = new(OnTypeToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_onTypeTo

	return p
}

func (s *OnTypeToContext) GetParser() antlr.Parser { return s.parser }

func (s *OnTypeToContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *OnTypeToContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *OnTypeToContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *OnTypeToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnTypeToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnTypeToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOnTypeTo(s)
	}
}

func (s *OnTypeToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOnTypeTo(s)
	}
}

func (s *OnTypeToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOnTypeTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OnTypeTo() (localctx IOnTypeToContext) {
	localctx = NewOnTypeToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, MySQLParserRULE_onTypeTo)
	var _la int

	p.SetState(4553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4539)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4540)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4542)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4541)
				p.AclType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4544)
			p.GrantIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4545)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		p.SetState(4551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserON_SYMBOL {
			{
				p.SetState(4546)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4548)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4547)
					p.AclType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(4550)
				p.GrantIdentifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAclTypeContext is an interface to support dynamic dispatch.
type IAclTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	PROCEDURE_SYMBOL() antlr.TerminalNode

	// IsAclTypeContext differentiates from other interfaces.
	IsAclTypeContext()
}

type AclTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAclTypeContext() *AclTypeContext {
	var p = new(AclTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_aclType
	return p
}

func InitEmptyAclTypeContext(p *AclTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_aclType
}

func (*AclTypeContext) IsAclTypeContext() {}

func NewAclTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AclTypeContext {
	var p = new(AclTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_aclType

	return p
}

func (s *AclTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AclTypeContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *AclTypeContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *AclTypeContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *AclTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AclTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AclTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAclType(s)
	}
}

func (s *AclTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAclType(s)
	}
}

func (s *AclTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAclType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AclType() (localctx IAclTypeContext) {
	localctx = NewAclTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, MySQLParserRULE_aclType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4555)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserFUNCTION_SYMBOL || _la == MySQLParserPROCEDURE_SYMBOL || _la == MySQLParserTABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrPrivilegesListContext is an interface to support dynamic dispatch.
type IRoleOrPrivilegesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRoleOrPrivilege() []IRoleOrPrivilegeContext
	RoleOrPrivilege(i int) IRoleOrPrivilegeContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRoleOrPrivilegesListContext differentiates from other interfaces.
	IsRoleOrPrivilegesListContext()
}

type RoleOrPrivilegesListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrPrivilegesListContext() *RoleOrPrivilegesListContext {
	var p = new(RoleOrPrivilegesListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrPrivilegesList
	return p
}

func InitEmptyRoleOrPrivilegesListContext(p *RoleOrPrivilegesListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrPrivilegesList
}

func (*RoleOrPrivilegesListContext) IsRoleOrPrivilegesListContext() {}

func NewRoleOrPrivilegesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrPrivilegesListContext {
	var p = new(RoleOrPrivilegesListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleOrPrivilegesList

	return p
}

func (s *RoleOrPrivilegesListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrPrivilegesListContext) AllRoleOrPrivilege() []IRoleOrPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleOrPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IRoleOrPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleOrPrivilegeContext); ok {
			tst[i] = t.(IRoleOrPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *RoleOrPrivilegesListContext) RoleOrPrivilege(i int) IRoleOrPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegeContext)
}

func (s *RoleOrPrivilegesListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *RoleOrPrivilegesListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *RoleOrPrivilegesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrPrivilegesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrPrivilegesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleOrPrivilegesList(s)
	}
}

func (s *RoleOrPrivilegesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleOrPrivilegesList(s)
	}
}

func (s *RoleOrPrivilegesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleOrPrivilegesList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleOrPrivilegesList() (localctx IRoleOrPrivilegesListContext) {
	localctx = NewRoleOrPrivilegesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, MySQLParserRULE_roleOrPrivilegesList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		p.RoleOrPrivilege()
	}
	p.SetState(4562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4558)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4559)
				p.RoleOrPrivilege()
			}

		}
		p.SetState(4564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 542, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrPrivilegeContext is an interface to support dynamic dispatch.
type IRoleOrPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObject returns the object token.
	GetObject() antlr.Token

	// SetObject sets the object token.
	SetObject(antlr.Token)

	// Getter signatures
	RoleIdentifierOrText() IRoleIdentifierOrTextContext
	AT_TEXT_SUFFIX() antlr.TerminalNode
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	ColumnInternalRefList() IColumnInternalRefListContext
	SELECT_SYMBOL() antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	REFERENCES_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	USAGE_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode
	EXECUTE_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	EVENT_SYMBOL() antlr.TerminalNode
	TRIGGER_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	SHOW_SYMBOL() antlr.TerminalNode
	DATABASES_SYMBOL() antlr.TerminalNode
	CREATE_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ALTER_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode

	// IsRoleOrPrivilegeContext differentiates from other interfaces.
	IsRoleOrPrivilegeContext()
}

type RoleOrPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	object antlr.Token
}

func NewEmptyRoleOrPrivilegeContext() *RoleOrPrivilegeContext {
	var p = new(RoleOrPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrPrivilege
	return p
}

func InitEmptyRoleOrPrivilegeContext(p *RoleOrPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrPrivilege
}

func (*RoleOrPrivilegeContext) IsRoleOrPrivilegeContext() {}

func NewRoleOrPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrPrivilegeContext {
	var p = new(RoleOrPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleOrPrivilege

	return p
}

func (s *RoleOrPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrPrivilegeContext) GetObject() antlr.Token { return s.object }

func (s *RoleOrPrivilegeContext) SetObject(v antlr.Token) { s.object = v }

func (s *RoleOrPrivilegeContext) RoleIdentifierOrText() IRoleIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierOrTextContext)
}

func (s *RoleOrPrivilegeContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_TEXT_SUFFIX, 0)
}

func (s *RoleOrPrivilegeContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SIGN_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *RoleOrPrivilegeContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *RoleOrPrivilegeContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSELECT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) REFERENCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREFERENCES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELETE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) USAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSAGE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXECUTE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELOAD_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESS_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROXY_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUPER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SHOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHOW_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DATABASES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPORARY_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROUTINE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATION_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLIENT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALTER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleOrPrivilege(s)
	}
}

func (s *RoleOrPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleOrPrivilege(s)
	}
}

func (s *RoleOrPrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleOrPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleOrPrivilege() (localctx IRoleOrPrivilegeContext) {
	localctx = NewRoleOrPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, MySQLParserRULE_roleOrPrivilege)
	var _la int

	p.SetState(4606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4565)

		if !(serverVersion > 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion > 80000", ""))
			goto errorExit
		}
		p.SetState(4576)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 545, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4566)
				p.RoleIdentifierOrText()
			}
			p.SetState(4568)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 543, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(4567)
					p.ColumnInternalRefList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 2:
			{
				p.SetState(4570)
				p.RoleIdentifierOrText()
			}
			p.SetState(4574)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySQLParserAT_TEXT_SUFFIX:
				{
					p.SetState(4571)
					p.Match(MySQLParserAT_TEXT_SUFFIX)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserAT_SIGN_SYMBOL:
				{
					p.SetState(4572)
					p.Match(MySQLParserAT_SIGN_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4573)
					p.TextOrIdentifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4578)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserINSERT_SYMBOL || _la == MySQLParserREFERENCES_SYMBOL || _la == MySQLParserSELECT_SYMBOL || _la == MySQLParserUPDATE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4580)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 546, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4579)
				p.ColumnInternalRefList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4582)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&36030033969577985) != 0) || _la == MySQLParserINDEX_SYMBOL || ((int64((_la-423)) & ^0x3f) == 0 && ((int64(1)<<(_la-423))&268435473) != 0) || _la == MySQLParserSHUTDOWN_SYMBOL || _la == MySQLParserSUPER_SYMBOL || _la == MySQLParserTRIGGER_SYMBOL || _la == MySQLParserUSAGE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4583)
			p.Match(MySQLParserGRANT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4584)
			p.Match(MySQLParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4585)
			p.Match(MySQLParserSHOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4586)
			p.Match(MySQLParserDATABASES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4587)
			p.Match(MySQLParserCREATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4591)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4588)
				p.Match(MySQLParserTEMPORARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4589)

				var _m = p.Match(MySQLParserTABLES_SYMBOL)

				localctx.(*RoleOrPrivilegeContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4590)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*RoleOrPrivilegeContext).object = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserROUTINE_SYMBOL || _la == MySQLParserTABLESPACE_SYMBOL || _la == MySQLParserUSER_SYMBOL || _la == MySQLParserVIEW_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*RoleOrPrivilegeContext).object = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4593)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4594)
			p.Match(MySQLParserTABLES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4595)
			p.Match(MySQLParserREPLICATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4596)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoleOrPrivilegeContext).object = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCLIENT_SYMBOL || _la == MySQLParserSLAVE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoleOrPrivilegeContext).object = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4597)
			p.Match(MySQLParserSHOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4598)
			p.Match(MySQLParserVIEW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4599)
			p.Match(MySQLParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4601)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4600)
				p.Match(MySQLParserROUTINE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(4603)

		if !(serverVersion > 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion > 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4604)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCREATE_SYMBOL || _la == MySQLParserDROP_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4605)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantIdentifierContext is an interface to support dynamic dispatch.
type IGrantIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMULT_OPERATOR() []antlr.TerminalNode
	MULT_OPERATOR(i int) antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	TableRef() ITableRefContext

	// IsGrantIdentifierContext differentiates from other interfaces.
	IsGrantIdentifierContext()
}

type GrantIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantIdentifierContext() *GrantIdentifierContext {
	var p = new(GrantIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantIdentifier
	return p
}

func InitEmptyGrantIdentifierContext(p *GrantIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantIdentifier
}

func (*GrantIdentifierContext) IsGrantIdentifierContext() {}

func NewGrantIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantIdentifierContext {
	var p = new(GrantIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grantIdentifier

	return p
}

func (s *GrantIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantIdentifierContext) AllMULT_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserMULT_OPERATOR)
}

func (s *GrantIdentifierContext) MULT_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, i)
}

func (s *GrantIdentifierContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, 0)
}

func (s *GrantIdentifierContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *GrantIdentifierContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *GrantIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrantIdentifier(s)
	}
}

func (s *GrantIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrantIdentifier(s)
	}
}

func (s *GrantIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrantIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GrantIdentifier() (localctx IGrantIdentifierContext) {
	localctx = NewGrantIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, MySQLParserRULE_grantIdentifier)
	var _la int

	p.SetState(4624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 552, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4608)
			p.Match(MySQLParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDOT_SYMBOL {
			{
				p.SetState(4609)
				p.Match(MySQLParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4610)
				p.Match(MySQLParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4613)
			p.SchemaRef()
		}
		p.SetState(4616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDOT_SYMBOL {
			{
				p.SetState(4614)
				p.Match(MySQLParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4615)
				p.Match(MySQLParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4618)
			p.TableRef()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4619)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(4620)
			p.SchemaRef()
		}
		{
			p.SetState(4621)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4622)
			p.TableRef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireListContext is an interface to support dynamic dispatch.
type IRequireListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRequireListElement() []IRequireListElementContext
	RequireListElement(i int) IRequireListElementContext
	AllAND_SYMBOL() []antlr.TerminalNode
	AND_SYMBOL(i int) antlr.TerminalNode

	// IsRequireListContext differentiates from other interfaces.
	IsRequireListContext()
}

type RequireListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequireListContext() *RequireListContext {
	var p = new(RequireListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireList
	return p
}

func InitEmptyRequireListContext(p *RequireListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireList
}

func (*RequireListContext) IsRequireListContext() {}

func NewRequireListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireListContext {
	var p = new(RequireListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_requireList

	return p
}

func (s *RequireListContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireListContext) AllRequireListElement() []IRequireListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequireListElementContext); ok {
			len++
		}
	}

	tst := make([]IRequireListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequireListElementContext); ok {
			tst[i] = t.(IRequireListElementContext)
			i++
		}
	}

	return tst
}

func (s *RequireListContext) RequireListElement(i int) IRequireListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireListElementContext)
}

func (s *RequireListContext) AllAND_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserAND_SYMBOL)
}

func (s *RequireListContext) AND_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, i)
}

func (s *RequireListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRequireList(s)
	}
}

func (s *RequireListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRequireList(s)
	}
}

func (s *RequireListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRequireList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RequireList() (localctx IRequireListContext) {
	localctx = NewRequireListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, MySQLParserRULE_requireList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4626)
		p.RequireListElement()
	}
	p.SetState(4633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 554, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4628)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserAND_SYMBOL {
				{
					p.SetState(4627)
					p.Match(MySQLParserAND_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(4630)
				p.RequireListElement()
			}

		}
		p.SetState(4635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 554, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireListElementContext is an interface to support dynamic dispatch.
type IRequireListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetElement returns the element token.
	GetElement() antlr.Token

	// SetElement sets the element token.
	SetElement(antlr.Token)

	// Getter signatures
	TextString() ITextStringContext
	CIPHER_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode

	// IsRequireListElementContext differentiates from other interfaces.
	IsRequireListElementContext()
}

type RequireListElementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	element antlr.Token
}

func NewEmptyRequireListElementContext() *RequireListElementContext {
	var p = new(RequireListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireListElement
	return p
}

func InitEmptyRequireListElementContext(p *RequireListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_requireListElement
}

func (*RequireListElementContext) IsRequireListElementContext() {}

func NewRequireListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireListElementContext {
	var p = new(RequireListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_requireListElement

	return p
}

func (s *RequireListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireListElementContext) GetElement() antlr.Token { return s.element }

func (s *RequireListElementContext) SetElement(v antlr.Token) { s.element = v }

func (s *RequireListElementContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *RequireListElementContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCIPHER_SYMBOL, 0)
}

func (s *RequireListElementContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISSUER_SYMBOL, 0)
}

func (s *RequireListElementContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBJECT_SYMBOL, 0)
}

func (s *RequireListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRequireListElement(s)
	}
}

func (s *RequireListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRequireListElement(s)
	}
}

func (s *RequireListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRequireListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RequireListElement() (localctx IRequireListElementContext) {
	localctx = NewRequireListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, MySQLParserRULE_requireListElement)
	p.SetState(4642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCIPHER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4636)

			var _m = p.Match(MySQLParserCIPHER_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4637)
			p.TextString()
		}

	case MySQLParserISSUER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4638)

			var _m = p.Match(MySQLParserISSUER_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4639)
			p.TextString()
		}

	case MySQLParserSUBJECT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4640)

			var _m = p.Match(MySQLParserSUBJECT_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4641)
			p.TextString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantOptionContext is an interface to support dynamic dispatch.
type IGrantOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	OPTION_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode

	// IsGrantOptionContext differentiates from other interfaces.
	IsGrantOptionContext()
}

type GrantOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyGrantOptionContext() *GrantOptionContext {
	var p = new(GrantOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantOption
	return p
}

func InitEmptyGrantOptionContext(p *GrantOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_grantOption
}

func (*GrantOptionContext) IsGrantOptionContext() {}

func NewGrantOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantOptionContext {
	var p = new(GrantOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_grantOption

	return p
}

func (s *GrantOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantOptionContext) GetOption() antlr.Token { return s.option }

func (s *GrantOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *GrantOptionContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTION_SYMBOL, 0)
}

func (s *GrantOptionContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANT_SYMBOL, 0)
}

func (s *GrantOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *GrantOptionContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *GrantOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGrantOption(s)
	}
}

func (s *GrantOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGrantOption(s)
	}
}

func (s *GrantOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGrantOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GrantOption() (localctx IGrantOptionContext) {
	localctx = NewGrantOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, MySQLParserRULE_grantOption)
	p.SetState(4654)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserGRANT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4644)

			var _m = p.Match(MySQLParserGRANT_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4645)
			p.Match(MySQLParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4646)

			var _m = p.Match(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4647)
			p.Ulong_number()
		}

	case MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4648)

			var _m = p.Match(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4649)
			p.Ulong_number()
		}

	case MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4650)

			var _m = p.Match(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4651)
			p.Ulong_number()
		}

	case MySQLParserMAX_USER_CONNECTIONS_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4652)

			var _m = p.Match(MySQLParserMAX_USER_CONNECTIONS_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4653)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	AllRoleList() []IRoleListContext
	RoleList(i int) IRoleListContext
	NONE_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *SetRoleContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *SetRoleContext) AllRoleList() []IRoleListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleListContext); ok {
			len++
		}
	}

	tst := make([]IRoleListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleListContext); ok {
			tst[i] = t.(IRoleListContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleList(i int) IRoleListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *SetRoleContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *SetRoleContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *SetRoleContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *SetRoleContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCEPT_SYMBOL, 0)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, MySQLParserRULE_setRole)
	var _la int

	p.SetState(4679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 559, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4656)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4657)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4658)
			p.RoleList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4659)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4661)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserNONE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4662)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4663)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4664)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 557, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4665)
				p.RoleList()
			}

		case 2:
			{
				p.SetState(4666)
				p.Match(MySQLParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4667)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4670)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4671)
			p.RoleList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4672)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4673)
			p.Match(MySQLParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4674)
			p.Match(MySQLParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEXCEPT_SYMBOL {
			{
				p.SetState(4675)
				p.Match(MySQLParserEXCEPT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4676)
				p.RoleList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRole() []IRoleContext
	Role(i int) IRoleContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllRole() []IRoleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleContext); ok {
			len++
		}
	}

	tst := make([]IRoleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleContext); ok {
			tst[i] = t.(IRoleContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) Role(i int) IRoleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *RoleListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *RoleListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (s *RoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, MySQLParserRULE_roleList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4681)
		p.Role()
	}
	p.SetState(4686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4682)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4683)
				p.Role()
			}

		}
		p.SetState(4688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 560, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleContext is an interface to support dynamic dispatch.
type IRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifierOrText() IRoleIdentifierOrTextContext
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsRoleContext differentiates from other interfaces.
	IsRoleContext()
}

type RoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleContext() *RoleContext {
	var p = new(RoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_role
	return p
}

func InitEmptyRoleContext(p *RoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_role
}

func (*RoleContext) IsRoleContext() {}

func NewRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleContext {
	var p = new(RoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_role

	return p
}

func (s *RoleContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleContext) RoleIdentifierOrText() IRoleIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierOrTextContext)
}

func (s *RoleContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SIGN_SYMBOL, 0)
}

func (s *RoleContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *RoleContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_TEXT_SUFFIX, 0)
}

func (s *RoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRole(s)
	}
}

func (s *RoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRole(s)
	}
}

func (s *RoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Role() (localctx IRoleContext) {
	localctx = NewRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, MySQLParserRULE_role)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4689)
		p.RoleIdentifierOrText()
	}
	p.SetState(4693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4690)
			p.Match(MySQLParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4691)
			p.TextOrIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 561, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4692)
			p.Match(MySQLParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAdministrationStatementContext is an interface to support dynamic dispatch.
type ITableAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableRefList() ITableRefListContext
	ANALYZE_SYMBOL() antlr.TerminalNode
	NoWriteToBinLog() INoWriteToBinLogContext
	Histogram() IHistogramContext
	CHECK_SYMBOL() antlr.TerminalNode
	AllCheckOption() []ICheckOptionContext
	CheckOption(i int) ICheckOptionContext
	CHECKSUM_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	OPTIMIZE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	AllRepairType() []IRepairTypeContext
	RepairType(i int) IRepairTypeContext

	// IsTableAdministrationStatementContext differentiates from other interfaces.
	IsTableAdministrationStatementContext()
}

type TableAdministrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyTableAdministrationStatementContext() *TableAdministrationStatementContext {
	var p = new(TableAdministrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAdministrationStatement
	return p
}

func InitEmptyTableAdministrationStatementContext(p *TableAdministrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAdministrationStatement
}

func (*TableAdministrationStatementContext) IsTableAdministrationStatementContext() {}

func NewTableAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAdministrationStatementContext {
	var p = new(TableAdministrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableAdministrationStatement

	return p
}

func (s *TableAdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAdministrationStatementContext) GetType_() antlr.Token { return s.type_ }

func (s *TableAdministrationStatementContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TableAdministrationStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) TableRefList() ITableRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefListContext)
}

func (s *TableAdministrationStatementContext) ANALYZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANALYZE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) NoWriteToBinLog() INoWriteToBinLogContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoWriteToBinLogContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoWriteToBinLogContext)
}

func (s *TableAdministrationStatementContext) Histogram() IHistogramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramContext)
}

func (s *TableAdministrationStatementContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECK_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) AllCheckOption() []ICheckOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckOptionContext); ok {
			tst[i] = t.(ICheckOptionContext)
			i++
		}
	}

	return tst
}

func (s *TableAdministrationStatementContext) CheckOption(i int) ICheckOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckOptionContext)
}

func (s *TableAdministrationStatementContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECKSUM_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) OPTIMIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIMIZE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPAIR_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) AllRepairType() []IRepairTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRepairTypeContext); ok {
			len++
		}
	}

	tst := make([]IRepairTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRepairTypeContext); ok {
			tst[i] = t.(IRepairTypeContext)
			i++
		}
	}

	return tst
}

func (s *TableAdministrationStatementContext) RepairType(i int) IRepairTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTypeContext)
}

func (s *TableAdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableAdministrationStatement(s)
	}
}

func (s *TableAdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableAdministrationStatement(s)
	}
}

func (s *TableAdministrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableAdministrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableAdministrationStatement() (localctx ITableAdministrationStatementContext) {
	localctx = NewTableAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, MySQLParserRULE_tableAdministrationStatement)
	var _la int

	p.SetState(4738)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserANALYZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4695)

			var _m = p.Match(MySQLParserANALYZE_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(4696)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(4699)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4700)
			p.TableRefList()
		}
		p.SetState(4703)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 563, p.GetParserRuleContext()) == 1 {
			p.SetState(4701)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(4702)
				p.Histogram()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserCHECK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4705)

			var _m = p.Match(MySQLParserCHECK_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4706)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4707)
			p.TableRefList()
		}
		p.SetState(4711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCHANGED_SYMBOL || ((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&1048593) != 0) || _la == MySQLParserMEDIUM_SYMBOL || _la == MySQLParserQUICK_SYMBOL {
			{
				p.SetState(4708)
				p.CheckOption()
			}

			p.SetState(4713)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case MySQLParserCHECKSUM_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4714)

			var _m = p.Match(MySQLParserCHECKSUM_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4715)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4716)
			p.TableRefList()
		}
		p.SetState(4718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserQUICK_SYMBOL {
			{
				p.SetState(4717)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserQUICK_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case MySQLParserOPTIMIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4720)

			var _m = p.Match(MySQLParserOPTIMIZE_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(4721)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(4724)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4725)
			p.TableRefList()
		}

	case MySQLParserREPAIR_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4726)

			var _m = p.Match(MySQLParserREPAIR_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(4727)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(4730)
			p.Match(MySQLParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4731)
			p.TableRefList()
		}
		p.SetState(4735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserQUICK_SYMBOL || _la == MySQLParserUSE_FRM_SYMBOL {
			{
				p.SetState(4732)
				p.RepairType()
			}

			p.SetState(4737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramContext is an interface to support dynamic dispatch.
type IHistogramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	WITH_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode

	// IsHistogramContext differentiates from other interfaces.
	IsHistogramContext()
}

type HistogramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHistogramContext() *HistogramContext {
	var p = new(HistogramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_histogram
	return p
}

func InitEmptyHistogramContext(p *HistogramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_histogram
}

func (*HistogramContext) IsHistogramContext() {}

func NewHistogramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramContext {
	var p = new(HistogramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_histogram

	return p
}

func (s *HistogramContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *HistogramContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTOGRAM_SYMBOL, 0)
}

func (s *HistogramContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *HistogramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *HistogramContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *HistogramContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *HistogramContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBUCKETS_SYMBOL, 0)
}

func (s *HistogramContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *HistogramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHistogram(s)
	}
}

func (s *HistogramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHistogram(s)
	}
}

func (s *HistogramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHistogram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Histogram() (localctx IHistogramContext) {
	localctx = NewHistogramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, MySQLParserRULE_histogram)
	var _la int

	p.SetState(4753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserUPDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4740)
			p.Match(MySQLParserUPDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4741)
			p.Match(MySQLParserHISTOGRAM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4742)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4743)
			p.IdentifierList()
		}
		p.SetState(4747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(4744)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4745)
				p.Match(MySQLParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4746)
				p.Match(MySQLParserBUCKETS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4749)
			p.Match(MySQLParserDROP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4750)
			p.Match(MySQLParserHISTOGRAM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4751)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4752)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckOptionContext is an interface to support dynamic dispatch.
type ICheckOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode

	// IsCheckOptionContext differentiates from other interfaces.
	IsCheckOptionContext()
}

type CheckOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckOptionContext() *CheckOptionContext {
	var p = new(CheckOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkOption
	return p
}

func InitEmptyCheckOptionContext(p *CheckOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkOption
}

func (*CheckOptionContext) IsCheckOptionContext() {}

func NewCheckOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckOptionContext {
	var p = new(CheckOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_checkOption

	return p
}

func (s *CheckOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckOptionContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *CheckOptionContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPGRADE_SYMBOL, 0)
}

func (s *CheckOptionContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *CheckOptionContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAST_SYMBOL, 0)
}

func (s *CheckOptionContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUM_SYMBOL, 0)
}

func (s *CheckOptionContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *CheckOptionContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGED_SYMBOL, 0)
}

func (s *CheckOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCheckOption(s)
	}
}

func (s *CheckOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCheckOption(s)
	}
}

func (s *CheckOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCheckOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CheckOption() (localctx ICheckOptionContext) {
	localctx = NewCheckOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, MySQLParserRULE_checkOption)
	var _la int

	p.SetState(4758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserFOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4755)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4756)
			p.Match(MySQLParserUPGRADE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCHANGED_SYMBOL, MySQLParserEXTENDED_SYMBOL, MySQLParserFAST_SYMBOL, MySQLParserMEDIUM_SYMBOL, MySQLParserQUICK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4757)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCHANGED_SYMBOL || _la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserFAST_SYMBOL || _la == MySQLParserMEDIUM_SYMBOL || _la == MySQLParserQUICK_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepairTypeContext is an interface to support dynamic dispatch.
type IRepairTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUICK_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode

	// IsRepairTypeContext differentiates from other interfaces.
	IsRepairTypeContext()
}

type RepairTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepairTypeContext() *RepairTypeContext {
	var p = new(RepairTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_repairType
	return p
}

func InitEmptyRepairTypeContext(p *RepairTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_repairType
}

func (*RepairTypeContext) IsRepairTypeContext() {}

func NewRepairTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTypeContext {
	var p = new(RepairTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_repairType

	return p
}

func (s *RepairTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTypeContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *RepairTypeContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *RepairTypeContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_FRM_SYMBOL, 0)
}

func (s *RepairTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepairTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRepairType(s)
	}
}

func (s *RepairTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRepairType(s)
	}
}

func (s *RepairTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRepairType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RepairType() (localctx IRepairTypeContext) {
	localctx = NewRepairTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, MySQLParserRULE_repairType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4760)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserEXTENDED_SYMBOL || _la == MySQLParserQUICK_SYMBOL || _la == MySQLParserUSE_FRM_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallUninstallStatmentContext is an interface to support dynamic dispatch.
type IInstallUninstallStatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAction_ returns the action_ token.
	GetAction_() antlr.Token

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetAction_ sets the action_ token.
	SetAction_(antlr.Token)

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	SONAME_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	INSTALL_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	TextStringLiteralList() ITextStringLiteralListContext
	COMPONENT_SYMBOL() antlr.TerminalNode
	PluginRef() IPluginRefContext
	UNINSTALL_SYMBOL() antlr.TerminalNode
	AllComponentRef() []IComponentRefContext
	ComponentRef(i int) IComponentRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsInstallUninstallStatmentContext differentiates from other interfaces.
	IsInstallUninstallStatmentContext()
}

type InstallUninstallStatmentContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	action_ antlr.Token
	type_   antlr.Token
}

func NewEmptyInstallUninstallStatmentContext() *InstallUninstallStatmentContext {
	var p = new(InstallUninstallStatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_installUninstallStatment
	return p
}

func InitEmptyInstallUninstallStatmentContext(p *InstallUninstallStatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_installUninstallStatment
}

func (*InstallUninstallStatmentContext) IsInstallUninstallStatmentContext() {}

func NewInstallUninstallStatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallUninstallStatmentContext {
	var p = new(InstallUninstallStatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_installUninstallStatment

	return p
}

func (s *InstallUninstallStatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallUninstallStatmentContext) GetAction_() antlr.Token { return s.action_ }

func (s *InstallUninstallStatmentContext) GetType_() antlr.Token { return s.type_ }

func (s *InstallUninstallStatmentContext) SetAction_(v antlr.Token) { s.action_ = v }

func (s *InstallUninstallStatmentContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *InstallUninstallStatmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InstallUninstallStatmentContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSONAME_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *InstallUninstallStatmentContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTALL_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) TextStringLiteralList() ITextStringLiteralListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralListContext)
}

func (s *InstallUninstallStatmentContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPONENT_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) PluginRef() IPluginRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluginRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluginRefContext)
}

func (s *InstallUninstallStatmentContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNINSTALL_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) AllComponentRef() []IComponentRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComponentRefContext); ok {
			len++
		}
	}

	tst := make([]IComponentRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComponentRefContext); ok {
			tst[i] = t.(IComponentRefContext)
			i++
		}
	}

	return tst
}

func (s *InstallUninstallStatmentContext) ComponentRef(i int) IComponentRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComponentRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComponentRefContext)
}

func (s *InstallUninstallStatmentContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *InstallUninstallStatmentContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *InstallUninstallStatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallUninstallStatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallUninstallStatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInstallUninstallStatment(s)
	}
}

func (s *InstallUninstallStatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInstallUninstallStatment(s)
	}
}

func (s *InstallUninstallStatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInstallUninstallStatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InstallUninstallStatment() (localctx IInstallUninstallStatmentContext) {
	localctx = NewInstallUninstallStatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, MySQLParserRULE_installUninstallStatment)
	var _la int

	p.SetState(4784)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4762)

			var _m = p.Match(MySQLParserINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4763)

			var _m = p.Match(MySQLParserPLUGIN_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4764)
			p.Identifier()
		}
		{
			p.SetState(4765)
			p.Match(MySQLParserSONAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4766)
			p.TextStringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4768)

			var _m = p.Match(MySQLParserINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4769)

			var _m = p.Match(MySQLParserCOMPONENT_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4770)
			p.TextStringLiteralList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4771)

			var _m = p.Match(MySQLParserUNINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4772)

			var _m = p.Match(MySQLParserPLUGIN_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4773)
			p.PluginRef()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4774)

			var _m = p.Match(MySQLParserUNINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4775)

			var _m = p.Match(MySQLParserCOMPONENT_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4776)
			p.ComponentRef()
		}
		p.SetState(4781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(4777)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4778)
				p.ComponentRef()
			}

			p.SetState(4783)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	StartOptionValueList() IStartOptionValueListContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *SetStatementContext) StartOptionValueList() IStartOptionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartOptionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartOptionValueListContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, MySQLParserRULE_setStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4786)
		p.Match(MySQLParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4787)
		p.StartOptionValueList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartOptionValueListContext is an interface to support dynamic dispatch.
type IStartOptionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionValueNoOptionType() IOptionValueNoOptionTypeContext
	OptionValueListContinued() IOptionValueListContinuedContext
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TransactionCharacteristics() ITransactionCharacteristicsContext
	OptionType() IOptionTypeContext
	StartOptionValueListFollowingOptionType() IStartOptionValueListFollowingOptionTypeContext
	AllPASSWORD_SYMBOL() []antlr.TerminalNode
	PASSWORD_SYMBOL(i int) antlr.TerminalNode
	Equal() IEqualContext
	TextString() ITextStringContext
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	User() IUserContext
	ReplacePassword() IReplacePasswordContext
	RetainCurrentPassword() IRetainCurrentPasswordContext
	TO_SYMBOL() antlr.TerminalNode
	RANDOM_SYMBOL() antlr.TerminalNode

	// IsStartOptionValueListContext differentiates from other interfaces.
	IsStartOptionValueListContext()
}

type StartOptionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartOptionValueListContext() *StartOptionValueListContext {
	var p = new(StartOptionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_startOptionValueList
	return p
}

func InitEmptyStartOptionValueListContext(p *StartOptionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_startOptionValueList
}

func (*StartOptionValueListContext) IsStartOptionValueListContext() {}

func NewStartOptionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartOptionValueListContext {
	var p = new(StartOptionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_startOptionValueList

	return p
}

func (s *StartOptionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *StartOptionValueListContext) OptionValueNoOptionType() IOptionValueNoOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueNoOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueNoOptionTypeContext)
}

func (s *StartOptionValueListContext) OptionValueListContinued() IOptionValueListContinuedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueListContinuedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueListContinuedContext)
}

func (s *StartOptionValueListContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRANSACTION_SYMBOL, 0)
}

func (s *StartOptionValueListContext) TransactionCharacteristics() ITransactionCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicsContext)
}

func (s *StartOptionValueListContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *StartOptionValueListContext) StartOptionValueListFollowingOptionType() IStartOptionValueListFollowingOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartOptionValueListFollowingOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartOptionValueListFollowingOptionTypeContext)
}

func (s *StartOptionValueListContext) AllPASSWORD_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserPASSWORD_SYMBOL)
}

func (s *StartOptionValueListContext) PASSWORD_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, i)
}

func (s *StartOptionValueListContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *StartOptionValueListContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *StartOptionValueListContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *StartOptionValueListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *StartOptionValueListContext) ReplacePassword() IReplacePasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePasswordContext)
}

func (s *StartOptionValueListContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *StartOptionValueListContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTO_SYMBOL, 0)
}

func (s *StartOptionValueListContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANDOM_SYMBOL, 0)
}

func (s *StartOptionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartOptionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartOptionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStartOptionValueList(s)
	}
}

func (s *StartOptionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStartOptionValueList(s)
	}
}

func (s *StartOptionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStartOptionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StartOptionValueList() (localctx IStartOptionValueListContext) {
	localctx = NewStartOptionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, MySQLParserRULE_startOptionValueList)
	var _la int

	p.SetState(4845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 584, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4789)
			p.OptionValueNoOptionType()
		}
		{
			p.SetState(4790)
			p.OptionValueListContinued()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4792)
			p.Match(MySQLParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4793)
			p.TransactionCharacteristics()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4794)
			p.OptionType()
		}
		{
			p.SetState(4795)
			p.StartOptionValueListFollowingOptionType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4797)
			p.Match(MySQLParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4800)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(4798)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4799)
				p.User()
			}

		}
		{
			p.SetState(4802)
			p.Equal()
		}
		p.SetState(4829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 580, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4803)
				p.TextString()
			}
			p.SetState(4805)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserREPLACE_SYMBOL {
				{
					p.SetState(4804)
					p.ReplacePassword()
				}

			}
			p.SetState(4808)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserRETAIN_SYMBOL {
				{
					p.SetState(4807)
					p.RetainCurrentPassword()
				}

			}

		case 2:
			{
				p.SetState(4810)
				p.TextString()
			}
			p.SetState(4812)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserREPLACE_SYMBOL {
				{
					p.SetState(4811)
					p.ReplacePassword()
				}

			}
			p.SetState(4815)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserRETAIN_SYMBOL {
				{
					p.SetState(4814)
					p.RetainCurrentPassword()
				}

			}

		case 3:
			p.SetState(4817)

			if !(serverVersion < 50706) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50706", ""))
				goto errorExit
			}
			{
				p.SetState(4818)
				p.Match(MySQLParserOLD_PASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4819)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4820)
				p.TextString()
			}
			{
				p.SetState(4821)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			p.SetState(4823)

			if !(serverVersion < 80014) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80014", ""))
				goto errorExit
			}
			{
				p.SetState(4824)
				p.Match(MySQLParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4825)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4826)
				p.TextString()
			}
			{
				p.SetState(4827)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(4831)

		if !(serverVersion >= 80018) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80018", ""))
			goto errorExit
		}
		{
			p.SetState(4832)
			p.Match(MySQLParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4835)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(4833)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4834)
				p.User()
			}

		}
		{
			p.SetState(4837)
			p.Match(MySQLParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4838)
			p.Match(MySQLParserRANDOM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserREPLACE_SYMBOL {
			{
				p.SetState(4839)
				p.ReplacePassword()
			}

		}
		p.SetState(4843)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserRETAIN_SYMBOL {
			{
				p.SetState(4842)
				p.RetainCurrentPassword()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCharacteristicsContext is an interface to support dynamic dispatch.
type ITransactionCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransactionAccessMode() ITransactionAccessModeContext
	IsolationLevel() IIsolationLevelContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsTransactionCharacteristicsContext differentiates from other interfaces.
	IsTransactionCharacteristicsContext()
}

type TransactionCharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCharacteristicsContext() *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionCharacteristics
	return p
}

func InitEmptyTransactionCharacteristicsContext(p *TransactionCharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionCharacteristics
}

func (*TransactionCharacteristicsContext) IsTransactionCharacteristicsContext() {}

func NewTransactionCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_transactionCharacteristics

	return p
}

func (s *TransactionCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCharacteristicsContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *TransactionCharacteristicsContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *TransactionCharacteristicsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *TransactionCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTransactionCharacteristics(s)
	}
}

func (s *TransactionCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTransactionCharacteristics(s)
	}
}

func (s *TransactionCharacteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTransactionCharacteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TransactionCharacteristics() (localctx ITransactionCharacteristicsContext) {
	localctx = NewTransactionCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, MySQLParserRULE_transactionCharacteristics)
	var _la int

	p.SetState(4856)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREAD_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4847)
			p.TransactionAccessMode()
		}
		p.SetState(4849)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserISOLATION_SYMBOL {
			{
				p.SetState(4848)
				p.IsolationLevel()
			}

		}

	case MySQLParserISOLATION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4851)
			p.IsolationLevel()
		}
		p.SetState(4854)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(4852)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4853)
				p.TransactionAccessMode()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRITE_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONLY_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, MySQLParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4858)
		p.Match(MySQLParserREAD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4859)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserONLY_SYMBOL || _la == MySQLParserWRITE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISOLATION_SYMBOL, 0)
}

func (s *IsolationLevelContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEVEL_SYMBOL, 0)
}

func (s *IsolationLevelContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPEATABLE_SYMBOL, 0)
}

func (s *IsolationLevelContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIALIZABLE_SYMBOL, 0)
}

func (s *IsolationLevelContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMITTED_SYMBOL, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNCOMMITTED_SYMBOL, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, MySQLParserRULE_isolationLevel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4861)
		p.Match(MySQLParserISOLATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4862)
		p.Match(MySQLParserLEVEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREPEATABLE_SYMBOL:
		{
			p.SetState(4863)
			p.Match(MySQLParserREPEATABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4864)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserREAD_SYMBOL:
		{
			p.SetState(4865)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4866)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCOMMITTED_SYMBOL || _la == MySQLParserUNCOMMITTED_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySQLParserSERIALIZABLE_SYMBOL:
		{
			p.SetState(4867)
			p.Match(MySQLParserSERIALIZABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueListContinuedContext is an interface to support dynamic dispatch.
type IOptionValueListContinuedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	AllOptionValue() []IOptionValueContext
	OptionValue(i int) IOptionValueContext

	// IsOptionValueListContinuedContext differentiates from other interfaces.
	IsOptionValueListContinuedContext()
}

type OptionValueListContinuedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueListContinuedContext() *OptionValueListContinuedContext {
	var p = new(OptionValueListContinuedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueListContinued
	return p
}

func InitEmptyOptionValueListContinuedContext(p *OptionValueListContinuedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueListContinued
}

func (*OptionValueListContinuedContext) IsOptionValueListContinuedContext() {}

func NewOptionValueListContinuedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueListContinuedContext {
	var p = new(OptionValueListContinuedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_optionValueListContinued

	return p
}

func (s *OptionValueListContinuedContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueListContinuedContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *OptionValueListContinuedContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *OptionValueListContinuedContext) AllOptionValue() []IOptionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionValueContext); ok {
			len++
		}
	}

	tst := make([]IOptionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionValueContext); ok {
			tst[i] = t.(IOptionValueContext)
			i++
		}
	}

	return tst
}

func (s *OptionValueListContinuedContext) OptionValue(i int) IOptionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueContext)
}

func (s *OptionValueListContinuedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueListContinuedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueListContinuedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOptionValueListContinued(s)
	}
}

func (s *OptionValueListContinuedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOptionValueListContinued(s)
	}
}

func (s *OptionValueListContinuedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOptionValueListContinued(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OptionValueListContinued() (localctx IOptionValueListContinuedContext) {
	localctx = NewOptionValueListContinuedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, MySQLParserRULE_optionValueListContinued)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(4870)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4871)
			p.OptionValue()
		}

		p.SetState(4876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueNoOptionTypeContext is an interface to support dynamic dispatch.
type IOptionValueNoOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext
	CharsetClause() ICharsetClauseContext
	UserVariable() IUserVariableContext
	Expr() IExprContext
	SetSystemVariable() ISetSystemVariableContext
	NAMES_SYMBOL() antlr.TerminalNode
	CharsetName() ICharsetNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	Collate() ICollateContext

	// IsOptionValueNoOptionTypeContext differentiates from other interfaces.
	IsOptionValueNoOptionTypeContext()
}

type OptionValueNoOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueNoOptionTypeContext() *OptionValueNoOptionTypeContext {
	var p = new(OptionValueNoOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueNoOptionType
	return p
}

func InitEmptyOptionValueNoOptionTypeContext(p *OptionValueNoOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueNoOptionType
}

func (*OptionValueNoOptionTypeContext) IsOptionValueNoOptionTypeContext() {}

func NewOptionValueNoOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueNoOptionTypeContext {
	var p = new(OptionValueNoOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_optionValueNoOptionType

	return p
}

func (s *OptionValueNoOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueNoOptionTypeContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueNoOptionTypeContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueNoOptionTypeContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueNoOptionTypeContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *OptionValueNoOptionTypeContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *OptionValueNoOptionTypeContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OptionValueNoOptionTypeContext) SetSystemVariable() ISetSystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetSystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetSystemVariableContext)
}

func (s *OptionValueNoOptionTypeContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAMES_SYMBOL, 0)
}

func (s *OptionValueNoOptionTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *OptionValueNoOptionTypeContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *OptionValueNoOptionTypeContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *OptionValueNoOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueNoOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueNoOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOptionValueNoOptionType(s)
	}
}

func (s *OptionValueNoOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOptionValueNoOptionType(s)
	}
}

func (s *OptionValueNoOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOptionValueNoOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OptionValueNoOptionType() (localctx IOptionValueNoOptionTypeContext) {
	localctx = NewOptionValueNoOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, MySQLParserRULE_optionValueNoOptionType)
	var _la int

	p.SetState(4902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 592, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4877)
			p.InternalVariableName()
		}
		{
			p.SetState(4878)
			p.Equal()
		}
		{
			p.SetState(4879)
			p.SetExprOrDefault()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4881)
			p.CharsetClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4882)
			p.UserVariable()
		}
		{
			p.SetState(4883)
			p.Equal()
		}
		{
			p.SetState(4884)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4886)
			p.SetSystemVariable()
		}
		{
			p.SetState(4887)
			p.Equal()
		}
		{
			p.SetState(4888)
			p.SetExprOrDefault()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4890)
			p.Match(MySQLParserNAMES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 591, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4891)
				p.Equal()
			}
			{
				p.SetState(4892)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(4894)
				p.CharsetName()
			}
			p.SetState(4896)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserCOLLATE_SYMBOL {
				{
					p.SetState(4895)
					p.Collate()
				}

			}

		case 3:
			p.SetState(4898)

			if !(serverVersion >= 80011) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
				goto errorExit
			}
			{
				p.SetState(4899)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueContext is an interface to support dynamic dispatch.
type IOptionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionType() IOptionTypeContext
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext
	OptionValueNoOptionType() IOptionValueNoOptionTypeContext

	// IsOptionValueContext differentiates from other interfaces.
	IsOptionValueContext()
}

type OptionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueContext() *OptionValueContext {
	var p = new(OptionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValue
	return p
}

func InitEmptyOptionValueContext(p *OptionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValue
}

func (*OptionValueContext) IsOptionValueContext() {}

func NewOptionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueContext {
	var p = new(OptionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_optionValue

	return p
}

func (s *OptionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *OptionValueContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueContext) OptionValueNoOptionType() IOptionValueNoOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueNoOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueNoOptionTypeContext)
}

func (s *OptionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOptionValue(s)
	}
}

func (s *OptionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOptionValue(s)
	}
}

func (s *OptionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOptionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OptionValue() (localctx IOptionValueContext) {
	localctx = NewOptionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, MySQLParserRULE_optionValue)
	p.SetState(4910)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 593, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4904)
			p.OptionType()
		}
		{
			p.SetState(4905)
			p.InternalVariableName()
		}
		{
			p.SetState(4906)
			p.Equal()
		}
		{
			p.SetState(4907)
			p.SetExprOrDefault()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4909)
			p.OptionValueNoOptionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetSystemVariableContext is an interface to support dynamic dispatch.
type ISetSystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_AT_SIGN_SYMBOL() antlr.TerminalNode
	InternalVariableName() IInternalVariableNameContext
	SetVarIdentType() ISetVarIdentTypeContext

	// IsSetSystemVariableContext differentiates from other interfaces.
	IsSetSystemVariableContext()
}

type SetSystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetSystemVariableContext() *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setSystemVariable
	return p
}

func InitEmptySetSystemVariableContext(p *SetSystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setSystemVariable
}

func (*SetSystemVariableContext) IsSetSystemVariableContext() {}

func NewSetSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setSystemVariable

	return p
}

func (s *SetSystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SetSystemVariableContext) AT_AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_AT_SIGN_SYMBOL, 0)
}

func (s *SetSystemVariableContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *SetSystemVariableContext) SetVarIdentType() ISetVarIdentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarIdentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarIdentTypeContext)
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetSystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetSystemVariable() (localctx ISetSystemVariableContext) {
	localctx = NewSetSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, MySQLParserRULE_setSystemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4912)
		p.Match(MySQLParserAT_AT_SIGN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4914)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 594, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4913)
			p.SetVarIdentType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4916)
		p.InternalVariableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartOptionValueListFollowingOptionTypeContext is an interface to support dynamic dispatch.
type IStartOptionValueListFollowingOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionValueFollowingOptionType() IOptionValueFollowingOptionTypeContext
	OptionValueListContinued() IOptionValueListContinuedContext
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TransactionCharacteristics() ITransactionCharacteristicsContext

	// IsStartOptionValueListFollowingOptionTypeContext differentiates from other interfaces.
	IsStartOptionValueListFollowingOptionTypeContext()
}

type StartOptionValueListFollowingOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartOptionValueListFollowingOptionTypeContext() *StartOptionValueListFollowingOptionTypeContext {
	var p = new(StartOptionValueListFollowingOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_startOptionValueListFollowingOptionType
	return p
}

func InitEmptyStartOptionValueListFollowingOptionTypeContext(p *StartOptionValueListFollowingOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_startOptionValueListFollowingOptionType
}

func (*StartOptionValueListFollowingOptionTypeContext) IsStartOptionValueListFollowingOptionTypeContext() {
}

func NewStartOptionValueListFollowingOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartOptionValueListFollowingOptionTypeContext {
	var p = new(StartOptionValueListFollowingOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_startOptionValueListFollowingOptionType

	return p
}

func (s *StartOptionValueListFollowingOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StartOptionValueListFollowingOptionTypeContext) OptionValueFollowingOptionType() IOptionValueFollowingOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueFollowingOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueFollowingOptionTypeContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) OptionValueListContinued() IOptionValueListContinuedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueListContinuedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueListContinuedContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRANSACTION_SYMBOL, 0)
}

func (s *StartOptionValueListFollowingOptionTypeContext) TransactionCharacteristics() ITransactionCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicsContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartOptionValueListFollowingOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartOptionValueListFollowingOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStartOptionValueListFollowingOptionType(s)
	}
}

func (s *StartOptionValueListFollowingOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStartOptionValueListFollowingOptionType(s)
	}
}

func (s *StartOptionValueListFollowingOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStartOptionValueListFollowingOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StartOptionValueListFollowingOptionType() (localctx IStartOptionValueListFollowingOptionTypeContext) {
	localctx = NewStartOptionValueListFollowingOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, MySQLParserRULE_startOptionValueListFollowingOptionType)
	p.SetState(4923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 595, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4918)
			p.OptionValueFollowingOptionType()
		}
		{
			p.SetState(4919)
			p.OptionValueListContinued()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4921)
			p.Match(MySQLParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4922)
			p.TransactionCharacteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueFollowingOptionTypeContext is an interface to support dynamic dispatch.
type IOptionValueFollowingOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext

	// IsOptionValueFollowingOptionTypeContext differentiates from other interfaces.
	IsOptionValueFollowingOptionTypeContext()
}

type OptionValueFollowingOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueFollowingOptionTypeContext() *OptionValueFollowingOptionTypeContext {
	var p = new(OptionValueFollowingOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueFollowingOptionType
	return p
}

func InitEmptyOptionValueFollowingOptionTypeContext(p *OptionValueFollowingOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionValueFollowingOptionType
}

func (*OptionValueFollowingOptionTypeContext) IsOptionValueFollowingOptionTypeContext() {}

func NewOptionValueFollowingOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueFollowingOptionTypeContext {
	var p = new(OptionValueFollowingOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_optionValueFollowingOptionType

	return p
}

func (s *OptionValueFollowingOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueFollowingOptionTypeContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueFollowingOptionTypeContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueFollowingOptionTypeContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueFollowingOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueFollowingOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueFollowingOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOptionValueFollowingOptionType(s)
	}
}

func (s *OptionValueFollowingOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOptionValueFollowingOptionType(s)
	}
}

func (s *OptionValueFollowingOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOptionValueFollowingOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OptionValueFollowingOptionType() (localctx IOptionValueFollowingOptionTypeContext) {
	localctx = NewOptionValueFollowingOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, MySQLParserRULE_optionValueFollowingOptionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4925)
		p.InternalVariableName()
	}
	{
		p.SetState(4926)
		p.Equal()
	}
	{
		p.SetState(4927)
		p.SetExprOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetExprOrDefaultContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSYSTEM_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetExprOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, MySQLParserRULE_setExprOrDefault)
	var _la int

	p.SetState(4933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4929)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4930)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserALL_SYMBOL || _la == MySQLParserBINARY_SYMBOL || _la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserON_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4931)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(4932)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserROW_SYMBOL || _la == MySQLParserSYSTEM_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// GetObject returns the object token.
	GetObject() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// SetObject sets the object token.
	SetObject(antlr.Token)

	// Getter signatures
	SHOW_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	EVENTS_SYMBOL() antlr.TerminalNode
	FromOrIn() IFromOrInContext
	COUNT_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Charset() ICharsetContext
	FOR_SYMBOL() antlr.TerminalNode
	User() IUserContext
	USING_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	CODE_SYMBOL() antlr.TerminalNode
	ProcedureRef() IProcedureRefContext
	FunctionRef() IFunctionRefContext
	AUTHORS_SYMBOL() antlr.TerminalNode
	DATABASES_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	CONTRIBUTORS_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	CREATE_SYMBOL() antlr.TerminalNode
	PROCEDURE_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	EngineRef() IEngineRefContext
	ALL_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	NonBlocking() INonBlockingContext
	BINLOG_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	KEYS_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	EventRef() IEventRefContext
	TriggerRef() ITriggerRefContext
	ViewRef() IViewRefContext
	LikeOrWhere() ILikeOrWhereContext
	ShowCommandType() IShowCommandTypeContext
	InDb() IInDbContext
	FULL_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	Ulonglong_number() IUlonglong_numberContext
	LimitClause() ILimitClauseContext
	Channel() IChannelContext
	EXTENDED_SYMBOL() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	STORAGE_SYMBOL() antlr.TerminalNode
	AllProfileType() []IProfileTypeContext
	ProfileType(i int) IProfileTypeContext
	QUERY_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	OptionType() IOptionTypeContext
	DATABASE_SYMBOL() antlr.TerminalNode
	EVENT_SYMBOL() antlr.TerminalNode
	TRIGGER_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
	object antlr.Token
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) GetValue() antlr.Token { return s.value }

func (s *ShowStatementContext) GetObject() antlr.Token { return s.object }

func (s *ShowStatementContext) SetValue(v antlr.Token) { s.value = v }

func (s *ShowStatementContext) SetObject(v antlr.Token) { s.object = v }

func (s *ShowStatementContext) SHOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHOW_SYMBOL, 0)
}

func (s *ShowStatementContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATUS_SYMBOL, 0)
}

func (s *ShowStatementContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *ShowStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ShowStatementContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENTS_SYMBOL, 0)
}

func (s *ShowStatementContext) FromOrIn() IFromOrInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromOrInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromOrInContext)
}

func (s *ShowStatementContext) COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOUNT_SYMBOL, 0)
}

func (s *ShowStatementContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ShowStatementContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *ShowStatementContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ShowStatementContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *ShowStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *ShowStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowStatementContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *ShowStatementContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *ShowStatementContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCODE_SYMBOL, 0)
}

func (s *ShowStatementContext) ProcedureRef() IProcedureRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureRefContext)
}

func (s *ShowStatementContext) FunctionRef() IFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionRefContext)
}

func (s *ShowStatementContext) AUTHORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTHORS_SYMBOL, 0)
}

func (s *ShowStatementContext) DATABASES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASES_SYMBOL, 0)
}

func (s *ShowStatementContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGERS_SYMBOL, 0)
}

func (s *ShowStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *ShowStatementContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_SYMBOL, 0)
}

func (s *ShowStatementContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGINS_SYMBOL, 0)
}

func (s *ShowStatementContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *ShowStatementContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMUTEX_SYMBOL, 0)
}

func (s *ShowStatementContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGS_SYMBOL, 0)
}

func (s *ShowStatementContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *ShowStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *ShowStatementContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *ShowStatementContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *ShowStatementContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *ShowStatementContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *ShowStatementContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINES_SYMBOL, 0)
}

func (s *ShowStatementContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWARNINGS_SYMBOL, 0)
}

func (s *ShowStatementContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERRORS_SYMBOL, 0)
}

func (s *ShowStatementContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILES_SYMBOL, 0)
}

func (s *ShowStatementContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILE_SYMBOL, 0)
}

func (s *ShowStatementContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESSLIST_SYMBOL, 0)
}

func (s *ShowStatementContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATION_SYMBOL, 0)
}

func (s *ShowStatementContext) CONTRIBUTORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTRIBUTORS_SYMBOL, 0)
}

func (s *ShowStatementContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *ShowStatementContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANTS_SYMBOL, 0)
}

func (s *ShowStatementContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *ShowStatementContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCEDURE_SYMBOL, 0)
}

func (s *ShowStatementContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *ShowStatementContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *ShowStatementContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *ShowStatementContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOSTS_SYMBOL, 0)
}

func (s *ShowStatementContext) NonBlocking() INonBlockingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonBlockingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonBlockingContext)
}

func (s *ShowStatementContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINLOG_SYMBOL, 0)
}

func (s *ShowStatementContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAYLOG_SYMBOL, 0)
}

func (s *ShowStatementContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *ShowStatementContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEXES_SYMBOL, 0)
}

func (s *ShowStatementContext) KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEYS_SYMBOL, 0)
}

func (s *ShowStatementContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARIABLES_SYMBOL, 0)
}

func (s *ShowStatementContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *ShowStatementContext) EventRef() IEventRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventRefContext)
}

func (s *ShowStatementContext) TriggerRef() ITriggerRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerRefContext)
}

func (s *ShowStatementContext) ViewRef() IViewRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefContext)
}

func (s *ShowStatementContext) LikeOrWhere() ILikeOrWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeOrWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeOrWhereContext)
}

func (s *ShowStatementContext) ShowCommandType() IShowCommandTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommandTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommandTypeContext)
}

func (s *ShowStatementContext) InDb() IInDbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInDbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInDbContext)
}

func (s *ShowStatementContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULL_SYMBOL, 0)
}

func (s *ShowStatementContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *ShowStatementContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *ShowStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowStatementContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ShowStatementContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *ShowStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowStatementContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *ShowStatementContext) AllProfileType() []IProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProfileTypeContext); ok {
			tst[i] = t.(IProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatementContext) ProfileType(i int) IProfileTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProfileTypeContext)
}

func (s *ShowStatementContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *ShowStatementContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *ShowStatementContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *ShowStatementContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *ShowStatementContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *ShowStatementContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGER_SYMBOL, 0)
}

func (s *ShowStatementContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *ShowStatementContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *ShowStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ShowStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ShowStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterShowStatement(s)
	}
}

func (s *ShowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitShowStatement(s)
	}
}

func (s *ShowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitShowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, MySQLParserRULE_showStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4935)
		p.Match(MySQLParserSHOW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5155)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 640, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4936)

		if !(serverVersion < 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50700", ""))
			goto errorExit
		}
		{
			p.SetState(4937)

			var _m = p.Match(MySQLParserAUTHORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4938)

			var _m = p.Match(MySQLParserDATABASES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4940)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4939)
				p.LikeOrWhere()
			}

		}

	case 3:
		p.SetState(4943)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 598, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4942)
				p.ShowCommandType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4945)

			var _m = p.Match(MySQLParserTABLES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4946)
				p.InDb()
			}

		}
		p.SetState(4950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4949)
				p.LikeOrWhere()
			}

		}

	case 4:
		p.SetState(4953)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFULL_SYMBOL {
			{
				p.SetState(4952)
				p.Match(MySQLParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4955)

			var _m = p.Match(MySQLParserTRIGGERS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4956)
				p.InDb()
			}

		}
		p.SetState(4960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4959)
				p.LikeOrWhere()
			}

		}

	case 5:
		{
			p.SetState(4962)

			var _m = p.Match(MySQLParserEVENTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4963)
				p.InDb()
			}

		}
		p.SetState(4967)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4966)
				p.LikeOrWhere()
			}

		}

	case 6:
		{
			p.SetState(4969)

			var _m = p.Match(MySQLParserTABLE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4970)
			p.Match(MySQLParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4972)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4971)
				p.InDb()
			}

		}
		p.SetState(4975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4974)
				p.LikeOrWhere()
			}

		}

	case 7:
		{
			p.SetState(4977)

			var _m = p.Match(MySQLParserOPEN_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4978)
			p.Match(MySQLParserTABLES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4979)
				p.InDb()
			}

		}
		p.SetState(4983)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(4982)
				p.LikeOrWhere()
			}

		}

	case 8:
		{
			p.SetState(4985)

			var _m = p.Match(MySQLParserPLUGINS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		{
			p.SetState(4986)

			var _m = p.Match(MySQLParserENGINE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 610, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4987)
				p.EngineRef()
			}

		case 2:
			{
				p.SetState(4988)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4991)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLOGS_SYMBOL || _la == MySQLParserMUTEX_SYMBOL || _la == MySQLParserSTATUS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		p.SetState(4993)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 611, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4992)
				p.ShowCommandType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4995)

			var _m = p.Match(MySQLParserCOLUMNS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4996)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4997)
			p.TableRef()
		}
		p.SetState(4999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(4998)
				p.InDb()
			}

		}
		p.SetState(5002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5001)
				p.LikeOrWhere()
			}

		}

	case 11:
		{
			p.SetState(5004)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBINARY_SYMBOL || _la == MySQLParserMASTER_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5005)

			var _m = p.Match(MySQLParserLOGS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		{
			p.SetState(5006)

			var _m = p.Match(MySQLParserSLAVE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserHOSTS_SYMBOL:
			{
				p.SetState(5007)
				p.Match(MySQLParserHOSTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySQLParserSTATUS_SYMBOL:
			{
				p.SetState(5008)
				p.Match(MySQLParserSTATUS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5009)
				p.NonBlocking()
			}
			p.SetState(5011)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5010)
					p.Channel()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		{
			p.SetState(5015)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBINLOG_SYMBOL || _la == MySQLParserRELAYLOG_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5016)
			p.Match(MySQLParserEVENTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5019)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5017)
				p.Match(MySQLParserIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5018)
				p.TextString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5023)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 617, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5021)
				p.Match(MySQLParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5022)
				p.Ulonglong_number()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5026)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 618, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5025)
				p.LimitClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5029)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 619, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5028)
				p.Channel()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 14:
		p.SetState(5033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 620, p.GetParserRuleContext()) == 1 {
			p.SetState(5031)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5032)
				p.Match(MySQLParserEXTENDED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5035)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&268435459) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5036)
			p.FromOrIn()
		}
		{
			p.SetState(5037)
			p.TableRef()
		}
		p.SetState(5039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL {
			{
				p.SetState(5038)
				p.InDb()
			}

		}
		p.SetState(5042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5041)
				p.WhereClause()
			}

		}

	case 15:
		p.SetState(5045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserSTORAGE_SYMBOL {
			{
				p.SetState(5044)
				p.Match(MySQLParserSTORAGE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5047)

			var _m = p.Match(MySQLParserENGINES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		{
			p.SetState(5048)
			p.Match(MySQLParserCOUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5049)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5050)
			p.Match(MySQLParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5051)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5052)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserERRORS_SYMBOL || _la == MySQLParserWARNINGS_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		{
			p.SetState(5053)

			var _m = p.Match(MySQLParserWARNINGS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIMIT_SYMBOL {
			{
				p.SetState(5054)
				p.LimitClause()
			}

		}

	case 18:
		{
			p.SetState(5057)

			var _m = p.Match(MySQLParserERRORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIMIT_SYMBOL {
			{
				p.SetState(5058)
				p.LimitClause()
			}

		}

	case 19:
		{
			p.SetState(5061)

			var _m = p.Match(MySQLParserPROFILES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		{
			p.SetState(5062)

			var _m = p.Match(MySQLParserPROFILE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5071)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserALL_SYMBOL || _la == MySQLParserBLOCK_SYMBOL || _la == MySQLParserCONTEXT_SYMBOL || _la == MySQLParserCPU_SYMBOL || _la == MySQLParserIPC_SYMBOL || _la == MySQLParserMEMORY_SYMBOL || _la == MySQLParserPAGE_SYMBOL || _la == MySQLParserSOURCE_SYMBOL || _la == MySQLParserSWAPS_SYMBOL {
			{
				p.SetState(5063)
				p.ProfileType()
			}
			p.SetState(5068)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySQLParserCOMMA_SYMBOL {
				{
					p.SetState(5064)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5065)
					p.ProfileType()
				}

				p.SetState(5070)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(5076)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(5073)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5074)
				p.Match(MySQLParserQUERY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5075)
				p.Match(MySQLParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(5079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIMIT_SYMBOL {
			{
				p.SetState(5078)
				p.LimitClause()
			}

		}

	case 21:
		p.SetState(5082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserGLOBAL_SYMBOL || _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserSESSION_SYMBOL || _la == MySQLParserPERSIST_SYMBOL || _la == MySQLParserPERSIST_ONLY_SYMBOL {
			{
				p.SetState(5081)
				p.OptionType()
			}

		}
		{
			p.SetState(5084)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserSTATUS_SYMBOL || _la == MySQLParserVARIABLES_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5086)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5085)
				p.LikeOrWhere()
			}

		}

	case 22:
		p.SetState(5089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFULL_SYMBOL {
			{
				p.SetState(5088)
				p.Match(MySQLParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5091)

			var _m = p.Match(MySQLParserPROCESSLIST_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		{
			p.SetState(5092)
			p.Charset()
		}
		p.SetState(5094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5093)
				p.LikeOrWhere()
			}

		}

	case 24:
		{
			p.SetState(5096)

			var _m = p.Match(MySQLParserCOLLATION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5097)
				p.LikeOrWhere()
			}

		}

	case 25:
		p.SetState(5100)

		if !(serverVersion < 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50700", ""))
			goto errorExit
		}
		{
			p.SetState(5101)

			var _m = p.Match(MySQLParserCONTRIBUTORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		{
			p.SetState(5102)

			var _m = p.Match(MySQLParserPRIVILEGES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		{
			p.SetState(5103)

			var _m = p.Match(MySQLParserGRANTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(5104)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5105)
				p.User()
			}

		}

	case 28:
		{
			p.SetState(5108)

			var _m = p.Match(MySQLParserGRANTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5109)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5110)
			p.User()
		}
		{
			p.SetState(5111)
			p.Match(MySQLParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5112)
			p.UserList()
		}

	case 29:
		{
			p.SetState(5114)

			var _m = p.Match(MySQLParserMASTER_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5115)
			p.Match(MySQLParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		{
			p.SetState(5116)

			var _m = p.Match(MySQLParserCREATE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 637, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5117)

				var _m = p.Match(MySQLParserDATABASE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5119)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 636, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5118)
					p.IfNotExists()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(5121)
				p.SchemaRef()
			}

		case 2:
			{
				p.SetState(5122)

				var _m = p.Match(MySQLParserEVENT_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5123)
				p.EventRef()
			}

		case 3:
			{
				p.SetState(5124)

				var _m = p.Match(MySQLParserFUNCTION_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5125)
				p.FunctionRef()
			}

		case 4:
			{
				p.SetState(5126)

				var _m = p.Match(MySQLParserPROCEDURE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5127)
				p.ProcedureRef()
			}

		case 5:
			{
				p.SetState(5128)

				var _m = p.Match(MySQLParserTABLE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5129)
				p.TableRef()
			}

		case 6:
			{
				p.SetState(5130)

				var _m = p.Match(MySQLParserTRIGGER_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5131)
				p.TriggerRef()
			}

		case 7:
			{
				p.SetState(5132)

				var _m = p.Match(MySQLParserVIEW_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5133)
				p.ViewRef()
			}

		case 8:
			p.SetState(5134)

			if !(serverVersion >= 50704) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50704", ""))
				goto errorExit
			}
			{
				p.SetState(5135)

				var _m = p.Match(MySQLParserUSER_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5136)
				p.User()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 31:
		{
			p.SetState(5139)

			var _m = p.Match(MySQLParserPROCEDURE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5140)
			p.Match(MySQLParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5142)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5141)
				p.LikeOrWhere()
			}

		}

	case 32:
		{
			p.SetState(5144)

			var _m = p.Match(MySQLParserFUNCTION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5145)
			p.Match(MySQLParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5147)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLIKE_SYMBOL || _la == MySQLParserWHERE_SYMBOL {
			{
				p.SetState(5146)
				p.LikeOrWhere()
			}

		}

	case 33:
		{
			p.SetState(5149)

			var _m = p.Match(MySQLParserPROCEDURE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5150)
			p.Match(MySQLParserCODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5151)
			p.ProcedureRef()
		}

	case 34:
		{
			p.SetState(5152)

			var _m = p.Match(MySQLParserFUNCTION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5153)
			p.Match(MySQLParserCODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5154)
			p.FunctionRef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCommandTypeContext is an interface to support dynamic dispatch.
type IShowCommandTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FULL_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode

	// IsShowCommandTypeContext differentiates from other interfaces.
	IsShowCommandTypeContext()
}

type ShowCommandTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommandTypeContext() *ShowCommandTypeContext {
	var p = new(ShowCommandTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_showCommandType
	return p
}

func InitEmptyShowCommandTypeContext(p *ShowCommandTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_showCommandType
}

func (*ShowCommandTypeContext) IsShowCommandTypeContext() {}

func NewShowCommandTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommandTypeContext {
	var p = new(ShowCommandTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_showCommandType

	return p
}

func (s *ShowCommandTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommandTypeContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULL_SYMBOL, 0)
}

func (s *ShowCommandTypeContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *ShowCommandTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommandTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCommandTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterShowCommandType(s)
	}
}

func (s *ShowCommandTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitShowCommandType(s)
	}
}

func (s *ShowCommandTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitShowCommandType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ShowCommandType() (localctx IShowCommandTypeContext) {
	localctx = NewShowCommandTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, MySQLParserRULE_showCommandType)
	var _la int

	p.SetState(5163)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 642, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5157)
			p.Match(MySQLParserFULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5158)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5159)
			p.Match(MySQLParserEXTENDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFULL_SYMBOL {
			{
				p.SetState(5160)
				p.Match(MySQLParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonBlockingContext is an interface to support dynamic dispatch.
type INonBlockingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONBLOCKING_SYMBOL() antlr.TerminalNode

	// IsNonBlockingContext differentiates from other interfaces.
	IsNonBlockingContext()
}

type NonBlockingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonBlockingContext() *NonBlockingContext {
	var p = new(NonBlockingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nonBlocking
	return p
}

func InitEmptyNonBlockingContext(p *NonBlockingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nonBlocking
}

func (*NonBlockingContext) IsNonBlockingContext() {}

func NewNonBlockingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonBlockingContext {
	var p = new(NonBlockingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_nonBlocking

	return p
}

func (s *NonBlockingContext) GetParser() antlr.Parser { return s.parser }

func (s *NonBlockingContext) NONBLOCKING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONBLOCKING_SYMBOL, 0)
}

func (s *NonBlockingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonBlockingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonBlockingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNonBlocking(s)
	}
}

func (s *NonBlockingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNonBlocking(s)
	}
}

func (s *NonBlockingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNonBlocking(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NonBlocking() (localctx INonBlockingContext) {
	localctx = NewNonBlockingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, MySQLParserRULE_nonBlocking)
	p.SetState(5170)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 644, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5165)

		if !(serverVersion >= 50700 && serverVersion < 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700 && serverVersion < 50706", ""))
			goto errorExit
		}
		p.SetState(5167)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 643, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5166)
				p.Match(MySQLParserNONBLOCKING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromOrInContext is an interface to support dynamic dispatch.
type IFromOrInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode

	// IsFromOrInContext differentiates from other interfaces.
	IsFromOrInContext()
}

type FromOrInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromOrInContext() *FromOrInContext {
	var p = new(FromOrInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fromOrIn
	return p
}

func InitEmptyFromOrInContext(p *FromOrInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fromOrIn
}

func (*FromOrInContext) IsFromOrInContext() {}

func NewFromOrInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromOrInContext {
	var p = new(FromOrInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fromOrIn

	return p
}

func (s *FromOrInContext) GetParser() antlr.Parser { return s.parser }

func (s *FromOrInContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *FromOrInContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *FromOrInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromOrInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromOrInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFromOrIn(s)
	}
}

func (s *FromOrInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFromOrIn(s)
	}
}

func (s *FromOrInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFromOrIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FromOrIn() (localctx IFromOrInContext) {
	localctx = NewFromOrInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, MySQLParserRULE_fromOrIn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5172)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserFROM_SYMBOL || _la == MySQLParserIN_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInDbContext is an interface to support dynamic dispatch.
type IInDbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FromOrIn() IFromOrInContext
	Identifier() IIdentifierContext

	// IsInDbContext differentiates from other interfaces.
	IsInDbContext()
}

type InDbContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInDbContext() *InDbContext {
	var p = new(InDbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_inDb
	return p
}

func InitEmptyInDbContext(p *InDbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_inDb
}

func (*InDbContext) IsInDbContext() {}

func NewInDbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InDbContext {
	var p = new(InDbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_inDb

	return p
}

func (s *InDbContext) GetParser() antlr.Parser { return s.parser }

func (s *InDbContext) FromOrIn() IFromOrInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromOrInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromOrInContext)
}

func (s *InDbContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InDbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInDb(s)
	}
}

func (s *InDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInDb(s)
	}
}

func (s *InDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInDb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InDb() (localctx IInDbContext) {
	localctx = NewInDbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, MySQLParserRULE_inDb)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5174)
		p.FromOrIn()
	}
	{
		p.SetState(5175)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProfileTypeContext is an interface to support dynamic dispatch.
type IProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BLOCK_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode

	// IsProfileTypeContext differentiates from other interfaces.
	IsProfileTypeContext()
}

type ProfileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProfileTypeContext() *ProfileTypeContext {
	var p = new(ProfileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_profileType
	return p
}

func InitEmptyProfileTypeContext(p *ProfileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_profileType
}

func (*ProfileTypeContext) IsProfileTypeContext() {}

func NewProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProfileTypeContext {
	var p = new(ProfileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_profileType

	return p
}

func (s *ProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProfileTypeContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBLOCK_SYMBOL, 0)
}

func (s *ProfileTypeContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIO_SYMBOL, 0)
}

func (s *ProfileTypeContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTEXT_SYMBOL, 0)
}

func (s *ProfileTypeContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWITCHES_SYMBOL, 0)
}

func (s *ProfileTypeContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPAGE_SYMBOL, 0)
}

func (s *ProfileTypeContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAULTS_SYMBOL, 0)
}

func (s *ProfileTypeContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *ProfileTypeContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCPU_SYMBOL, 0)
}

func (s *ProfileTypeContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIPC_SYMBOL, 0)
}

func (s *ProfileTypeContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMORY_SYMBOL, 0)
}

func (s *ProfileTypeContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOURCE_SYMBOL, 0)
}

func (s *ProfileTypeContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWAPS_SYMBOL, 0)
}

func (s *ProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterProfileType(s)
	}
}

func (s *ProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitProfileType(s)
	}
}

func (s *ProfileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitProfileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ProfileType() (localctx IProfileTypeContext) {
	localctx = NewProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, MySQLParserRULE_profileType)
	var _la int

	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserBLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5177)
			p.Match(MySQLParserBLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5178)
			p.Match(MySQLParserIO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCONTEXT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5179)
			p.Match(MySQLParserCONTEXT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5180)
			p.Match(MySQLParserSWITCHES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserPAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5181)
			p.Match(MySQLParserPAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5182)
			p.Match(MySQLParserFAULTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserALL_SYMBOL, MySQLParserCPU_SYMBOL, MySQLParserIPC_SYMBOL, MySQLParserMEMORY_SYMBOL, MySQLParserSOURCE_SYMBOL, MySQLParserSWAPS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5183)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserALL_SYMBOL || _la == MySQLParserCPU_SYMBOL || _la == MySQLParserIPC_SYMBOL || _la == MySQLParserMEMORY_SYMBOL || _la == MySQLParserSOURCE_SYMBOL || _la == MySQLParserSWAPS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOtherAdministrativeStatementContext is an interface to support dynamic dispatch.
type IOtherAdministrativeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TextLiteral() ITextLiteralContext
	BINLOG_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	KeyCacheListOrParts() IKeyCacheListOrPartsContext
	IN_SYMBOL() antlr.TerminalNode
	CACHE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	FLUSH_SYMBOL() antlr.TerminalNode
	FlushTables() IFlushTablesContext
	AllFlushOption() []IFlushOptionContext
	FlushOption(i int) IFlushOptionContext
	NoWriteToBinLog() INoWriteToBinLogContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Expr() IExprContext
	KILL_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	INTO_SYMBOL() antlr.TerminalNode
	PreloadTail() IPreloadTailContext
	LOAD_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode

	// IsOtherAdministrativeStatementContext differentiates from other interfaces.
	IsOtherAdministrativeStatementContext()
}

type OtherAdministrativeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyOtherAdministrativeStatementContext() *OtherAdministrativeStatementContext {
	var p = new(OtherAdministrativeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_otherAdministrativeStatement
	return p
}

func InitEmptyOtherAdministrativeStatementContext(p *OtherAdministrativeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_otherAdministrativeStatement
}

func (*OtherAdministrativeStatementContext) IsOtherAdministrativeStatementContext() {}

func NewOtherAdministrativeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OtherAdministrativeStatementContext {
	var p = new(OtherAdministrativeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_otherAdministrativeStatement

	return p
}

func (s *OtherAdministrativeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OtherAdministrativeStatementContext) GetType_() antlr.Token { return s.type_ }

func (s *OtherAdministrativeStatementContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *OtherAdministrativeStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *OtherAdministrativeStatementContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINLOG_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) KeyCacheListOrParts() IKeyCacheListOrPartsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyCacheListOrPartsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyCacheListOrPartsContext)
}

func (s *OtherAdministrativeStatementContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCACHE_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OtherAdministrativeStatementContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) FLUSH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLUSH_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) FlushTables() IFlushTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTablesContext)
}

func (s *OtherAdministrativeStatementContext) AllFlushOption() []IFlushOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFlushOptionContext); ok {
			len++
		}
	}

	tst := make([]IFlushOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFlushOptionContext); ok {
			tst[i] = t.(IFlushOptionContext)
			i++
		}
	}

	return tst
}

func (s *OtherAdministrativeStatementContext) FlushOption(i int) IFlushOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushOptionContext)
}

func (s *OtherAdministrativeStatementContext) NoWriteToBinLog() INoWriteToBinLogContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoWriteToBinLogContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoWriteToBinLogContext)
}

func (s *OtherAdministrativeStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *OtherAdministrativeStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *OtherAdministrativeStatementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OtherAdministrativeStatementContext) KILL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKILL_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONNECTION_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) PreloadTail() IPreloadTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreloadTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreloadTailContext)
}

func (s *OtherAdministrativeStatementContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOAD_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *OtherAdministrativeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OtherAdministrativeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OtherAdministrativeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOtherAdministrativeStatement(s)
	}
}

func (s *OtherAdministrativeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOtherAdministrativeStatement(s)
	}
}

func (s *OtherAdministrativeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOtherAdministrativeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OtherAdministrativeStatement() (localctx IOtherAdministrativeStatementContext) {
	localctx = NewOtherAdministrativeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, MySQLParserRULE_otherAdministrativeStatement)
	var _la int

	p.SetState(5223)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 651, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5186)

			var _m = p.Match(MySQLParserBINLOG_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5187)
			p.TextLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5188)

			var _m = p.Match(MySQLParserCACHE_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5189)
			p.Match(MySQLParserINDEX_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5190)
			p.KeyCacheListOrParts()
		}
		{
			p.SetState(5191)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5194)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 646, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5192)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(5193)
				p.Match(MySQLParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5196)

			var _m = p.Match(MySQLParserFLUSH_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5198)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 647, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5197)
				p.NoWriteToBinLog()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5209)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 649, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5200)
				p.FlushTables()
			}

		case 2:
			{
				p.SetState(5201)
				p.FlushOption()
			}
			p.SetState(5206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == MySQLParserCOMMA_SYMBOL {
				{
					p.SetState(5202)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5203)
					p.FlushOption()
				}

				p.SetState(5208)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5211)

			var _m = p.Match(MySQLParserKILL_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5213)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 650, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5212)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserCONNECTION_SYMBOL || _la == MySQLParserQUERY_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5215)
			p.expr(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5216)

			var _m = p.Match(MySQLParserLOAD_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5217)
			p.Match(MySQLParserINDEX_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5218)
			p.Match(MySQLParserINTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5219)
			p.Match(MySQLParserCACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5220)
			p.PreloadTail()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5221)

		if !(serverVersion >= 50709) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50709", ""))
			goto errorExit
		}
		{
			p.SetState(5222)

			var _m = p.Match(MySQLParserSHUTDOWN_SYMBOL)

			localctx.(*OtherAdministrativeStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyCacheListOrPartsContext is an interface to support dynamic dispatch.
type IKeyCacheListOrPartsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyCacheList() IKeyCacheListContext
	AssignToKeycachePartition() IAssignToKeycachePartitionContext

	// IsKeyCacheListOrPartsContext differentiates from other interfaces.
	IsKeyCacheListOrPartsContext()
}

type KeyCacheListOrPartsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyCacheListOrPartsContext() *KeyCacheListOrPartsContext {
	var p = new(KeyCacheListOrPartsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyCacheListOrParts
	return p
}

func InitEmptyKeyCacheListOrPartsContext(p *KeyCacheListOrPartsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyCacheListOrParts
}

func (*KeyCacheListOrPartsContext) IsKeyCacheListOrPartsContext() {}

func NewKeyCacheListOrPartsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyCacheListOrPartsContext {
	var p = new(KeyCacheListOrPartsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyCacheListOrParts

	return p
}

func (s *KeyCacheListOrPartsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyCacheListOrPartsContext) KeyCacheList() IKeyCacheListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyCacheListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyCacheListContext)
}

func (s *KeyCacheListOrPartsContext) AssignToKeycachePartition() IAssignToKeycachePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignToKeycachePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignToKeycachePartitionContext)
}

func (s *KeyCacheListOrPartsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyCacheListOrPartsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyCacheListOrPartsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyCacheListOrParts(s)
	}
}

func (s *KeyCacheListOrPartsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyCacheListOrParts(s)
	}
}

func (s *KeyCacheListOrPartsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyCacheListOrParts(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyCacheListOrParts() (localctx IKeyCacheListOrPartsContext) {
	localctx = NewKeyCacheListOrPartsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, MySQLParserRULE_keyCacheListOrParts)
	p.SetState(5227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 652, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5225)
			p.KeyCacheList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5226)
			p.AssignToKeycachePartition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyCacheListContext is an interface to support dynamic dispatch.
type IKeyCacheListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignToKeycache() []IAssignToKeycacheContext
	AssignToKeycache(i int) IAssignToKeycacheContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyCacheListContext differentiates from other interfaces.
	IsKeyCacheListContext()
}

type KeyCacheListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyCacheListContext() *KeyCacheListContext {
	var p = new(KeyCacheListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyCacheList
	return p
}

func InitEmptyKeyCacheListContext(p *KeyCacheListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyCacheList
}

func (*KeyCacheListContext) IsKeyCacheListContext() {}

func NewKeyCacheListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyCacheListContext {
	var p = new(KeyCacheListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyCacheList

	return p
}

func (s *KeyCacheListContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyCacheListContext) AllAssignToKeycache() []IAssignToKeycacheContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignToKeycacheContext); ok {
			len++
		}
	}

	tst := make([]IAssignToKeycacheContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignToKeycacheContext); ok {
			tst[i] = t.(IAssignToKeycacheContext)
			i++
		}
	}

	return tst
}

func (s *KeyCacheListContext) AssignToKeycache(i int) IAssignToKeycacheContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignToKeycacheContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignToKeycacheContext)
}

func (s *KeyCacheListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *KeyCacheListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *KeyCacheListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyCacheListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyCacheListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyCacheList(s)
	}
}

func (s *KeyCacheListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyCacheList(s)
	}
}

func (s *KeyCacheListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyCacheList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyCacheList() (localctx IKeyCacheListContext) {
	localctx = NewKeyCacheListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, MySQLParserRULE_keyCacheList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5229)
		p.AssignToKeycache()
	}
	p.SetState(5234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(5230)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5231)
			p.AssignToKeycache()
		}

		p.SetState(5236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignToKeycacheContext is an interface to support dynamic dispatch.
type IAssignToKeycacheContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	CacheKeyList() ICacheKeyListContext

	// IsAssignToKeycacheContext differentiates from other interfaces.
	IsAssignToKeycacheContext()
}

type AssignToKeycacheContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignToKeycacheContext() *AssignToKeycacheContext {
	var p = new(AssignToKeycacheContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_assignToKeycache
	return p
}

func InitEmptyAssignToKeycacheContext(p *AssignToKeycacheContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_assignToKeycache
}

func (*AssignToKeycacheContext) IsAssignToKeycacheContext() {}

func NewAssignToKeycacheContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignToKeycacheContext {
	var p = new(AssignToKeycacheContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_assignToKeycache

	return p
}

func (s *AssignToKeycacheContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignToKeycacheContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *AssignToKeycacheContext) CacheKeyList() ICacheKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheKeyListContext)
}

func (s *AssignToKeycacheContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignToKeycacheContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignToKeycacheContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAssignToKeycache(s)
	}
}

func (s *AssignToKeycacheContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAssignToKeycache(s)
	}
}

func (s *AssignToKeycacheContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAssignToKeycache(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AssignToKeycache() (localctx IAssignToKeycacheContext) {
	localctx = NewAssignToKeycacheContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, MySQLParserRULE_assignToKeycache)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5237)
		p.TableRef()
	}
	p.SetState(5239)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL {
		{
			p.SetState(5238)
			p.CacheKeyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignToKeycachePartitionContext is an interface to support dynamic dispatch.
type IAssignToKeycachePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	PARTITION_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllOrPartitionNameList() IAllOrPartitionNameListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CacheKeyList() ICacheKeyListContext

	// IsAssignToKeycachePartitionContext differentiates from other interfaces.
	IsAssignToKeycachePartitionContext()
}

type AssignToKeycachePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignToKeycachePartitionContext() *AssignToKeycachePartitionContext {
	var p = new(AssignToKeycachePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_assignToKeycachePartition
	return p
}

func InitEmptyAssignToKeycachePartitionContext(p *AssignToKeycachePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_assignToKeycachePartition
}

func (*AssignToKeycachePartitionContext) IsAssignToKeycachePartitionContext() {}

func NewAssignToKeycachePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignToKeycachePartitionContext {
	var p = new(AssignToKeycachePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_assignToKeycachePartition

	return p
}

func (s *AssignToKeycachePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignToKeycachePartitionContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *AssignToKeycachePartitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *AssignToKeycachePartitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *AssignToKeycachePartitionContext) AllOrPartitionNameList() IAllOrPartitionNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllOrPartitionNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllOrPartitionNameListContext)
}

func (s *AssignToKeycachePartitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *AssignToKeycachePartitionContext) CacheKeyList() ICacheKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheKeyListContext)
}

func (s *AssignToKeycachePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignToKeycachePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignToKeycachePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAssignToKeycachePartition(s)
	}
}

func (s *AssignToKeycachePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAssignToKeycachePartition(s)
	}
}

func (s *AssignToKeycachePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAssignToKeycachePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AssignToKeycachePartition() (localctx IAssignToKeycachePartitionContext) {
	localctx = NewAssignToKeycachePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, MySQLParserRULE_assignToKeycachePartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5241)
		p.TableRef()
	}
	{
		p.SetState(5242)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5243)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5244)
		p.AllOrPartitionNameList()
	}
	{
		p.SetState(5245)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5247)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL {
		{
			p.SetState(5246)
			p.CacheKeyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICacheKeyListContext is an interface to support dynamic dispatch.
type ICacheKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyOrIndex() IKeyOrIndexContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	KeyUsageList() IKeyUsageListContext

	// IsCacheKeyListContext differentiates from other interfaces.
	IsCacheKeyListContext()
}

type CacheKeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCacheKeyListContext() *CacheKeyListContext {
	var p = new(CacheKeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cacheKeyList
	return p
}

func InitEmptyCacheKeyListContext(p *CacheKeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cacheKeyList
}

func (*CacheKeyListContext) IsCacheKeyListContext() {}

func NewCacheKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CacheKeyListContext {
	var p = new(CacheKeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cacheKeyList

	return p
}

func (s *CacheKeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *CacheKeyListContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *CacheKeyListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CacheKeyListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CacheKeyListContext) KeyUsageList() IKeyUsageListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyUsageListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyUsageListContext)
}

func (s *CacheKeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CacheKeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CacheKeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCacheKeyList(s)
	}
}

func (s *CacheKeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCacheKeyList(s)
	}
}

func (s *CacheKeyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCacheKeyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CacheKeyList() (localctx ICacheKeyListContext) {
	localctx = NewCacheKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, MySQLParserRULE_cacheKeyList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5249)
		p.KeyOrIndex()
	}
	{
		p.SetState(5250)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 656, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5251)
			p.KeyUsageList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5254)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyUsageElementContext is an interface to support dynamic dispatch.
type IKeyUsageElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	PRIMARY_SYMBOL() antlr.TerminalNode

	// IsKeyUsageElementContext differentiates from other interfaces.
	IsKeyUsageElementContext()
}

type KeyUsageElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyUsageElementContext() *KeyUsageElementContext {
	var p = new(KeyUsageElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyUsageElement
	return p
}

func InitEmptyKeyUsageElementContext(p *KeyUsageElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyUsageElement
}

func (*KeyUsageElementContext) IsKeyUsageElementContext() {}

func NewKeyUsageElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyUsageElementContext {
	var p = new(KeyUsageElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyUsageElement

	return p
}

func (s *KeyUsageElementContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyUsageElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyUsageElementContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *KeyUsageElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyUsageElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyUsageElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyUsageElement(s)
	}
}

func (s *KeyUsageElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyUsageElement(s)
	}
}

func (s *KeyUsageElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyUsageElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyUsageElement() (localctx IKeyUsageElementContext) {
	localctx = NewKeyUsageElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, MySQLParserRULE_keyUsageElement)
	p.SetState(5258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 657, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5256)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5257)
			p.Match(MySQLParserPRIMARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyUsageListContext is an interface to support dynamic dispatch.
type IKeyUsageListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKeyUsageElement() []IKeyUsageElementContext
	KeyUsageElement(i int) IKeyUsageElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyUsageListContext differentiates from other interfaces.
	IsKeyUsageListContext()
}

type KeyUsageListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyUsageListContext() *KeyUsageListContext {
	var p = new(KeyUsageListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyUsageList
	return p
}

func InitEmptyKeyUsageListContext(p *KeyUsageListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyUsageList
}

func (*KeyUsageListContext) IsKeyUsageListContext() {}

func NewKeyUsageListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyUsageListContext {
	var p = new(KeyUsageListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyUsageList

	return p
}

func (s *KeyUsageListContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyUsageListContext) AllKeyUsageElement() []IKeyUsageElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyUsageElementContext); ok {
			len++
		}
	}

	tst := make([]IKeyUsageElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyUsageElementContext); ok {
			tst[i] = t.(IKeyUsageElementContext)
			i++
		}
	}

	return tst
}

func (s *KeyUsageListContext) KeyUsageElement(i int) IKeyUsageElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyUsageElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyUsageElementContext)
}

func (s *KeyUsageListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *KeyUsageListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *KeyUsageListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyUsageListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyUsageListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyUsageList(s)
	}
}

func (s *KeyUsageListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyUsageList(s)
	}
}

func (s *KeyUsageListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyUsageList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyUsageList() (localctx IKeyUsageListContext) {
	localctx = NewKeyUsageListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, MySQLParserRULE_keyUsageList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5260)
		p.KeyUsageElement()
	}
	p.SetState(5265)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(5261)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5262)
			p.KeyUsageElement()
		}

		p.SetState(5267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushOptionContext is an interface to support dynamic dispatch.
type IFlushOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	DES_KEY_FILE_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	USER_RESOURCES_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	LogType() ILogTypeContext
	RELAY_SYMBOL() antlr.TerminalNode
	Channel() IChannelContext
	CACHE_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	OPTIMIZER_COSTS_SYMBOL() antlr.TerminalNode

	// IsFlushOptionContext differentiates from other interfaces.
	IsFlushOptionContext()
}

type FlushOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyFlushOptionContext() *FlushOptionContext {
	var p = new(FlushOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushOption
	return p
}

func InitEmptyFlushOptionContext(p *FlushOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushOption
}

func (*FlushOptionContext) IsFlushOptionContext() {}

func NewFlushOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushOptionContext {
	var p = new(FlushOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_flushOption

	return p
}

func (s *FlushOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushOptionContext) GetOption() antlr.Token { return s.option }

func (s *FlushOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *FlushOptionContext) DES_KEY_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDES_KEY_FILE_SYMBOL, 0)
}

func (s *FlushOptionContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOSTS_SYMBOL, 0)
}

func (s *FlushOptionContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *FlushOptionContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATUS_SYMBOL, 0)
}

func (s *FlushOptionContext) USER_RESOURCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_RESOURCES_SYMBOL, 0)
}

func (s *FlushOptionContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGS_SYMBOL, 0)
}

func (s *FlushOptionContext) LogType() ILogTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogTypeContext)
}

func (s *FlushOptionContext) RELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_SYMBOL, 0)
}

func (s *FlushOptionContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *FlushOptionContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCACHE_SYMBOL, 0)
}

func (s *FlushOptionContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *FlushOptionContext) OPTIMIZER_COSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIMIZER_COSTS_SYMBOL, 0)
}

func (s *FlushOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFlushOption(s)
	}
}

func (s *FlushOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFlushOption(s)
	}
}

func (s *FlushOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFlushOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FlushOption() (localctx IFlushOptionContext) {
	localctx = NewFlushOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, MySQLParserRULE_flushOption)
	var _la int

	p.SetState(5283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 661, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5268)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*FlushOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDES_KEY_FILE_SYMBOL || _la == MySQLParserHOSTS_SYMBOL || _la == MySQLParserPRIVILEGES_SYMBOL || _la == MySQLParserSTATUS_SYMBOL || _la == MySQLParserUSER_RESOURCES_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*FlushOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserBINARY_SYMBOL || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&35184372088837) != 0) || _la == MySQLParserSLOW_SYMBOL {
			{
				p.SetState(5269)
				p.LogType()
			}

		}
		{
			p.SetState(5272)

			var _m = p.Match(MySQLParserLOGS_SYMBOL)

			localctx.(*FlushOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5273)

			var _m = p.Match(MySQLParserRELAY_SYMBOL)

			localctx.(*FlushOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5274)
			p.Match(MySQLParserLOGS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5276)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 660, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5275)
				p.Channel()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5278)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5279)

			var _m = p.Match(MySQLParserQUERY_SYMBOL)

			localctx.(*FlushOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5280)
			p.Match(MySQLParserCACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5281)

		if !(serverVersion >= 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
			goto errorExit
		}
		{
			p.SetState(5282)

			var _m = p.Match(MySQLParserOPTIMIZER_COSTS_SYMBOL)

			localctx.(*FlushOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogTypeContext is an interface to support dynamic dispatch.
type ILogTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	GENERAL_SYMBOL() antlr.TerminalNode
	SLOW_SYMBOL() antlr.TerminalNode

	// IsLogTypeContext differentiates from other interfaces.
	IsLogTypeContext()
}

type LogTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogTypeContext() *LogTypeContext {
	var p = new(LogTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logType
	return p
}

func InitEmptyLogTypeContext(p *LogTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logType
}

func (*LogTypeContext) IsLogTypeContext() {}

func NewLogTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogTypeContext {
	var p = new(LogTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_logType

	return p
}

func (s *LogTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *LogTypeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *LogTypeContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *LogTypeContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERROR_SYMBOL, 0)
}

func (s *LogTypeContext) GENERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGENERAL_SYMBOL, 0)
}

func (s *LogTypeContext) SLOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLOW_SYMBOL, 0)
}

func (s *LogTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLogType(s)
	}
}

func (s *LogTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLogType(s)
	}
}

func (s *LogTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLogType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LogType() (localctx ILogTypeContext) {
	localctx = NewLogTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, MySQLParserRULE_logType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5285)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserBINARY_SYMBOL || ((int64((_la-163)) & ^0x3f) == 0 && ((int64(1)<<(_la-163))&35184372088837) != 0) || _la == MySQLParserSLOW_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushTablesContext is an interface to support dynamic dispatch.
type IFlushTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLES_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FlushTablesOptions() IFlushTablesOptionsContext

	// IsFlushTablesContext differentiates from other interfaces.
	IsFlushTablesContext()
}

type FlushTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTablesContext() *FlushTablesContext {
	var p = new(FlushTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushTables
	return p
}

func InitEmptyFlushTablesContext(p *FlushTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushTables
}

func (*FlushTablesContext) IsFlushTablesContext() {}

func NewFlushTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTablesContext {
	var p = new(FlushTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_flushTables

	return p
}

func (s *FlushTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTablesContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *FlushTablesContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_SYMBOL, 0)
}

func (s *FlushTablesContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *FlushTablesContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *FlushTablesContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *FlushTablesContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *FlushTablesContext) FlushTablesOptions() IFlushTablesOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFlushTablesOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFlushTablesOptionsContext)
}

func (s *FlushTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFlushTables(s)
	}
}

func (s *FlushTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFlushTables(s)
	}
}

func (s *FlushTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFlushTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FlushTables() (localctx IFlushTablesContext) {
	localctx = NewFlushTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, MySQLParserRULE_flushTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5287)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserTABLES_SYMBOL || _la == MySQLParserTABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5295)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5288)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5289)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5290)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 663, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5291)
			p.IdentifierList()
		}
		p.SetState(5293)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 662, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5292)
				p.FlushTablesOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFlushTablesOptionsContext is an interface to support dynamic dispatch.
type IFlushTablesOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode

	// IsFlushTablesOptionsContext differentiates from other interfaces.
	IsFlushTablesOptionsContext()
}

type FlushTablesOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFlushTablesOptionsContext() *FlushTablesOptionsContext {
	var p = new(FlushTablesOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushTablesOptions
	return p
}

func InitEmptyFlushTablesOptionsContext(p *FlushTablesOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_flushTablesOptions
}

func (*FlushTablesOptionsContext) IsFlushTablesOptionsContext() {}

func NewFlushTablesOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FlushTablesOptionsContext {
	var p = new(FlushTablesOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_flushTablesOptions

	return p
}

func (s *FlushTablesOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FlushTablesOptionsContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *FlushTablesOptionsContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPORT_SYMBOL, 0)
}

func (s *FlushTablesOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *FlushTablesOptionsContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_SYMBOL, 0)
}

func (s *FlushTablesOptionsContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCK_SYMBOL, 0)
}

func (s *FlushTablesOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FlushTablesOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FlushTablesOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFlushTablesOptions(s)
	}
}

func (s *FlushTablesOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFlushTablesOptions(s)
	}
}

func (s *FlushTablesOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFlushTablesOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FlushTablesOptions() (localctx IFlushTablesOptionsContext) {
	localctx = NewFlushTablesOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, MySQLParserRULE_flushTablesOptions)
	p.SetState(5303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 664, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5297)

		if !(serverVersion >= 50606) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50606", ""))
			goto errorExit
		}
		{
			p.SetState(5298)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5299)
			p.Match(MySQLParserEXPORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5300)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5301)
			p.Match(MySQLParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5302)
			p.Match(MySQLParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreloadTailContext is an interface to support dynamic dispatch.
type IPreloadTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	AdminPartition() IAdminPartitionContext
	CacheKeyList() ICacheKeyListContext
	IGNORE_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode
	PreloadList() IPreloadListContext

	// IsPreloadTailContext differentiates from other interfaces.
	IsPreloadTailContext()
}

type PreloadTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreloadTailContext() *PreloadTailContext {
	var p = new(PreloadTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadTail
	return p
}

func InitEmptyPreloadTailContext(p *PreloadTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadTail
}

func (*PreloadTailContext) IsPreloadTailContext() {}

func NewPreloadTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreloadTailContext {
	var p = new(PreloadTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_preloadTail

	return p
}

func (s *PreloadTailContext) GetParser() antlr.Parser { return s.parser }

func (s *PreloadTailContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *PreloadTailContext) AdminPartition() IAdminPartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminPartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminPartitionContext)
}

func (s *PreloadTailContext) CacheKeyList() ICacheKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheKeyListContext)
}

func (s *PreloadTailContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *PreloadTailContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAVES_SYMBOL, 0)
}

func (s *PreloadTailContext) PreloadList() IPreloadListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreloadListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreloadListContext)
}

func (s *PreloadTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreloadTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreloadTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPreloadTail(s)
	}
}

func (s *PreloadTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPreloadTail(s)
	}
}

func (s *PreloadTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPreloadTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PreloadTail() (localctx IPreloadTailContext) {
	localctx = NewPreloadTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, MySQLParserRULE_preloadTail)
	var _la int

	p.SetState(5315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 667, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5305)
			p.TableRef()
		}
		{
			p.SetState(5306)
			p.AdminPartition()
		}
		p.SetState(5308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL {
			{
				p.SetState(5307)
				p.CacheKeyList()
			}

		}
		p.SetState(5312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIGNORE_SYMBOL {
			{
				p.SetState(5310)
				p.Match(MySQLParserIGNORE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5311)
				p.Match(MySQLParserLEAVES_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5314)
			p.PreloadList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreloadListContext is an interface to support dynamic dispatch.
type IPreloadListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPreloadKeys() []IPreloadKeysContext
	PreloadKeys(i int) IPreloadKeysContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPreloadListContext differentiates from other interfaces.
	IsPreloadListContext()
}

type PreloadListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreloadListContext() *PreloadListContext {
	var p = new(PreloadListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadList
	return p
}

func InitEmptyPreloadListContext(p *PreloadListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadList
}

func (*PreloadListContext) IsPreloadListContext() {}

func NewPreloadListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreloadListContext {
	var p = new(PreloadListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_preloadList

	return p
}

func (s *PreloadListContext) GetParser() antlr.Parser { return s.parser }

func (s *PreloadListContext) AllPreloadKeys() []IPreloadKeysContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreloadKeysContext); ok {
			len++
		}
	}

	tst := make([]IPreloadKeysContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreloadKeysContext); ok {
			tst[i] = t.(IPreloadKeysContext)
			i++
		}
	}

	return tst
}

func (s *PreloadListContext) PreloadKeys(i int) IPreloadKeysContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreloadKeysContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreloadKeysContext)
}

func (s *PreloadListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *PreloadListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *PreloadListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreloadListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreloadListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPreloadList(s)
	}
}

func (s *PreloadListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPreloadList(s)
	}
}

func (s *PreloadListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPreloadList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PreloadList() (localctx IPreloadListContext) {
	localctx = NewPreloadListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, MySQLParserRULE_preloadList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5317)
		p.PreloadKeys()
	}
	p.SetState(5322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(5318)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5319)
			p.PreloadKeys()
		}

		p.SetState(5324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreloadKeysContext is an interface to support dynamic dispatch.
type IPreloadKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	CacheKeyList() ICacheKeyListContext
	IGNORE_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode

	// IsPreloadKeysContext differentiates from other interfaces.
	IsPreloadKeysContext()
}

type PreloadKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreloadKeysContext() *PreloadKeysContext {
	var p = new(PreloadKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadKeys
	return p
}

func InitEmptyPreloadKeysContext(p *PreloadKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_preloadKeys
}

func (*PreloadKeysContext) IsPreloadKeysContext() {}

func NewPreloadKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreloadKeysContext {
	var p = new(PreloadKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_preloadKeys

	return p
}

func (s *PreloadKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *PreloadKeysContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *PreloadKeysContext) CacheKeyList() ICacheKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICacheKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICacheKeyListContext)
}

func (s *PreloadKeysContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *PreloadKeysContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAVES_SYMBOL, 0)
}

func (s *PreloadKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreloadKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreloadKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPreloadKeys(s)
	}
}

func (s *PreloadKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPreloadKeys(s)
	}
}

func (s *PreloadKeysContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPreloadKeys(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PreloadKeys() (localctx IPreloadKeysContext) {
	localctx = NewPreloadKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, MySQLParserRULE_preloadKeys)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)
		p.TableRef()
	}
	p.SetState(5327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL {
		{
			p.SetState(5326)
			p.CacheKeyList()
		}

	}
	p.SetState(5331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserIGNORE_SYMBOL {
		{
			p.SetState(5329)
			p.Match(MySQLParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5330)
			p.Match(MySQLParserLEAVES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminPartitionContext is an interface to support dynamic dispatch.
type IAdminPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllOrPartitionNameList() IAllOrPartitionNameListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsAdminPartitionContext differentiates from other interfaces.
	IsAdminPartitionContext()
}

type AdminPartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminPartitionContext() *AdminPartitionContext {
	var p = new(AdminPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_adminPartition
	return p
}

func InitEmptyAdminPartitionContext(p *AdminPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_adminPartition
}

func (*AdminPartitionContext) IsAdminPartitionContext() {}

func NewAdminPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminPartitionContext {
	var p = new(AdminPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_adminPartition

	return p
}

func (s *AdminPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminPartitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *AdminPartitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *AdminPartitionContext) AllOrPartitionNameList() IAllOrPartitionNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAllOrPartitionNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAllOrPartitionNameListContext)
}

func (s *AdminPartitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *AdminPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAdminPartition(s)
	}
}

func (s *AdminPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAdminPartition(s)
	}
}

func (s *AdminPartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAdminPartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AdminPartition() (localctx IAdminPartitionContext) {
	localctx = NewAdminPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, MySQLParserRULE_adminPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5333)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5334)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5335)
		p.AllOrPartitionNameList()
	}
	{
		p.SetState(5336)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupManagementContext is an interface to support dynamic dispatch.
type IResourceGroupManagementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateResourceGroup() ICreateResourceGroupContext
	AlterResourceGroup() IAlterResourceGroupContext
	SetResourceGroup() ISetResourceGroupContext
	DropResourceGroup() IDropResourceGroupContext

	// IsResourceGroupManagementContext differentiates from other interfaces.
	IsResourceGroupManagementContext()
}

type ResourceGroupManagementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupManagementContext() *ResourceGroupManagementContext {
	var p = new(ResourceGroupManagementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupManagement
	return p
}

func InitEmptyResourceGroupManagementContext(p *ResourceGroupManagementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupManagement
}

func (*ResourceGroupManagementContext) IsResourceGroupManagementContext() {}

func NewResourceGroupManagementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupManagementContext {
	var p = new(ResourceGroupManagementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resourceGroupManagement

	return p
}

func (s *ResourceGroupManagementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupManagementContext) CreateResourceGroup() ICreateResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupContext)
}

func (s *ResourceGroupManagementContext) AlterResourceGroup() IAlterResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupContext)
}

func (s *ResourceGroupManagementContext) SetResourceGroup() ISetResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetResourceGroupContext)
}

func (s *ResourceGroupManagementContext) DropResourceGroup() IDropResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupContext)
}

func (s *ResourceGroupManagementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupManagementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupManagementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResourceGroupManagement(s)
	}
}

func (s *ResourceGroupManagementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResourceGroupManagement(s)
	}
}

func (s *ResourceGroupManagementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResourceGroupManagement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResourceGroupManagement() (localctx IResourceGroupManagementContext) {
	localctx = NewResourceGroupManagementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, MySQLParserRULE_resourceGroupManagement)
	p.SetState(5342)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCREATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5338)
			p.CreateResourceGroup()
		}

	case MySQLParserALTER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5339)
			p.AlterResourceGroup()
		}

	case MySQLParserSET_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5340)
			p.SetResourceGroup()
		}

	case MySQLParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5341)
			p.DropResourceGroup()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupContext is an interface to support dynamic dispatch.
type ICreateResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	TYPE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	Equal() IEqualContext
	ResourceGroupVcpuList() IResourceGroupVcpuListContext
	ResourceGroupPriority() IResourceGroupPriorityContext
	ResourceGroupEnableDisable() IResourceGroupEnableDisableContext

	// IsCreateResourceGroupContext differentiates from other interfaces.
	IsCreateResourceGroupContext()
}

type CreateResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupContext() *CreateResourceGroupContext {
	var p = new(CreateResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createResourceGroup
	return p
}

func InitEmptyCreateResourceGroupContext(p *CreateResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createResourceGroup
}

func (*CreateResourceGroupContext) IsCreateResourceGroupContext() {}

func NewCreateResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupContext {
	var p = new(CreateResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createResourceGroup

	return p
}

func (s *CreateResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCREATE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSYSTEM_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CreateResourceGroupContext) ResourceGroupVcpuList() IResourceGroupVcpuListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupVcpuListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupVcpuListContext)
}

func (s *CreateResourceGroupContext) ResourceGroupPriority() IResourceGroupPriorityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupPriorityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupPriorityContext)
}

func (s *CreateResourceGroupContext) ResourceGroupEnableDisable() IResourceGroupEnableDisableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupEnableDisableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupEnableDisableContext)
}

func (s *CreateResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateResourceGroup(s)
	}
}

func (s *CreateResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateResourceGroup(s)
	}
}

func (s *CreateResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateResourceGroup() (localctx ICreateResourceGroupContext) {
	localctx = NewCreateResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, MySQLParserRULE_createResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5344)
		p.Match(MySQLParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5345)
		p.Match(MySQLParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5346)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5347)
		p.Identifier()
	}
	{
		p.SetState(5348)
		p.Match(MySQLParserTYPE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserEQUAL_OPERATOR || _la == MySQLParserASSIGN_OPERATOR {
		{
			p.SetState(5349)
			p.Equal()
		}

	}
	{
		p.SetState(5352)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserUSER_SYMBOL || _la == MySQLParserSYSTEM_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserVCPU_SYMBOL {
		{
			p.SetState(5353)
			p.ResourceGroupVcpuList()
		}

	}
	p.SetState(5357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserTHREAD_PRIORITY_SYMBOL {
		{
			p.SetState(5356)
			p.ResourceGroupPriority()
		}

	}
	p.SetState(5360)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDISABLE_SYMBOL || _la == MySQLParserENABLE_SYMBOL {
		{
			p.SetState(5359)
			p.ResourceGroupEnableDisable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupVcpuListContext is an interface to support dynamic dispatch.
type IResourceGroupVcpuListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VCPU_SYMBOL() antlr.TerminalNode
	AllVcpuNumOrRange() []IVcpuNumOrRangeContext
	VcpuNumOrRange(i int) IVcpuNumOrRangeContext
	Equal() IEqualContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsResourceGroupVcpuListContext differentiates from other interfaces.
	IsResourceGroupVcpuListContext()
}

type ResourceGroupVcpuListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupVcpuListContext() *ResourceGroupVcpuListContext {
	var p = new(ResourceGroupVcpuListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupVcpuList
	return p
}

func InitEmptyResourceGroupVcpuListContext(p *ResourceGroupVcpuListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupVcpuList
}

func (*ResourceGroupVcpuListContext) IsResourceGroupVcpuListContext() {}

func NewResourceGroupVcpuListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupVcpuListContext {
	var p = new(ResourceGroupVcpuListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resourceGroupVcpuList

	return p
}

func (s *ResourceGroupVcpuListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupVcpuListContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVCPU_SYMBOL, 0)
}

func (s *ResourceGroupVcpuListContext) AllVcpuNumOrRange() []IVcpuNumOrRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVcpuNumOrRangeContext); ok {
			len++
		}
	}

	tst := make([]IVcpuNumOrRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVcpuNumOrRangeContext); ok {
			tst[i] = t.(IVcpuNumOrRangeContext)
			i++
		}
	}

	return tst
}

func (s *ResourceGroupVcpuListContext) VcpuNumOrRange(i int) IVcpuNumOrRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVcpuNumOrRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVcpuNumOrRangeContext)
}

func (s *ResourceGroupVcpuListContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *ResourceGroupVcpuListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ResourceGroupVcpuListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ResourceGroupVcpuListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupVcpuListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupVcpuListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResourceGroupVcpuList(s)
	}
}

func (s *ResourceGroupVcpuListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResourceGroupVcpuList(s)
	}
}

func (s *ResourceGroupVcpuListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResourceGroupVcpuList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResourceGroupVcpuList() (localctx IResourceGroupVcpuListContext) {
	localctx = NewResourceGroupVcpuListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, MySQLParserRULE_resourceGroupVcpuList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5362)
		p.Match(MySQLParserVCPU_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserEQUAL_OPERATOR || _la == MySQLParserASSIGN_OPERATOR {
		{
			p.SetState(5363)
			p.Equal()
		}

	}
	{
		p.SetState(5366)
		p.VcpuNumOrRange()
	}
	p.SetState(5373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserINT_NUMBER || _la == MySQLParserCOMMA_SYMBOL {
		p.SetState(5368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(5367)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5370)
			p.VcpuNumOrRange()
		}

		p.SetState(5375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVcpuNumOrRangeContext is an interface to support dynamic dispatch.
type IVcpuNumOrRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	MINUS_OPERATOR() antlr.TerminalNode

	// IsVcpuNumOrRangeContext differentiates from other interfaces.
	IsVcpuNumOrRangeContext()
}

type VcpuNumOrRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcpuNumOrRangeContext() *VcpuNumOrRangeContext {
	var p = new(VcpuNumOrRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_vcpuNumOrRange
	return p
}

func InitEmptyVcpuNumOrRangeContext(p *VcpuNumOrRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_vcpuNumOrRange
}

func (*VcpuNumOrRangeContext) IsVcpuNumOrRangeContext() {}

func NewVcpuNumOrRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcpuNumOrRangeContext {
	var p = new(VcpuNumOrRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_vcpuNumOrRange

	return p
}

func (s *VcpuNumOrRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *VcpuNumOrRangeContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserINT_NUMBER)
}

func (s *VcpuNumOrRangeContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, i)
}

func (s *VcpuNumOrRangeContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUS_OPERATOR, 0)
}

func (s *VcpuNumOrRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcpuNumOrRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcpuNumOrRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVcpuNumOrRange(s)
	}
}

func (s *VcpuNumOrRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVcpuNumOrRange(s)
	}
}

func (s *VcpuNumOrRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVcpuNumOrRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) VcpuNumOrRange() (localctx IVcpuNumOrRangeContext) {
	localctx = NewVcpuNumOrRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, MySQLParserRULE_vcpuNumOrRange)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5376)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5379)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserMINUS_OPERATOR {
		{
			p.SetState(5377)
			p.Match(MySQLParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5378)
			p.Match(MySQLParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupPriorityContext is an interface to support dynamic dispatch.
type IResourceGroupPriorityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	Equal() IEqualContext

	// IsResourceGroupPriorityContext differentiates from other interfaces.
	IsResourceGroupPriorityContext()
}

type ResourceGroupPriorityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupPriorityContext() *ResourceGroupPriorityContext {
	var p = new(ResourceGroupPriorityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupPriority
	return p
}

func InitEmptyResourceGroupPriorityContext(p *ResourceGroupPriorityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupPriority
}

func (*ResourceGroupPriorityContext) IsResourceGroupPriorityContext() {}

func NewResourceGroupPriorityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupPriorityContext {
	var p = new(ResourceGroupPriorityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resourceGroupPriority

	return p
}

func (s *ResourceGroupPriorityContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupPriorityContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *ResourceGroupPriorityContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *ResourceGroupPriorityContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *ResourceGroupPriorityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupPriorityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupPriorityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResourceGroupPriority(s)
	}
}

func (s *ResourceGroupPriorityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResourceGroupPriority(s)
	}
}

func (s *ResourceGroupPriorityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResourceGroupPriority(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResourceGroupPriority() (localctx IResourceGroupPriorityContext) {
	localctx = NewResourceGroupPriorityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, MySQLParserRULE_resourceGroupPriority)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5381)
		p.Match(MySQLParserTHREAD_PRIORITY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserEQUAL_OPERATOR || _la == MySQLParserASSIGN_OPERATOR {
		{
			p.SetState(5382)
			p.Equal()
		}

	}
	{
		p.SetState(5385)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupEnableDisableContext is an interface to support dynamic dispatch.
type IResourceGroupEnableDisableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode

	// IsResourceGroupEnableDisableContext differentiates from other interfaces.
	IsResourceGroupEnableDisableContext()
}

type ResourceGroupEnableDisableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupEnableDisableContext() *ResourceGroupEnableDisableContext {
	var p = new(ResourceGroupEnableDisableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupEnableDisable
	return p
}

func InitEmptyResourceGroupEnableDisableContext(p *ResourceGroupEnableDisableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupEnableDisable
}

func (*ResourceGroupEnableDisableContext) IsResourceGroupEnableDisableContext() {}

func NewResourceGroupEnableDisableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupEnableDisableContext {
	var p = new(ResourceGroupEnableDisableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resourceGroupEnableDisable

	return p
}

func (s *ResourceGroupEnableDisableContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupEnableDisableContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *ResourceGroupEnableDisableContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *ResourceGroupEnableDisableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupEnableDisableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupEnableDisableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResourceGroupEnableDisable(s)
	}
}

func (s *ResourceGroupEnableDisableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResourceGroupEnableDisable(s)
	}
}

func (s *ResourceGroupEnableDisableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResourceGroupEnableDisable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResourceGroupEnableDisable() (localctx IResourceGroupEnableDisableContext) {
	localctx = NewResourceGroupEnableDisableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, MySQLParserRULE_resourceGroupEnableDisable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5387)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDISABLE_SYMBOL || _la == MySQLParserENABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupContext is an interface to support dynamic dispatch.
type IAlterResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	ResourceGroupRef() IResourceGroupRefContext
	ResourceGroupVcpuList() IResourceGroupVcpuListContext
	ResourceGroupPriority() IResourceGroupPriorityContext
	ResourceGroupEnableDisable() IResourceGroupEnableDisableContext
	FORCE_SYMBOL() antlr.TerminalNode

	// IsAlterResourceGroupContext differentiates from other interfaces.
	IsAlterResourceGroupContext()
}

type AlterResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupContext() *AlterResourceGroupContext {
	var p = new(AlterResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterResourceGroup
	return p
}

func InitEmptyAlterResourceGroupContext(p *AlterResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterResourceGroup
}

func (*AlterResourceGroupContext) IsAlterResourceGroupContext() {}

func NewAlterResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupContext {
	var p = new(AlterResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterResourceGroup

	return p
}

func (s *AlterResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALTER_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) ResourceGroupRef() IResourceGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupRefContext)
}

func (s *AlterResourceGroupContext) ResourceGroupVcpuList() IResourceGroupVcpuListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupVcpuListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupVcpuListContext)
}

func (s *AlterResourceGroupContext) ResourceGroupPriority() IResourceGroupPriorityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupPriorityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupPriorityContext)
}

func (s *AlterResourceGroupContext) ResourceGroupEnableDisable() IResourceGroupEnableDisableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupEnableDisableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupEnableDisableContext)
}

func (s *AlterResourceGroupContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORCE_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterResourceGroup(s)
	}
}

func (s *AlterResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterResourceGroup(s)
	}
}

func (s *AlterResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterResourceGroup() (localctx IAlterResourceGroupContext) {
	localctx = NewAlterResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, MySQLParserRULE_alterResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5389)
		p.Match(MySQLParserALTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5390)
		p.Match(MySQLParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5391)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5392)
		p.ResourceGroupRef()
	}
	p.SetState(5394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserVCPU_SYMBOL {
		{
			p.SetState(5393)
			p.ResourceGroupVcpuList()
		}

	}
	p.SetState(5397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserTHREAD_PRIORITY_SYMBOL {
		{
			p.SetState(5396)
			p.ResourceGroupPriority()
		}

	}
	p.SetState(5400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDISABLE_SYMBOL || _la == MySQLParserENABLE_SYMBOL {
		{
			p.SetState(5399)
			p.ResourceGroupEnableDisable()
		}

	}
	p.SetState(5403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserFORCE_SYMBOL {
		{
			p.SetState(5402)
			p.Match(MySQLParserFORCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetResourceGroupContext is an interface to support dynamic dispatch.
type ISetResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR_SYMBOL() antlr.TerminalNode
	ThreadIdList() IThreadIdListContext

	// IsSetResourceGroupContext differentiates from other interfaces.
	IsSetResourceGroupContext()
}

type SetResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetResourceGroupContext() *SetResourceGroupContext {
	var p = new(SetResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setResourceGroup
	return p
}

func InitEmptySetResourceGroupContext(p *SetResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setResourceGroup
}

func (*SetResourceGroupContext) IsSetResourceGroupContext() {}

func NewSetResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetResourceGroupContext {
	var p = new(SetResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setResourceGroup

	return p
}

func (s *SetResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SetResourceGroupContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *SetResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *SetResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *SetResourceGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetResourceGroupContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *SetResourceGroupContext) ThreadIdList() IThreadIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadIdListContext)
}

func (s *SetResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetResourceGroup(s)
	}
}

func (s *SetResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetResourceGroup(s)
	}
}

func (s *SetResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetResourceGroup() (localctx ISetResourceGroupContext) {
	localctx = NewSetResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, MySQLParserRULE_setResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5405)
		p.Match(MySQLParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5406)
		p.Match(MySQLParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5407)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5408)
		p.Identifier()
	}
	p.SetState(5411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserFOR_SYMBOL {
		{
			p.SetState(5409)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5410)
			p.ThreadIdList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThreadIdListContext is an interface to support dynamic dispatch.
type IThreadIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReal_ulong_number() []IReal_ulong_numberContext
	Real_ulong_number(i int) IReal_ulong_numberContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsThreadIdListContext differentiates from other interfaces.
	IsThreadIdListContext()
}

type ThreadIdListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadIdListContext() *ThreadIdListContext {
	var p = new(ThreadIdListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_threadIdList
	return p
}

func InitEmptyThreadIdListContext(p *ThreadIdListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_threadIdList
}

func (*ThreadIdListContext) IsThreadIdListContext() {}

func NewThreadIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadIdListContext {
	var p = new(ThreadIdListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_threadIdList

	return p
}

func (s *ThreadIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadIdListContext) AllReal_ulong_number() []IReal_ulong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			len++
		}
	}

	tst := make([]IReal_ulong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReal_ulong_numberContext); ok {
			tst[i] = t.(IReal_ulong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ThreadIdListContext) Real_ulong_number(i int) IReal_ulong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *ThreadIdListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ThreadIdListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ThreadIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThreadIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterThreadIdList(s)
	}
}

func (s *ThreadIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitThreadIdList(s)
	}
}

func (s *ThreadIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitThreadIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ThreadIdList() (localctx IThreadIdListContext) {
	localctx = NewThreadIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, MySQLParserRULE_threadIdList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5413)
		p.Real_ulong_number()
	}
	p.SetState(5420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&2199090364423) != 0 {
		p.SetState(5415)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(5414)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5417)
			p.Real_ulong_number()
		}

		p.SetState(5422)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupContext is an interface to support dynamic dispatch.
type IDropResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	ResourceGroupRef() IResourceGroupRefContext
	FORCE_SYMBOL() antlr.TerminalNode

	// IsDropResourceGroupContext differentiates from other interfaces.
	IsDropResourceGroupContext()
}

type DropResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupContext() *DropResourceGroupContext {
	var p = new(DropResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropResourceGroup
	return p
}

func InitEmptyDropResourceGroupContext(p *DropResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dropResourceGroup
}

func (*DropResourceGroupContext) IsDropResourceGroupContext() {}

func NewDropResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupContext {
	var p = new(DropResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dropResourceGroup

	return p
}

func (s *DropResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDROP_SYMBOL, 0)
}

func (s *DropResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *DropResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_SYMBOL, 0)
}

func (s *DropResourceGroupContext) ResourceGroupRef() IResourceGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupRefContext)
}

func (s *DropResourceGroupContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORCE_SYMBOL, 0)
}

func (s *DropResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDropResourceGroup(s)
	}
}

func (s *DropResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDropResourceGroup(s)
	}
}

func (s *DropResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDropResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DropResourceGroup() (localctx IDropResourceGroupContext) {
	localctx = NewDropResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, MySQLParserRULE_dropResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5423)
		p.Match(MySQLParserDROP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5424)
		p.Match(MySQLParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5425)
		p.Match(MySQLParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5426)
		p.ResourceGroupRef()
	}
	p.SetState(5428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserFORCE_SYMBOL {
		{
			p.SetState(5427)
			p.Match(MySQLParserFORCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUtilityStatementContext is an interface to support dynamic dispatch.
type IUtilityStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DescribeStatement() IDescribeStatementContext
	ExplainStatement() IExplainStatementContext
	HelpCommand() IHelpCommandContext
	UseCommand() IUseCommandContext
	RestartServer() IRestartServerContext

	// IsUtilityStatementContext differentiates from other interfaces.
	IsUtilityStatementContext()
}

type UtilityStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtilityStatementContext() *UtilityStatementContext {
	var p = new(UtilityStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_utilityStatement
	return p
}

func InitEmptyUtilityStatementContext(p *UtilityStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_utilityStatement
}

func (*UtilityStatementContext) IsUtilityStatementContext() {}

func NewUtilityStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UtilityStatementContext {
	var p = new(UtilityStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_utilityStatement

	return p
}

func (s *UtilityStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UtilityStatementContext) DescribeStatement() IDescribeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescribeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescribeStatementContext)
}

func (s *UtilityStatementContext) ExplainStatement() IExplainStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainStatementContext)
}

func (s *UtilityStatementContext) HelpCommand() IHelpCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpCommandContext)
}

func (s *UtilityStatementContext) UseCommand() IUseCommandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseCommandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseCommandContext)
}

func (s *UtilityStatementContext) RestartServer() IRestartServerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestartServerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestartServerContext)
}

func (s *UtilityStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UtilityStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UtilityStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUtilityStatement(s)
	}
}

func (s *UtilityStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUtilityStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UtilityStatement() (localctx IUtilityStatementContext) {
	localctx = NewUtilityStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, MySQLParserRULE_utilityStatement)
	p.SetState(5436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 689, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5430)
			p.DescribeStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5431)
			p.ExplainStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5432)
			p.HelpCommand()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5433)
			p.UseCommand()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5434)

		if !(serverVersion >= 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
			goto errorExit
		}
		{
			p.SetState(5435)
			p.RestartServer()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescribeStatementContext is an interface to support dynamic dispatch.
type IDescribeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	EXPLAIN_SYMBOL() antlr.TerminalNode
	DESCRIBE_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	ColumnRef() IColumnRefContext

	// IsDescribeStatementContext differentiates from other interfaces.
	IsDescribeStatementContext()
}

type DescribeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescribeStatementContext() *DescribeStatementContext {
	var p = new(DescribeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_describeStatement
	return p
}

func InitEmptyDescribeStatementContext(p *DescribeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_describeStatement
}

func (*DescribeStatementContext) IsDescribeStatementContext() {}

func NewDescribeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescribeStatementContext {
	var p = new(DescribeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_describeStatement

	return p
}

func (s *DescribeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescribeStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *DescribeStatementContext) EXPLAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPLAIN_SYMBOL, 0)
}

func (s *DescribeStatementContext) DESCRIBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESCRIBE_SYMBOL, 0)
}

func (s *DescribeStatementContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESC_SYMBOL, 0)
}

func (s *DescribeStatementContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *DescribeStatementContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *DescribeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescribeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDescribeStatement(s)
	}
}

func (s *DescribeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDescribeStatement(s)
	}
}

func (s *DescribeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDescribeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DescribeStatement() (localctx IDescribeStatementContext) {
	localctx = NewDescribeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, MySQLParserRULE_describeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5438)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-134)) & ^0x3f) == 0 && ((int64(1)<<(_la-134))&17592186044419) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5439)
		p.TableRef()
	}
	p.SetState(5442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 690, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5440)
			p.TextString()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 690, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5441)
			p.ColumnRef()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainStatementContext is an interface to support dynamic dispatch.
type IExplainStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExplainableStatement() IExplainableStatementContext
	EXPLAIN_SYMBOL() antlr.TerminalNode
	DESCRIBE_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	ANALYZE_SYMBOL() antlr.TerminalNode

	// IsExplainStatementContext differentiates from other interfaces.
	IsExplainStatementContext()
}

type ExplainStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainStatementContext() *ExplainStatementContext {
	var p = new(ExplainStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explainStatement
	return p
}

func InitEmptyExplainStatementContext(p *ExplainStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explainStatement
}

func (*ExplainStatementContext) IsExplainStatementContext() {}

func NewExplainStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainStatementContext {
	var p = new(ExplainStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_explainStatement

	return p
}

func (s *ExplainStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainStatementContext) ExplainableStatement() IExplainableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainableStatementContext)
}

func (s *ExplainStatementContext) EXPLAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPLAIN_SYMBOL, 0)
}

func (s *ExplainStatementContext) DESCRIBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESCRIBE_SYMBOL, 0)
}

func (s *ExplainStatementContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESC_SYMBOL, 0)
}

func (s *ExplainStatementContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *ExplainStatementContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONS_SYMBOL, 0)
}

func (s *ExplainStatementContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORMAT_SYMBOL, 0)
}

func (s *ExplainStatementContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *ExplainStatementContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *ExplainStatementContext) ANALYZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANALYZE_SYMBOL, 0)
}

func (s *ExplainStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExplainStatement(s)
	}
}

func (s *ExplainStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExplainStatement(s)
	}
}

func (s *ExplainStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExplainStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExplainStatement() (localctx IExplainStatementContext) {
	localctx = NewExplainStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, MySQLParserRULE_explainStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5444)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-134)) & ^0x3f) == 0 && ((int64(1)<<(_la-134))&17592186044419) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) == 1 {
		p.SetState(5445)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5446)
			p.Match(MySQLParserEXTENDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) == 2 {
		p.SetState(5447)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5448)
			p.Match(MySQLParserPARTITIONS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) == 3 {
		p.SetState(5449)

		if !(serverVersion >= 50605) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50605", ""))
			goto errorExit
		}
		{
			p.SetState(5450)
			p.Match(MySQLParserFORMAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5451)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5452)
			p.TextOrIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) == 4 {
		p.SetState(5453)

		if !(serverVersion >= 80018) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80018", ""))
			goto errorExit
		}
		{
			p.SetState(5454)
			p.Match(MySQLParserANALYZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 691, p.GetParserRuleContext()) == 5 {
		p.SetState(5455)

		if !(serverVersion >= 80019) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
			goto errorExit
		}
		{
			p.SetState(5456)
			p.Match(MySQLParserANALYZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5457)
			p.Match(MySQLParserFORMAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5458)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5459)
			p.TextOrIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5462)
		p.ExplainableStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainableStatementContext is an interface to support dynamic dispatch.
type IExplainableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SelectStatement() ISelectStatementContext
	DeleteStatement() IDeleteStatementContext
	InsertStatement() IInsertStatementContext
	ReplaceStatement() IReplaceStatementContext
	UpdateStatement() IUpdateStatementContext
	FOR_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext

	// IsExplainableStatementContext differentiates from other interfaces.
	IsExplainableStatementContext()
}

type ExplainableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainableStatementContext() *ExplainableStatementContext {
	var p = new(ExplainableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explainableStatement
	return p
}

func InitEmptyExplainableStatementContext(p *ExplainableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_explainableStatement
}

func (*ExplainableStatementContext) IsExplainableStatementContext() {}

func NewExplainableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainableStatementContext {
	var p = new(ExplainableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_explainableStatement

	return p
}

func (s *ExplainableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainableStatementContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *ExplainableStatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *ExplainableStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *ExplainableStatementContext) ReplaceStatement() IReplaceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplaceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplaceStatementContext)
}

func (s *ExplainableStatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *ExplainableStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *ExplainableStatementContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONNECTION_SYMBOL, 0)
}

func (s *ExplainableStatementContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *ExplainableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExplainableStatement(s)
	}
}

func (s *ExplainableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExplainableStatement(s)
	}
}

func (s *ExplainableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExplainableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExplainableStatement() (localctx IExplainableStatementContext) {
	localctx = NewExplainableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, MySQLParserRULE_explainableStatement)
	p.SetState(5476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5464)
			p.SelectStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5465)

		if !(serverVersion >= 50603) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50603", ""))
			goto errorExit
		}
		p.SetState(5470)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 692, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5466)
				p.DeleteStatement()
			}

		case 2:
			{
				p.SetState(5467)
				p.InsertStatement()
			}

		case 3:
			{
				p.SetState(5468)
				p.ReplaceStatement()
			}

		case 4:
			{
				p.SetState(5469)
				p.UpdateStatement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5472)

		if !(serverVersion >= 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
			goto errorExit
		}
		{
			p.SetState(5473)
			p.Match(MySQLParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5474)
			p.Match(MySQLParserCONNECTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5475)
			p.Real_ulong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpCommandContext is an interface to support dynamic dispatch.
type IHelpCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext

	// IsHelpCommandContext differentiates from other interfaces.
	IsHelpCommandContext()
}

type HelpCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpCommandContext() *HelpCommandContext {
	var p = new(HelpCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_helpCommand
	return p
}

func InitEmptyHelpCommandContext(p *HelpCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_helpCommand
}

func (*HelpCommandContext) IsHelpCommandContext() {}

func NewHelpCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpCommandContext {
	var p = new(HelpCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_helpCommand

	return p
}

func (s *HelpCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpCommandContext) HELP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHELP_SYMBOL, 0)
}

func (s *HelpCommandContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *HelpCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHelpCommand(s)
	}
}

func (s *HelpCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHelpCommand(s)
	}
}

func (s *HelpCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHelpCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HelpCommand() (localctx IHelpCommandContext) {
	localctx = NewHelpCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, MySQLParserRULE_helpCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5478)
		p.Match(MySQLParserHELP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5479)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseCommandContext is an interface to support dynamic dispatch.
type IUseCommandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsUseCommandContext differentiates from other interfaces.
	IsUseCommandContext()
}

type UseCommandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseCommandContext() *UseCommandContext {
	var p = new(UseCommandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_useCommand
	return p
}

func InitEmptyUseCommandContext(p *UseCommandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_useCommand
}

func (*UseCommandContext) IsUseCommandContext() {}

func NewUseCommandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseCommandContext {
	var p = new(UseCommandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_useCommand

	return p
}

func (s *UseCommandContext) GetParser() antlr.Parser { return s.parser }

func (s *UseCommandContext) USE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_SYMBOL, 0)
}

func (s *UseCommandContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseCommandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCommandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseCommandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUseCommand(s)
	}
}

func (s *UseCommandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUseCommand(s)
	}
}

func (s *UseCommandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUseCommand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UseCommand() (localctx IUseCommandContext) {
	localctx = NewUseCommandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, MySQLParserRULE_useCommand)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5481)
		p.Match(MySQLParserUSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5482)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestartServerContext is an interface to support dynamic dispatch.
type IRestartServerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTART_SYMBOL() antlr.TerminalNode

	// IsRestartServerContext differentiates from other interfaces.
	IsRestartServerContext()
}

type RestartServerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestartServerContext() *RestartServerContext {
	var p = new(RestartServerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_restartServer
	return p
}

func InitEmptyRestartServerContext(p *RestartServerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_restartServer
}

func (*RestartServerContext) IsRestartServerContext() {}

func NewRestartServerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestartServerContext {
	var p = new(RestartServerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_restartServer

	return p
}

func (s *RestartServerContext) GetParser() antlr.Parser { return s.parser }

func (s *RestartServerContext) RESTART_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTART_SYMBOL, 0)
}

func (s *RestartServerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestartServerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestartServerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRestartServer(s)
	}
}

func (s *RestartServerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRestartServer(s)
	}
}

func (s *RestartServerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRestartServer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RestartServer() (localctx IRestartServerContext) {
	localctx = NewRestartServerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, MySQLParserRULE_restartServer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5484)
		p.Match(MySQLParserRESTART_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyAll(ctx *ExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExprOrContext struct {
	ExprContext
	op antlr.Token
}

func NewExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprOrContext {
	var p = new(ExprOrContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprOrContext) GetOp() antlr.Token { return s.op }

func (s *ExprOrContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprOrContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprOrContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprOrContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOR_SYMBOL, 0)
}

func (s *ExprOrContext) LOGICAL_OR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGICAL_OR_OPERATOR, 0)
}

func (s *ExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprOr(s)
	}
}

func (s *ExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprOr(s)
	}
}

func (s *ExprOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprNotContext struct {
	ExprContext
}

func NewExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprNotContext {
	var p = new(ExprNotContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprNotContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *ExprNotContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprNot(s)
	}
}

func (s *ExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprNot(s)
	}
}

func (s *ExprNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprIsContext struct {
	ExprContext
	type_ antlr.Token
}

func NewExprIsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIsContext {
	var p = new(ExprIsContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprIsContext) GetType_() antlr.Token { return s.type_ }

func (s *ExprIsContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ExprIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIsContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *ExprIsContext) IS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIS_SYMBOL, 0)
}

func (s *ExprIsContext) TRUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUE_SYMBOL, 0)
}

func (s *ExprIsContext) FALSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFALSE_SYMBOL, 0)
}

func (s *ExprIsContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNKNOWN_SYMBOL, 0)
}

func (s *ExprIsContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *ExprIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprIs(s)
	}
}

func (s *ExprIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprIs(s)
	}
}

func (s *ExprIsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprIs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAndContext struct {
	ExprContext
	op antlr.Token
}

func NewExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAndContext {
	var p = new(ExprAndContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprAndContext) GetOp() antlr.Token { return s.op }

func (s *ExprAndContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAndContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprAndContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAndContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, 0)
}

func (s *ExprAndContext) LOGICAL_AND_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGICAL_AND_OPERATOR, 0)
}

func (s *ExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprAnd(s)
	}
}

func (s *ExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprAnd(s)
	}
}

func (s *ExprAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprXorContext struct {
	ExprContext
}

func NewExprXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprXorContext {
	var p = new(ExprXorContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprXorContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprXorContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprXorContext) XOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXOR_SYMBOL, 0)
}

func (s *ExprXorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprXor(s)
	}
}

func (s *ExprXorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprXor(s)
	}
}

func (s *ExprXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprXor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *MySQLParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 676
	p.EnterRecursionRule(localctx, 676, MySQLParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExprIsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5487)
			p.boolPri(0)
		}
		p.SetState(5493)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 695, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5488)
				p.Match(MySQLParserIS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5490)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserNOT_SYMBOL || _la == MySQLParserNOT2_SYMBOL {
				{
					p.SetState(5489)
					p.NotRule()
				}

			}
			{
				p.SetState(5492)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ExprIsContext).type_ = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserFALSE_SYMBOL || _la == MySQLParserTRUE_SYMBOL || _la == MySQLParserUNKNOWN_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ExprIsContext).type_ = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5495)
			p.Match(MySQLParserNOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5496)
			p.expr(4)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5508)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_expr)
				p.SetState(5499)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5500)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprAndContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserAND_SYMBOL || _la == MySQLParserLOGICAL_AND_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprAndContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5501)
					p.expr(4)
				}

			case 2:
				localctx = NewExprXorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_expr)
				p.SetState(5502)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5503)
					p.Match(MySQLParserXOR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5504)
					p.expr(3)
				}

			case 3:
				localctx = NewExprOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_expr)
				p.SetState(5505)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5506)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprOrContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserOR_SYMBOL || _la == MySQLParserLOGICAL_OR_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprOrContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5507)
					p.expr(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 698, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolPriContext is an interface to support dynamic dispatch.
type IBoolPriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBoolPriContext differentiates from other interfaces.
	IsBoolPriContext()
}

type BoolPriContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolPriContext() *BoolPriContext {
	var p = new(BoolPriContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_boolPri
	return p
}

func InitEmptyBoolPriContext(p *BoolPriContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_boolPri
}

func (*BoolPriContext) IsBoolPriContext() {}

func NewBoolPriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolPriContext {
	var p = new(BoolPriContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_boolPri

	return p
}

func (s *BoolPriContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolPriContext) CopyAll(ctx *BoolPriContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BoolPriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolPriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PrimaryExprPredicateContext struct {
	BoolPriContext
}

func NewPrimaryExprPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprPredicateContext {
	var p = new(PrimaryExprPredicateContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PrimaryExprPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrimaryExprPredicate(s)
	}
}

func (s *PrimaryExprPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrimaryExprPredicate(s)
	}
}

func (s *PrimaryExprPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrimaryExprPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprCompareContext struct {
	BoolPriContext
}

func NewPrimaryExprCompareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprCompareContext {
	var p = new(PrimaryExprCompareContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprCompareContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprCompareContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *PrimaryExprCompareContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PrimaryExprCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrimaryExprCompare(s)
	}
}

func (s *PrimaryExprCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrimaryExprCompare(s)
	}
}

func (s *PrimaryExprCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrimaryExprCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprAllAnyContext struct {
	BoolPriContext
}

func NewPrimaryExprAllAnyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprAllAnyContext {
	var p = new(PrimaryExprAllAnyContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprAllAnyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprAllAnyContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprAllAnyContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *PrimaryExprAllAnyContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PrimaryExprAllAnyContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *PrimaryExprAllAnyContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANY_SYMBOL, 0)
}

func (s *PrimaryExprAllAnyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrimaryExprAllAny(s)
	}
}

func (s *PrimaryExprAllAnyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrimaryExprAllAny(s)
	}
}

func (s *PrimaryExprAllAnyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrimaryExprAllAny(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprIsNullContext struct {
	BoolPriContext
}

func NewPrimaryExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprIsNullContext {
	var p = new(PrimaryExprIsNullContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprIsNullContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprIsNullContext) IS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIS_SYMBOL, 0)
}

func (s *PrimaryExprIsNullContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *PrimaryExprIsNullContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *PrimaryExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrimaryExprIsNull(s)
	}
}

func (s *PrimaryExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrimaryExprIsNull(s)
	}
}

func (s *PrimaryExprIsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrimaryExprIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) BoolPri() (localctx IBoolPriContext) {
	return p.boolPri(0)
}

func (p *MySQLParser) boolPri(_p int) (localctx IBoolPriContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBoolPriContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBoolPriContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 678
	p.EnterRecursionRule(localctx, 678, MySQLParserRULE_boolPri, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewPrimaryExprPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(5514)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5531)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 700, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPrimaryExprIsNullContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_boolPri)
				p.SetState(5516)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5517)
					p.Match(MySQLParserIS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5519)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == MySQLParserNOT_SYMBOL || _la == MySQLParserNOT2_SYMBOL {
					{
						p.SetState(5518)
						p.NotRule()
					}

				}
				{
					p.SetState(5521)
					p.Match(MySQLParserNULL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewPrimaryExprCompareContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_boolPri)
				p.SetState(5522)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5523)
					p.CompOp()
				}
				{
					p.SetState(5524)
					p.Predicate()
				}

			case 3:
				localctx = NewPrimaryExprAllAnyContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_boolPri)
				p.SetState(5526)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5527)
					p.CompOp()
				}
				{
					p.SetState(5528)
					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserALL_SYMBOL || _la == MySQLParserANY_SYMBOL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5529)
					p.Subquery()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5535)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompOpContext is an interface to support dynamic dispatch.
type ICompOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	NULL_SAFE_EQUAL_OPERATOR() antlr.TerminalNode
	GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode
	GREATER_THAN_OPERATOR() antlr.TerminalNode
	LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode
	LESS_THAN_OPERATOR() antlr.TerminalNode
	NOT_EQUAL_OPERATOR() antlr.TerminalNode

	// IsCompOpContext differentiates from other interfaces.
	IsCompOpContext()
}

type CompOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompOpContext() *CompOpContext {
	var p = new(CompOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compOp
	return p
}

func InitEmptyCompOpContext(p *CompOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compOp
}

func (*CompOpContext) IsCompOpContext() {}

func NewCompOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompOpContext {
	var p = new(CompOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_compOp

	return p
}

func (s *CompOpContext) GetParser() antlr.Parser { return s.parser }

func (s *CompOpContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *CompOpContext) NULL_SAFE_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SAFE_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserGREATER_OR_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GREATER_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserGREATER_THAN_OPERATOR, 0)
}

func (s *CompOpContext) LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_OR_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) LESS_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_THAN_OPERATOR, 0)
}

func (s *CompOpContext) NOT_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCompOp(s)
	}
}

func (s *CompOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCompOp(s)
	}
}

func (s *CompOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCompOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CompOp() (localctx ICompOpContext) {
	localctx = NewCompOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, MySQLParserRULE_compOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5536)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-750)) & ^0x3f) == 0 && ((int64(1)<<(_la-750))&253) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBitExpr() []IBitExprContext
	BitExpr(i int) IBitExprContext
	PredicateOperations() IPredicateOperationsContext
	MEMBER_SYMBOL() antlr.TerminalNode
	SimpleExprWithParentheses() ISimpleExprWithParenthesesContext
	SOUNDS_SYMBOL() antlr.TerminalNode
	LIKE_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	OF_SYMBOL() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) AllBitExpr() []IBitExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitExprContext); ok {
			len++
		}
	}

	tst := make([]IBitExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitExprContext); ok {
			tst[i] = t.(IBitExprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) BitExpr(i int) IBitExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) MEMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMBER_SYMBOL, 0)
}

func (s *PredicateContext) SimpleExprWithParentheses() ISimpleExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprWithParenthesesContext)
}

func (s *PredicateContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOUNDS_SYMBOL, 0)
}

func (s *PredicateContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIKE_SYMBOL, 0)
}

func (s *PredicateContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *PredicateContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOF_SYMBOL, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, MySQLParserRULE_predicate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5538)
		p.bitExpr(0)
	}
	p.SetState(5552)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
		p.SetState(5540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL || _la == MySQLParserNOT2_SYMBOL {
			{
				p.SetState(5539)
				p.NotRule()
			}

		}
		{
			p.SetState(5542)
			p.PredicateOperations()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) == 2 {
		p.SetState(5543)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(5544)
			p.Match(MySQLParserMEMBER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserOF_SYMBOL {
			{
				p.SetState(5545)
				p.Match(MySQLParserOF_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5548)
			p.SimpleExprWithParentheses()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(5549)
			p.Match(MySQLParserSOUNDS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5550)
			p.Match(MySQLParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5551)
			p.bitExpr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_predicateOperations

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateExprRegexContext struct {
	PredicateOperationsContext
}

func NewPredicateExprRegexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprRegexContext {
	var p = new(PredicateExprRegexContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprRegexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprRegexContext) REGEXP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREGEXP_SYMBOL, 0)
}

func (s *PredicateExprRegexContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateExprRegexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPredicateExprRegex(s)
	}
}

func (s *PredicateExprRegexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPredicateExprRegex(s)
	}
}

func (s *PredicateExprRegexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPredicateExprRegex(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprBetweenContext struct {
	PredicateOperationsContext
}

func NewPredicateExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprBetweenContext {
	var p = new(PredicateExprBetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprBetweenContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBETWEEN_SYMBOL, 0)
}

func (s *PredicateExprBetweenContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateExprBetweenContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAND_SYMBOL, 0)
}

func (s *PredicateExprBetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPredicateExprBetween(s)
	}
}

func (s *PredicateExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPredicateExprBetween(s)
	}
}

func (s *PredicateExprBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPredicateExprBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprInContext struct {
	PredicateOperationsContext
}

func NewPredicateExprInContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprInContext {
	var p = new(PredicateExprInContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprInContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *PredicateExprInContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PredicateExprInContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PredicateExprInContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PredicateExprInContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PredicateExprInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPredicateExprIn(s)
	}
}

func (s *PredicateExprInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPredicateExprIn(s)
	}
}

func (s *PredicateExprInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPredicateExprIn(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprLikeContext struct {
	PredicateOperationsContext
}

func NewPredicateExprLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprLikeContext {
	var p = new(PredicateExprLikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprLikeContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIKE_SYMBOL, 0)
}

func (s *PredicateExprLikeContext) AllSimpleExpr() []ISimpleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExprContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExprContext); ok {
			tst[i] = t.(ISimpleExprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateExprLikeContext) SimpleExpr(i int) ISimpleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *PredicateExprLikeContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserESCAPE_SYMBOL, 0)
}

func (s *PredicateExprLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPredicateExprLike(s)
	}
}

func (s *PredicateExprLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPredicateExprLike(s)
	}
}

func (s *PredicateExprLikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPredicateExprLike(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PredicateOperations() (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, MySQLParserRULE_predicateOperations)
	p.SetState(5575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserIN_SYMBOL:
		localctx = NewPredicateExprInContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5554)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5560)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 705, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5555)
				p.Subquery()
			}

		case 2:
			{
				p.SetState(5556)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5557)
				p.ExprList()
			}
			{
				p.SetState(5558)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case MySQLParserBETWEEN_SYMBOL:
		localctx = NewPredicateExprBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5562)
			p.Match(MySQLParserBETWEEN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5563)
			p.bitExpr(0)
		}
		{
			p.SetState(5564)
			p.Match(MySQLParserAND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5565)
			p.Predicate()
		}

	case MySQLParserLIKE_SYMBOL:
		localctx = NewPredicateExprLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5567)
			p.Match(MySQLParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5568)
			p.simpleExpr(0)
		}
		p.SetState(5571)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5569)
				p.Match(MySQLParserESCAPE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5570)
				p.simpleExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserREGEXP_SYMBOL:
		localctx = NewPredicateExprRegexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5573)
			p.Match(MySQLParserREGEXP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5574)
			p.bitExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitExprContext is an interface to support dynamic dispatch.
type IBitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	SimpleExpr() ISimpleExprContext
	AllBitExpr() []IBitExprContext
	BitExpr(i int) IBitExprContext
	BITWISE_XOR_OPERATOR() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	DIV_OPERATOR() antlr.TerminalNode
	MOD_OPERATOR() antlr.TerminalNode
	DIV_SYMBOL() antlr.TerminalNode
	MOD_SYMBOL() antlr.TerminalNode
	PLUS_OPERATOR() antlr.TerminalNode
	MINUS_OPERATOR() antlr.TerminalNode
	SHIFT_LEFT_OPERATOR() antlr.TerminalNode
	SHIFT_RIGHT_OPERATOR() antlr.TerminalNode
	BITWISE_AND_OPERATOR() antlr.TerminalNode
	BITWISE_OR_OPERATOR() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext

	// IsBitExprContext differentiates from other interfaces.
	IsBitExprContext()
}

type BitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyBitExprContext() *BitExprContext {
	var p = new(BitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_bitExpr
	return p
}

func InitEmptyBitExprContext(p *BitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_bitExpr
}

func (*BitExprContext) IsBitExprContext() {}

func NewBitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitExprContext {
	var p = new(BitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_bitExpr

	return p
}

func (s *BitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitExprContext) GetOp() antlr.Token { return s.op }

func (s *BitExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitExprContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *BitExprContext) AllBitExpr() []IBitExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitExprContext); ok {
			len++
		}
	}

	tst := make([]IBitExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitExprContext); ok {
			tst[i] = t.(IBitExprContext)
			i++
		}
	}

	return tst
}

func (s *BitExprContext) BitExpr(i int) IBitExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *BitExprContext) BITWISE_XOR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserBITWISE_XOR_OPERATOR, 0)
}

func (s *BitExprContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *BitExprContext) DIV_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIV_OPERATOR, 0)
}

func (s *BitExprContext) MOD_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMOD_OPERATOR, 0)
}

func (s *BitExprContext) DIV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIV_SYMBOL, 0)
}

func (s *BitExprContext) MOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMOD_SYMBOL, 0)
}

func (s *BitExprContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUS_OPERATOR, 0)
}

func (s *BitExprContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUS_OPERATOR, 0)
}

func (s *BitExprContext) SHIFT_LEFT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHIFT_LEFT_OPERATOR, 0)
}

func (s *BitExprContext) SHIFT_RIGHT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHIFT_RIGHT_OPERATOR, 0)
}

func (s *BitExprContext) BITWISE_AND_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserBITWISE_AND_OPERATOR, 0)
}

func (s *BitExprContext) BITWISE_OR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserBITWISE_OR_OPERATOR, 0)
}

func (s *BitExprContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *BitExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *BitExprContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *BitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterBitExpr(s)
	}
}

func (s *BitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitBitExpr(s)
	}
}

func (s *BitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitBitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) BitExpr() (localctx IBitExprContext) {
	return p.bitExpr(0)
}

func (p *MySQLParser) bitExpr(_p int) (localctx IBitExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 686
	p.EnterRecursionRule(localctx, 686, MySQLParserRULE_bitExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5578)
		p.simpleExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5604)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5580)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(5581)

					var _m = p.Match(MySQLParserBITWISE_XOR_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5582)
					p.bitExpr(8)
				}

			case 2:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5583)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(5584)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserDIV_SYMBOL || _la == MySQLParserMOD_SYMBOL || ((int64((_la-760)) & ^0x3f) == 0 && ((int64(1)<<(_la-760))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5585)
					p.bitExpr(7)
				}

			case 3:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5586)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(5587)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserPLUS_OPERATOR || _la == MySQLParserMINUS_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5588)
					p.bitExpr(6)
				}

			case 4:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5589)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(5590)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserSHIFT_LEFT_OPERATOR || _la == MySQLParserSHIFT_RIGHT_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5591)
					p.bitExpr(4)
				}

			case 5:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5592)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5593)

					var _m = p.Match(MySQLParserBITWISE_AND_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5594)
					p.bitExpr(3)
				}

			case 6:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5595)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5596)

					var _m = p.Match(MySQLParserBITWISE_OR_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5597)
					p.bitExpr(2)
				}

			case 7:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_bitExpr)
				p.SetState(5598)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(5599)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == MySQLParserPLUS_OPERATOR || _la == MySQLParserMINUS_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(5600)
					p.Match(MySQLParserINTERVAL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5601)
					p.expr(0)
				}
				{
					p.SetState(5602)
					p.Interval()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 709, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExprContext is an interface to support dynamic dispatch.
type ISimpleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimpleExprContext differentiates from other interfaces.
	IsSimpleExprContext()
}

type SimpleExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprContext() *SimpleExprContext {
	var p = new(SimpleExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleExpr
	return p
}

func InitEmptySimpleExprContext(p *SimpleExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleExpr
}

func (*SimpleExprContext) IsSimpleExprContext() {}

func NewSimpleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprContext {
	var p = new(SimpleExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_simpleExpr

	return p
}

func (s *SimpleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprContext) CopyAll(ctx *SimpleExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimpleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleExprConvertContext struct {
	SimpleExprContext
}

func NewSimpleExprConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConvertContext {
	var p = new(SimpleExprConvertContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConvertContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONVERT_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprConvertContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) CastType() ICastTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTypeContext)
}

func (s *SimpleExprConvertContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprConvert(s)
	}
}

func (s *SimpleExprConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprConvert(s)
	}
}

func (s *SimpleExprConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprVariableContext struct {
	SimpleExprContext
}

func NewSimpleExprVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprVariableContext {
	var p = new(SimpleExprVariableContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SimpleExprVariableContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *SimpleExprVariableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprVariable(s)
	}
}

func (s *SimpleExprVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprVariable(s)
	}
}

func (s *SimpleExprVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCastContext struct {
	SimpleExprContext
}

func NewSimpleExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCastContext {
	var p = new(SimpleExprCastContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCastContext) CAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCAST_SYMBOL, 0)
}

func (s *SimpleExprCastContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprCastContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprCastContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *SimpleExprCastContext) CastType() ICastTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTypeContext)
}

func (s *SimpleExprCastContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprCastContext) ArrayCast() IArrayCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCastContext)
}

func (s *SimpleExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprCast(s)
	}
}

func (s *SimpleExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprCast(s)
	}
}

func (s *SimpleExprCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprUnaryContext struct {
	SimpleExprContext
	op antlr.Token
}

func NewSimpleExprUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprUnaryContext {
	var p = new(SimpleExprUnaryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprUnaryContext) GetOp() antlr.Token { return s.op }

func (s *SimpleExprUnaryContext) SetOp(v antlr.Token) { s.op = v }

func (s *SimpleExprUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprUnaryContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprUnaryContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUS_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUS_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) BITWISE_NOT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserBITWISE_NOT_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprUnary(s)
	}
}

func (s *SimpleExprUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprUnary(s)
	}
}

func (s *SimpleExprUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprOdbcContext struct {
	SimpleExprContext
}

func NewSimpleExprOdbcContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprOdbcContext {
	var p = new(SimpleExprOdbcContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprOdbcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprOdbcContext) OPEN_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_CURLY_SYMBOL, 0)
}

func (s *SimpleExprOdbcContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleExprOdbcContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprOdbcContext) CLOSE_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_CURLY_SYMBOL, 0)
}

func (s *SimpleExprOdbcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprOdbc(s)
	}
}

func (s *SimpleExprOdbcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprOdbc(s)
	}
}

func (s *SimpleExprOdbcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprOdbc(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprRuntimeFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprRuntimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprRuntimeFunctionContext {
	var p = new(SimpleExprRuntimeFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprRuntimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprRuntimeFunctionContext) RuntimeFunctionCall() IRuntimeFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuntimeFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuntimeFunctionCallContext)
}

func (s *SimpleExprRuntimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprRuntimeFunction(s)
	}
}

func (s *SimpleExprRuntimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprRuntimeFunction(s)
	}
}

func (s *SimpleExprRuntimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprRuntimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprFunctionContext {
	var p = new(SimpleExprFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprFunctionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SimpleExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprFunction(s)
	}
}

func (s *SimpleExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprFunction(s)
	}
}

func (s *SimpleExprFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCollateContext struct {
	SimpleExprContext
}

func NewSimpleExprCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCollateContext {
	var p = new(SimpleExprCollateContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCollateContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprCollateContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATE_SYMBOL, 0)
}

func (s *SimpleExprCollateContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SimpleExprCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprCollate(s)
	}
}

func (s *SimpleExprCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprCollate(s)
	}
}

func (s *SimpleExprCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprMatchContext struct {
	SimpleExprContext
}

func NewSimpleExprMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprMatchContext {
	var p = new(SimpleExprMatchContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprMatchContext) MATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMATCH_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) IdentListArg() IIdentListArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListArgContext)
}

func (s *SimpleExprMatchContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGAINST_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *SimpleExprMatchContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) FulltextOptions() IFulltextOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFulltextOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFulltextOptionsContext)
}

func (s *SimpleExprMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprMatch(s)
	}
}

func (s *SimpleExprMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprMatch(s)
	}
}

func (s *SimpleExprMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprWindowingFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprWindowingFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprWindowingFunctionContext {
	var p = new(SimpleExprWindowingFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprWindowingFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprWindowingFunctionContext) WindowFunctionCall() IWindowFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionCallContext)
}

func (s *SimpleExprWindowingFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprWindowingFunction(s)
	}
}

func (s *SimpleExprWindowingFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprWindowingFunction(s)
	}
}

func (s *SimpleExprWindowingFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprWindowingFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprBinaryContext struct {
	SimpleExprContext
}

func NewSimpleExprBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprBinaryContext {
	var p = new(SimpleExprBinaryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprBinaryContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *SimpleExprBinaryContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprBinary(s)
	}
}

func (s *SimpleExprBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprBinary(s)
	}
}

func (s *SimpleExprBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprColumnRefContext struct {
	SimpleExprContext
}

func NewSimpleExprColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprColumnRefContext {
	var p = new(SimpleExprColumnRefContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprColumnRefContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *SimpleExprColumnRefContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *SimpleExprColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprColumnRef(s)
	}
}

func (s *SimpleExprColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprColumnRef(s)
	}
}

func (s *SimpleExprColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprParamMarkerContext struct {
	SimpleExprContext
}

func NewSimpleExprParamMarkerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprParamMarkerContext {
	var p = new(SimpleExprParamMarkerContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprParamMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprParamMarkerContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARAM_MARKER, 0)
}

func (s *SimpleExprParamMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprParamMarker(s)
	}
}

func (s *SimpleExprParamMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprParamMarker(s)
	}
}

func (s *SimpleExprParamMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprParamMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprSumContext struct {
	SimpleExprContext
}

func NewSimpleExprSumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprSumContext {
	var p = new(SimpleExprSumContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprSumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprSumContext) SumExpr() ISumExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISumExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISumExprContext)
}

func (s *SimpleExprSumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprSum(s)
	}
}

func (s *SimpleExprSumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprSum(s)
	}
}

func (s *SimpleExprSumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprSum(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprConvertUsingContext struct {
	SimpleExprContext
}

func NewSimpleExprConvertUsingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConvertUsingContext {
	var p = new(SimpleExprConvertUsingContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConvertUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConvertUsingContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONVERT_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprConvertUsingContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SimpleExprConvertUsingContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprConvertUsing(s)
	}
}

func (s *SimpleExprConvertUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprConvertUsing(s)
	}
}

func (s *SimpleExprConvertUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprConvertUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprSubQueryContext struct {
	SimpleExprContext
}

func NewSimpleExprSubQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprSubQueryContext {
	var p = new(SimpleExprSubQueryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprSubQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprSubQueryContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SimpleExprSubQueryContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXISTS_SYMBOL, 0)
}

func (s *SimpleExprSubQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprSubQuery(s)
	}
}

func (s *SimpleExprSubQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprSubQuery(s)
	}
}

func (s *SimpleExprSubQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprSubQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprGroupingOperationContext struct {
	SimpleExprContext
}

func NewSimpleExprGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprGroupingOperationContext {
	var p = new(SimpleExprGroupingOperationContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprGroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprGroupingOperationContext) GroupingOperation() IGroupingOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingOperationContext)
}

func (s *SimpleExprGroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprGroupingOperation(s)
	}
}

func (s *SimpleExprGroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprGroupingOperation(s)
	}
}

func (s *SimpleExprGroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprNotContext struct {
	SimpleExprContext
}

func NewSimpleExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprNotContext {
	var p = new(SimpleExprNotContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprNotContext) Not2Rule() INot2RuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot2RuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot2RuleContext)
}

func (s *SimpleExprNotContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprNot(s)
	}
}

func (s *SimpleExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprNot(s)
	}
}

func (s *SimpleExprNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprValuesContext struct {
	SimpleExprContext
}

func NewSimpleExprValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprValuesContext {
	var p = new(SimpleExprValuesContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprValuesContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUES_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleExprValuesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprValues(s)
	}
}

func (s *SimpleExprValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprValues(s)
	}
}

func (s *SimpleExprValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprValues(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprDefaultContext struct {
	SimpleExprContext
}

func NewSimpleExprDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprDefaultContext {
	var p = new(SimpleExprDefaultContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprDefaultContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleExprDefaultContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprDefault(s)
	}
}

func (s *SimpleExprDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprDefault(s)
	}
}

func (s *SimpleExprDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprListContext struct {
	SimpleExprContext
}

func NewSimpleExprListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprListContext {
	var p = new(SimpleExprListContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprListContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SimpleExprListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprListContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *SimpleExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprList(s)
	}
}

func (s *SimpleExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprList(s)
	}
}

func (s *SimpleExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprIntervalContext struct {
	SimpleExprContext
}

func NewSimpleExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprIntervalContext {
	var p = new(SimpleExprIntervalContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprIntervalContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *SimpleExprIntervalContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprIntervalContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *SimpleExprIntervalContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUS_OPERATOR, 0)
}

func (s *SimpleExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprInterval(s)
	}
}

func (s *SimpleExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprInterval(s)
	}
}

func (s *SimpleExprIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCaseContext struct {
	SimpleExprContext
}

func NewSimpleExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCaseContext {
	var p = new(SimpleExprCaseContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCaseContext) CASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASE_SYMBOL, 0)
}

func (s *SimpleExprCaseContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *SimpleExprCaseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprCaseContext) AllWhenExpression() []IWhenExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			len++
		}
	}

	tst := make([]IWhenExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenExpressionContext); ok {
			tst[i] = t.(IWhenExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprCaseContext) WhenExpression(i int) IWhenExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *SimpleExprCaseContext) AllThenExpression() []IThenExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThenExpressionContext); ok {
			len++
		}
	}

	tst := make([]IThenExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThenExpressionContext); ok {
			tst[i] = t.(IThenExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprCaseContext) ThenExpression(i int) IThenExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThenExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThenExpressionContext)
}

func (s *SimpleExprCaseContext) ElseExpression() IElseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseExpressionContext)
}

func (s *SimpleExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprCase(s)
	}
}

func (s *SimpleExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprCase(s)
	}
}

func (s *SimpleExprCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprConcatContext struct {
	SimpleExprContext
}

func NewSimpleExprConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConcatContext {
	var p = new(SimpleExprConcatContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConcatContext) AllSimpleExpr() []ISimpleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExprContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExprContext); ok {
			tst[i] = t.(ISimpleExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprConcatContext) SimpleExpr(i int) ISimpleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprConcatContext) CONCAT_PIPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONCAT_PIPES_SYMBOL, 0)
}

func (s *SimpleExprConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprConcat(s)
	}
}

func (s *SimpleExprConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprConcat(s)
	}
}

func (s *SimpleExprConcatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprConcat(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprLiteralContext struct {
	SimpleExprContext
}

func NewSimpleExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprLiteralContext {
	var p = new(SimpleExprLiteralContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SimpleExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprLiteral(s)
	}
}

func (s *SimpleExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprLiteral(s)
	}
}

func (s *SimpleExprLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SimpleExpr() (localctx ISimpleExprContext) {
	return p.simpleExpr(0)
}

func (p *MySQLParser) simpleExpr(_p int) (localctx ISimpleExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimpleExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 688
	p.EnterRecursionRule(localctx, 688, MySQLParserRULE_simpleExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 719, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleExprVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5610)
			p.Variable()
		}
		p.SetState(5614)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5611)
				p.Equal()
			}
			{
				p.SetState(5612)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSimpleExprColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5616)
			p.ColumnRef()
		}
		p.SetState(5618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5617)
				p.JsonOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSimpleExprRuntimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5620)
			p.RuntimeFunctionCall()
		}

	case 4:
		localctx = NewSimpleExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5621)
			p.FunctionCall()
		}

	case 5:
		localctx = NewSimpleExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5622)
			p.Literal()
		}

	case 6:
		localctx = NewSimpleExprParamMarkerContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5623)
			p.Match(MySQLParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSimpleExprSumContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5624)
			p.SumExpr()
		}

	case 8:
		localctx = NewSimpleExprGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5625)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5626)
			p.GroupingOperation()
		}

	case 9:
		localctx = NewSimpleExprWindowingFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5627)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5628)
			p.WindowFunctionCall()
		}

	case 10:
		localctx = NewSimpleExprUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5629)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleExprUnaryContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-758)) & ^0x3f) == 0 && ((int64(1)<<(_la-758))&67) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleExprUnaryContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5630)
			p.simpleExpr(14)
		}

	case 11:
		localctx = NewSimpleExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5631)
			p.Not2Rule()
		}
		{
			p.SetState(5632)
			p.simpleExpr(13)
		}

	case 12:
		localctx = NewSimpleExprListContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5635)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserROW_SYMBOL {
			{
				p.SetState(5634)
				p.Match(MySQLParserROW_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5637)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5638)
			p.ExprList()
		}
		{
			p.SetState(5639)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewSimpleExprSubQueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(5642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEXISTS_SYMBOL {
			{
				p.SetState(5641)
				p.Match(MySQLParserEXISTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5644)
			p.Subquery()
		}

	case 14:
		localctx = NewSimpleExprOdbcContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5645)
			p.Match(MySQLParserOPEN_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5646)
			p.Identifier()
		}
		{
			p.SetState(5647)
			p.expr(0)
		}
		{
			p.SetState(5648)
			p.Match(MySQLParserCLOSE_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleExprMatchContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5650)
			p.Match(MySQLParserMATCH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5651)
			p.IdentListArg()
		}
		{
			p.SetState(5652)
			p.Match(MySQLParserAGAINST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5654)
			p.bitExpr(0)
		}
		p.SetState(5656)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIN_SYMBOL || _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(5655)
				p.FulltextOptions()
			}

		}
		{
			p.SetState(5658)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSimpleExprBinaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5660)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5661)
			p.simpleExpr(8)
		}

	case 17:
		localctx = NewSimpleExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5662)
			p.Match(MySQLParserCAST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5663)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5664)
			p.expr(0)
		}
		{
			p.SetState(5665)
			p.Match(MySQLParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5666)
			p.CastType()
		}
		p.SetState(5668)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5667)
				p.ArrayCast()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5670)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewSimpleExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5672)
			p.Match(MySQLParserCASE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5674)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5673)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(5679)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySQLParserWHEN_SYMBOL {
			{
				p.SetState(5676)
				p.WhenExpression()
			}
			{
				p.SetState(5677)
				p.ThenExpression()
			}

			p.SetState(5681)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(5684)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserELSE_SYMBOL {
			{
				p.SetState(5683)
				p.ElseExpression()
			}

		}
		{
			p.SetState(5686)
			p.Match(MySQLParserEND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewSimpleExprConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5688)
			p.Match(MySQLParserCONVERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5689)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5690)
			p.expr(0)
		}
		{
			p.SetState(5691)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5692)
			p.CastType()
		}
		{
			p.SetState(5693)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewSimpleExprConvertUsingContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5695)
			p.Match(MySQLParserCONVERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5696)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5697)
			p.expr(0)
		}
		{
			p.SetState(5698)
			p.Match(MySQLParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5699)
			p.CharsetName()
		}
		{
			p.SetState(5700)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewSimpleExprDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5702)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5703)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5704)
			p.SimpleIdentifier()
		}
		{
			p.SetState(5705)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewSimpleExprValuesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5707)
			p.Match(MySQLParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5708)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5709)
			p.SimpleIdentifier()
		}
		{
			p.SetState(5710)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewSimpleExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5712)
			p.Match(MySQLParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5713)
			p.expr(0)
		}
		{
			p.SetState(5714)
			p.Interval()
		}
		{
			p.SetState(5715)
			p.Match(MySQLParserPLUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5716)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 721, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5726)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimpleExprConcatContext(p, NewSimpleExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_simpleExpr)
				p.SetState(5720)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(5721)
					p.Match(MySQLParserCONCAT_PIPES_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5722)
					p.simpleExpr(16)
				}

			case 2:
				localctx = NewSimpleExprCollateContext(p, NewSimpleExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, MySQLParserRULE_simpleExpr)
				p.SetState(5723)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(5724)
					p.Match(MySQLParserCOLLATE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5725)
					p.TextOrIdentifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 721, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCastContext is an interface to support dynamic dispatch.
type IArrayCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_SYMBOL() antlr.TerminalNode

	// IsArrayCastContext differentiates from other interfaces.
	IsArrayCastContext()
}

type ArrayCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCastContext() *ArrayCastContext {
	var p = new(ArrayCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_arrayCast
	return p
}

func InitEmptyArrayCastContext(p *ArrayCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_arrayCast
}

func (*ArrayCastContext) IsArrayCastContext() {}

func NewArrayCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCastContext {
	var p = new(ArrayCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_arrayCast

	return p
}

func (s *ArrayCastContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCastContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserARRAY_SYMBOL, 0)
}

func (s *ArrayCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterArrayCast(s)
	}
}

func (s *ArrayCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitArrayCast(s)
	}
}

func (s *ArrayCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitArrayCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ArrayCast() (localctx IArrayCastContext) {
	localctx = NewArrayCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, MySQLParserRULE_arrayCast)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5731)

	if !(serverVersion >= 80017) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
		goto errorExit
	}
	{
		p.SetState(5732)
		p.Match(MySQLParserARRAY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_SEPARATOR_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	JSON_UNQUOTED_SEPARATOR_SYMBOL() antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) JSON_SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_SEPARATOR_SYMBOL, 0)
}

func (s *JsonOperatorContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JsonOperatorContext) JSON_UNQUOTED_SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_UNQUOTED_SEPARATOR_SYMBOL, 0)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, MySQLParserRULE_jsonOperator)
	p.SetState(5740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 722, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5734)

		if !(serverVersion >= 50708) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50708", ""))
			goto errorExit
		}
		{
			p.SetState(5735)
			p.Match(MySQLParserJSON_SEPARATOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5736)
			p.TextStringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5737)

		if !(serverVersion >= 50713) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50713", ""))
			goto errorExit
		}
		{
			p.SetState(5738)
			p.Match(MySQLParserJSON_UNQUOTED_SEPARATOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5739)
			p.TextStringLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISumExprContext is an interface to support dynamic dispatch.
type ISumExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	InSumExpr() IInSumExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	WindowingClause() IWindowingClauseContext
	BIT_AND_SYMBOL() antlr.TerminalNode
	BIT_OR_SYMBOL() antlr.TerminalNode
	BIT_XOR_SYMBOL() antlr.TerminalNode
	JsonFunction() IJsonFunctionContext
	MULT_OPERATOR() antlr.TerminalNode
	COUNT_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	MIN_SYMBOL() antlr.TerminalNode
	MAX_SYMBOL() antlr.TerminalNode
	STD_SYMBOL() antlr.TerminalNode
	VARIANCE_SYMBOL() antlr.TerminalNode
	STDDEV_SAMP_SYMBOL() antlr.TerminalNode
	VAR_SAMP_SYMBOL() antlr.TerminalNode
	SUM_SYMBOL() antlr.TerminalNode
	GROUP_CONCAT_SYMBOL() antlr.TerminalNode
	OrderClause() IOrderClauseContext
	SEPARATOR_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext

	// IsSumExprContext differentiates from other interfaces.
	IsSumExprContext()
}

type SumExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySumExprContext() *SumExprContext {
	var p = new(SumExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sumExpr
	return p
}

func InitEmptySumExprContext(p *SumExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sumExpr
}

func (*SumExprContext) IsSumExprContext() {}

func NewSumExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SumExprContext {
	var p = new(SumExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_sumExpr

	return p
}

func (s *SumExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SumExprContext) GetName() antlr.Token { return s.name }

func (s *SumExprContext) SetName(v antlr.Token) { s.name = v }

func (s *SumExprContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SumExprContext) InSumExpr() IInSumExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSumExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSumExprContext)
}

func (s *SumExprContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SumExprContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_SYMBOL, 0)
}

func (s *SumExprContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISTINCT_SYMBOL, 0)
}

func (s *SumExprContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *SumExprContext) BIT_AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_AND_SYMBOL, 0)
}

func (s *SumExprContext) BIT_OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_OR_SYMBOL, 0)
}

func (s *SumExprContext) BIT_XOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_XOR_SYMBOL, 0)
}

func (s *SumExprContext) JsonFunction() IJsonFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonFunctionContext)
}

func (s *SumExprContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *SumExprContext) COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOUNT_SYMBOL, 0)
}

func (s *SumExprContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *SumExprContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SumExprContext) MIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIN_SYMBOL, 0)
}

func (s *SumExprContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_SYMBOL, 0)
}

func (s *SumExprContext) STD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTD_SYMBOL, 0)
}

func (s *SumExprContext) VARIANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARIANCE_SYMBOL, 0)
}

func (s *SumExprContext) STDDEV_SAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTDDEV_SAMP_SYMBOL, 0)
}

func (s *SumExprContext) VAR_SAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVAR_SAMP_SYMBOL, 0)
}

func (s *SumExprContext) SUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUM_SYMBOL, 0)
}

func (s *SumExprContext) GROUP_CONCAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_CONCAT_SYMBOL, 0)
}

func (s *SumExprContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *SumExprContext) SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSEPARATOR_SYMBOL, 0)
}

func (s *SumExprContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SumExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SumExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SumExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSumExpr(s)
	}
}

func (s *SumExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSumExpr(s)
	}
}

func (s *SumExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSumExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SumExpr() (localctx ISumExprContext) {
	localctx = NewSumExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, MySQLParserRULE_sumExpr)
	var _la int

	p.SetState(5873)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5742)

			var _m = p.Match(MySQLParserAVG_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5743)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5745)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5744)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5747)
			p.InSumExpr()
		}
		{
			p.SetState(5748)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5751)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 724, p.GetParserRuleContext()) == 1 {
			p.SetState(5749)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5750)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5753)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SumExprContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&377957122048) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SumExprContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5754)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5755)
			p.InSumExpr()
		}
		{
			p.SetState(5756)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5759)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) == 1 {
			p.SetState(5757)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5758)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5761)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(5762)
			p.JsonFunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5763)

			var _m = p.Match(MySQLParserCOUNT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5764)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserALL_SYMBOL {
			{
				p.SetState(5765)
				p.Match(MySQLParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5768)
			p.Match(MySQLParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5769)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5772)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 727, p.GetParserRuleContext()) == 1 {
			p.SetState(5770)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5771)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5774)

			var _m = p.Match(MySQLParserCOUNT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5775)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5783)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 729, p.GetParserRuleContext()) {
		case 1:
			p.SetState(5777)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserALL_SYMBOL {
				{
					p.SetState(5776)
					p.Match(MySQLParserALL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5779)
				p.Match(MySQLParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5780)
				p.InSumExpr()
			}

		case 3:
			{
				p.SetState(5781)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5782)
				p.ExprList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(5785)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5788)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 730, p.GetParserRuleContext()) == 1 {
			p.SetState(5786)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5787)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5790)

			var _m = p.Match(MySQLParserMIN_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5791)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5793)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5792)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5795)
			p.InSumExpr()
		}
		{
			p.SetState(5796)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5799)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 732, p.GetParserRuleContext()) == 1 {
			p.SetState(5797)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5798)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5801)

			var _m = p.Match(MySQLParserMAX_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5802)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5804)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 733, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5803)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5806)
			p.InSumExpr()
		}
		{
			p.SetState(5807)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5810)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 734, p.GetParserRuleContext()) == 1 {
			p.SetState(5808)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5809)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5812)

			var _m = p.Match(MySQLParserSTD_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5813)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5814)
			p.InSumExpr()
		}
		{
			p.SetState(5815)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5818)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 735, p.GetParserRuleContext()) == 1 {
			p.SetState(5816)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5817)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5820)

			var _m = p.Match(MySQLParserVARIANCE_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5821)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5822)
			p.InSumExpr()
		}
		{
			p.SetState(5823)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5826)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 736, p.GetParserRuleContext()) == 1 {
			p.SetState(5824)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5825)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5828)

			var _m = p.Match(MySQLParserSTDDEV_SAMP_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5829)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5830)
			p.InSumExpr()
		}
		{
			p.SetState(5831)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5834)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 737, p.GetParserRuleContext()) == 1 {
			p.SetState(5832)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5833)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5836)

			var _m = p.Match(MySQLParserVAR_SAMP_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5837)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5838)
			p.InSumExpr()
		}
		{
			p.SetState(5839)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5842)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 738, p.GetParserRuleContext()) == 1 {
			p.SetState(5840)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5841)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5844)

			var _m = p.Match(MySQLParserSUM_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5845)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5847)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 739, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5846)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5849)
			p.InSumExpr()
		}
		{
			p.SetState(5850)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5853)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 740, p.GetParserRuleContext()) == 1 {
			p.SetState(5851)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5852)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5855)

			var _m = p.Match(MySQLParserGROUP_CONCAT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5856)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5857)
				p.Match(MySQLParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5860)
			p.ExprList()
		}
		p.SetState(5862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserORDER_SYMBOL {
			{
				p.SetState(5861)
				p.OrderClause()
			}

		}
		p.SetState(5866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserSEPARATOR_SYMBOL {
			{
				p.SetState(5864)
				p.Match(MySQLParserSEPARATOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5865)
				p.TextString()
			}

		}
		{
			p.SetState(5868)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5871)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 744, p.GetParserRuleContext()) == 1 {
			p.SetState(5869)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			{
				p.SetState(5870)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingOperationContext is an interface to support dynamic dispatch.
type IGroupingOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPING_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsGroupingOperationContext differentiates from other interfaces.
	IsGroupingOperationContext()
}

type GroupingOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingOperationContext() *GroupingOperationContext {
	var p = new(GroupingOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupingOperation
	return p
}

func InitEmptyGroupingOperationContext(p *GroupingOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupingOperation
}

func (*GroupingOperationContext) IsGroupingOperationContext() {}

func NewGroupingOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_groupingOperation

	return p
}

func (s *GroupingOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingOperationContext) GROUPING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUPING_SYMBOL, 0)
}

func (s *GroupingOperationContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *GroupingOperationContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GroupingOperationContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GroupingOperation() (localctx IGroupingOperationContext) {
	localctx = NewGroupingOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, MySQLParserRULE_groupingOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5875)
		p.Match(MySQLParserGROUPING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5876)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5877)
		p.ExprList()
	}
	{
		p.SetState(5878)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionCallContext is an interface to support dynamic dispatch.
type IWindowFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parentheses() IParenthesesContext
	WindowingClause() IWindowingClauseContext
	ROW_NUMBER_SYMBOL() antlr.TerminalNode
	RANK_SYMBOL() antlr.TerminalNode
	DENSE_RANK_SYMBOL() antlr.TerminalNode
	CUME_DIST_SYMBOL() antlr.TerminalNode
	PERCENT_RANK_SYMBOL() antlr.TerminalNode
	NTILE_SYMBOL() antlr.TerminalNode
	SimpleExprWithParentheses() ISimpleExprWithParenthesesContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	LEAD_SYMBOL() antlr.TerminalNode
	LAG_SYMBOL() antlr.TerminalNode
	LeadLagInfo() ILeadLagInfoContext
	NullTreatment() INullTreatmentContext
	ExprWithParentheses() IExprWithParenthesesContext
	FIRST_VALUE_SYMBOL() antlr.TerminalNode
	LAST_VALUE_SYMBOL() antlr.TerminalNode
	NTH_VALUE_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode
	SimpleExpr() ISimpleExprContext
	FROM_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode

	// IsWindowFunctionCallContext differentiates from other interfaces.
	IsWindowFunctionCallContext()
}

type WindowFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFunctionCallContext() *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFunctionCall
	return p
}

func InitEmptyWindowFunctionCallContext(p *WindowFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowFunctionCall
}

func (*WindowFunctionCallContext) IsWindowFunctionCallContext() {}

func NewWindowFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowFunctionCall

	return p
}

func (s *WindowFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionCallContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *WindowFunctionCallContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *WindowFunctionCallContext) ROW_NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_NUMBER_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) DENSE_RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDENSE_RANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) CUME_DIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCUME_DIST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) PERCENT_RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERCENT_RANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) NTILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNTILE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) SimpleExprWithParentheses() ISimpleExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprWithParenthesesContext)
}

func (s *WindowFunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LEAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAD_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAG_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LeadLagInfo() ILeadLagInfoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeadLagInfoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeadLagInfoContext)
}

func (s *WindowFunctionCallContext) NullTreatment() INullTreatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullTreatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *WindowFunctionCallContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *WindowFunctionCallContext) FIRST_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAST_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) NTH_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNTH_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *WindowFunctionCallContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowFunctionCall() (localctx IWindowFunctionCallContext) {
	localctx = NewWindowFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, MySQLParserRULE_windowFunctionCall)
	var _la int

	p.SetState(5922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCUME_DIST_SYMBOL, MySQLParserDENSE_RANK_SYMBOL, MySQLParserPERCENT_RANK_SYMBOL, MySQLParserRANK_SYMBOL, MySQLParserROW_NUMBER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5880)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-678)) & ^0x3f) == 0 && ((int64(1)<<(_la-678))&344067) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5881)
			p.Parentheses()
		}
		{
			p.SetState(5882)
			p.WindowingClause()
		}

	case MySQLParserNTILE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5884)
			p.Match(MySQLParserNTILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5885)
			p.SimpleExprWithParentheses()
		}
		{
			p.SetState(5886)
			p.WindowingClause()
		}

	case MySQLParserLAG_SYMBOL, MySQLParserLEAD_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5888)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLAG_SYMBOL || _la == MySQLParserLEAD_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5889)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5890)
			p.expr(0)
		}
		p.SetState(5892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(5891)
				p.LeadLagInfo()
			}

		}
		{
			p.SetState(5894)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserRESPECT_SYMBOL {
			{
				p.SetState(5895)
				p.NullTreatment()
			}

		}
		{
			p.SetState(5898)
			p.WindowingClause()
		}

	case MySQLParserFIRST_VALUE_SYMBOL, MySQLParserLAST_VALUE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5900)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserFIRST_VALUE_SYMBOL || _la == MySQLParserLAST_VALUE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5901)
			p.ExprWithParentheses()
		}
		p.SetState(5903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserRESPECT_SYMBOL {
			{
				p.SetState(5902)
				p.NullTreatment()
			}

		}
		{
			p.SetState(5905)
			p.WindowingClause()
		}

	case MySQLParserNTH_VALUE_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5907)
			p.Match(MySQLParserNTH_VALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5908)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5909)
			p.expr(0)
		}
		{
			p.SetState(5910)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5911)
			p.simpleExpr(0)
		}
		{
			p.SetState(5912)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL {
			{
				p.SetState(5913)
				p.Match(MySQLParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5914)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserFIRST_SYMBOL || _la == MySQLParserLAST_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(5918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserRESPECT_SYMBOL {
			{
				p.SetState(5917)
				p.NullTreatment()
			}

		}
		{
			p.SetState(5920)
			p.WindowingClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowingClauseContext is an interface to support dynamic dispatch.
type IWindowingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER_SYMBOL() antlr.TerminalNode
	WindowName() IWindowNameContext
	WindowSpec() IWindowSpecContext

	// IsWindowingClauseContext differentiates from other interfaces.
	IsWindowingClauseContext()
}

type WindowingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowingClauseContext() *WindowingClauseContext {
	var p = new(WindowingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowingClause
	return p
}

func InitEmptyWindowingClauseContext(p *WindowingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowingClause
}

func (*WindowingClauseContext) IsWindowingClauseContext() {}

func NewWindowingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowingClauseContext {
	var p = new(WindowingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowingClause

	return p
}

func (s *WindowingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowingClauseContext) OVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOVER_SYMBOL, 0)
}

func (s *WindowingClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowingClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowingClause(s)
	}
}

func (s *WindowingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowingClause(s)
	}
}

func (s *WindowingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowingClause() (localctx IWindowingClauseContext) {
	localctx = NewWindowingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, MySQLParserRULE_windowingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5924)
		p.Match(MySQLParserOVER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5925)
			p.WindowName()
		}

	case 2:
		{
			p.SetState(5926)
			p.WindowSpec()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeadLagInfoContext is an interface to support dynamic dispatch.
type ILeadLagInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	Expr() IExprContext

	// IsLeadLagInfoContext differentiates from other interfaces.
	IsLeadLagInfoContext()
}

type LeadLagInfoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeadLagInfoContext() *LeadLagInfoContext {
	var p = new(LeadLagInfoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_leadLagInfo
	return p
}

func InitEmptyLeadLagInfoContext(p *LeadLagInfoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_leadLagInfo
}

func (*LeadLagInfoContext) IsLeadLagInfoContext() {}

func NewLeadLagInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeadLagInfoContext {
	var p = new(LeadLagInfoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_leadLagInfo

	return p
}

func (s *LeadLagInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *LeadLagInfoContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *LeadLagInfoContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *LeadLagInfoContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *LeadLagInfoContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARAM_MARKER, 0)
}

func (s *LeadLagInfoContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LeadLagInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeadLagInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeadLagInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLeadLagInfo(s)
	}
}

func (s *LeadLagInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLeadLagInfo(s)
	}
}

func (s *LeadLagInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLeadLagInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LeadLagInfo() (localctx ILeadLagInfoContext) {
	localctx = NewLeadLagInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, MySQLParserRULE_leadLagInfo)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5929)
		p.Match(MySQLParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5932)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserDECIMAL_NUMBER, MySQLParserFLOAT_NUMBER:
		{
			p.SetState(5930)
			p.Ulonglong_number()
		}

	case MySQLParserPARAM_MARKER:
		{
			p.SetState(5931)
			p.Match(MySQLParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(5936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(5934)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5935)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nullTreatment
	return p
}

func InitEmptyNullTreatmentContext(p *NullTreatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nullTreatment
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULLS_SYMBOL, 0)
}

func (s *NullTreatmentContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESPECT_SYMBOL, 0)
}

func (s *NullTreatmentContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SYMBOL, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (s *NullTreatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNullTreatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, MySQLParserRULE_nullTreatment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5938)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserIGNORE_SYMBOL || _la == MySQLParserRESPECT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5939)
		p.Match(MySQLParserNULLS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonFunctionContext is an interface to support dynamic dispatch.
type IJsonFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_ARRAYAGG_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllInSumExpr() []IInSumExprContext
	InSumExpr(i int) IInSumExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	WindowingClause() IWindowingClauseContext
	JSON_OBJECTAGG_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsJsonFunctionContext differentiates from other interfaces.
	IsJsonFunctionContext()
}

type JsonFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonFunctionContext() *JsonFunctionContext {
	var p = new(JsonFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jsonFunction
	return p
}

func InitEmptyJsonFunctionContext(p *JsonFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_jsonFunction
}

func (*JsonFunctionContext) IsJsonFunctionContext() {}

func NewJsonFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonFunctionContext {
	var p = new(JsonFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_jsonFunction

	return p
}

func (s *JsonFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonFunctionContext) JSON_ARRAYAGG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_ARRAYAGG_SYMBOL, 0)
}

func (s *JsonFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *JsonFunctionContext) AllInSumExpr() []IInSumExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInSumExprContext); ok {
			len++
		}
	}

	tst := make([]IInSumExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInSumExprContext); ok {
			tst[i] = t.(IInSumExprContext)
			i++
		}
	}

	return tst
}

func (s *JsonFunctionContext) InSumExpr(i int) IInSumExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSumExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSumExprContext)
}

func (s *JsonFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *JsonFunctionContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *JsonFunctionContext) JSON_OBJECTAGG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_OBJECTAGG_SYMBOL, 0)
}

func (s *JsonFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *JsonFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterJsonFunction(s)
	}
}

func (s *JsonFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitJsonFunction(s)
	}
}

func (s *JsonFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitJsonFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) JsonFunction() (localctx IJsonFunctionContext) {
	localctx = NewJsonFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, MySQLParserRULE_jsonFunction)
	p.SetState(5957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserJSON_ARRAYAGG_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5941)
			p.Match(MySQLParserJSON_ARRAYAGG_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5942)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5943)
			p.InSumExpr()
		}
		{
			p.SetState(5944)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5946)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 755, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5945)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserJSON_OBJECTAGG_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5948)
			p.Match(MySQLParserJSON_OBJECTAGG_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5949)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5950)
			p.InSumExpr()
		}
		{
			p.SetState(5951)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5952)
			p.InSumExpr()
		}
		{
			p.SetState(5953)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5955)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 756, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5954)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInSumExprContext is an interface to support dynamic dispatch.
type IInSumExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ALL_SYMBOL() antlr.TerminalNode

	// IsInSumExprContext differentiates from other interfaces.
	IsInSumExprContext()
}

type InSumExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInSumExprContext() *InSumExprContext {
	var p = new(InSumExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_inSumExpr
	return p
}

func InitEmptyInSumExprContext(p *InSumExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_inSumExpr
}

func (*InSumExprContext) IsInSumExprContext() {}

func NewInSumExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InSumExprContext {
	var p = new(InSumExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_inSumExpr

	return p
}

func (s *InSumExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InSumExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InSumExprContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALL_SYMBOL, 0)
}

func (s *InSumExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSumExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InSumExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInSumExpr(s)
	}
}

func (s *InSumExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInSumExpr(s)
	}
}

func (s *InSumExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInSumExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InSumExpr() (localctx IInSumExprContext) {
	localctx = NewInSumExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, MySQLParserRULE_inSumExpr)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(5960)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 758, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5959)
			p.Match(MySQLParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5962)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListArgContext is an interface to support dynamic dispatch.
type IIdentListArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentList() IIdentListContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsIdentListArgContext differentiates from other interfaces.
	IsIdentListArgContext()
}

type IdentListArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListArgContext() *IdentListArgContext {
	var p = new(IdentListArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identListArg
	return p
}

func InitEmptyIdentListArgContext(p *IdentListArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identListArg
}

func (*IdentListArgContext) IsIdentListArgContext() {}

func NewIdentListArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListArgContext {
	var p = new(IdentListArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identListArg

	return p
}

func (s *IdentListArgContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListArgContext) IdentList() IIdentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListContext)
}

func (s *IdentListArgContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *IdentListArgContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IdentListArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentListArg(s)
	}
}

func (s *IdentListArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentListArg(s)
	}
}

func (s *IdentListArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentListArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentListArg() (localctx IIdentListArgContext) {
	localctx = NewIdentListArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, MySQLParserRULE_identListArg)
	p.SetState(5969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 759, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5964)
			p.IdentList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5965)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5966)
			p.IdentList()
		}
		{
			p.SetState(5967)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListContext is an interface to support dynamic dispatch.
type IIdentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIdentListContext differentiates from other interfaces.
	IsIdentListContext()
}

type IdentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListContext() *IdentListContext {
	var p = new(IdentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identList
	return p
}

func InitEmptyIdentListContext(p *IdentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identList
}

func (*IdentListContext) IsIdentListContext() {}

func NewIdentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListContext {
	var p = new(IdentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identList

	return p
}

func (s *IdentListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentListContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *IdentListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *IdentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentList(s)
	}
}

func (s *IdentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentList(s)
	}
}

func (s *IdentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentList() (localctx IIdentListContext) {
	localctx = NewIdentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, MySQLParserRULE_identList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5971)
		p.SimpleIdentifier()
	}
	p.SetState(5976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(5972)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5973)
			p.SimpleIdentifier()
		}

		p.SetState(5978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFulltextOptionsContext is an interface to support dynamic dispatch.
type IFulltextOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	NATURAL_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode

	// IsFulltextOptionsContext differentiates from other interfaces.
	IsFulltextOptionsContext()
}

type FulltextOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFulltextOptionsContext() *FulltextOptionsContext {
	var p = new(FulltextOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fulltextOptions
	return p
}

func InitEmptyFulltextOptionsContext(p *FulltextOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fulltextOptions
}

func (*FulltextOptionsContext) IsFulltextOptionsContext() {}

func NewFulltextOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FulltextOptionsContext {
	var p = new(FulltextOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fulltextOptions

	return p
}

func (s *FulltextOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FulltextOptionsContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *FulltextOptionsContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOLEAN_SYMBOL, 0)
}

func (s *FulltextOptionsContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODE_SYMBOL, 0)
}

func (s *FulltextOptionsContext) NATURAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATURAL_SYMBOL, 0)
}

func (s *FulltextOptionsContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLANGUAGE_SYMBOL, 0)
}

func (s *FulltextOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *FulltextOptionsContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *FulltextOptionsContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPANSION_SYMBOL, 0)
}

func (s *FulltextOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FulltextOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FulltextOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFulltextOptions(s)
	}
}

func (s *FulltextOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFulltextOptions(s)
	}
}

func (s *FulltextOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFulltextOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FulltextOptions() (localctx IFulltextOptionsContext) {
	localctx = NewFulltextOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, MySQLParserRULE_fulltextOptions)
	var _la int

	p.SetState(5994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 762, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5979)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5980)
			p.Match(MySQLParserBOOLEAN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5981)
			p.Match(MySQLParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5982)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5983)
			p.Match(MySQLParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5984)
			p.Match(MySQLParserLANGUAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5985)
			p.Match(MySQLParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserWITH_SYMBOL {
			{
				p.SetState(5986)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5987)
				p.Match(MySQLParserQUERY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5988)
				p.Match(MySQLParserEXPANSION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5991)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5992)
			p.Match(MySQLParserQUERY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5993)
			p.Match(MySQLParserEXPANSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuntimeFunctionCallContext is an interface to support dynamic dispatch.
type IRuntimeFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	USING_SYMBOL() antlr.TerminalNode
	CharsetName() ICharsetNameContext
	CURRENT_USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext
	ExprWithParentheses() IExprWithParenthesesContext
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TrimFunction() ITrimFunctionContext
	USER_SYMBOL() antlr.TerminalNode
	VALUES_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	Interval() IIntervalContext
	CURDATE_SYMBOL() antlr.TerminalNode
	CURTIME_SYMBOL() antlr.TerminalNode
	TimeFunctionParameters() ITimeFunctionParametersContext
	DATE_ADD_SYMBOL() antlr.TerminalNode
	DATE_SUB_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	EXTRACT_SYMBOL() antlr.TerminalNode
	DateTimeTtype() IDateTimeTtypeContext
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	NOW_SYMBOL() antlr.TerminalNode
	BitExpr() IBitExprContext
	IN_SYMBOL() antlr.TerminalNode
	POSITION_SYMBOL() antlr.TerminalNode
	SubstringFunction() ISubstringFunctionContext
	SYSDATE_SYMBOL() antlr.TerminalNode
	IntervalTimeStamp() IIntervalTimeStampContext
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	UTC_DATE_SYMBOL() antlr.TerminalNode
	UTC_TIME_SYMBOL() antlr.TerminalNode
	UTC_TIMESTAMP_SYMBOL() antlr.TerminalNode
	ASCII_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	ExprListWithParentheses() IExprListWithParenthesesContext
	COALESCE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	DATABASE_SYMBOL() antlr.TerminalNode
	IF_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MOD_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	REPEAT_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	WsNumCodepoints() IWsNumCodepointsContext
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	WeightStringLevels() IWeightStringLevelsContext
	GeometryFunction() IGeometryFunctionContext

	// IsRuntimeFunctionCallContext differentiates from other interfaces.
	IsRuntimeFunctionCallContext()
}

type RuntimeFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyRuntimeFunctionCallContext() *RuntimeFunctionCallContext {
	var p = new(RuntimeFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_runtimeFunctionCall
	return p
}

func InitEmptyRuntimeFunctionCallContext(p *RuntimeFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_runtimeFunctionCall
}

func (*RuntimeFunctionCallContext) IsRuntimeFunctionCallContext() {}

func NewRuntimeFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuntimeFunctionCallContext {
	var p = new(RuntimeFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_runtimeFunctionCall

	return p
}

func (s *RuntimeFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *RuntimeFunctionCallContext) GetName() antlr.Token { return s.name }

func (s *RuntimeFunctionCallContext) SetName(v antlr.Token) { s.name = v }

func (s *RuntimeFunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *RuntimeFunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *RuntimeFunctionCallContext) CURRENT_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_USER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *RuntimeFunctionCallContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *RuntimeFunctionCallContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *RuntimeFunctionCallContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RuntimeFunctionCallContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *RuntimeFunctionCallContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *RuntimeFunctionCallContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTERVAL_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEFT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMONTH_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRIGHT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECOND_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TrimFunction() ITrimFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimFunctionContext)
}

func (s *RuntimeFunctionCallContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUES_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADDDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RuntimeFunctionCallContext) CURDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CURTIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURTIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *RuntimeFunctionCallContext) DATE_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_ADD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DATE_SUB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SUB_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) EXTRACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTRACT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DateTimeTtype() IDateTimeTtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimeTtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimeTtypeContext)
}

func (s *RuntimeFunctionCallContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_FORMAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) NOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOW_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *RuntimeFunctionCallContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOSITION_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SubstringFunction() ISubstringFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubstringFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubstringFunctionContext)
}

func (s *RuntimeFunctionCallContext) SYSDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSYSDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) IntervalTimeStamp() IIntervalTimeStampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTimeStampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTimeStampContext)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUTC_DATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUTC_TIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUTC_TIMESTAMP_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASCII_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHARSET_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ExprListWithParentheses() IExprListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListWithParenthesesContext)
}

func (s *RuntimeFunctionCallContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOALESCE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATION_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATABASE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIF_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORMAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMICROSECOND_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMOD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *RuntimeFunctionCallContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUARTER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REPEAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPEAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREVERSE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_COUNT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUNCATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEEK_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WsNumCodepoints() IWsNumCodepointsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsNumCodepointsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsNumCodepointsContext)
}

func (s *RuntimeFunctionCallContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *RuntimeFunctionCallContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *RuntimeFunctionCallContext) WeightStringLevels() IWeightStringLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWeightStringLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWeightStringLevelsContext)
}

func (s *RuntimeFunctionCallContext) GeometryFunction() IGeometryFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeometryFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeometryFunctionContext)
}

func (s *RuntimeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuntimeFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuntimeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRuntimeFunctionCall(s)
	}
}

func (s *RuntimeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRuntimeFunctionCall(s)
	}
}

func (s *RuntimeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRuntimeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RuntimeFunctionCall() (localctx IRuntimeFunctionCallContext) {
	localctx = NewRuntimeFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, MySQLParserRULE_runtimeFunctionCall)
	var _la int

	p.SetState(6269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 780, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5996)

			var _m = p.Match(MySQLParserCHAR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5997)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5998)
			p.ExprList()
		}
		p.SetState(6001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserUSING_SYMBOL {
			{
				p.SetState(5999)
				p.Match(MySQLParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6000)
				p.CharsetName()
			}

		}
		{
			p.SetState(6003)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6005)

			var _m = p.Match(MySQLParserCURRENT_USER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6007)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 764, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6006)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6009)

			var _m = p.Match(MySQLParserDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6010)
			p.ExprWithParentheses()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6011)

			var _m = p.Match(MySQLParserDAY_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6012)
			p.ExprWithParentheses()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6013)

			var _m = p.Match(MySQLParserHOUR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6014)
			p.ExprWithParentheses()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6015)

			var _m = p.Match(MySQLParserINSERT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6016)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6017)
			p.expr(0)
		}
		{
			p.SetState(6018)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6019)
			p.expr(0)
		}
		{
			p.SetState(6020)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6021)
			p.expr(0)
		}
		{
			p.SetState(6022)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6023)
			p.expr(0)
		}
		{
			p.SetState(6024)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6026)

			var _m = p.Match(MySQLParserINTERVAL_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6027)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6028)
			p.expr(0)
		}
		p.SetState(6031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6029)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6030)
				p.expr(0)
			}

			p.SetState(6033)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6035)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6037)

			var _m = p.Match(MySQLParserLEFT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6038)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6039)
			p.expr(0)
		}
		{
			p.SetState(6040)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6041)
			p.expr(0)
		}
		{
			p.SetState(6042)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6044)

			var _m = p.Match(MySQLParserMINUTE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6045)
			p.ExprWithParentheses()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6046)

			var _m = p.Match(MySQLParserMONTH_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6047)
			p.ExprWithParentheses()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6048)

			var _m = p.Match(MySQLParserRIGHT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6049)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6050)
			p.expr(0)
		}
		{
			p.SetState(6051)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6052)
			p.expr(0)
		}
		{
			p.SetState(6053)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6055)

			var _m = p.Match(MySQLParserSECOND_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6056)
			p.ExprWithParentheses()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6057)

			var _m = p.Match(MySQLParserTIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6058)
			p.ExprWithParentheses()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6059)

			var _m = p.Match(MySQLParserTIMESTAMP_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6060)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6061)
			p.expr(0)
		}
		p.SetState(6064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6062)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6063)
				p.expr(0)
			}

		}
		{
			p.SetState(6066)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6068)
			p.TrimFunction()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6069)

			var _m = p.Match(MySQLParserUSER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6070)
			p.Parentheses()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6071)

			var _m = p.Match(MySQLParserVALUES_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6072)
			p.ExprWithParentheses()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6073)

			var _m = p.Match(MySQLParserYEAR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6074)
			p.ExprWithParentheses()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6075)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserADDDATE_SYMBOL || _la == MySQLParserSUBDATE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6076)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6077)
			p.expr(0)
		}
		{
			p.SetState(6078)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6084)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 767, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(6079)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(6080)
				p.Match(MySQLParserINTERVAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6081)
				p.expr(0)
			}
			{
				p.SetState(6082)
				p.Interval()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6086)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6088)

			var _m = p.Match(MySQLParserCURDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6090)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 768, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6089)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6092)

			var _m = p.Match(MySQLParserCURTIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6094)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 769, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6093)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6096)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDATE_ADD_SYMBOL || _la == MySQLParserDATE_SUB_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6097)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6098)
			p.expr(0)
		}
		{
			p.SetState(6099)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6100)
			p.Match(MySQLParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6101)
			p.expr(0)
		}
		{
			p.SetState(6102)
			p.Interval()
		}
		{
			p.SetState(6103)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6105)

			var _m = p.Match(MySQLParserEXTRACT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6106)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6107)
			p.Interval()
		}
		{
			p.SetState(6108)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6109)
			p.expr(0)
		}
		{
			p.SetState(6110)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6112)

			var _m = p.Match(MySQLParserGET_FORMAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6113)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6114)
			p.DateTimeTtype()
		}
		{
			p.SetState(6115)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6116)
			p.expr(0)
		}
		{
			p.SetState(6117)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6119)

			var _m = p.Match(MySQLParserNOW_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6121)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 770, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6120)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6123)

			var _m = p.Match(MySQLParserPOSITION_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6124)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6125)
			p.bitExpr(0)
		}
		{
			p.SetState(6126)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6127)
			p.expr(0)
		}
		{
			p.SetState(6128)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6130)
			p.SubstringFunction()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(6131)

			var _m = p.Match(MySQLParserSYSDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6133)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6132)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(6135)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserTIMESTAMP_ADD_SYMBOL || _la == MySQLParserTIMESTAMP_DIFF_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6136)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6137)
			p.IntervalTimeStamp()
		}
		{
			p.SetState(6138)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6139)
			p.expr(0)
		}
		{
			p.SetState(6140)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6141)
			p.expr(0)
		}
		{
			p.SetState(6142)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(6144)

			var _m = p.Match(MySQLParserUTC_DATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6146)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6145)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(6148)

			var _m = p.Match(MySQLParserUTC_TIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6150)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6149)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(6152)

			var _m = p.Match(MySQLParserUTC_TIMESTAMP_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6154)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6153)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(6156)

			var _m = p.Match(MySQLParserASCII_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6157)
			p.ExprWithParentheses()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(6158)

			var _m = p.Match(MySQLParserCHARSET_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6159)
			p.ExprWithParentheses()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(6160)

			var _m = p.Match(MySQLParserCOALESCE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6161)
			p.ExprListWithParentheses()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(6162)

			var _m = p.Match(MySQLParserCOLLATION_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6163)
			p.ExprWithParentheses()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(6164)

			var _m = p.Match(MySQLParserDATABASE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6165)
			p.Parentheses()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(6166)

			var _m = p.Match(MySQLParserIF_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6167)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6168)
			p.expr(0)
		}
		{
			p.SetState(6169)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6170)
			p.expr(0)
		}
		{
			p.SetState(6171)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6172)
			p.expr(0)
		}
		{
			p.SetState(6173)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(6175)

			var _m = p.Match(MySQLParserFORMAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6176)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6177)
			p.expr(0)
		}
		{
			p.SetState(6178)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6179)
			p.expr(0)
		}
		p.SetState(6182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6180)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6181)
				p.expr(0)
			}

		}
		{
			p.SetState(6184)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(6186)

			var _m = p.Match(MySQLParserMICROSECOND_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6187)
			p.ExprWithParentheses()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(6188)

			var _m = p.Match(MySQLParserMOD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6189)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6190)
			p.expr(0)
		}
		{
			p.SetState(6191)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6192)
			p.expr(0)
		}
		{
			p.SetState(6193)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		p.SetState(6195)

		if !(serverVersion < 50607) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50607", ""))
			goto errorExit
		}
		{
			p.SetState(6196)

			var _m = p.Match(MySQLParserOLD_PASSWORD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6197)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6198)
			p.TextLiteral()
		}
		{
			p.SetState(6199)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		p.SetState(6201)

		if !(serverVersion < 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
			goto errorExit
		}
		{
			p.SetState(6202)

			var _m = p.Match(MySQLParserPASSWORD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6203)
			p.ExprWithParentheses()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(6204)

			var _m = p.Match(MySQLParserQUARTER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6205)
			p.ExprWithParentheses()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(6206)

			var _m = p.Match(MySQLParserREPEAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6207)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6208)
			p.expr(0)
		}
		{
			p.SetState(6209)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6210)
			p.expr(0)
		}
		{
			p.SetState(6211)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(6213)

			var _m = p.Match(MySQLParserREPLACE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6214)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6215)
			p.expr(0)
		}
		{
			p.SetState(6216)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6217)
			p.expr(0)
		}
		{
			p.SetState(6218)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6219)
			p.expr(0)
		}
		{
			p.SetState(6220)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(6222)

			var _m = p.Match(MySQLParserREVERSE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6223)
			p.ExprWithParentheses()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(6224)

			var _m = p.Match(MySQLParserROW_COUNT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6225)
			p.Parentheses()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(6226)

			var _m = p.Match(MySQLParserTRUNCATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6227)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6228)
			p.expr(0)
		}
		{
			p.SetState(6229)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6230)
			p.expr(0)
		}
		{
			p.SetState(6231)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(6233)

			var _m = p.Match(MySQLParserWEEK_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6234)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6235)
			p.expr(0)
		}
		p.SetState(6238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6236)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6237)
				p.expr(0)
			}

		}
		{
			p.SetState(6240)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(6242)

			var _m = p.Match(MySQLParserWEIGHT_STRING_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6243)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6244)
			p.expr(0)
		}
		p.SetState(6264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 779, p.GetParserRuleContext()) {
		case 1:
			p.SetState(6248)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 777, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6245)
					p.Match(MySQLParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6246)
					p.Match(MySQLParserCHAR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6247)
					p.WsNumCodepoints()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(6252)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 778, p.GetParserRuleContext()) == 1 {
				p.SetState(6250)

				if !(serverVersion < 80000) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
					goto errorExit
				}
				{
					p.SetState(6251)
					p.WeightStringLevels()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 2:
			{
				p.SetState(6254)
				p.Match(MySQLParserAS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6255)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6256)
				p.WsNumCodepoints()
			}

		case 3:
			{
				p.SetState(6257)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6258)
				p.Ulong_number()
			}
			{
				p.SetState(6259)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6260)
				p.Ulong_number()
			}
			{
				p.SetState(6261)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6262)
				p.Ulong_number()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(6266)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(6268)
			p.GeometryFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeometryFunctionContext is an interface to support dynamic dispatch.
type IGeometryFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	ExprListWithParentheses() IExprListWithParenthesesContext
	LINESTRING_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode

	// IsGeometryFunctionContext differentiates from other interfaces.
	IsGeometryFunctionContext()
}

type GeometryFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyGeometryFunctionContext() *GeometryFunctionContext {
	var p = new(GeometryFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_geometryFunction
	return p
}

func InitEmptyGeometryFunctionContext(p *GeometryFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_geometryFunction
}

func (*GeometryFunctionContext) IsGeometryFunctionContext() {}

func NewGeometryFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeometryFunctionContext {
	var p = new(GeometryFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_geometryFunction

	return p
}

func (s *GeometryFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeometryFunctionContext) GetName() antlr.Token { return s.name }

func (s *GeometryFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *GeometryFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *GeometryFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *GeometryFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GeometryFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *GeometryFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *GeometryFunctionContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTAINS_SYMBOL, 0)
}

func (s *GeometryFunctionContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *GeometryFunctionContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GeometryFunctionContext) ExprListWithParentheses() IExprListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListWithParenthesesContext)
}

func (s *GeometryFunctionContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINESTRING_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTILINESTRING_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOINT_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *GeometryFunctionContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOINT_SYMBOL, 0)
}

func (s *GeometryFunctionContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOLYGON_SYMBOL, 0)
}

func (s *GeometryFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeometryFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeometryFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGeometryFunction(s)
	}
}

func (s *GeometryFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGeometryFunction(s)
	}
}

func (s *GeometryFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGeometryFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GeometryFunction() (localctx IGeometryFunctionContext) {
	localctx = NewGeometryFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, MySQLParserRULE_geometryFunction)
	p.SetState(6302)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 782, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6271)

		if !(serverVersion < 50706) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50706", ""))
			goto errorExit
		}
		{
			p.SetState(6272)

			var _m = p.Match(MySQLParserCONTAINS_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6273)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6274)
			p.expr(0)
		}
		{
			p.SetState(6275)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6276)
			p.expr(0)
		}
		{
			p.SetState(6277)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6279)

			var _m = p.Match(MySQLParserGEOMETRYCOLLECTION_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6280)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6282)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 781, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6281)
				p.ExprList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6284)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6285)

			var _m = p.Match(MySQLParserLINESTRING_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6286)
			p.ExprListWithParentheses()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6287)

			var _m = p.Match(MySQLParserMULTILINESTRING_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6288)
			p.ExprListWithParentheses()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6289)

			var _m = p.Match(MySQLParserMULTIPOINT_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6290)
			p.ExprListWithParentheses()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6291)

			var _m = p.Match(MySQLParserMULTIPOLYGON_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6292)
			p.ExprListWithParentheses()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6293)

			var _m = p.Match(MySQLParserPOINT_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6294)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6295)
			p.expr(0)
		}
		{
			p.SetState(6296)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6297)
			p.expr(0)
		}
		{
			p.SetState(6298)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6300)

			var _m = p.Match(MySQLParserPOLYGON_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6301)
			p.ExprListWithParentheses()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeFunctionParametersContext is an interface to support dynamic dispatch.
type ITimeFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FractionalPrecision() IFractionalPrecisionContext

	// IsTimeFunctionParametersContext differentiates from other interfaces.
	IsTimeFunctionParametersContext()
}

type TimeFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeFunctionParametersContext() *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_timeFunctionParameters
	return p
}

func InitEmptyTimeFunctionParametersContext(p *TimeFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_timeFunctionParameters
}

func (*TimeFunctionParametersContext) IsTimeFunctionParametersContext() {}

func NewTimeFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_timeFunctionParameters

	return p
}

func (s *TimeFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeFunctionParametersContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *TimeFunctionParametersContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TimeFunctionParametersContext) FractionalPrecision() IFractionalPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFractionalPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFractionalPrecisionContext)
}

func (s *TimeFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTimeFunctionParameters(s)
	}
}

func (s *TimeFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTimeFunctionParameters(s)
	}
}

func (s *TimeFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTimeFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TimeFunctionParameters() (localctx ITimeFunctionParametersContext) {
	localctx = NewTimeFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, MySQLParserRULE_timeFunctionParameters)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6304)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6306)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 783, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6305)
			p.FractionalPrecision()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6308)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFractionalPrecisionContext is an interface to support dynamic dispatch.
type IFractionalPrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode

	// IsFractionalPrecisionContext differentiates from other interfaces.
	IsFractionalPrecisionContext()
}

type FractionalPrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFractionalPrecisionContext() *FractionalPrecisionContext {
	var p = new(FractionalPrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fractionalPrecision
	return p
}

func InitEmptyFractionalPrecisionContext(p *FractionalPrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fractionalPrecision
}

func (*FractionalPrecisionContext) IsFractionalPrecisionContext() {}

func NewFractionalPrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FractionalPrecisionContext {
	var p = new(FractionalPrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fractionalPrecision

	return p
}

func (s *FractionalPrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *FractionalPrecisionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *FractionalPrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FractionalPrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FractionalPrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFractionalPrecision(s)
	}
}

func (s *FractionalPrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFractionalPrecision(s)
	}
}

func (s *FractionalPrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFractionalPrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FractionalPrecision() (localctx IFractionalPrecisionContext) {
	localctx = NewFractionalPrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, MySQLParserRULE_fractionalPrecision)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(6310)

	if !(serverVersion >= 50604) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50604", ""))
		goto errorExit
	}
	{
		p.SetState(6311)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWeightStringLevelsContext is an interface to support dynamic dispatch.
type IWeightStringLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEVEL_SYMBOL() antlr.TerminalNode
	AllReal_ulong_number() []IReal_ulong_numberContext
	Real_ulong_number(i int) IReal_ulong_numberContext
	MINUS_OPERATOR() antlr.TerminalNode
	AllWeightStringLevelListItem() []IWeightStringLevelListItemContext
	WeightStringLevelListItem(i int) IWeightStringLevelListItemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWeightStringLevelsContext differentiates from other interfaces.
	IsWeightStringLevelsContext()
}

type WeightStringLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWeightStringLevelsContext() *WeightStringLevelsContext {
	var p = new(WeightStringLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_weightStringLevels
	return p
}

func InitEmptyWeightStringLevelsContext(p *WeightStringLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_weightStringLevels
}

func (*WeightStringLevelsContext) IsWeightStringLevelsContext() {}

func NewWeightStringLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WeightStringLevelsContext {
	var p = new(WeightStringLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_weightStringLevels

	return p
}

func (s *WeightStringLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *WeightStringLevelsContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEVEL_SYMBOL, 0)
}

func (s *WeightStringLevelsContext) AllReal_ulong_number() []IReal_ulong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			len++
		}
	}

	tst := make([]IReal_ulong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReal_ulong_numberContext); ok {
			tst[i] = t.(IReal_ulong_numberContext)
			i++
		}
	}

	return tst
}

func (s *WeightStringLevelsContext) Real_ulong_number(i int) IReal_ulong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WeightStringLevelsContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUS_OPERATOR, 0)
}

func (s *WeightStringLevelsContext) AllWeightStringLevelListItem() []IWeightStringLevelListItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWeightStringLevelListItemContext); ok {
			len++
		}
	}

	tst := make([]IWeightStringLevelListItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWeightStringLevelListItemContext); ok {
			tst[i] = t.(IWeightStringLevelListItemContext)
			i++
		}
	}

	return tst
}

func (s *WeightStringLevelsContext) WeightStringLevelListItem(i int) IWeightStringLevelListItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWeightStringLevelListItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWeightStringLevelListItemContext)
}

func (s *WeightStringLevelsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *WeightStringLevelsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *WeightStringLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightStringLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WeightStringLevelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWeightStringLevels(s)
	}
}

func (s *WeightStringLevelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWeightStringLevels(s)
	}
}

func (s *WeightStringLevelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWeightStringLevels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WeightStringLevels() (localctx IWeightStringLevelsContext) {
	localctx = NewWeightStringLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, MySQLParserRULE_weightStringLevels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6313)
		p.Match(MySQLParserLEVEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 785, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6314)
			p.Real_ulong_number()
		}
		{
			p.SetState(6315)
			p.Match(MySQLParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6316)
			p.Real_ulong_number()
		}

	case 2:
		{
			p.SetState(6318)
			p.WeightStringLevelListItem()
		}
		p.SetState(6323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6319)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6320)
				p.WeightStringLevelListItem()
			}

			p.SetState(6325)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWeightStringLevelListItemContext is an interface to support dynamic dispatch.
type IWeightStringLevelListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Real_ulong_number() IReal_ulong_numberContext
	REVERSE_SYMBOL() antlr.TerminalNode
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsWeightStringLevelListItemContext differentiates from other interfaces.
	IsWeightStringLevelListItemContext()
}

type WeightStringLevelListItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWeightStringLevelListItemContext() *WeightStringLevelListItemContext {
	var p = new(WeightStringLevelListItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_weightStringLevelListItem
	return p
}

func InitEmptyWeightStringLevelListItemContext(p *WeightStringLevelListItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_weightStringLevelListItem
}

func (*WeightStringLevelListItemContext) IsWeightStringLevelListItemContext() {}

func NewWeightStringLevelListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WeightStringLevelListItemContext {
	var p = new(WeightStringLevelListItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_weightStringLevelListItem

	return p
}

func (s *WeightStringLevelListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WeightStringLevelListItemContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WeightStringLevelListItemContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREVERSE_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASC_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESC_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightStringLevelListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WeightStringLevelListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWeightStringLevelListItem(s)
	}
}

func (s *WeightStringLevelListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWeightStringLevelListItem(s)
	}
}

func (s *WeightStringLevelListItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWeightStringLevelListItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WeightStringLevelListItem() (localctx IWeightStringLevelListItemContext) {
	localctx = NewWeightStringLevelListItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, MySQLParserRULE_weightStringLevelListItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6328)
		p.Real_ulong_number()
	}
	p.SetState(6334)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySQLParserASC_SYMBOL, MySQLParserDESC_SYMBOL:
		{
			p.SetState(6329)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserREVERSE_SYMBOL {
			{
				p.SetState(6330)
				p.Match(MySQLParserREVERSE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case MySQLParserREVERSE_SYMBOL:
		{
			p.SetState(6333)
			p.Match(MySQLParserREVERSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCOMMA_SYMBOL, MySQLParserCLOSE_PAR_SYMBOL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateTimeTtypeContext is an interface to support dynamic dispatch.
type IDateTimeTtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode

	// IsDateTimeTtypeContext differentiates from other interfaces.
	IsDateTimeTtypeContext()
}

type DateTimeTtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeTtypeContext() *DateTimeTtypeContext {
	var p = new(DateTimeTtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dateTimeTtype
	return p
}

func InitEmptyDateTimeTtypeContext(p *DateTimeTtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dateTimeTtype
}

func (*DateTimeTtypeContext) IsDateTimeTtypeContext() {}

func NewDateTimeTtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeTtypeContext {
	var p = new(DateTimeTtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dateTimeTtype

	return p
}

func (s *DateTimeTtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeTtypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATETIME_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeTtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeTtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDateTimeTtype(s)
	}
}

func (s *DateTimeTtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDateTimeTtype(s)
	}
}

func (s *DateTimeTtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDateTimeTtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DateTimeTtype() (localctx IDateTimeTtypeContext) {
	localctx = NewDateTimeTtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, MySQLParserRULE_dateTimeTtype)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6336)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDATETIME_SYMBOL || _la == MySQLParserDATE_SYMBOL || _la == MySQLParserTIMESTAMP_SYMBOL || _la == MySQLParserTIME_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimFunctionContext is an interface to support dynamic dispatch.
type ITrimFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIM_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	LEADING_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	TRAILING_SYMBOL() antlr.TerminalNode
	BOTH_SYMBOL() antlr.TerminalNode

	// IsTrimFunctionContext differentiates from other interfaces.
	IsTrimFunctionContext()
}

type TrimFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimFunctionContext() *TrimFunctionContext {
	var p = new(TrimFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_trimFunction
	return p
}

func InitEmptyTrimFunctionContext(p *TrimFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_trimFunction
}

func (*TrimFunctionContext) IsTrimFunctionContext() {}

func NewTrimFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimFunctionContext {
	var p = new(TrimFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_trimFunction

	return p
}

func (s *TrimFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimFunctionContext) TRIM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIM_SYMBOL, 0)
}

func (s *TrimFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *TrimFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TrimFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TrimFunctionContext) LEADING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEADING_SYMBOL, 0)
}

func (s *TrimFunctionContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *TrimFunctionContext) TRAILING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRAILING_SYMBOL, 0)
}

func (s *TrimFunctionContext) BOTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOTH_SYMBOL, 0)
}

func (s *TrimFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTrimFunction(s)
	}
}

func (s *TrimFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTrimFunction(s)
	}
}

func (s *TrimFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTrimFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TrimFunction() (localctx ITrimFunctionContext) {
	localctx = NewTrimFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, MySQLParserRULE_trimFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6338)
		p.Match(MySQLParserTRIM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6339)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 792, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6340)
			p.expr(0)
		}
		p.SetState(6343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFROM_SYMBOL {
			{
				p.SetState(6341)
				p.Match(MySQLParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6342)
				p.expr(0)
			}

		}

	case 2:
		{
			p.SetState(6345)
			p.Match(MySQLParserLEADING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6347)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 789, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6346)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6349)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6350)
			p.expr(0)
		}

	case 3:
		{
			p.SetState(6351)
			p.Match(MySQLParserTRAILING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6353)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 790, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6352)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6355)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6356)
			p.expr(0)
		}

	case 4:
		{
			p.SetState(6357)
			p.Match(MySQLParserBOTH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6359)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 791, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6358)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6361)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6362)
			p.expr(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(6365)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubstringFunctionContext is an interface to support dynamic dispatch.
type ISubstringFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSTRING_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode

	// IsSubstringFunctionContext differentiates from other interfaces.
	IsSubstringFunctionContext()
}

type SubstringFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubstringFunctionContext() *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_substringFunction
	return p
}

func InitEmptySubstringFunctionContext(p *SubstringFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_substringFunction
}

func (*SubstringFunctionContext) IsSubstringFunctionContext() {}

func NewSubstringFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_substringFunction

	return p
}

func (s *SubstringFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubstringFunctionContext) SUBSTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBSTRING_SYMBOL, 0)
}

func (s *SubstringFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SubstringFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SubstringFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *SubstringFunctionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *SubstringFunctionContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *SubstringFunctionContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubstringFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSubstringFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SubstringFunction() (localctx ISubstringFunctionContext) {
	localctx = NewSubstringFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, MySQLParserRULE_substringFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6367)
		p.Match(MySQLParserSUBSTRING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6368)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6369)
		p.expr(0)
	}
	p.SetState(6382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCOMMA_SYMBOL:
		{
			p.SetState(6370)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6371)
			p.expr(0)
		}
		p.SetState(6374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6372)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6373)
				p.expr(0)
			}

		}

	case MySQLParserFROM_SYMBOL:
		{
			p.SetState(6376)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6377)
			p.expr(0)
		}
		p.SetState(6380)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserFOR_SYMBOL {
			{
				p.SetState(6378)
				p.Match(MySQLParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6379)
				p.expr(0)
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(6384)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	UdfExprList() IUdfExprListContext
	QualifiedIdentifier() IQualifiedIdentifierContext
	ExprList() IExprListContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *FunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *FunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FunctionCallContext) UdfExprList() IUdfExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUdfExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUdfExprListContext)
}

func (s *FunctionCallContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, MySQLParserRULE_functionCall)
	p.SetState(6400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 798, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6386)
			p.PureIdentifier()
		}
		{
			p.SetState(6387)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6389)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 796, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6388)
				p.UdfExprList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6391)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6393)
			p.QualifiedIdentifier()
		}
		{
			p.SetState(6394)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6396)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 797, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6395)
				p.ExprList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6398)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfExprListContext is an interface to support dynamic dispatch.
type IUdfExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUdfExpr() []IUdfExprContext
	UdfExpr(i int) IUdfExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUdfExprListContext differentiates from other interfaces.
	IsUdfExprListContext()
}

type UdfExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfExprListContext() *UdfExprListContext {
	var p = new(UdfExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfExprList
	return p
}

func InitEmptyUdfExprListContext(p *UdfExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfExprList
}

func (*UdfExprListContext) IsUdfExprListContext() {}

func NewUdfExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfExprListContext {
	var p = new(UdfExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_udfExprList

	return p
}

func (s *UdfExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfExprListContext) AllUdfExpr() []IUdfExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUdfExprContext); ok {
			len++
		}
	}

	tst := make([]IUdfExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUdfExprContext); ok {
			tst[i] = t.(IUdfExprContext)
			i++
		}
	}

	return tst
}

func (s *UdfExprListContext) UdfExpr(i int) IUdfExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUdfExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUdfExprContext)
}

func (s *UdfExprListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *UdfExprListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *UdfExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUdfExprList(s)
	}
}

func (s *UdfExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUdfExprList(s)
	}
}

func (s *UdfExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUdfExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UdfExprList() (localctx IUdfExprListContext) {
	localctx = NewUdfExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, MySQLParserRULE_udfExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6402)
		p.UdfExpr()
	}
	p.SetState(6407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(6403)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6404)
			p.UdfExpr()
		}

		p.SetState(6409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfExprContext is an interface to support dynamic dispatch.
type IUdfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	SelectAlias() ISelectAliasContext

	// IsUdfExprContext differentiates from other interfaces.
	IsUdfExprContext()
}

type UdfExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfExprContext() *UdfExprContext {
	var p = new(UdfExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfExpr
	return p
}

func InitEmptyUdfExprContext(p *UdfExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfExpr
}

func (*UdfExprContext) IsUdfExprContext() {}

func NewUdfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfExprContext {
	var p = new(UdfExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_udfExpr

	return p
}

func (s *UdfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UdfExprContext) SelectAlias() ISelectAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectAliasContext)
}

func (s *UdfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUdfExpr(s)
	}
}

func (s *UdfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUdfExpr(s)
	}
}

func (s *UdfExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUdfExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UdfExpr() (localctx IUdfExprContext) {
	localctx = NewUdfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, MySQLParserRULE_udfExpr)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6410)
		p.expr(0)
	}
	p.SetState(6412)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 800, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6411)
			p.SelectAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserVariable() IUserVariableContext
	SystemVariable() ISystemVariableContext

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *VariableContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, MySQLParserRULE_variable)
	p.SetState(6416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserAT_SIGN_SYMBOL, MySQLParserAT_TEXT_SUFFIX:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6414)
			p.UserVariable()
		}

	case MySQLParserAT_AT_SIGN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6415)
			p.SystemVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SIGN_SYMBOL, 0)
}

func (s *UserVariableContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *UserVariableContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_TEXT_SUFFIX, 0)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, MySQLParserRULE_userVariable)
	p.SetState(6421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserAT_SIGN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6418)
			p.Match(MySQLParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6419)
			p.TextOrIdentifier()
		}

	case MySQLParserAT_TEXT_SUFFIX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6420)
			p.Match(MySQLParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	VarIdentType() IVarIdentTypeContext
	DotIdentifier() IDotIdentifierContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AT_AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_AT_SIGN_SYMBOL, 0)
}

func (s *SystemVariableContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SystemVariableContext) VarIdentType() IVarIdentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarIdentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarIdentTypeContext)
}

func (s *SystemVariableContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, MySQLParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6423)
		p.Match(MySQLParserAT_AT_SIGN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6425)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 803, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6424)
			p.VarIdentType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6427)
		p.TextOrIdentifier()
	}
	p.SetState(6429)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 804, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6428)
			p.DotIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInternalVariableNameContext is an interface to support dynamic dispatch.
type IInternalVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LValueIdentifier() ILValueIdentifierContext
	DotIdentifier() IDotIdentifierContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsInternalVariableNameContext differentiates from other interfaces.
	IsInternalVariableNameContext()
}

type InternalVariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInternalVariableNameContext() *InternalVariableNameContext {
	var p = new(InternalVariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_internalVariableName
	return p
}

func InitEmptyInternalVariableNameContext(p *InternalVariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_internalVariableName
}

func (*InternalVariableNameContext) IsInternalVariableNameContext() {}

func NewInternalVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InternalVariableNameContext {
	var p = new(InternalVariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_internalVariableName

	return p
}

func (s *InternalVariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *InternalVariableNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InternalVariableNameContext) LValueIdentifier() ILValueIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILValueIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILValueIdentifierContext)
}

func (s *InternalVariableNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *InternalVariableNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *InternalVariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InternalVariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InternalVariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInternalVariableName(s)
	}
}

func (s *InternalVariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInternalVariableName(s)
	}
}

func (s *InternalVariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInternalVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InternalVariableName() (localctx IInternalVariableNameContext) {
	localctx = NewInternalVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, MySQLParserRULE_internalVariableName)
	var _la int

	p.SetState(6445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 808, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6441)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 807, p.GetParserRuleContext()) {
		case 1:
			p.SetState(6431)

			if !(serverVersion < 80017) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
				goto errorExit
			}
			{
				p.SetState(6432)
				p.Identifier()
			}
			p.SetState(6434)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserDOT_SYMBOL {
				{
					p.SetState(6433)
					p.DotIdentifier()
				}

			}

		case 2:
			p.SetState(6436)

			if !(serverVersion >= 80017) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
				goto errorExit
			}
			{
				p.SetState(6437)
				p.LValueIdentifier()
			}
			p.SetState(6439)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserDOT_SYMBOL {
				{
					p.SetState(6438)
					p.DotIdentifier()
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6443)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6444)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWHEN_SYMBOL, 0)
}

func (s *WhenExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, MySQLParserRULE_whenExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6447)
		p.Match(MySQLParserWHEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6448)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThenExpressionContext is an interface to support dynamic dispatch.
type IThenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THEN_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsThenExpressionContext differentiates from other interfaces.
	IsThenExpressionContext()
}

type ThenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThenExpressionContext() *ThenExpressionContext {
	var p = new(ThenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_thenExpression
	return p
}

func InitEmptyThenExpressionContext(p *ThenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_thenExpression
}

func (*ThenExpressionContext) IsThenExpressionContext() {}

func NewThenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThenExpressionContext {
	var p = new(ThenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_thenExpression

	return p
}

func (s *ThenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThenExpressionContext) THEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHEN_SYMBOL, 0)
}

func (s *ThenExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ThenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterThenExpression(s)
	}
}

func (s *ThenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitThenExpression(s)
	}
}

func (s *ThenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitThenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ThenExpression() (localctx IThenExpressionContext) {
	localctx = NewThenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, MySQLParserRULE_thenExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6450)
		p.Match(MySQLParserTHEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6451)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseExpressionContext is an interface to support dynamic dispatch.
type IElseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsElseExpressionContext differentiates from other interfaces.
	IsElseExpressionContext()
}

type ElseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseExpressionContext() *ElseExpressionContext {
	var p = new(ElseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_elseExpression
	return p
}

func InitEmptyElseExpressionContext(p *ElseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_elseExpression
}

func (*ElseExpressionContext) IsElseExpressionContext() {}

func NewElseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseExpressionContext {
	var p = new(ElseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_elseExpression

	return p
}

func (s *ElseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseExpressionContext) ELSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserELSE_SYMBOL, 0)
}

func (s *ElseExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ElseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterElseExpression(s)
	}
}

func (s *ElseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitElseExpression(s)
	}
}

func (s *ElseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitElseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ElseExpression() (localctx IElseExpressionContext) {
	localctx = NewElseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, MySQLParserRULE_elseExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6453)
		p.Match(MySQLParserELSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6454)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastTypeContext is an interface to support dynamic dispatch.
type ICastTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SYMBOL() antlr.TerminalNode
	FieldLength() IFieldLengthContext
	CHAR_SYMBOL() antlr.TerminalNode
	CharsetWithOptBinary() ICharsetWithOptBinaryContext
	Nchar() INcharContext
	SIGNED_SYMBOL() antlr.TerminalNode
	INT_SYMBOL() antlr.TerminalNode
	UNSIGNED_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TypeDatetimePrecision() ITypeDatetimePrecisionContext
	DATETIME_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	FloatOptions() IFloatOptionsContext
	JSON_SYMBOL() antlr.TerminalNode
	RealType() IRealTypeContext
	FLOAT_SYMBOL() antlr.TerminalNode
	StandardFloatOptions() IStandardFloatOptionsContext

	// IsCastTypeContext differentiates from other interfaces.
	IsCastTypeContext()
}

type CastTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastTypeContext() *CastTypeContext {
	var p = new(CastTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_castType
	return p
}

func InitEmptyCastTypeContext(p *CastTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_castType
}

func (*CastTypeContext) IsCastTypeContext() {}

func NewCastTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastTypeContext {
	var p = new(CastTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_castType

	return p
}

func (s *CastTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastTypeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *CastTypeContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *CastTypeContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAR_SYMBOL, 0)
}

func (s *CastTypeContext) CharsetWithOptBinary() ICharsetWithOptBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetWithOptBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetWithOptBinaryContext)
}

func (s *CastTypeContext) Nchar() INcharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INcharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INcharContext)
}

func (s *CastTypeContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIGNED_SYMBOL, 0)
}

func (s *CastTypeContext) INT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_SYMBOL, 0)
}

func (s *CastTypeContext) UNSIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNSIGNED_SYMBOL, 0)
}

func (s *CastTypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *CastTypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *CastTypeContext) TypeDatetimePrecision() ITypeDatetimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDatetimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDatetimePrecisionContext)
}

func (s *CastTypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATETIME_SYMBOL, 0)
}

func (s *CastTypeContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_SYMBOL, 0)
}

func (s *CastTypeContext) FloatOptions() IFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatOptionsContext)
}

func (s *CastTypeContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_SYMBOL, 0)
}

func (s *CastTypeContext) RealType() IRealTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealTypeContext)
}

func (s *CastTypeContext) FLOAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLOAT_SYMBOL, 0)
}

func (s *CastTypeContext) StandardFloatOptions() IStandardFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFloatOptionsContext)
}

func (s *CastTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCastType(s)
	}
}

func (s *CastTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCastType(s)
	}
}

func (s *CastTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCastType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CastType() (localctx ICastTypeContext) {
	localctx = NewCastTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, MySQLParserRULE_castType)
	p.SetState(6501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 819, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6456)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6458)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6457)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6460)
			p.Match(MySQLParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6462)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 810, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6461)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6465)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 811, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6464)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6467)
			p.Nchar()
		}
		p.SetState(6469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 812, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6468)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6471)
			p.Match(MySQLParserSIGNED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6473)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 813, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6472)
				p.Match(MySQLParserINT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6475)
			p.Match(MySQLParserUNSIGNED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6477)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6476)
				p.Match(MySQLParserINT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6479)
			p.Match(MySQLParserDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6480)
			p.Match(MySQLParserTIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6482)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6481)
				p.TypeDatetimePrecision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6484)
			p.Match(MySQLParserDATETIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6486)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 816, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6485)
				p.TypeDatetimePrecision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6488)
			p.Match(MySQLParserDECIMAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6490)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 817, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6489)
				p.FloatOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(6492)

		if !(serverVersion >= 50708) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50708", ""))
			goto errorExit
		}
		{
			p.SetState(6493)
			p.Match(MySQLParserJSON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		p.SetState(6494)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(6495)
			p.RealType()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		p.SetState(6496)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(6497)
			p.Match(MySQLParserFLOAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6499)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6498)
				p.StandardFloatOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ExprListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, MySQLParserRULE_exprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6503)
		p.expr(0)
	}
	p.SetState(6508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(6504)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6505)
			p.expr(0)
		}

		p.SetState(6510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charset
	return p
}

func InitEmptyCharsetContext(p *CharsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charset
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAR_SYMBOL, 0)
}

func (s *CharsetContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *CharsetContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHARSET_SYMBOL, 0)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCharset(s)
	}
}

func (s *CharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCharset(s)
	}
}

func (s *CharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Charset() (localctx ICharsetContext) {
	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, MySQLParserRULE_charset)
	p.SetState(6514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6511)
			p.Match(MySQLParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6512)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserCHARSET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6513)
			p.Match(MySQLParserCHARSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotRuleContext is an interface to support dynamic dispatch.
type INotRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT_SYMBOL() antlr.TerminalNode
	NOT2_SYMBOL() antlr.TerminalNode

	// IsNotRuleContext differentiates from other interfaces.
	IsNotRuleContext()
}

type NotRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotRuleContext() *NotRuleContext {
	var p = new(NotRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_notRule
	return p
}

func InitEmptyNotRuleContext(p *NotRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_notRule
}

func (*NotRuleContext) IsNotRuleContext() {}

func NewNotRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotRuleContext {
	var p = new(NotRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_notRule

	return p
}

func (s *NotRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *NotRuleContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *NotRuleContext) NOT2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT2_SYMBOL, 0)
}

func (s *NotRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNotRule(s)
	}
}

func (s *NotRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNotRule(s)
	}
}

func (s *NotRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNotRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NotRule() (localctx INotRuleContext) {
	localctx = NewNotRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, MySQLParserRULE_notRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6516)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserNOT_SYMBOL || _la == MySQLParserNOT2_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot2RuleContext is an interface to support dynamic dispatch.
type INot2RuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGICAL_NOT_OPERATOR() antlr.TerminalNode
	NOT2_SYMBOL() antlr.TerminalNode

	// IsNot2RuleContext differentiates from other interfaces.
	IsNot2RuleContext()
}

type Not2RuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot2RuleContext() *Not2RuleContext {
	var p = new(Not2RuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_not2Rule
	return p
}

func InitEmptyNot2RuleContext(p *Not2RuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_not2Rule
}

func (*Not2RuleContext) IsNot2RuleContext() {}

func NewNot2RuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not2RuleContext {
	var p = new(Not2RuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_not2Rule

	return p
}

func (s *Not2RuleContext) GetParser() antlr.Parser { return s.parser }

func (s *Not2RuleContext) LOGICAL_NOT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGICAL_NOT_OPERATOR, 0)
}

func (s *Not2RuleContext) NOT2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT2_SYMBOL, 0)
}

func (s *Not2RuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not2RuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not2RuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNot2Rule(s)
	}
}

func (s *Not2RuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNot2Rule(s)
	}
}

func (s *Not2RuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNot2Rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Not2Rule() (localctx INot2RuleContext) {
	localctx = NewNot2RuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, MySQLParserRULE_not2Rule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6518)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserNOT2_SYMBOL || _la == MySQLParserLOGICAL_NOT_OPERATOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTimeStamp() IIntervalTimeStampContext
	SECOND_MICROSECOND_SYMBOL() antlr.TerminalNode
	MINUTE_MICROSECOND_SYMBOL() antlr.TerminalNode
	MINUTE_SECOND_SYMBOL() antlr.TerminalNode
	HOUR_MICROSECOND_SYMBOL() antlr.TerminalNode
	HOUR_SECOND_SYMBOL() antlr.TerminalNode
	HOUR_MINUTE_SYMBOL() antlr.TerminalNode
	DAY_MICROSECOND_SYMBOL() antlr.TerminalNode
	DAY_SECOND_SYMBOL() antlr.TerminalNode
	DAY_MINUTE_SYMBOL() antlr.TerminalNode
	DAY_HOUR_SYMBOL() antlr.TerminalNode
	YEAR_MONTH_SYMBOL() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) IntervalTimeStamp() IIntervalTimeStampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTimeStampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTimeStampContext)
}

func (s *IntervalContext) SECOND_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECOND_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) MINUTE_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) MINUTE_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_MINUTE_SYMBOL, 0)
}

func (s *IntervalContext) DAY_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) DAY_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) DAY_MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_MINUTE_SYMBOL, 0)
}

func (s *IntervalContext) DAY_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_HOUR_SYMBOL, 0)
}

func (s *IntervalContext) YEAR_MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_MONTH_SYMBOL, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, MySQLParserRULE_interval)
	var _la int

	p.SetState(6522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserDAY_SYMBOL, MySQLParserHOUR_SYMBOL, MySQLParserMICROSECOND_SYMBOL, MySQLParserMINUTE_SYMBOL, MySQLParserMONTH_SYMBOL, MySQLParserQUARTER_SYMBOL, MySQLParserSECOND_SYMBOL, MySQLParserWEEK_SYMBOL, MySQLParserYEAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6520)
			p.IntervalTimeStamp()
		}

	case MySQLParserDAY_HOUR_SYMBOL, MySQLParserDAY_MICROSECOND_SYMBOL, MySQLParserDAY_MINUTE_SYMBOL, MySQLParserDAY_SECOND_SYMBOL, MySQLParserHOUR_MICROSECOND_SYMBOL, MySQLParserHOUR_MINUTE_SYMBOL, MySQLParserHOUR_SECOND_SYMBOL, MySQLParserMINUTE_MICROSECOND_SYMBOL, MySQLParserMINUTE_SECOND_SYMBOL, MySQLParserSECOND_MICROSECOND_SYMBOL, MySQLParserYEAR_MONTH_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6521)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-118)) & ^0x3f) == 0 && ((int64(1)<<(_la-118))&15) != 0) || ((int64((_la-226)) & ^0x3f) == 0 && ((int64(1)<<(_la-226))&7) != 0) || _la == MySQLParserMINUTE_MICROSECOND_SYMBOL || _la == MySQLParserMINUTE_SECOND_SYMBOL || _la == MySQLParserSECOND_MICROSECOND_SYMBOL || _la == MySQLParserYEAR_MONTH_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTimeStampContext is an interface to support dynamic dispatch.
type IIntervalTimeStampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MICROSECOND_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode

	// IsIntervalTimeStampContext differentiates from other interfaces.
	IsIntervalTimeStampContext()
}

type IntervalTimeStampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTimeStampContext() *IntervalTimeStampContext {
	var p = new(IntervalTimeStampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_intervalTimeStamp
	return p
}

func InitEmptyIntervalTimeStampContext(p *IntervalTimeStampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_intervalTimeStamp
}

func (*IntervalTimeStampContext) IsIntervalTimeStampContext() {}

func NewIntervalTimeStampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTimeStampContext {
	var p = new(IntervalTimeStampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_intervalTimeStamp

	return p
}

func (s *IntervalTimeStampContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTimeStampContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMICROSECOND_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECOND_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEEK_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMONTH_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUARTER_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTimeStampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTimeStampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIntervalTimeStamp(s)
	}
}

func (s *IntervalTimeStampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIntervalTimeStamp(s)
	}
}

func (s *IntervalTimeStampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIntervalTimeStamp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IntervalTimeStamp() (localctx IIntervalTimeStampContext) {
	localctx = NewIntervalTimeStampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, MySQLParserRULE_intervalTimeStamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6524)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDAY_SYMBOL || _la == MySQLParserHOUR_SYMBOL || ((int64((_la-337)) & ^0x3f) == 0 && ((int64(1)<<(_la-337))&8257) != 0) || _la == MySQLParserQUARTER_SYMBOL || _la == MySQLParserSECOND_SYMBOL || _la == MySQLParserWEEK_SYMBOL || _la == MySQLParserYEAR_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListWithParenthesesContext is an interface to support dynamic dispatch.
type IExprListWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsExprListWithParenthesesContext differentiates from other interfaces.
	IsExprListWithParenthesesContext()
}

type ExprListWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListWithParenthesesContext() *ExprListWithParenthesesContext {
	var p = new(ExprListWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprListWithParentheses
	return p
}

func InitEmptyExprListWithParenthesesContext(p *ExprListWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprListWithParentheses
}

func (*ExprListWithParenthesesContext) IsExprListWithParenthesesContext() {}

func NewExprListWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListWithParenthesesContext {
	var p = new(ExprListWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_exprListWithParentheses

	return p
}

func (s *ExprListWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ExprListWithParenthesesContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ExprListWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ExprListWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprListWithParentheses(s)
	}
}

func (s *ExprListWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprListWithParentheses(s)
	}
}

func (s *ExprListWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprListWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExprListWithParentheses() (localctx IExprListWithParenthesesContext) {
	localctx = NewExprListWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, MySQLParserRULE_exprListWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6526)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6527)
		p.ExprList()
	}
	{
		p.SetState(6528)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprWithParenthesesContext is an interface to support dynamic dispatch.
type IExprWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsExprWithParenthesesContext differentiates from other interfaces.
	IsExprWithParenthesesContext()
}

type ExprWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprWithParenthesesContext() *ExprWithParenthesesContext {
	var p = new(ExprWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprWithParentheses
	return p
}

func InitEmptyExprWithParenthesesContext(p *ExprWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_exprWithParentheses
}

func (*ExprWithParenthesesContext) IsExprWithParenthesesContext() {}

func NewExprWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprWithParenthesesContext {
	var p = new(ExprWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_exprWithParentheses

	return p
}

func (s *ExprWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ExprWithParenthesesContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ExprWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterExprWithParentheses(s)
	}
}

func (s *ExprWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitExprWithParentheses(s)
	}
}

func (s *ExprWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitExprWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ExprWithParentheses() (localctx IExprWithParenthesesContext) {
	localctx = NewExprWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, MySQLParserRULE_exprWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6530)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6531)
		p.expr(0)
	}
	{
		p.SetState(6532)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExprWithParenthesesContext is an interface to support dynamic dispatch.
type ISimpleExprWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	SimpleExpr() ISimpleExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsSimpleExprWithParenthesesContext differentiates from other interfaces.
	IsSimpleExprWithParenthesesContext()
}

type SimpleExprWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprWithParenthesesContext() *SimpleExprWithParenthesesContext {
	var p = new(SimpleExprWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleExprWithParentheses
	return p
}

func InitEmptySimpleExprWithParenthesesContext(p *SimpleExprWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleExprWithParentheses
}

func (*SimpleExprWithParenthesesContext) IsSimpleExprWithParenthesesContext() {}

func NewSimpleExprWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprWithParenthesesContext {
	var p = new(SimpleExprWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_simpleExprWithParentheses

	return p
}

func (s *SimpleExprWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprWithParenthesesContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExprWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleExprWithParentheses(s)
	}
}

func (s *SimpleExprWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleExprWithParentheses(s)
	}
}

func (s *SimpleExprWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleExprWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SimpleExprWithParentheses() (localctx ISimpleExprWithParenthesesContext) {
	localctx = NewSimpleExprWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, MySQLParserRULE_simpleExprWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6534)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6535)
		p.simpleExpr(0)
	}
	{
		p.SetState(6536)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderListContext is an interface to support dynamic dispatch.
type IOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrderExpression() []IOrderExpressionContext
	OrderExpression(i int) IOrderExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsOrderListContext differentiates from other interfaces.
	IsOrderListContext()
}

type OrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderListContext() *OrderListContext {
	var p = new(OrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderList
	return p
}

func InitEmptyOrderListContext(p *OrderListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderList
}

func (*OrderListContext) IsOrderListContext() {}

func NewOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderListContext {
	var p = new(OrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_orderList

	return p
}

func (s *OrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderListContext) AllOrderExpression() []IOrderExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderExpressionContext); ok {
			tst[i] = t.(IOrderExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderListContext) OrderExpression(i int) IOrderExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExpressionContext)
}

func (s *OrderListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *OrderListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *OrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOrderList(s)
	}
}

func (s *OrderListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOrderList(s)
	}
}

func (s *OrderListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOrderList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OrderList() (localctx IOrderListContext) {
	localctx = NewOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, MySQLParserRULE_orderList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6538)
		p.OrderExpression()
	}
	p.SetState(6543)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 823, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6539)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6540)
				p.OrderExpression()
			}

		}
		p.SetState(6545)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 823, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExpressionContext is an interface to support dynamic dispatch.
type IOrderExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Direction() IDirectionContext

	// IsOrderExpressionContext differentiates from other interfaces.
	IsOrderExpressionContext()
}

type OrderExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExpressionContext() *OrderExpressionContext {
	var p = new(OrderExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderExpression
	return p
}

func InitEmptyOrderExpressionContext(p *OrderExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_orderExpression
}

func (*OrderExpressionContext) IsOrderExpressionContext() {}

func NewOrderExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExpressionContext {
	var p = new(OrderExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_orderExpression

	return p
}

func (s *OrderExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OrderExpressionContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *OrderExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOrderExpression(s)
	}
}

func (s *OrderExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOrderExpression(s)
	}
}

func (s *OrderExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOrderExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OrderExpression() (localctx IOrderExpressionContext) {
	localctx = NewOrderExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, MySQLParserRULE_orderExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6546)
		p.expr(0)
	}
	p.SetState(6548)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 824, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6547)
			p.Direction()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupListContext is an interface to support dynamic dispatch.
type IGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupingExpression() []IGroupingExpressionContext
	GroupingExpression(i int) IGroupingExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsGroupListContext differentiates from other interfaces.
	IsGroupListContext()
}

type GroupListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupListContext() *GroupListContext {
	var p = new(GroupListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupList
	return p
}

func InitEmptyGroupListContext(p *GroupListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupList
}

func (*GroupListContext) IsGroupListContext() {}

func NewGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupListContext {
	var p = new(GroupListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_groupList

	return p
}

func (s *GroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupListContext) AllGroupingExpression() []IGroupingExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingExpressionContext); ok {
			len++
		}
	}

	tst := make([]IGroupingExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingExpressionContext); ok {
			tst[i] = t.(IGroupingExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupListContext) GroupingExpression(i int) IGroupingExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingExpressionContext)
}

func (s *GroupListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *GroupListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *GroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGroupList(s)
	}
}

func (s *GroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGroupList(s)
	}
}

func (s *GroupListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGroupList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GroupList() (localctx IGroupListContext) {
	localctx = NewGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, MySQLParserRULE_groupList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6550)
		p.GroupingExpression()
	}
	p.SetState(6555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(6551)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6552)
			p.GroupingExpression()
		}

		p.SetState(6557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingExpressionContext is an interface to support dynamic dispatch.
type IGroupingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsGroupingExpressionContext differentiates from other interfaces.
	IsGroupingExpressionContext()
}

type GroupingExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingExpressionContext() *GroupingExpressionContext {
	var p = new(GroupingExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupingExpression
	return p
}

func InitEmptyGroupingExpressionContext(p *GroupingExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_groupingExpression
}

func (*GroupingExpressionContext) IsGroupingExpressionContext() {}

func NewGroupingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingExpressionContext {
	var p = new(GroupingExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_groupingExpression

	return p
}

func (s *GroupingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GroupingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGroupingExpression(s)
	}
}

func (s *GroupingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGroupingExpression(s)
	}
}

func (s *GroupingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGroupingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GroupingExpression() (localctx IGroupingExpressionContext) {
	localctx = NewGroupingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, MySQLParserRULE_groupingExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6558)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelContext is an interface to support dynamic dispatch.
type IChannelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext

	// IsChannelContext differentiates from other interfaces.
	IsChannelContext()
}

type ChannelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelContext() *ChannelContext {
	var p = new(ChannelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_channel
	return p
}

func InitEmptyChannelContext(p *ChannelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_channel
}

func (*ChannelContext) IsChannelContext() {}

func NewChannelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelContext {
	var p = new(ChannelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_channel

	return p
}

func (s *ChannelContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *ChannelContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANNEL_SYMBOL, 0)
}

func (s *ChannelContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *ChannelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterChannel(s)
	}
}

func (s *ChannelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitChannel(s)
	}
}

func (s *ChannelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitChannel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Channel() (localctx IChannelContext) {
	localctx = NewChannelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, MySQLParserRULE_channel)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(6560)

	if !(serverVersion >= 50706) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
		goto errorExit
	}
	{
		p.SetState(6561)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6562)
		p.Match(MySQLParserCHANNEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6563)
		p.TextStringNoLinebreak()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleStatement() ISimpleStatementContext
	ReturnStatement() IReturnStatementContext
	IfStatement() IIfStatementContext
	CaseStatement() ICaseStatementContext
	LabeledBlock() ILabeledBlockContext
	UnlabeledBlock() IUnlabeledBlockContext
	LabeledControl() ILabeledControlContext
	UnlabeledControl() IUnlabeledControlContext
	LeaveStatement() ILeaveStatementContext
	IterateStatement() IIterateStatementContext
	CursorOpen() ICursorOpenContext
	CursorFetch() ICursorFetchContext
	CursorClose() ICursorCloseContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) SimpleStatement() ISimpleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) CaseStatement() ICaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseStatementContext)
}

func (s *CompoundStatementContext) LabeledBlock() ILabeledBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledBlockContext)
}

func (s *CompoundStatementContext) UnlabeledBlock() IUnlabeledBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabeledBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabeledBlockContext)
}

func (s *CompoundStatementContext) LabeledControl() ILabeledControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledControlContext)
}

func (s *CompoundStatementContext) UnlabeledControl() IUnlabeledControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabeledControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabeledControlContext)
}

func (s *CompoundStatementContext) LeaveStatement() ILeaveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeaveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeaveStatementContext)
}

func (s *CompoundStatementContext) IterateStatement() IIterateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterateStatementContext)
}

func (s *CompoundStatementContext) CursorOpen() ICursorOpenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorOpenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorOpenContext)
}

func (s *CompoundStatementContext) CursorFetch() ICursorFetchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorFetchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorFetchContext)
}

func (s *CompoundStatementContext) CursorClose() ICursorCloseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorCloseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorCloseContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, MySQLParserRULE_compoundStatement)
	p.SetState(6578)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 826, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6565)
			p.SimpleStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6566)
			p.ReturnStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6567)
			p.IfStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6568)
			p.CaseStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6569)
			p.LabeledBlock()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6570)
			p.UnlabeledBlock()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6571)
			p.LabeledControl()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6572)
			p.UnlabeledControl()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6573)
			p.LeaveStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6574)
			p.IterateStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6575)
			p.CursorOpen()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6576)
			p.CursorFetch()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6577)
			p.CursorClose()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURN_SYMBOL, 0)
}

func (s *ReturnStatementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, MySQLParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6580)
		p.Match(MySQLParserRETURN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6581)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIF_SYMBOL() []antlr.TerminalNode
	IF_SYMBOL(i int) antlr.TerminalNode
	IfBody() IIfBodyContext
	END_SYMBOL() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) AllIF_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserIF_SYMBOL)
}

func (s *IfStatementContext) IF_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserIF_SYMBOL, i)
}

func (s *IfStatementContext) IfBody() IIfBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfBodyContext)
}

func (s *IfStatementContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, MySQLParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6583)
		p.Match(MySQLParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6584)
		p.IfBody()
	}
	{
		p.SetState(6585)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6586)
		p.Match(MySQLParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfBodyContext is an interface to support dynamic dispatch.
type IIfBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ThenStatement() IThenStatementContext
	ELSEIF_SYMBOL() antlr.TerminalNode
	IfBody() IIfBodyContext
	ELSE_SYMBOL() antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext

	// IsIfBodyContext differentiates from other interfaces.
	IsIfBodyContext()
}

type IfBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfBodyContext() *IfBodyContext {
	var p = new(IfBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifBody
	return p
}

func InitEmptyIfBodyContext(p *IfBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifBody
}

func (*IfBodyContext) IsIfBodyContext() {}

func NewIfBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfBodyContext {
	var p = new(IfBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ifBody

	return p
}

func (s *IfBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *IfBodyContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *IfBodyContext) ThenStatement() IThenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThenStatementContext)
}

func (s *IfBodyContext) ELSEIF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserELSEIF_SYMBOL, 0)
}

func (s *IfBodyContext) IfBody() IIfBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfBodyContext)
}

func (s *IfBodyContext) ELSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserELSE_SYMBOL, 0)
}

func (s *IfBodyContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *IfBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIfBody(s)
	}
}

func (s *IfBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIfBody(s)
	}
}

func (s *IfBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIfBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IfBody() (localctx IIfBodyContext) {
	localctx = NewIfBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, MySQLParserRULE_ifBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6588)
		p.expr(0)
	}
	{
		p.SetState(6589)
		p.ThenStatement()
	}
	p.SetState(6594)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case MySQLParserELSEIF_SYMBOL:
		{
			p.SetState(6590)
			p.Match(MySQLParserELSEIF_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6591)
			p.IfBody()
		}

	case MySQLParserELSE_SYMBOL:
		{
			p.SetState(6592)
			p.Match(MySQLParserELSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6593)
			p.CompoundStatementList()
		}

	case MySQLParserEND_SYMBOL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThenStatementContext is an interface to support dynamic dispatch.
type IThenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THEN_SYMBOL() antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext

	// IsThenStatementContext differentiates from other interfaces.
	IsThenStatementContext()
}

type ThenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThenStatementContext() *ThenStatementContext {
	var p = new(ThenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_thenStatement
	return p
}

func InitEmptyThenStatementContext(p *ThenStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_thenStatement
}

func (*ThenStatementContext) IsThenStatementContext() {}

func NewThenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThenStatementContext {
	var p = new(ThenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_thenStatement

	return p
}

func (s *ThenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ThenStatementContext) THEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHEN_SYMBOL, 0)
}

func (s *ThenStatementContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *ThenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterThenStatement(s)
	}
}

func (s *ThenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitThenStatement(s)
	}
}

func (s *ThenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitThenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ThenStatement() (localctx IThenStatementContext) {
	localctx = NewThenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, MySQLParserRULE_thenStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6596)
		p.Match(MySQLParserTHEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6597)
		p.CompoundStatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementListContext is an interface to support dynamic dispatch.
type ICompoundStatementListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCompoundStatement() []ICompoundStatementContext
	CompoundStatement(i int) ICompoundStatementContext
	AllSEMICOLON_SYMBOL() []antlr.TerminalNode
	SEMICOLON_SYMBOL(i int) antlr.TerminalNode

	// IsCompoundStatementListContext differentiates from other interfaces.
	IsCompoundStatementListContext()
}

type CompoundStatementListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementListContext() *CompoundStatementListContext {
	var p = new(CompoundStatementListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compoundStatementList
	return p
}

func InitEmptyCompoundStatementListContext(p *CompoundStatementListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_compoundStatementList
}

func (*CompoundStatementListContext) IsCompoundStatementListContext() {}

func NewCompoundStatementListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementListContext {
	var p = new(CompoundStatementListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_compoundStatementList

	return p
}

func (s *CompoundStatementListContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementListContext) AllCompoundStatement() []ICompoundStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			len++
		}
	}

	tst := make([]ICompoundStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompoundStatementContext); ok {
			tst[i] = t.(ICompoundStatementContext)
			i++
		}
	}

	return tst
}

func (s *CompoundStatementListContext) CompoundStatement(i int) ICompoundStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *CompoundStatementListContext) AllSEMICOLON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserSEMICOLON_SYMBOL)
}

func (s *CompoundStatementListContext) SEMICOLON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserSEMICOLON_SYMBOL, i)
}

func (s *CompoundStatementListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCompoundStatementList(s)
	}
}

func (s *CompoundStatementListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCompoundStatementList(s)
	}
}

func (s *CompoundStatementListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCompoundStatementList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CompoundStatementList() (localctx ICompoundStatementListContext) {
	localctx = NewCompoundStatementListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, MySQLParserRULE_compoundStatementList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(6599)
				p.CompoundStatement()
			}
			{
				p.SetState(6600)
				p.Match(MySQLParserSEMICOLON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(6604)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 828, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseStatementContext is an interface to support dynamic dispatch.
type ICaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCASE_SYMBOL() []antlr.TerminalNode
	CASE_SYMBOL(i int) antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	AllWhenExpression() []IWhenExpressionContext
	WhenExpression(i int) IWhenExpressionContext
	AllThenStatement() []IThenStatementContext
	ThenStatement(i int) IThenStatementContext
	ElseStatement() IElseStatementContext

	// IsCaseStatementContext differentiates from other interfaces.
	IsCaseStatementContext()
}

type CaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseStatementContext() *CaseStatementContext {
	var p = new(CaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_caseStatement
	return p
}

func InitEmptyCaseStatementContext(p *CaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_caseStatement
}

func (*CaseStatementContext) IsCaseStatementContext() {}

func NewCaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseStatementContext {
	var p = new(CaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_caseStatement

	return p
}

func (s *CaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseStatementContext) AllCASE_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCASE_SYMBOL)
}

func (s *CaseStatementContext) CASE_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCASE_SYMBOL, i)
}

func (s *CaseStatementContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *CaseStatementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *CaseStatementContext) AllWhenExpression() []IWhenExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			len++
		}
	}

	tst := make([]IWhenExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenExpressionContext); ok {
			tst[i] = t.(IWhenExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) WhenExpression(i int) IWhenExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *CaseStatementContext) AllThenStatement() []IThenStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThenStatementContext); ok {
			len++
		}
	}

	tst := make([]IThenStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThenStatementContext); ok {
			tst[i] = t.(IThenStatementContext)
			i++
		}
	}

	return tst
}

func (s *CaseStatementContext) ThenStatement(i int) IThenStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThenStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThenStatementContext)
}

func (s *CaseStatementContext) ElseStatement() IElseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseStatementContext)
}

func (s *CaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCaseStatement(s)
	}
}

func (s *CaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCaseStatement(s)
	}
}

func (s *CaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CaseStatement() (localctx ICaseStatementContext) {
	localctx = NewCaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, MySQLParserRULE_caseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6606)
		p.Match(MySQLParserCASE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 829, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6607)
			p.expr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == MySQLParserWHEN_SYMBOL {
		{
			p.SetState(6610)
			p.WhenExpression()
		}
		{
			p.SetState(6611)
			p.ThenStatement()
		}

		p.SetState(6615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(6618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserELSE_SYMBOL {
		{
			p.SetState(6617)
			p.ElseStatement()
		}

	}
	{
		p.SetState(6620)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6621)
		p.Match(MySQLParserCASE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseStatementContext is an interface to support dynamic dispatch.
type IElseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE_SYMBOL() antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext

	// IsElseStatementContext differentiates from other interfaces.
	IsElseStatementContext()
}

type ElseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseStatementContext() *ElseStatementContext {
	var p = new(ElseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_elseStatement
	return p
}

func InitEmptyElseStatementContext(p *ElseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_elseStatement
}

func (*ElseStatementContext) IsElseStatementContext() {}

func NewElseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseStatementContext {
	var p = new(ElseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_elseStatement

	return p
}

func (s *ElseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseStatementContext) ELSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserELSE_SYMBOL, 0)
}

func (s *ElseStatementContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *ElseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterElseStatement(s)
	}
}

func (s *ElseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitElseStatement(s)
	}
}

func (s *ElseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitElseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ElseStatement() (localctx IElseStatementContext) {
	localctx = NewElseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, MySQLParserRULE_elseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6623)
		p.Match(MySQLParserELSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6624)
		p.CompoundStatementList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledBlockContext is an interface to support dynamic dispatch.
type ILabeledBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	BeginEndBlock() IBeginEndBlockContext
	LabelRef() ILabelRefContext

	// IsLabeledBlockContext differentiates from other interfaces.
	IsLabeledBlockContext()
}

type LabeledBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledBlockContext() *LabeledBlockContext {
	var p = new(LabeledBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labeledBlock
	return p
}

func InitEmptyLabeledBlockContext(p *LabeledBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labeledBlock
}

func (*LabeledBlockContext) IsLabeledBlockContext() {}

func NewLabeledBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledBlockContext {
	var p = new(LabeledBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_labeledBlock

	return p
}

func (s *LabeledBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledBlockContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabeledBlockContext) BeginEndBlock() IBeginEndBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginEndBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginEndBlockContext)
}

func (s *LabeledBlockContext) LabelRef() ILabelRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelRefContext)
}

func (s *LabeledBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabeledBlock(s)
	}
}

func (s *LabeledBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabeledBlock(s)
	}
}

func (s *LabeledBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabeledBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LabeledBlock() (localctx ILabeledBlockContext) {
	localctx = NewLabeledBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, MySQLParserRULE_labeledBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6626)
		p.Label()
	}
	{
		p.SetState(6627)
		p.BeginEndBlock()
	}
	p.SetState(6629)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 832, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6628)
			p.LabelRef()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabeledBlockContext is an interface to support dynamic dispatch.
type IUnlabeledBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BeginEndBlock() IBeginEndBlockContext

	// IsUnlabeledBlockContext differentiates from other interfaces.
	IsUnlabeledBlockContext()
}

type UnlabeledBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabeledBlockContext() *UnlabeledBlockContext {
	var p = new(UnlabeledBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unlabeledBlock
	return p
}

func InitEmptyUnlabeledBlockContext(p *UnlabeledBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unlabeledBlock
}

func (*UnlabeledBlockContext) IsUnlabeledBlockContext() {}

func NewUnlabeledBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabeledBlockContext {
	var p = new(UnlabeledBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_unlabeledBlock

	return p
}

func (s *UnlabeledBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabeledBlockContext) BeginEndBlock() IBeginEndBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginEndBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginEndBlockContext)
}

func (s *UnlabeledBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabeledBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabeledBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUnlabeledBlock(s)
	}
}

func (s *UnlabeledBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUnlabeledBlock(s)
	}
}

func (s *UnlabeledBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUnlabeledBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UnlabeledBlock() (localctx IUnlabeledBlockContext) {
	localctx = NewUnlabeledBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, MySQLParserRULE_unlabeledBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6631)
		p.BeginEndBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext
	COLON_SYMBOL() antlr.TerminalNode

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_label
	return p
}

func InitEmptyLabelContext(p *LabelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_label
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *LabelContext) COLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLON_SYMBOL, 0)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (s *LabelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Label() (localctx ILabelContext) {
	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, MySQLParserRULE_label)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6633)
		p.LabelIdentifier()
	}
	{
		p.SetState(6634)
		p.Match(MySQLParserCOLON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginEndBlockContext is an interface to support dynamic dispatch.
type IBeginEndBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN_SYMBOL() antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	SpDeclarations() ISpDeclarationsContext
	CompoundStatementList() ICompoundStatementListContext

	// IsBeginEndBlockContext differentiates from other interfaces.
	IsBeginEndBlockContext()
}

type BeginEndBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginEndBlockContext() *BeginEndBlockContext {
	var p = new(BeginEndBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_beginEndBlock
	return p
}

func InitEmptyBeginEndBlockContext(p *BeginEndBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_beginEndBlock
}

func (*BeginEndBlockContext) IsBeginEndBlockContext() {}

func NewBeginEndBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginEndBlockContext {
	var p = new(BeginEndBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_beginEndBlock

	return p
}

func (s *BeginEndBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginEndBlockContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEGIN_SYMBOL, 0)
}

func (s *BeginEndBlockContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *BeginEndBlockContext) SpDeclarations() ISpDeclarationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpDeclarationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpDeclarationsContext)
}

func (s *BeginEndBlockContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *BeginEndBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginEndBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginEndBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterBeginEndBlock(s)
	}
}

func (s *BeginEndBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitBeginEndBlock(s)
	}
}

func (s *BeginEndBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitBeginEndBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) BeginEndBlock() (localctx IBeginEndBlockContext) {
	localctx = NewBeginEndBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, MySQLParserRULE_beginEndBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6636)
		p.Match(MySQLParserBEGIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 833, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6637)
			p.SpDeclarations()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6641)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 834, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6640)
			p.CompoundStatementList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6643)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledControlContext is an interface to support dynamic dispatch.
type ILabeledControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Label() ILabelContext
	UnlabeledControl() IUnlabeledControlContext
	LabelRef() ILabelRefContext

	// IsLabeledControlContext differentiates from other interfaces.
	IsLabeledControlContext()
}

type LabeledControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledControlContext() *LabeledControlContext {
	var p = new(LabeledControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labeledControl
	return p
}

func InitEmptyLabeledControlContext(p *LabeledControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labeledControl
}

func (*LabeledControlContext) IsLabeledControlContext() {}

func NewLabeledControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledControlContext {
	var p = new(LabeledControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_labeledControl

	return p
}

func (s *LabeledControlContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledControlContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *LabeledControlContext) UnlabeledControl() IUnlabeledControlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnlabeledControlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnlabeledControlContext)
}

func (s *LabeledControlContext) LabelRef() ILabelRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelRefContext)
}

func (s *LabeledControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabeledControl(s)
	}
}

func (s *LabeledControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabeledControl(s)
	}
}

func (s *LabeledControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabeledControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LabeledControl() (localctx ILabeledControlContext) {
	localctx = NewLabeledControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, MySQLParserRULE_labeledControl)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6645)
		p.Label()
	}
	{
		p.SetState(6646)
		p.UnlabeledControl()
	}
	p.SetState(6648)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 835, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6647)
			p.LabelRef()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnlabeledControlContext is an interface to support dynamic dispatch.
type IUnlabeledControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LoopBlock() ILoopBlockContext
	WhileDoBlock() IWhileDoBlockContext
	RepeatUntilBlock() IRepeatUntilBlockContext

	// IsUnlabeledControlContext differentiates from other interfaces.
	IsUnlabeledControlContext()
}

type UnlabeledControlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnlabeledControlContext() *UnlabeledControlContext {
	var p = new(UnlabeledControlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unlabeledControl
	return p
}

func InitEmptyUnlabeledControlContext(p *UnlabeledControlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unlabeledControl
}

func (*UnlabeledControlContext) IsUnlabeledControlContext() {}

func NewUnlabeledControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnlabeledControlContext {
	var p = new(UnlabeledControlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_unlabeledControl

	return p
}

func (s *UnlabeledControlContext) GetParser() antlr.Parser { return s.parser }

func (s *UnlabeledControlContext) LoopBlock() ILoopBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoopBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoopBlockContext)
}

func (s *UnlabeledControlContext) WhileDoBlock() IWhileDoBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileDoBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileDoBlockContext)
}

func (s *UnlabeledControlContext) RepeatUntilBlock() IRepeatUntilBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepeatUntilBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepeatUntilBlockContext)
}

func (s *UnlabeledControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnlabeledControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnlabeledControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUnlabeledControl(s)
	}
}

func (s *UnlabeledControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUnlabeledControl(s)
	}
}

func (s *UnlabeledControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUnlabeledControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UnlabeledControl() (localctx IUnlabeledControlContext) {
	localctx = NewUnlabeledControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, MySQLParserRULE_unlabeledControl)
	p.SetState(6653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserLOOP_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6650)
			p.LoopBlock()
		}

	case MySQLParserWHILE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6651)
			p.WhileDoBlock()
		}

	case MySQLParserREPEAT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6652)
			p.RepeatUntilBlock()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoopBlockContext is an interface to support dynamic dispatch.
type ILoopBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLOOP_SYMBOL() []antlr.TerminalNode
	LOOP_SYMBOL(i int) antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext
	END_SYMBOL() antlr.TerminalNode

	// IsLoopBlockContext differentiates from other interfaces.
	IsLoopBlockContext()
}

type LoopBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoopBlockContext() *LoopBlockContext {
	var p = new(LoopBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loopBlock
	return p
}

func InitEmptyLoopBlockContext(p *LoopBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_loopBlock
}

func (*LoopBlockContext) IsLoopBlockContext() {}

func NewLoopBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoopBlockContext {
	var p = new(LoopBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_loopBlock

	return p
}

func (s *LoopBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *LoopBlockContext) AllLOOP_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserLOOP_SYMBOL)
}

func (s *LoopBlockContext) LOOP_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserLOOP_SYMBOL, i)
}

func (s *LoopBlockContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *LoopBlockContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *LoopBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoopBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoopBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLoopBlock(s)
	}
}

func (s *LoopBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLoopBlock(s)
	}
}

func (s *LoopBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLoopBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LoopBlock() (localctx ILoopBlockContext) {
	localctx = NewLoopBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, MySQLParserRULE_loopBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6655)
		p.Match(MySQLParserLOOP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6656)
		p.CompoundStatementList()
	}
	{
		p.SetState(6657)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6658)
		p.Match(MySQLParserLOOP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileDoBlockContext is an interface to support dynamic dispatch.
type IWhileDoBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllWHILE_SYMBOL() []antlr.TerminalNode
	WHILE_SYMBOL(i int) antlr.TerminalNode
	Expr() IExprContext
	DO_SYMBOL() antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext
	END_SYMBOL() antlr.TerminalNode

	// IsWhileDoBlockContext differentiates from other interfaces.
	IsWhileDoBlockContext()
}

type WhileDoBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileDoBlockContext() *WhileDoBlockContext {
	var p = new(WhileDoBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whileDoBlock
	return p
}

func InitEmptyWhileDoBlockContext(p *WhileDoBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_whileDoBlock
}

func (*WhileDoBlockContext) IsWhileDoBlockContext() {}

func NewWhileDoBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileDoBlockContext {
	var p = new(WhileDoBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_whileDoBlock

	return p
}

func (s *WhileDoBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileDoBlockContext) AllWHILE_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserWHILE_SYMBOL)
}

func (s *WhileDoBlockContext) WHILE_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserWHILE_SYMBOL, i)
}

func (s *WhileDoBlockContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhileDoBlockContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *WhileDoBlockContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *WhileDoBlockContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *WhileDoBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileDoBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileDoBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWhileDoBlock(s)
	}
}

func (s *WhileDoBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWhileDoBlock(s)
	}
}

func (s *WhileDoBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWhileDoBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WhileDoBlock() (localctx IWhileDoBlockContext) {
	localctx = NewWhileDoBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, MySQLParserRULE_whileDoBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6660)
		p.Match(MySQLParserWHILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6661)
		p.expr(0)
	}
	{
		p.SetState(6662)
		p.Match(MySQLParserDO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6663)
		p.CompoundStatementList()
	}
	{
		p.SetState(6664)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6665)
		p.Match(MySQLParserWHILE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepeatUntilBlockContext is an interface to support dynamic dispatch.
type IRepeatUntilBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllREPEAT_SYMBOL() []antlr.TerminalNode
	REPEAT_SYMBOL(i int) antlr.TerminalNode
	CompoundStatementList() ICompoundStatementListContext
	UNTIL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	END_SYMBOL() antlr.TerminalNode

	// IsRepeatUntilBlockContext differentiates from other interfaces.
	IsRepeatUntilBlockContext()
}

type RepeatUntilBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepeatUntilBlockContext() *RepeatUntilBlockContext {
	var p = new(RepeatUntilBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_repeatUntilBlock
	return p
}

func InitEmptyRepeatUntilBlockContext(p *RepeatUntilBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_repeatUntilBlock
}

func (*RepeatUntilBlockContext) IsRepeatUntilBlockContext() {}

func NewRepeatUntilBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepeatUntilBlockContext {
	var p = new(RepeatUntilBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_repeatUntilBlock

	return p
}

func (s *RepeatUntilBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *RepeatUntilBlockContext) AllREPEAT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserREPEAT_SYMBOL)
}

func (s *RepeatUntilBlockContext) REPEAT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserREPEAT_SYMBOL, i)
}

func (s *RepeatUntilBlockContext) CompoundStatementList() ICompoundStatementListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementListContext)
}

func (s *RepeatUntilBlockContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNTIL_SYMBOL, 0)
}

func (s *RepeatUntilBlockContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RepeatUntilBlockContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *RepeatUntilBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepeatUntilBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepeatUntilBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRepeatUntilBlock(s)
	}
}

func (s *RepeatUntilBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRepeatUntilBlock(s)
	}
}

func (s *RepeatUntilBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRepeatUntilBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RepeatUntilBlock() (localctx IRepeatUntilBlockContext) {
	localctx = NewRepeatUntilBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, MySQLParserRULE_repeatUntilBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6667)
		p.Match(MySQLParserREPEAT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6668)
		p.CompoundStatementList()
	}
	{
		p.SetState(6669)
		p.Match(MySQLParserUNTIL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6670)
		p.expr(0)
	}
	{
		p.SetState(6671)
		p.Match(MySQLParserEND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6672)
		p.Match(MySQLParserREPEAT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpDeclarationsContext is an interface to support dynamic dispatch.
type ISpDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSpDeclaration() []ISpDeclarationContext
	SpDeclaration(i int) ISpDeclarationContext
	AllSEMICOLON_SYMBOL() []antlr.TerminalNode
	SEMICOLON_SYMBOL(i int) antlr.TerminalNode

	// IsSpDeclarationsContext differentiates from other interfaces.
	IsSpDeclarationsContext()
}

type SpDeclarationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpDeclarationsContext() *SpDeclarationsContext {
	var p = new(SpDeclarationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spDeclarations
	return p
}

func InitEmptySpDeclarationsContext(p *SpDeclarationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spDeclarations
}

func (*SpDeclarationsContext) IsSpDeclarationsContext() {}

func NewSpDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpDeclarationsContext {
	var p = new(SpDeclarationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_spDeclarations

	return p
}

func (s *SpDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *SpDeclarationsContext) AllSpDeclaration() []ISpDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ISpDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpDeclarationContext); ok {
			tst[i] = t.(ISpDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SpDeclarationsContext) SpDeclaration(i int) ISpDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpDeclarationContext)
}

func (s *SpDeclarationsContext) AllSEMICOLON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserSEMICOLON_SYMBOL)
}

func (s *SpDeclarationsContext) SEMICOLON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserSEMICOLON_SYMBOL, i)
}

func (s *SpDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSpDeclarations(s)
	}
}

func (s *SpDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSpDeclarations(s)
	}
}

func (s *SpDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSpDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SpDeclarations() (localctx ISpDeclarationsContext) {
	localctx = NewSpDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, MySQLParserRULE_spDeclarations)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6677)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(6674)
				p.SpDeclaration()
			}
			{
				p.SetState(6675)
				p.Match(MySQLParserSEMICOLON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(6679)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpDeclarationContext is an interface to support dynamic dispatch.
type ISpDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext
	ConditionDeclaration() IConditionDeclarationContext
	HandlerDeclaration() IHandlerDeclarationContext
	CursorDeclaration() ICursorDeclarationContext

	// IsSpDeclarationContext differentiates from other interfaces.
	IsSpDeclarationContext()
}

type SpDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpDeclarationContext() *SpDeclarationContext {
	var p = new(SpDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spDeclaration
	return p
}

func InitEmptySpDeclarationContext(p *SpDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spDeclaration
}

func (*SpDeclarationContext) IsSpDeclarationContext() {}

func NewSpDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpDeclarationContext {
	var p = new(SpDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_spDeclaration

	return p
}

func (s *SpDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SpDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *SpDeclarationContext) ConditionDeclaration() IConditionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionDeclarationContext)
}

func (s *SpDeclarationContext) HandlerDeclaration() IHandlerDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerDeclarationContext)
}

func (s *SpDeclarationContext) CursorDeclaration() ICursorDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICursorDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICursorDeclarationContext)
}

func (s *SpDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSpDeclaration(s)
	}
}

func (s *SpDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSpDeclaration(s)
	}
}

func (s *SpDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSpDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SpDeclaration() (localctx ISpDeclarationContext) {
	localctx = NewSpDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, MySQLParserRULE_spDeclaration)
	p.SetState(6685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6681)
			p.VariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6682)
			p.ConditionDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6683)
			p.HandlerDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6684)
			p.CursorDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DataType() IDataTypeContext
	Collate() ICollateContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) DECLARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECLARE_SYMBOL, 0)
}

func (s *VariableDeclarationContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *VariableDeclarationContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *VariableDeclarationContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *VariableDeclarationContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *VariableDeclarationContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, MySQLParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6687)
		p.Match(MySQLParserDECLARE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6688)
		p.IdentifierList()
	}
	{
		p.SetState(6689)
		p.DataType()
	}
	p.SetState(6691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserCOLLATE_SYMBOL {
		{
			p.SetState(6690)
			p.Collate()
		}

	}
	p.SetState(6695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFAULT_SYMBOL {
		{
			p.SetState(6693)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6694)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionDeclarationContext is an interface to support dynamic dispatch.
type IConditionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	CONDITION_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	SpCondition() ISpConditionContext

	// IsConditionDeclarationContext differentiates from other interfaces.
	IsConditionDeclarationContext()
}

type ConditionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionDeclarationContext() *ConditionDeclarationContext {
	var p = new(ConditionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_conditionDeclaration
	return p
}

func InitEmptyConditionDeclarationContext(p *ConditionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_conditionDeclaration
}

func (*ConditionDeclarationContext) IsConditionDeclarationContext() {}

func NewConditionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionDeclarationContext {
	var p = new(ConditionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_conditionDeclaration

	return p
}

func (s *ConditionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionDeclarationContext) DECLARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECLARE_SYMBOL, 0)
}

func (s *ConditionDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConditionDeclarationContext) CONDITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONDITION_SYMBOL, 0)
}

func (s *ConditionDeclarationContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *ConditionDeclarationContext) SpCondition() ISpConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpConditionContext)
}

func (s *ConditionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConditionDeclaration(s)
	}
}

func (s *ConditionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConditionDeclaration(s)
	}
}

func (s *ConditionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConditionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConditionDeclaration() (localctx IConditionDeclarationContext) {
	localctx = NewConditionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, MySQLParserRULE_conditionDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6697)
		p.Match(MySQLParserDECLARE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6698)
		p.Identifier()
	}
	{
		p.SetState(6699)
		p.Match(MySQLParserCONDITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6700)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6701)
		p.SpCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpConditionContext is an interface to support dynamic dispatch.
type ISpConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ulong_number() IUlong_numberContext
	Sqlstate() ISqlstateContext

	// IsSpConditionContext differentiates from other interfaces.
	IsSpConditionContext()
}

type SpConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpConditionContext() *SpConditionContext {
	var p = new(SpConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spCondition
	return p
}

func InitEmptySpConditionContext(p *SpConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spCondition
}

func (*SpConditionContext) IsSpConditionContext() {}

func NewSpConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpConditionContext {
	var p = new(SpConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_spCondition

	return p
}

func (s *SpConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpConditionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *SpConditionContext) Sqlstate() ISqlstateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlstateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlstateContext)
}

func (s *SpConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSpCondition(s)
	}
}

func (s *SpConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSpCondition(s)
	}
}

func (s *SpConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSpCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SpCondition() (localctx ISpConditionContext) {
	localctx = NewSpConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, MySQLParserRULE_spCondition)
	p.SetState(6705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserHEX_NUMBER, MySQLParserDECIMAL_NUMBER, MySQLParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6703)
			p.Ulong_number()
		}

	case MySQLParserSQLSTATE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6704)
			p.Sqlstate()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISqlstateContext is an interface to support dynamic dispatch.
type ISqlstateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SQLSTATE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	VALUE_SYMBOL() antlr.TerminalNode

	// IsSqlstateContext differentiates from other interfaces.
	IsSqlstateContext()
}

type SqlstateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlstateContext() *SqlstateContext {
	var p = new(SqlstateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sqlstate
	return p
}

func InitEmptySqlstateContext(p *SqlstateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sqlstate
}

func (*SqlstateContext) IsSqlstateContext() {}

func NewSqlstateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlstateContext {
	var p = new(SqlstateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_sqlstate

	return p
}

func (s *SqlstateContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlstateContext) SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQLSTATE_SYMBOL, 0)
}

func (s *SqlstateContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *SqlstateContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUE_SYMBOL, 0)
}

func (s *SqlstateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlstateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlstateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSqlstate(s)
	}
}

func (s *SqlstateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSqlstate(s)
	}
}

func (s *SqlstateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSqlstate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Sqlstate() (localctx ISqlstateContext) {
	localctx = NewSqlstateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, MySQLParserRULE_sqlstate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6707)
		p.Match(MySQLParserSQLSTATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6709)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6708)
			p.Match(MySQLParserVALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6711)
		p.TextLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerDeclarationContext is an interface to support dynamic dispatch.
type IHandlerDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE_SYMBOL() antlr.TerminalNode
	HANDLER_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	AllHandlerCondition() []IHandlerConditionContext
	HandlerCondition(i int) IHandlerConditionContext
	CompoundStatement() ICompoundStatementContext
	CONTINUE_SYMBOL() antlr.TerminalNode
	EXIT_SYMBOL() antlr.TerminalNode
	UNDO_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsHandlerDeclarationContext differentiates from other interfaces.
	IsHandlerDeclarationContext()
}

type HandlerDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerDeclarationContext() *HandlerDeclarationContext {
	var p = new(HandlerDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerDeclaration
	return p
}

func InitEmptyHandlerDeclarationContext(p *HandlerDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerDeclaration
}

func (*HandlerDeclarationContext) IsHandlerDeclarationContext() {}

func NewHandlerDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerDeclarationContext {
	var p = new(HandlerDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_handlerDeclaration

	return p
}

func (s *HandlerDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerDeclarationContext) DECLARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECLARE_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHANDLER_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) AllHandlerCondition() []IHandlerConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerConditionContext); ok {
			len++
		}
	}

	tst := make([]IHandlerConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerConditionContext); ok {
			tst[i] = t.(IHandlerConditionContext)
			i++
		}
	}

	return tst
}

func (s *HandlerDeclarationContext) HandlerCondition(i int) IHandlerConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerConditionContext)
}

func (s *HandlerDeclarationContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *HandlerDeclarationContext) CONTINUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTINUE_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) EXIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXIT_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) UNDO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_SYMBOL, 0)
}

func (s *HandlerDeclarationContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *HandlerDeclarationContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *HandlerDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHandlerDeclaration(s)
	}
}

func (s *HandlerDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHandlerDeclaration(s)
	}
}

func (s *HandlerDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHandlerDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HandlerDeclaration() (localctx IHandlerDeclarationContext) {
	localctx = NewHandlerDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, MySQLParserRULE_handlerDeclaration)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6713)
		p.Match(MySQLParserDECLARE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6714)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserCONTINUE_SYMBOL || _la == MySQLParserEXIT_SYMBOL || _la == MySQLParserUNDO_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6715)
		p.Match(MySQLParserHANDLER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6716)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6717)
		p.HandlerCondition()
	}
	p.SetState(6722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 843, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6718)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6719)
				p.HandlerCondition()
			}

		}
		p.SetState(6724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 843, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(6725)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerConditionContext is an interface to support dynamic dispatch.
type IHandlerConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SpCondition() ISpConditionContext
	Identifier() IIdentifierContext
	SQLWARNING_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	FOUND_SYMBOL() antlr.TerminalNode
	SQLEXCEPTION_SYMBOL() antlr.TerminalNode

	// IsHandlerConditionContext differentiates from other interfaces.
	IsHandlerConditionContext()
}

type HandlerConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerConditionContext() *HandlerConditionContext {
	var p = new(HandlerConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerCondition
	return p
}

func InitEmptyHandlerConditionContext(p *HandlerConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_handlerCondition
}

func (*HandlerConditionContext) IsHandlerConditionContext() {}

func NewHandlerConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerConditionContext {
	var p = new(HandlerConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_handlerCondition

	return p
}

func (s *HandlerConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerConditionContext) SpCondition() ISpConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpConditionContext)
}

func (s *HandlerConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *HandlerConditionContext) SQLWARNING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQLWARNING_SYMBOL, 0)
}

func (s *HandlerConditionContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *HandlerConditionContext) FOUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOUND_SYMBOL, 0)
}

func (s *HandlerConditionContext) SQLEXCEPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQLEXCEPTION_SYMBOL, 0)
}

func (s *HandlerConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterHandlerCondition(s)
	}
}

func (s *HandlerConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitHandlerCondition(s)
	}
}

func (s *HandlerConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitHandlerCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) HandlerCondition() (localctx IHandlerConditionContext) {
	localctx = NewHandlerConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, MySQLParserRULE_handlerCondition)
	p.SetState(6734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6727)
			p.SpCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6728)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6729)
			p.Match(MySQLParserSQLWARNING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6730)
			p.NotRule()
		}
		{
			p.SetState(6731)
			p.Match(MySQLParserFOUND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6733)
			p.Match(MySQLParserSQLEXCEPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorDeclarationContext is an interface to support dynamic dispatch.
type ICursorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	CURSOR_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	SelectStatement() ISelectStatementContext

	// IsCursorDeclarationContext differentiates from other interfaces.
	IsCursorDeclarationContext()
}

type CursorDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorDeclarationContext() *CursorDeclarationContext {
	var p = new(CursorDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorDeclaration
	return p
}

func InitEmptyCursorDeclarationContext(p *CursorDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorDeclaration
}

func (*CursorDeclarationContext) IsCursorDeclarationContext() {}

func NewCursorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorDeclarationContext {
	var p = new(CursorDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cursorDeclaration

	return p
}

func (s *CursorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorDeclarationContext) DECLARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECLARE_SYMBOL, 0)
}

func (s *CursorDeclarationContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CursorDeclarationContext) CURSOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURSOR_SYMBOL, 0)
}

func (s *CursorDeclarationContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOR_SYMBOL, 0)
}

func (s *CursorDeclarationContext) SelectStatement() ISelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementContext)
}

func (s *CursorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCursorDeclaration(s)
	}
}

func (s *CursorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCursorDeclaration(s)
	}
}

func (s *CursorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCursorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CursorDeclaration() (localctx ICursorDeclarationContext) {
	localctx = NewCursorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, MySQLParserRULE_cursorDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6736)
		p.Match(MySQLParserDECLARE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6737)
		p.Identifier()
	}
	{
		p.SetState(6738)
		p.Match(MySQLParserCURSOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6739)
		p.Match(MySQLParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6740)
		p.SelectStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterateStatementContext is an interface to support dynamic dispatch.
type IIterateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ITERATE_SYMBOL() antlr.TerminalNode
	LabelRef() ILabelRefContext

	// IsIterateStatementContext differentiates from other interfaces.
	IsIterateStatementContext()
}

type IterateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterateStatementContext() *IterateStatementContext {
	var p = new(IterateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_iterateStatement
	return p
}

func InitEmptyIterateStatementContext(p *IterateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_iterateStatement
}

func (*IterateStatementContext) IsIterateStatementContext() {}

func NewIterateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterateStatementContext {
	var p = new(IterateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_iterateStatement

	return p
}

func (s *IterateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterateStatementContext) ITERATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserITERATE_SYMBOL, 0)
}

func (s *IterateStatementContext) LabelRef() ILabelRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelRefContext)
}

func (s *IterateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIterateStatement(s)
	}
}

func (s *IterateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIterateStatement(s)
	}
}

func (s *IterateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIterateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IterateStatement() (localctx IIterateStatementContext) {
	localctx = NewIterateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, MySQLParserRULE_iterateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6742)
		p.Match(MySQLParserITERATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6743)
		p.LabelRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeaveStatementContext is an interface to support dynamic dispatch.
type ILeaveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEAVE_SYMBOL() antlr.TerminalNode
	LabelRef() ILabelRefContext

	// IsLeaveStatementContext differentiates from other interfaces.
	IsLeaveStatementContext()
}

type LeaveStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeaveStatementContext() *LeaveStatementContext {
	var p = new(LeaveStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_leaveStatement
	return p
}

func InitEmptyLeaveStatementContext(p *LeaveStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_leaveStatement
}

func (*LeaveStatementContext) IsLeaveStatementContext() {}

func NewLeaveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeaveStatementContext {
	var p = new(LeaveStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_leaveStatement

	return p
}

func (s *LeaveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LeaveStatementContext) LEAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAVE_SYMBOL, 0)
}

func (s *LeaveStatementContext) LabelRef() ILabelRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelRefContext)
}

func (s *LeaveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeaveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeaveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLeaveStatement(s)
	}
}

func (s *LeaveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLeaveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LeaveStatement() (localctx ILeaveStatementContext) {
	localctx = NewLeaveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, MySQLParserRULE_leaveStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6745)
		p.Match(MySQLParserLEAVE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6746)
		p.LabelRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetDiagnosticsContext is an interface to support dynamic dispatch.
type IGetDiagnosticsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GET_SYMBOL() antlr.TerminalNode
	DIAGNOSTICS_SYMBOL() antlr.TerminalNode
	AllStatementInformationItem() []IStatementInformationItemContext
	StatementInformationItem(i int) IStatementInformationItemContext
	CONDITION_SYMBOL() antlr.TerminalNode
	SignalAllowedExpr() ISignalAllowedExprContext
	AllConditionInformationItem() []IConditionInformationItemContext
	ConditionInformationItem(i int) IConditionInformationItemContext
	CURRENT_SYMBOL() antlr.TerminalNode
	STACKED_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsGetDiagnosticsContext differentiates from other interfaces.
	IsGetDiagnosticsContext()
}

type GetDiagnosticsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetDiagnosticsContext() *GetDiagnosticsContext {
	var p = new(GetDiagnosticsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_getDiagnostics
	return p
}

func InitEmptyGetDiagnosticsContext(p *GetDiagnosticsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_getDiagnostics
}

func (*GetDiagnosticsContext) IsGetDiagnosticsContext() {}

func NewGetDiagnosticsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetDiagnosticsContext {
	var p = new(GetDiagnosticsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_getDiagnostics

	return p
}

func (s *GetDiagnosticsContext) GetParser() antlr.Parser { return s.parser }

func (s *GetDiagnosticsContext) GET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_SYMBOL, 0)
}

func (s *GetDiagnosticsContext) DIAGNOSTICS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIAGNOSTICS_SYMBOL, 0)
}

func (s *GetDiagnosticsContext) AllStatementInformationItem() []IStatementInformationItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementInformationItemContext); ok {
			len++
		}
	}

	tst := make([]IStatementInformationItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementInformationItemContext); ok {
			tst[i] = t.(IStatementInformationItemContext)
			i++
		}
	}

	return tst
}

func (s *GetDiagnosticsContext) StatementInformationItem(i int) IStatementInformationItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementInformationItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementInformationItemContext)
}

func (s *GetDiagnosticsContext) CONDITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONDITION_SYMBOL, 0)
}

func (s *GetDiagnosticsContext) SignalAllowedExpr() ISignalAllowedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalAllowedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalAllowedExprContext)
}

func (s *GetDiagnosticsContext) AllConditionInformationItem() []IConditionInformationItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionInformationItemContext); ok {
			len++
		}
	}

	tst := make([]IConditionInformationItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionInformationItemContext); ok {
			tst[i] = t.(IConditionInformationItemContext)
			i++
		}
	}

	return tst
}

func (s *GetDiagnosticsContext) ConditionInformationItem(i int) IConditionInformationItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionInformationItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionInformationItemContext)
}

func (s *GetDiagnosticsContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *GetDiagnosticsContext) STACKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTACKED_SYMBOL, 0)
}

func (s *GetDiagnosticsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *GetDiagnosticsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *GetDiagnosticsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetDiagnosticsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetDiagnosticsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGetDiagnostics(s)
	}
}

func (s *GetDiagnosticsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGetDiagnostics(s)
	}
}

func (s *GetDiagnosticsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGetDiagnostics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GetDiagnostics() (localctx IGetDiagnosticsContext) {
	localctx = NewGetDiagnosticsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, MySQLParserRULE_getDiagnostics)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6748)
		p.Match(MySQLParserGET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6752)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6749)
			p.Match(MySQLParserCURRENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 2 {
		p.SetState(6750)

		if !(serverVersion >= 50700) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
			goto errorExit
		}
		{
			p.SetState(6751)
			p.Match(MySQLParserSTACKED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6754)
		p.Match(MySQLParserDIAGNOSTICS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 848, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6755)
			p.StatementInformationItem()
		}
		p.SetState(6760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6756)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6757)
				p.StatementInformationItem()
			}

			p.SetState(6762)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(6763)
			p.Match(MySQLParserCONDITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6764)
			p.SignalAllowedExpr()
		}
		{
			p.SetState(6765)
			p.ConditionInformationItem()
		}
		p.SetState(6770)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6766)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6767)
				p.ConditionInformationItem()
			}

			p.SetState(6772)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalAllowedExprContext is an interface to support dynamic dispatch.
type ISignalAllowedExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	Variable() IVariableContext
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsSignalAllowedExprContext differentiates from other interfaces.
	IsSignalAllowedExprContext()
}

type SignalAllowedExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalAllowedExprContext() *SignalAllowedExprContext {
	var p = new(SignalAllowedExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalAllowedExpr
	return p
}

func InitEmptySignalAllowedExprContext(p *SignalAllowedExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalAllowedExpr
}

func (*SignalAllowedExprContext) IsSignalAllowedExprContext() {}

func NewSignalAllowedExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalAllowedExprContext {
	var p = new(SignalAllowedExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_signalAllowedExpr

	return p
}

func (s *SignalAllowedExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalAllowedExprContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SignalAllowedExprContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SignalAllowedExprContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *SignalAllowedExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalAllowedExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalAllowedExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSignalAllowedExpr(s)
	}
}

func (s *SignalAllowedExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSignalAllowedExpr(s)
	}
}

func (s *SignalAllowedExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSignalAllowedExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SignalAllowedExpr() (localctx ISignalAllowedExprContext) {
	localctx = NewSignalAllowedExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, MySQLParserRULE_signalAllowedExpr)
	p.SetState(6778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 849, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6775)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6776)
			p.Variable()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6777)
			p.QualifiedIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementInformationItemContext is an interface to support dynamic dispatch.
type IStatementInformationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	NUMBER_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	Variable() IVariableContext
	Identifier() IIdentifierContext

	// IsStatementInformationItemContext differentiates from other interfaces.
	IsStatementInformationItemContext()
}

type StatementInformationItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementInformationItemContext() *StatementInformationItemContext {
	var p = new(StatementInformationItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_statementInformationItem
	return p
}

func InitEmptyStatementInformationItemContext(p *StatementInformationItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_statementInformationItem
}

func (*StatementInformationItemContext) IsStatementInformationItemContext() {}

func NewStatementInformationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementInformationItemContext {
	var p = new(StatementInformationItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_statementInformationItem

	return p
}

func (s *StatementInformationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementInformationItemContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *StatementInformationItemContext) NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNUMBER_SYMBOL, 0)
}

func (s *StatementInformationItemContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_COUNT_SYMBOL, 0)
}

func (s *StatementInformationItemContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *StatementInformationItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementInformationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementInformationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementInformationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStatementInformationItem(s)
	}
}

func (s *StatementInformationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStatementInformationItem(s)
	}
}

func (s *StatementInformationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStatementInformationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StatementInformationItem() (localctx IStatementInformationItemContext) {
	localctx = NewStatementInformationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, MySQLParserRULE_statementInformationItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6782)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 850, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6780)
			p.Variable()
		}

	case 2:
		{
			p.SetState(6781)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(6784)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6785)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserNUMBER_SYMBOL || _la == MySQLParserROW_COUNT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionInformationItemContext is an interface to support dynamic dispatch.
type IConditionInformationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	Variable() IVariableContext
	Identifier() IIdentifierContext
	SignalInformationItemName() ISignalInformationItemNameContext
	RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode

	// IsConditionInformationItemContext differentiates from other interfaces.
	IsConditionInformationItemContext()
}

type ConditionInformationItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionInformationItemContext() *ConditionInformationItemContext {
	var p = new(ConditionInformationItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_conditionInformationItem
	return p
}

func InitEmptyConditionInformationItemContext(p *ConditionInformationItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_conditionInformationItem
}

func (*ConditionInformationItemContext) IsConditionInformationItemContext() {}

func NewConditionInformationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionInformationItemContext {
	var p = new(ConditionInformationItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_conditionInformationItem

	return p
}

func (s *ConditionInformationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionInformationItemContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *ConditionInformationItemContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *ConditionInformationItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConditionInformationItemContext) SignalInformationItemName() ISignalInformationItemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalInformationItemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalInformationItemNameContext)
}

func (s *ConditionInformationItemContext) RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNED_SQLSTATE_SYMBOL, 0)
}

func (s *ConditionInformationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionInformationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionInformationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConditionInformationItem(s)
	}
}

func (s *ConditionInformationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConditionInformationItem(s)
	}
}

func (s *ConditionInformationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConditionInformationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConditionInformationItem() (localctx IConditionInformationItemContext) {
	localctx = NewConditionInformationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, MySQLParserRULE_conditionInformationItem)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(6789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 851, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6787)
			p.Variable()
		}

	case 2:
		{
			p.SetState(6788)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(6791)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6794)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCATALOG_NAME_SYMBOL, MySQLParserCLASS_ORIGIN_SYMBOL, MySQLParserCOLUMN_NAME_SYMBOL, MySQLParserCONSTRAINT_CATALOG_SYMBOL, MySQLParserCONSTRAINT_NAME_SYMBOL, MySQLParserCONSTRAINT_SCHEMA_SYMBOL, MySQLParserCURSOR_NAME_SYMBOL, MySQLParserMESSAGE_TEXT_SYMBOL, MySQLParserMYSQL_ERRNO_SYMBOL, MySQLParserSCHEMA_NAME_SYMBOL, MySQLParserSUBCLASS_ORIGIN_SYMBOL, MySQLParserTABLE_NAME_SYMBOL:
		{
			p.SetState(6792)
			p.SignalInformationItemName()
		}

	case MySQLParserRETURNED_SQLSTATE_SYMBOL:
		{
			p.SetState(6793)
			p.Match(MySQLParserRETURNED_SQLSTATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalInformationItemNameContext is an interface to support dynamic dispatch.
type ISignalInformationItemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode
	CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode
	CATALOG_NAME_SYMBOL() antlr.TerminalNode
	SCHEMA_NAME_SYMBOL() antlr.TerminalNode
	TABLE_NAME_SYMBOL() antlr.TerminalNode
	COLUMN_NAME_SYMBOL() antlr.TerminalNode
	CURSOR_NAME_SYMBOL() antlr.TerminalNode
	MESSAGE_TEXT_SYMBOL() antlr.TerminalNode
	MYSQL_ERRNO_SYMBOL() antlr.TerminalNode

	// IsSignalInformationItemNameContext differentiates from other interfaces.
	IsSignalInformationItemNameContext()
}

type SignalInformationItemNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalInformationItemNameContext() *SignalInformationItemNameContext {
	var p = new(SignalInformationItemNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalInformationItemName
	return p
}

func InitEmptySignalInformationItemNameContext(p *SignalInformationItemNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalInformationItemName
}

func (*SignalInformationItemNameContext) IsSignalInformationItemNameContext() {}

func NewSignalInformationItemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalInformationItemNameContext {
	var p = new(SignalInformationItemNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_signalInformationItemName

	return p
}

func (s *SignalInformationItemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalInformationItemNameContext) CLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLASS_ORIGIN_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBCLASS_ORIGIN_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_CATALOG_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_SCHEMA_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) CATALOG_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCATALOG_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) SCHEMA_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEMA_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) TABLE_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) COLUMN_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) CURSOR_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURSOR_NAME_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) MESSAGE_TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMESSAGE_TEXT_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) MYSQL_ERRNO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMYSQL_ERRNO_SYMBOL, 0)
}

func (s *SignalInformationItemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalInformationItemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalInformationItemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSignalInformationItemName(s)
	}
}

func (s *SignalInformationItemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSignalInformationItemName(s)
	}
}

func (s *SignalInformationItemNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSignalInformationItemName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SignalInformationItemName() (localctx ISignalInformationItemNameContext) {
	localctx = NewSignalInformationItemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, MySQLParserRULE_signalInformationItemName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6796)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-53)) & ^0x3f) == 0 && ((int64(1)<<(_la-53))&18014518769616897) != 0) || _la == MySQLParserMESSAGE_TEXT_SYMBOL || _la == MySQLParserMYSQL_ERRNO_SYMBOL || _la == MySQLParserSCHEMA_NAME_SYMBOL || _la == MySQLParserSUBCLASS_ORIGIN_SYMBOL || _la == MySQLParserTABLE_NAME_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalStatementContext is an interface to support dynamic dispatch.
type ISignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SIGNAL_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	Sqlstate() ISqlstateContext
	SET_SYMBOL() antlr.TerminalNode
	AllSignalInformationItem() []ISignalInformationItemContext
	SignalInformationItem(i int) ISignalInformationItemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSignalStatementContext differentiates from other interfaces.
	IsSignalStatementContext()
}

type SignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalStatementContext() *SignalStatementContext {
	var p = new(SignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalStatement
	return p
}

func InitEmptySignalStatementContext(p *SignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalStatement
}

func (*SignalStatementContext) IsSignalStatementContext() {}

func NewSignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalStatementContext {
	var p = new(SignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_signalStatement

	return p
}

func (s *SignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalStatementContext) SIGNAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIGNAL_SYMBOL, 0)
}

func (s *SignalStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SignalStatementContext) Sqlstate() ISqlstateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlstateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlstateContext)
}

func (s *SignalStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *SignalStatementContext) AllSignalInformationItem() []ISignalInformationItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalInformationItemContext); ok {
			len++
		}
	}

	tst := make([]ISignalInformationItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalInformationItemContext); ok {
			tst[i] = t.(ISignalInformationItemContext)
			i++
		}
	}

	return tst
}

func (s *SignalStatementContext) SignalInformationItem(i int) ISignalInformationItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalInformationItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalInformationItemContext)
}

func (s *SignalStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *SignalStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *SignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSignalStatement(s)
	}
}

func (s *SignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSignalStatement(s)
	}
}

func (s *SignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SignalStatement() (localctx ISignalStatementContext) {
	localctx = NewSignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, MySQLParserRULE_signalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6798)
		p.Match(MySQLParserSIGNAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 853, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6799)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(6800)
			p.Sqlstate()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(6812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSET_SYMBOL {
		{
			p.SetState(6803)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6804)
			p.SignalInformationItem()
		}
		p.SetState(6809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6805)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6806)
				p.SignalInformationItem()
			}

			p.SetState(6811)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResignalStatementContext is an interface to support dynamic dispatch.
type IResignalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESIGNAL_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	Sqlstate() ISqlstateContext
	SET_SYMBOL() antlr.TerminalNode
	AllSignalInformationItem() []ISignalInformationItemContext
	SignalInformationItem(i int) ISignalInformationItemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsResignalStatementContext differentiates from other interfaces.
	IsResignalStatementContext()
}

type ResignalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResignalStatementContext() *ResignalStatementContext {
	var p = new(ResignalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resignalStatement
	return p
}

func InitEmptyResignalStatementContext(p *ResignalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resignalStatement
}

func (*ResignalStatementContext) IsResignalStatementContext() {}

func NewResignalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResignalStatementContext {
	var p = new(ResignalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resignalStatement

	return p
}

func (s *ResignalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResignalStatementContext) RESIGNAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESIGNAL_SYMBOL, 0)
}

func (s *ResignalStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResignalStatementContext) Sqlstate() ISqlstateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISqlstateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISqlstateContext)
}

func (s *ResignalStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *ResignalStatementContext) AllSignalInformationItem() []ISignalInformationItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISignalInformationItemContext); ok {
			len++
		}
	}

	tst := make([]ISignalInformationItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISignalInformationItemContext); ok {
			tst[i] = t.(ISignalInformationItemContext)
			i++
		}
	}

	return tst
}

func (s *ResignalStatementContext) SignalInformationItem(i int) ISignalInformationItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalInformationItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalInformationItemContext)
}

func (s *ResignalStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ResignalStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ResignalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResignalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResignalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResignalStatement(s)
	}
}

func (s *ResignalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResignalStatement(s)
	}
}

func (s *ResignalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResignalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResignalStatement() (localctx IResignalStatementContext) {
	localctx = NewResignalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, MySQLParserRULE_resignalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6814)
		p.Match(MySQLParserRESIGNAL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6817)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 856, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6815)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 856, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6816)
			p.Sqlstate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserSET_SYMBOL {
		{
			p.SetState(6819)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6820)
			p.SignalInformationItem()
		}
		p.SetState(6825)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(6821)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6822)
				p.SignalInformationItem()
			}

			p.SetState(6827)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignalInformationItemContext is an interface to support dynamic dispatch.
type ISignalInformationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SignalInformationItemName() ISignalInformationItemNameContext
	EQUAL_OPERATOR() antlr.TerminalNode
	SignalAllowedExpr() ISignalAllowedExprContext

	// IsSignalInformationItemContext differentiates from other interfaces.
	IsSignalInformationItemContext()
}

type SignalInformationItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalInformationItemContext() *SignalInformationItemContext {
	var p = new(SignalInformationItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalInformationItem
	return p
}

func InitEmptySignalInformationItemContext(p *SignalInformationItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signalInformationItem
}

func (*SignalInformationItemContext) IsSignalInformationItemContext() {}

func NewSignalInformationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalInformationItemContext {
	var p = new(SignalInformationItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_signalInformationItem

	return p
}

func (s *SignalInformationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalInformationItemContext) SignalInformationItemName() ISignalInformationItemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalInformationItemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalInformationItemNameContext)
}

func (s *SignalInformationItemContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *SignalInformationItemContext) SignalAllowedExpr() ISignalAllowedExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignalAllowedExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignalAllowedExprContext)
}

func (s *SignalInformationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalInformationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalInformationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSignalInformationItem(s)
	}
}

func (s *SignalInformationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSignalInformationItem(s)
	}
}

func (s *SignalInformationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSignalInformationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SignalInformationItem() (localctx ISignalInformationItemContext) {
	localctx = NewSignalInformationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, MySQLParserRULE_signalInformationItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6830)
		p.SignalInformationItemName()
	}
	{
		p.SetState(6831)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6832)
		p.SignalAllowedExpr()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorOpenContext is an interface to support dynamic dispatch.
type ICursorOpenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsCursorOpenContext differentiates from other interfaces.
	IsCursorOpenContext()
}

type CursorOpenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorOpenContext() *CursorOpenContext {
	var p = new(CursorOpenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorOpen
	return p
}

func InitEmptyCursorOpenContext(p *CursorOpenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorOpen
}

func (*CursorOpenContext) IsCursorOpenContext() {}

func NewCursorOpenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorOpenContext {
	var p = new(CursorOpenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cursorOpen

	return p
}

func (s *CursorOpenContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorOpenContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_SYMBOL, 0)
}

func (s *CursorOpenContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CursorOpenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorOpenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorOpenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCursorOpen(s)
	}
}

func (s *CursorOpenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCursorOpen(s)
	}
}

func (s *CursorOpenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCursorOpen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CursorOpen() (localctx ICursorOpenContext) {
	localctx = NewCursorOpenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, MySQLParserRULE_cursorOpen)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6834)
		p.Match(MySQLParserOPEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6835)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorCloseContext is an interface to support dynamic dispatch.
type ICursorCloseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLOSE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsCursorCloseContext differentiates from other interfaces.
	IsCursorCloseContext()
}

type CursorCloseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorCloseContext() *CursorCloseContext {
	var p = new(CursorCloseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorClose
	return p
}

func InitEmptyCursorCloseContext(p *CursorCloseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorClose
}

func (*CursorCloseContext) IsCursorCloseContext() {}

func NewCursorCloseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorCloseContext {
	var p = new(CursorCloseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cursorClose

	return p
}

func (s *CursorCloseContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorCloseContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_SYMBOL, 0)
}

func (s *CursorCloseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CursorCloseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorCloseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorCloseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCursorClose(s)
	}
}

func (s *CursorCloseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCursorClose(s)
	}
}

func (s *CursorCloseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCursorClose(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CursorClose() (localctx ICursorCloseContext) {
	localctx = NewCursorCloseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, MySQLParserRULE_cursorClose)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6837)
		p.Match(MySQLParserCLOSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6838)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICursorFetchContext is an interface to support dynamic dispatch.
type ICursorFetchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FETCH_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	INTO_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FROM_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode

	// IsCursorFetchContext differentiates from other interfaces.
	IsCursorFetchContext()
}

type CursorFetchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCursorFetchContext() *CursorFetchContext {
	var p = new(CursorFetchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorFetch
	return p
}

func InitEmptyCursorFetchContext(p *CursorFetchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_cursorFetch
}

func (*CursorFetchContext) IsCursorFetchContext() {}

func NewCursorFetchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CursorFetchContext {
	var p = new(CursorFetchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_cursorFetch

	return p
}

func (s *CursorFetchContext) GetParser() antlr.Parser { return s.parser }

func (s *CursorFetchContext) FETCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFETCH_SYMBOL, 0)
}

func (s *CursorFetchContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CursorFetchContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINTO_SYMBOL, 0)
}

func (s *CursorFetchContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CursorFetchContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFROM_SYMBOL, 0)
}

func (s *CursorFetchContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEXT_SYMBOL, 0)
}

func (s *CursorFetchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CursorFetchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CursorFetchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCursorFetch(s)
	}
}

func (s *CursorFetchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCursorFetch(s)
	}
}

func (s *CursorFetchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCursorFetch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CursorFetch() (localctx ICursorFetchContext) {
	localctx = NewCursorFetchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, MySQLParserRULE_cursorFetch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6840)
		p.Match(MySQLParserFETCH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6845)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 860, p.GetParserRuleContext()) == 1 {
		p.SetState(6842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNEXT_SYMBOL {
			{
				p.SetState(6841)
				p.Match(MySQLParserNEXT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6844)
			p.Match(MySQLParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(6847)
		p.Identifier()
	}
	{
		p.SetState(6848)
		p.Match(MySQLParserINTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6849)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScheduleContext is an interface to support dynamic dispatch.
type IScheduleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	EVERY_SYMBOL() antlr.TerminalNode
	Interval() IIntervalContext
	STARTS_SYMBOL() antlr.TerminalNode
	ENDS_SYMBOL() antlr.TerminalNode

	// IsScheduleContext differentiates from other interfaces.
	IsScheduleContext()
}

type ScheduleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScheduleContext() *ScheduleContext {
	var p = new(ScheduleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schedule
	return p
}

func InitEmptyScheduleContext(p *ScheduleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schedule
}

func (*ScheduleContext) IsScheduleContext() {}

func NewScheduleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScheduleContext {
	var p = new(ScheduleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_schedule

	return p
}

func (s *ScheduleContext) GetParser() antlr.Parser { return s.parser }

func (s *ScheduleContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SYMBOL, 0)
}

func (s *ScheduleContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ScheduleContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ScheduleContext) EVERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVERY_SYMBOL, 0)
}

func (s *ScheduleContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *ScheduleContext) STARTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTARTS_SYMBOL, 0)
}

func (s *ScheduleContext) ENDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENDS_SYMBOL, 0)
}

func (s *ScheduleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScheduleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScheduleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSchedule(s)
	}
}

func (s *ScheduleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSchedule(s)
	}
}

func (s *ScheduleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSchedule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Schedule() (localctx IScheduleContext) {
	localctx = NewScheduleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, MySQLParserRULE_schedule)
	var _la int

	p.SetState(6864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserAT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6851)
			p.Match(MySQLParserAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6852)
			p.expr(0)
		}

	case MySQLParserEVERY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6853)
			p.Match(MySQLParserEVERY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6854)
			p.expr(0)
		}
		{
			p.SetState(6855)
			p.Interval()
		}
		p.SetState(6858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserSTARTS_SYMBOL {
			{
				p.SetState(6856)
				p.Match(MySQLParserSTARTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6857)
				p.expr(0)
			}

		}
		p.SetState(6862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserENDS_SYMBOL {
			{
				p.SetState(6860)
				p.Match(MySQLParserENDS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6861)
				p.expr(0)
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefinitionContext is an interface to support dynamic dispatch.
type IColumnDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnName() IColumnNameContext
	FieldDefinition() IFieldDefinitionContext
	CheckOrReferences() ICheckOrReferencesContext

	// IsColumnDefinitionContext differentiates from other interfaces.
	IsColumnDefinitionContext()
}

type ColumnDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefinitionContext() *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnDefinition
	return p
}

func InitEmptyColumnDefinitionContext(p *ColumnDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnDefinition
}

func (*ColumnDefinitionContext) IsColumnDefinitionContext() {}

func NewColumnDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefinitionContext {
	var p = new(ColumnDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnDefinition

	return p
}

func (s *ColumnDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefinitionContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnDefinitionContext) FieldDefinition() IFieldDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldDefinitionContext)
}

func (s *ColumnDefinitionContext) CheckOrReferences() ICheckOrReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckOrReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckOrReferencesContext)
}

func (s *ColumnDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnDefinition(s)
	}
}

func (s *ColumnDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnDefinition() (localctx IColumnDefinitionContext) {
	localctx = NewColumnDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, MySQLParserRULE_columnDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6866)
		p.ColumnName()
	}
	{
		p.SetState(6867)
		p.FieldDefinition()
	}
	p.SetState(6869)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 864, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6868)
			p.CheckOrReferences()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckOrReferencesContext is an interface to support dynamic dispatch.
type ICheckOrReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CheckConstraint() ICheckConstraintContext
	References() IReferencesContext

	// IsCheckOrReferencesContext differentiates from other interfaces.
	IsCheckOrReferencesContext()
}

type CheckOrReferencesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckOrReferencesContext() *CheckOrReferencesContext {
	var p = new(CheckOrReferencesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkOrReferences
	return p
}

func InitEmptyCheckOrReferencesContext(p *CheckOrReferencesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkOrReferences
}

func (*CheckOrReferencesContext) IsCheckOrReferencesContext() {}

func NewCheckOrReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckOrReferencesContext {
	var p = new(CheckOrReferencesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_checkOrReferences

	return p
}

func (s *CheckOrReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckOrReferencesContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *CheckOrReferencesContext) References() IReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferencesContext)
}

func (s *CheckOrReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckOrReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckOrReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCheckOrReferences(s)
	}
}

func (s *CheckOrReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCheckOrReferences(s)
	}
}

func (s *CheckOrReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCheckOrReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CheckOrReferences() (localctx ICheckOrReferencesContext) {
	localctx = NewCheckOrReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, MySQLParserRULE_checkOrReferences)
	p.SetState(6874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 865, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6871)

		if !(serverVersion < 80016) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80016", ""))
			goto errorExit
		}
		{
			p.SetState(6872)
			p.CheckConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6873)
			p.References()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckConstraintContext is an interface to support dynamic dispatch.
type ICheckConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHECK_SYMBOL() antlr.TerminalNode
	ExprWithParentheses() IExprWithParenthesesContext

	// IsCheckConstraintContext differentiates from other interfaces.
	IsCheckConstraintContext()
}

type CheckConstraintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckConstraintContext() *CheckConstraintContext {
	var p = new(CheckConstraintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkConstraint
	return p
}

func InitEmptyCheckConstraintContext(p *CheckConstraintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_checkConstraint
}

func (*CheckConstraintContext) IsCheckConstraintContext() {}

func NewCheckConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckConstraintContext {
	var p = new(CheckConstraintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_checkConstraint

	return p
}

func (s *CheckConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckConstraintContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECK_SYMBOL, 0)
}

func (s *CheckConstraintContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *CheckConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCheckConstraint(s)
	}
}

func (s *CheckConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCheckConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CheckConstraint() (localctx ICheckConstraintContext) {
	localctx = NewCheckConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, MySQLParserRULE_checkConstraint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6876)
		p.Match(MySQLParserCHECK_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6877)
		p.ExprWithParentheses()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintEnforcementContext is an interface to support dynamic dispatch.
type IConstraintEnforcementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENFORCED_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode

	// IsConstraintEnforcementContext differentiates from other interfaces.
	IsConstraintEnforcementContext()
}

type ConstraintEnforcementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintEnforcementContext() *ConstraintEnforcementContext {
	var p = new(ConstraintEnforcementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintEnforcement
	return p
}

func InitEmptyConstraintEnforcementContext(p *ConstraintEnforcementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintEnforcement
}

func (*ConstraintEnforcementContext) IsConstraintEnforcementContext() {}

func NewConstraintEnforcementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintEnforcementContext {
	var p = new(ConstraintEnforcementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_constraintEnforcement

	return p
}

func (s *ConstraintEnforcementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintEnforcementContext) ENFORCED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENFORCED_SYMBOL, 0)
}

func (s *ConstraintEnforcementContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *ConstraintEnforcementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintEnforcementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintEnforcementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConstraintEnforcement(s)
	}
}

func (s *ConstraintEnforcementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConstraintEnforcement(s)
	}
}

func (s *ConstraintEnforcementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConstraintEnforcement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConstraintEnforcement() (localctx IConstraintEnforcementContext) {
	localctx = NewConstraintEnforcementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, MySQLParserRULE_constraintEnforcement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserNOT_SYMBOL {
		{
			p.SetState(6879)
			p.Match(MySQLParserNOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6882)
		p.Match(MySQLParserENFORCED_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableConstraintDefContext is an interface to support dynamic dispatch.
type ITableConstraintDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	KeyListVariants() IKeyListVariantsContext
	KEY_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	IndexNameAndType() IIndexNameAndTypeContext
	AllIndexOption() []IIndexOptionContext
	IndexOption(i int) IIndexOptionContext
	FULLTEXT_SYMBOL() antlr.TerminalNode
	KeyOrIndex() IKeyOrIndexContext
	IndexName() IIndexNameContext
	AllFulltextIndexOption() []IFulltextIndexOptionContext
	FulltextIndexOption(i int) IFulltextIndexOptionContext
	SPATIAL_SYMBOL() antlr.TerminalNode
	AllSpatialIndexOption() []ISpatialIndexOptionContext
	SpatialIndexOption(i int) ISpatialIndexOptionContext
	KeyList() IKeyListContext
	References() IReferencesContext
	CheckConstraint() ICheckConstraintContext
	ConstraintName() IConstraintNameContext
	FOREIGN_SYMBOL() antlr.TerminalNode
	PRIMARY_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	ConstraintEnforcement() IConstraintEnforcementContext

	// IsTableConstraintDefContext differentiates from other interfaces.
	IsTableConstraintDefContext()
}

type TableConstraintDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyTableConstraintDefContext() *TableConstraintDefContext {
	var p = new(TableConstraintDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableConstraintDef
	return p
}

func InitEmptyTableConstraintDefContext(p *TableConstraintDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableConstraintDef
}

func (*TableConstraintDefContext) IsTableConstraintDefContext() {}

func NewTableConstraintDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableConstraintDefContext {
	var p = new(TableConstraintDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableConstraintDef

	return p
}

func (s *TableConstraintDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TableConstraintDefContext) GetType_() antlr.Token { return s.type_ }

func (s *TableConstraintDefContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TableConstraintDefContext) KeyListVariants() IKeyListVariantsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListVariantsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListVariantsContext)
}

func (s *TableConstraintDefContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *TableConstraintDefContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *TableConstraintDefContext) IndexNameAndType() IIndexNameAndTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameAndTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameAndTypeContext)
}

func (s *TableConstraintDefContext) AllIndexOption() []IIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOptionContext); ok {
			tst[i] = t.(IIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *TableConstraintDefContext) IndexOption(i int) IIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOptionContext)
}

func (s *TableConstraintDefContext) FULLTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULLTEXT_SYMBOL, 0)
}

func (s *TableConstraintDefContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *TableConstraintDefContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *TableConstraintDefContext) AllFulltextIndexOption() []IFulltextIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFulltextIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]IFulltextIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFulltextIndexOptionContext); ok {
			tst[i] = t.(IFulltextIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *TableConstraintDefContext) FulltextIndexOption(i int) IFulltextIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFulltextIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFulltextIndexOptionContext)
}

func (s *TableConstraintDefContext) SPATIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSPATIAL_SYMBOL, 0)
}

func (s *TableConstraintDefContext) AllSpatialIndexOption() []ISpatialIndexOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpatialIndexOptionContext); ok {
			len++
		}
	}

	tst := make([]ISpatialIndexOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpatialIndexOptionContext); ok {
			tst[i] = t.(ISpatialIndexOptionContext)
			i++
		}
	}

	return tst
}

func (s *TableConstraintDefContext) SpatialIndexOption(i int) ISpatialIndexOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpatialIndexOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpatialIndexOptionContext)
}

func (s *TableConstraintDefContext) KeyList() IKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListContext)
}

func (s *TableConstraintDefContext) References() IReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferencesContext)
}

func (s *TableConstraintDefContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *TableConstraintDefContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *TableConstraintDefContext) FOREIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOREIGN_SYMBOL, 0)
}

func (s *TableConstraintDefContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *TableConstraintDefContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNIQUE_SYMBOL, 0)
}

func (s *TableConstraintDefContext) ConstraintEnforcement() IConstraintEnforcementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintEnforcementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintEnforcementContext)
}

func (s *TableConstraintDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableConstraintDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableConstraintDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableConstraintDef(s)
	}
}

func (s *TableConstraintDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableConstraintDef(s)
	}
}

func (s *TableConstraintDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableConstraintDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableConstraintDef() (localctx ITableConstraintDefContext) {
	localctx = NewTableConstraintDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, MySQLParserRULE_tableConstraintDef)
	var _la int

	var _alt int

	p.SetState(6959)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINDEX_SYMBOL, MySQLParserKEY_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6884)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*TableConstraintDefContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserINDEX_SYMBOL || _la == MySQLParserKEY_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*TableConstraintDefContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(6886)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 867, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6885)
				p.IndexNameAndType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6888)
			p.KeyListVariants()
		}
		p.SetState(6892)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 868, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6889)
					p.IndexOption()
				}

			}
			p.SetState(6894)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 868, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserFULLTEXT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6895)

			var _m = p.Match(MySQLParserFULLTEXT_SYMBOL)

			localctx.(*TableConstraintDefContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6897)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 869, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6896)
				p.KeyOrIndex()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6900)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6899)
				p.IndexName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6902)
			p.KeyListVariants()
		}
		p.SetState(6906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 871, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6903)
					p.FulltextIndexOption()
				}

			}
			p.SetState(6908)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 871, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserSPATIAL_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6909)

			var _m = p.Match(MySQLParserSPATIAL_SYMBOL)

			localctx.(*TableConstraintDefContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6911)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 872, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6910)
				p.KeyOrIndex()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6914)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 873, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6913)
				p.IndexName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6916)
			p.KeyListVariants()
		}
		p.SetState(6920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 874, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6917)
					p.SpatialIndexOption()
				}

			}
			p.SetState(6922)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 874, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case MySQLParserCHECK_SYMBOL, MySQLParserCONSTRAINT_SYMBOL, MySQLParserFOREIGN_SYMBOL, MySQLParserPRIMARY_SYMBOL, MySQLParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(6924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCONSTRAINT_SYMBOL {
			{
				p.SetState(6923)
				p.ConstraintName()
			}

		}
		p.SetState(6957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserPRIMARY_SYMBOL, MySQLParserUNIQUE_SYMBOL:
			p.SetState(6932)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case MySQLParserPRIMARY_SYMBOL:
				{
					p.SetState(6926)

					var _m = p.Match(MySQLParserPRIMARY_SYMBOL)

					localctx.(*TableConstraintDefContext).type_ = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6927)
					p.Match(MySQLParserKEY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case MySQLParserUNIQUE_SYMBOL:
				{
					p.SetState(6928)

					var _m = p.Match(MySQLParserUNIQUE_SYMBOL)

					localctx.(*TableConstraintDefContext).type_ = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6930)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 876, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(6929)
						p.KeyOrIndex()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}
			p.SetState(6935)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 878, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6934)
					p.IndexNameAndType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(6937)
				p.KeyListVariants()
			}
			p.SetState(6941)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 879, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(6938)
						p.IndexOption()
					}

				}
				p.SetState(6943)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 879, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case MySQLParserFOREIGN_SYMBOL:
			{
				p.SetState(6944)

				var _m = p.Match(MySQLParserFOREIGN_SYMBOL)

				localctx.(*TableConstraintDefContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6945)
				p.Match(MySQLParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6947)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 880, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6946)
					p.IndexName()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(6949)
				p.KeyList()
			}
			{
				p.SetState(6950)
				p.References()
			}

		case MySQLParserCHECK_SYMBOL:
			{
				p.SetState(6952)
				p.CheckConstraint()
			}
			p.SetState(6955)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 881, p.GetParserRuleContext()) == 1 {
				p.SetState(6953)

				if !(serverVersion >= 80017) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
					goto errorExit
				}
				{
					p.SetState(6954)
					p.ConstraintEnforcement()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintNameContext is an interface to support dynamic dispatch.
type IConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRAINT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsConstraintNameContext differentiates from other interfaces.
	IsConstraintNameContext()
}

type ConstraintNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintNameContext() *ConstraintNameContext {
	var p = new(ConstraintNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintName
	return p
}

func InitEmptyConstraintNameContext(p *ConstraintNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_constraintName
}

func (*ConstraintNameContext) IsConstraintNameContext() {}

func NewConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintNameContext {
	var p = new(ConstraintNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_constraintName

	return p
}

func (s *ConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintNameContext) CONSTRAINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_SYMBOL, 0)
}

func (s *ConstraintNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterConstraintName(s)
	}
}

func (s *ConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitConstraintName(s)
	}
}

func (s *ConstraintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitConstraintName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ConstraintName() (localctx IConstraintNameContext) {
	localctx = NewConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, MySQLParserRULE_constraintName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6961)
		p.Match(MySQLParserCONSTRAINT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6963)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 884, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6962)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldDefinitionContext is an interface to support dynamic dispatch.
type IFieldDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	AS_SYMBOL() antlr.TerminalNode
	ExprWithParentheses() IExprWithParenthesesContext
	AllColumnAttribute() []IColumnAttributeContext
	ColumnAttribute(i int) IColumnAttributeContext
	Collate() ICollateContext
	GENERATED_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	VIRTUAL_SYMBOL() antlr.TerminalNode
	STORED_SYMBOL() antlr.TerminalNode
	AllGcolAttribute() []IGcolAttributeContext
	GcolAttribute(i int) IGcolAttributeContext

	// IsFieldDefinitionContext differentiates from other interfaces.
	IsFieldDefinitionContext()
}

type FieldDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDefinitionContext() *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldDefinition
	return p
}

func InitEmptyFieldDefinitionContext(p *FieldDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldDefinition
}

func (*FieldDefinitionContext) IsFieldDefinitionContext() {}

func NewFieldDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDefinitionContext {
	var p = new(FieldDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldDefinition

	return p
}

func (s *FieldDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *FieldDefinitionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *FieldDefinitionContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *FieldDefinitionContext) AllColumnAttribute() []IColumnAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnAttributeContext); ok {
			len++
		}
	}

	tst := make([]IColumnAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnAttributeContext); ok {
			tst[i] = t.(IColumnAttributeContext)
			i++
		}
	}

	return tst
}

func (s *FieldDefinitionContext) ColumnAttribute(i int) IColumnAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAttributeContext)
}

func (s *FieldDefinitionContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *FieldDefinitionContext) GENERATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGENERATED_SYMBOL, 0)
}

func (s *FieldDefinitionContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALWAYS_SYMBOL, 0)
}

func (s *FieldDefinitionContext) VIRTUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIRTUAL_SYMBOL, 0)
}

func (s *FieldDefinitionContext) STORED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORED_SYMBOL, 0)
}

func (s *FieldDefinitionContext) AllGcolAttribute() []IGcolAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGcolAttributeContext); ok {
			len++
		}
	}

	tst := make([]IGcolAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGcolAttributeContext); ok {
			tst[i] = t.(IGcolAttributeContext)
			i++
		}
	}

	return tst
}

func (s *FieldDefinitionContext) GcolAttribute(i int) IGcolAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGcolAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGcolAttributeContext)
}

func (s *FieldDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldDefinition(s)
	}
}

func (s *FieldDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldDefinition(s)
	}
}

func (s *FieldDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldDefinition() (localctx IFieldDefinitionContext) {
	localctx = NewFieldDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, MySQLParserRULE_fieldDefinition)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6965)
		p.DataType()
	}
	p.SetState(7001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 892, p.GetParserRuleContext()) {
	case 1:
		p.SetState(6969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 885, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6966)
					p.ColumnAttribute()
				}

			}
			p.SetState(6971)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 885, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.SetState(6972)

		if !(serverVersion >= 50707) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50707", ""))
			goto errorExit
		}
		p.SetState(6974)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCOLLATE_SYMBOL {
			{
				p.SetState(6973)
				p.Collate()
			}

		}
		p.SetState(6978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserGENERATED_SYMBOL {
			{
				p.SetState(6976)
				p.Match(MySQLParserGENERATED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6977)
				p.Match(MySQLParserALWAYS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6980)
			p.Match(MySQLParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6981)
			p.ExprWithParentheses()
		}
		p.SetState(6983)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 888, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6982)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserSTORED_SYMBOL || _la == MySQLParserVIRTUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6999)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 891, p.GetParserRuleContext()) {
		case 1:
			p.SetState(6985)

			if !(serverVersion < 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
				goto errorExit
			}
			p.SetState(6989)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(6986)
						p.GcolAttribute()
					}

				}
				p.SetState(6991)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 889, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case 2:
			p.SetState(6992)

			if !(serverVersion >= 80000) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
				goto errorExit
			}
			p.SetState(6996)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 890, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(6993)
						p.ColumnAttribute()
					}

				}
				p.SetState(6998)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 890, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAttributeContext is an interface to support dynamic dispatch.
type IColumnAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// Getter signatures
	NullLiteral() INullLiteralContext
	NOT_SYMBOL() antlr.TerminalNode
	SECONDARY_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	SignedLiteral() ISignedLiteralContext
	NOW_SYMBOL() antlr.TerminalNode
	ExprWithParentheses() IExprWithParenthesesContext
	TimeFunctionParameters() ITimeFunctionParametersContext
	UPDATE_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	PRIMARY_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	COMMENT_SYMBOL() antlr.TerminalNode
	Collate() ICollateContext
	ColumnFormat() IColumnFormatContext
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	StorageMedia() IStorageMediaContext
	STORAGE_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	SRID_SYMBOL() antlr.TerminalNode
	CheckConstraint() ICheckConstraintContext
	ConstraintName() IConstraintNameContext
	ConstraintEnforcement() IConstraintEnforcementContext

	// IsColumnAttributeContext differentiates from other interfaces.
	IsColumnAttributeContext()
}

type ColumnAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
}

func NewEmptyColumnAttributeContext() *ColumnAttributeContext {
	var p = new(ColumnAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnAttribute
	return p
}

func InitEmptyColumnAttributeContext(p *ColumnAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnAttribute
}

func (*ColumnAttributeContext) IsColumnAttributeContext() {}

func NewColumnAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAttributeContext {
	var p = new(ColumnAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnAttribute

	return p
}

func (s *ColumnAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAttributeContext) GetValue() antlr.Token { return s.value }

func (s *ColumnAttributeContext) SetValue(v antlr.Token) { s.value = v }

func (s *ColumnAttributeContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *ColumnAttributeContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOT_SYMBOL, 0)
}

func (s *ColumnAttributeContext) SECONDARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_SYMBOL, 0)
}

func (s *ColumnAttributeContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *ColumnAttributeContext) SignedLiteral() ISignedLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedLiteralContext)
}

func (s *ColumnAttributeContext) NOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOW_SYMBOL, 0)
}

func (s *ColumnAttributeContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *ColumnAttributeContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *ColumnAttributeContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *ColumnAttributeContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, 0)
}

func (s *ColumnAttributeContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *ColumnAttributeContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUE_SYMBOL, 0)
}

func (s *ColumnAttributeContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIAL_SYMBOL, 0)
}

func (s *ColumnAttributeContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *ColumnAttributeContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *ColumnAttributeContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNIQUE_SYMBOL, 0)
}

func (s *ColumnAttributeContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *ColumnAttributeContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *ColumnAttributeContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *ColumnAttributeContext) ColumnFormat() IColumnFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFormatContext)
}

func (s *ColumnAttributeContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *ColumnAttributeContext) StorageMedia() IStorageMediaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageMediaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageMediaContext)
}

func (s *ColumnAttributeContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *ColumnAttributeContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *ColumnAttributeContext) SRID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSRID_SYMBOL, 0)
}

func (s *ColumnAttributeContext) CheckConstraint() ICheckConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckConstraintContext)
}

func (s *ColumnAttributeContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ColumnAttributeContext) ConstraintEnforcement() IConstraintEnforcementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintEnforcementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintEnforcementContext)
}

func (s *ColumnAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnAttribute(s)
	}
}

func (s *ColumnAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnAttribute(s)
	}
}

func (s *ColumnAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnAttribute() (localctx IColumnAttributeContext) {
	localctx = NewColumnAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, MySQLParserRULE_columnAttribute)
	var _la int

	p.SetState(7055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 900, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL {
			{
				p.SetState(7003)
				p.Match(MySQLParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7006)
			p.NullLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7007)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(7008)
			p.Match(MySQLParserNOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7009)
			p.Match(MySQLParserSECONDARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7010)

			var _m = p.Match(MySQLParserDEFAULT_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 895, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7011)
				p.SignedLiteral()
			}

		case 2:
			{
				p.SetState(7012)
				p.Match(MySQLParserNOW_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7014)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 894, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7013)
					p.TimeFunctionParameters()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 3:
			p.SetState(7016)

			if !(serverVersion >= 80013) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80013", ""))
				goto errorExit
			}
			{
				p.SetState(7017)
				p.ExprWithParentheses()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7020)

			var _m = p.Match(MySQLParserON_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7021)
			p.Match(MySQLParserUPDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7022)
			p.Match(MySQLParserNOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7024)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 896, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7023)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7026)

			var _m = p.Match(MySQLParserAUTO_INCREMENT_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7027)

			var _m = p.Match(MySQLParserSERIAL_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7028)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7029)
			p.Match(MySQLParserVALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		p.SetState(7031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserPRIMARY_SYMBOL {
			{
				p.SetState(7030)
				p.Match(MySQLParserPRIMARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7033)

			var _m = p.Match(MySQLParserKEY_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7034)

			var _m = p.Match(MySQLParserUNIQUE_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7036)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 898, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7035)
				p.Match(MySQLParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7038)

			var _m = p.Match(MySQLParserCOMMENT_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7039)
			p.TextLiteral()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7040)
			p.Collate()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7041)

			var _m = p.Match(MySQLParserCOLUMN_FORMAT_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7042)
			p.ColumnFormat()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7043)

			var _m = p.Match(MySQLParserSTORAGE_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7044)
			p.StorageMedia()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		p.SetState(7045)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(7046)

			var _m = p.Match(MySQLParserSRID_SYMBOL)

			localctx.(*ColumnAttributeContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7047)
			p.Real_ulonglong_number()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		p.SetState(7048)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		p.SetState(7050)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserCONSTRAINT_SYMBOL {
			{
				p.SetState(7049)
				p.ConstraintName()
			}

		}
		{
			p.SetState(7052)
			p.CheckConstraint()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		p.SetState(7053)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(7054)
			p.ConstraintEnforcement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnFormatContext is an interface to support dynamic dispatch.
type IColumnFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIXED_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsColumnFormatContext differentiates from other interfaces.
	IsColumnFormatContext()
}

type ColumnFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnFormatContext() *ColumnFormatContext {
	var p = new(ColumnFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnFormat
	return p
}

func InitEmptyColumnFormatContext(p *ColumnFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnFormat
}

func (*ColumnFormatContext) IsColumnFormatContext() {}

func NewColumnFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnFormatContext {
	var p = new(ColumnFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnFormat

	return p
}

func (s *ColumnFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnFormatContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIXED_SYMBOL, 0)
}

func (s *ColumnFormatContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDYNAMIC_SYMBOL, 0)
}

func (s *ColumnFormatContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *ColumnFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnFormat(s)
	}
}

func (s *ColumnFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnFormat(s)
	}
}

func (s *ColumnFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnFormat() (localctx IColumnFormatContext) {
	localctx = NewColumnFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, MySQLParserRULE_columnFormat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7057)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserDYNAMIC_SYMBOL || _la == MySQLParserFIXED_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageMediaContext is an interface to support dynamic dispatch.
type IStorageMediaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISK_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsStorageMediaContext differentiates from other interfaces.
	IsStorageMediaContext()
}

type StorageMediaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageMediaContext() *StorageMediaContext {
	var p = new(StorageMediaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_storageMedia
	return p
}

func InitEmptyStorageMediaContext(p *StorageMediaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_storageMedia
}

func (*StorageMediaContext) IsStorageMediaContext() {}

func NewStorageMediaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageMediaContext {
	var p = new(StorageMediaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_storageMedia

	return p
}

func (s *StorageMediaContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageMediaContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISK_SYMBOL, 0)
}

func (s *StorageMediaContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMORY_SYMBOL, 0)
}

func (s *StorageMediaContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *StorageMediaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageMediaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageMediaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStorageMedia(s)
	}
}

func (s *StorageMediaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStorageMedia(s)
	}
}

func (s *StorageMediaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStorageMedia(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StorageMedia() (localctx IStorageMediaContext) {
	localctx = NewStorageMediaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, MySQLParserRULE_storageMedia)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7059)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserDEFAULT_SYMBOL || _la == MySQLParserDISK_SYMBOL || _la == MySQLParserMEMORY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGcolAttributeContext is an interface to support dynamic dispatch.
type IGcolAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIQUE_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	NULL_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	PRIMARY_SYMBOL() antlr.TerminalNode

	// IsGcolAttributeContext differentiates from other interfaces.
	IsGcolAttributeContext()
}

type GcolAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGcolAttributeContext() *GcolAttributeContext {
	var p = new(GcolAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_gcolAttribute
	return p
}

func InitEmptyGcolAttributeContext(p *GcolAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_gcolAttribute
}

func (*GcolAttributeContext) IsGcolAttributeContext() {}

func NewGcolAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GcolAttributeContext {
	var p = new(GcolAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_gcolAttribute

	return p
}

func (s *GcolAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *GcolAttributeContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNIQUE_SYMBOL, 0)
}

func (s *GcolAttributeContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *GcolAttributeContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *GcolAttributeContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *GcolAttributeContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *GcolAttributeContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *GcolAttributeContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIMARY_SYMBOL, 0)
}

func (s *GcolAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GcolAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GcolAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterGcolAttribute(s)
	}
}

func (s *GcolAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitGcolAttribute(s)
	}
}

func (s *GcolAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitGcolAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) GcolAttribute() (localctx IGcolAttributeContext) {
	localctx = NewGcolAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, MySQLParserRULE_gcolAttribute)
	var _la int

	p.SetState(7075)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7061)
			p.Match(MySQLParserUNIQUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7063)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 901, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7062)
				p.Match(MySQLParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7065)
			p.Match(MySQLParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7066)
			p.TextString()
		}

	case MySQLParserNOT_SYMBOL, MySQLParserNULL_SYMBOL, MySQLParserNOT2_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserNOT_SYMBOL || _la == MySQLParserNOT2_SYMBOL {
			{
				p.SetState(7067)
				p.NotRule()
			}

		}
		{
			p.SetState(7070)
			p.Match(MySQLParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserKEY_SYMBOL, MySQLParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserPRIMARY_SYMBOL {
			{
				p.SetState(7071)
				p.Match(MySQLParserPRIMARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7074)
			p.Match(MySQLParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferencesContext is an interface to support dynamic dispatch.
type IReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatch returns the match token.
	GetMatch() antlr.Token

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetMatch sets the match token.
	SetMatch(antlr.Token)

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	REFERENCES_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	MATCH_SYMBOL() antlr.TerminalNode
	AllON_SYMBOL() []antlr.TerminalNode
	ON_SYMBOL(i int) antlr.TerminalNode
	AllDeleteOption() []IDeleteOptionContext
	DeleteOption(i int) IDeleteOptionContext
	UPDATE_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode

	// IsReferencesContext differentiates from other interfaces.
	IsReferencesContext()
}

type ReferencesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	match  antlr.Token
	option antlr.Token
}

func NewEmptyReferencesContext() *ReferencesContext {
	var p = new(ReferencesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_references
	return p
}

func InitEmptyReferencesContext(p *ReferencesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_references
}

func (*ReferencesContext) IsReferencesContext() {}

func NewReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencesContext {
	var p = new(ReferencesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_references

	return p
}

func (s *ReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencesContext) GetMatch() antlr.Token { return s.match }

func (s *ReferencesContext) GetOption() antlr.Token { return s.option }

func (s *ReferencesContext) SetMatch(v antlr.Token) { s.match = v }

func (s *ReferencesContext) SetOption(v antlr.Token) { s.option = v }

func (s *ReferencesContext) REFERENCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREFERENCES_SYMBOL, 0)
}

func (s *ReferencesContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ReferencesContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *ReferencesContext) MATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMATCH_SYMBOL, 0)
}

func (s *ReferencesContext) AllON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserON_SYMBOL)
}

func (s *ReferencesContext) ON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserON_SYMBOL, i)
}

func (s *ReferencesContext) AllDeleteOption() []IDeleteOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteOptionContext); ok {
			len++
		}
	}

	tst := make([]IDeleteOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteOptionContext); ok {
			tst[i] = t.(IDeleteOptionContext)
			i++
		}
	}

	return tst
}

func (s *ReferencesContext) DeleteOption(i int) IDeleteOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOptionContext)
}

func (s *ReferencesContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPDATE_SYMBOL, 0)
}

func (s *ReferencesContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELETE_SYMBOL, 0)
}

func (s *ReferencesContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULL_SYMBOL, 0)
}

func (s *ReferencesContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTIAL_SYMBOL, 0)
}

func (s *ReferencesContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIMPLE_SYMBOL, 0)
}

func (s *ReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReferences(s)
	}
}

func (s *ReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReferences(s)
	}
}

func (s *ReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) References() (localctx IReferencesContext) {
	localctx = NewReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, MySQLParserRULE_references)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7077)
		p.Match(MySQLParserREFERENCES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7078)
		p.TableRef()
	}
	p.SetState(7080)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(7079)
			p.IdentifierListWithParentheses()
		}

	}
	p.SetState(7084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserMATCH_SYMBOL {
		{
			p.SetState(7082)
			p.Match(MySQLParserMATCH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7083)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferencesContext).match = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserFULL_SYMBOL || _la == MySQLParserPARTIAL_SYMBOL || _la == MySQLParserSIMPLE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferencesContext).match = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(7102)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 909, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7086)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7087)

			var _m = p.Match(MySQLParserUPDATE_SYMBOL)

			localctx.(*ReferencesContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7088)
			p.DeleteOption()
		}
		p.SetState(7092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserON_SYMBOL {
			{
				p.SetState(7089)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7090)
				p.Match(MySQLParserDELETE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7091)
				p.DeleteOption()
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 909, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7094)
			p.Match(MySQLParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7095)

			var _m = p.Match(MySQLParserDELETE_SYMBOL)

			localctx.(*ReferencesContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7096)
			p.DeleteOption()
		}
		p.SetState(7100)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserON_SYMBOL {
			{
				p.SetState(7097)
				p.Match(MySQLParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7098)
				p.Match(MySQLParserUPDATE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7099)
				p.DeleteOption()
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOptionContext is an interface to support dynamic dispatch.
type IDeleteOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	NullLiteral() INullLiteralContext
	NO_SYMBOL() antlr.TerminalNode
	ACTION_SYMBOL() antlr.TerminalNode

	// IsDeleteOptionContext differentiates from other interfaces.
	IsDeleteOptionContext()
}

type DeleteOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOptionContext() *DeleteOptionContext {
	var p = new(DeleteOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteOption
	return p
}

func InitEmptyDeleteOptionContext(p *DeleteOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_deleteOption
}

func (*DeleteOptionContext) IsDeleteOptionContext() {}

func NewDeleteOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOptionContext {
	var p = new(DeleteOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_deleteOption

	return p
}

func (s *DeleteOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOptionContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTRICT_SYMBOL, 0)
}

func (s *DeleteOptionContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADE_SYMBOL, 0)
}

func (s *DeleteOptionContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *DeleteOptionContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *DeleteOptionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *DeleteOptionContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTION_SYMBOL, 0)
}

func (s *DeleteOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDeleteOption(s)
	}
}

func (s *DeleteOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDeleteOption(s)
	}
}

func (s *DeleteOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDeleteOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DeleteOption() (localctx IDeleteOptionContext) {
	localctx = NewDeleteOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, MySQLParserRULE_deleteOption)
	var _la int

	p.SetState(7109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserCASCADE_SYMBOL, MySQLParserRESTRICT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7104)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCASCADE_SYMBOL || _la == MySQLParserRESTRICT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case MySQLParserSET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7105)
			p.Match(MySQLParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7106)
			p.NullLiteral()
		}

	case MySQLParserNO_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7107)
			p.Match(MySQLParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7108)
			p.Match(MySQLParserACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListContext is an interface to support dynamic dispatch.
type IKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllKeyPart() []IKeyPartContext
	KeyPart(i int) IKeyPartContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyListContext differentiates from other interfaces.
	IsKeyListContext()
}

type KeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListContext() *KeyListContext {
	var p = new(KeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyList
	return p
}

func InitEmptyKeyListContext(p *KeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyList
}

func (*KeyListContext) IsKeyListContext() {}

func NewKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListContext {
	var p = new(KeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyList

	return p
}

func (s *KeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *KeyListContext) AllKeyPart() []IKeyPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartContext); ok {
			tst[i] = t.(IKeyPartContext)
			i++
		}
	}

	return tst
}

func (s *KeyListContext) KeyPart(i int) IKeyPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartContext)
}

func (s *KeyListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *KeyListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *KeyListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *KeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyList(s)
	}
}

func (s *KeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyList(s)
	}
}

func (s *KeyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyList() (localctx IKeyListContext) {
	localctx = NewKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, MySQLParserRULE_keyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7111)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7112)
		p.KeyPart()
	}
	p.SetState(7117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(7113)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7114)
			p.KeyPart()
		}

		p.SetState(7119)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7120)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartContext is an interface to support dynamic dispatch.
type IKeyPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FieldLength() IFieldLengthContext
	Direction() IDirectionContext

	// IsKeyPartContext differentiates from other interfaces.
	IsKeyPartContext()
}

type KeyPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartContext() *KeyPartContext {
	var p = new(KeyPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyPart
	return p
}

func InitEmptyKeyPartContext(p *KeyPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyPart
}

func (*KeyPartContext) IsKeyPartContext() {}

func NewKeyPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartContext {
	var p = new(KeyPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyPart

	return p
}

func (s *KeyPartContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *KeyPartContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *KeyPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyPart(s)
	}
}

func (s *KeyPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyPart(s)
	}
}

func (s *KeyPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyPart() (localctx IKeyPartContext) {
	localctx = NewKeyPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, MySQLParserRULE_keyPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7122)
		p.Identifier()
	}
	p.SetState(7124)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(7123)
			p.FieldLength()
		}

	}
	p.SetState(7127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL {
		{
			p.SetState(7126)
			p.Direction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListWithExpressionContext is an interface to support dynamic dispatch.
type IKeyListWithExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllKeyPartOrExpression() []IKeyPartOrExpressionContext
	KeyPartOrExpression(i int) IKeyPartOrExpressionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyListWithExpressionContext differentiates from other interfaces.
	IsKeyListWithExpressionContext()
}

type KeyListWithExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListWithExpressionContext() *KeyListWithExpressionContext {
	var p = new(KeyListWithExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyListWithExpression
	return p
}

func InitEmptyKeyListWithExpressionContext(p *KeyListWithExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyListWithExpression
}

func (*KeyListWithExpressionContext) IsKeyListWithExpressionContext() {}

func NewKeyListWithExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListWithExpressionContext {
	var p = new(KeyListWithExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyListWithExpression

	return p
}

func (s *KeyListWithExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListWithExpressionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *KeyListWithExpressionContext) AllKeyPartOrExpression() []IKeyPartOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartOrExpressionContext); ok {
			tst[i] = t.(IKeyPartOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyListWithExpressionContext) KeyPartOrExpression(i int) IKeyPartOrExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartOrExpressionContext)
}

func (s *KeyListWithExpressionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *KeyListWithExpressionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *KeyListWithExpressionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *KeyListWithExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListWithExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListWithExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyListWithExpression(s)
	}
}

func (s *KeyListWithExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyListWithExpression(s)
	}
}

func (s *KeyListWithExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyListWithExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyListWithExpression() (localctx IKeyListWithExpressionContext) {
	localctx = NewKeyListWithExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, MySQLParserRULE_keyListWithExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7129)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7130)
		p.KeyPartOrExpression()
	}
	p.SetState(7135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(7131)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7132)
			p.KeyPartOrExpression()
		}

		p.SetState(7137)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7138)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartOrExpressionContext is an interface to support dynamic dispatch.
type IKeyPartOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyPart() IKeyPartContext
	ExprWithParentheses() IExprWithParenthesesContext
	Direction() IDirectionContext

	// IsKeyPartOrExpressionContext differentiates from other interfaces.
	IsKeyPartOrExpressionContext()
}

type KeyPartOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartOrExpressionContext() *KeyPartOrExpressionContext {
	var p = new(KeyPartOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyPartOrExpression
	return p
}

func InitEmptyKeyPartOrExpressionContext(p *KeyPartOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyPartOrExpression
}

func (*KeyPartOrExpressionContext) IsKeyPartOrExpressionContext() {}

func NewKeyPartOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartOrExpressionContext {
	var p = new(KeyPartOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyPartOrExpression

	return p
}

func (s *KeyPartOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartOrExpressionContext) KeyPart() IKeyPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartContext)
}

func (s *KeyPartOrExpressionContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *KeyPartOrExpressionContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *KeyPartOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyPartOrExpression(s)
	}
}

func (s *KeyPartOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyPartOrExpression(s)
	}
}

func (s *KeyPartOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyPartOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyPartOrExpression() (localctx IKeyPartOrExpressionContext) {
	localctx = NewKeyPartOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, MySQLParserRULE_keyPartOrExpression)
	var _la int

	p.SetState(7145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 916, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7140)
			p.KeyPart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7141)
			p.ExprWithParentheses()
		}
		p.SetState(7143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserASC_SYMBOL || _la == MySQLParserDESC_SYMBOL {
			{
				p.SetState(7142)
				p.Direction()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListVariantsContext is an interface to support dynamic dispatch.
type IKeyListVariantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyListWithExpression() IKeyListWithExpressionContext
	KeyList() IKeyListContext

	// IsKeyListVariantsContext differentiates from other interfaces.
	IsKeyListVariantsContext()
}

type KeyListVariantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListVariantsContext() *KeyListVariantsContext {
	var p = new(KeyListVariantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyListVariants
	return p
}

func InitEmptyKeyListVariantsContext(p *KeyListVariantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_keyListVariants
}

func (*KeyListVariantsContext) IsKeyListVariantsContext() {}

func NewKeyListVariantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListVariantsContext {
	var p = new(KeyListVariantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_keyListVariants

	return p
}

func (s *KeyListVariantsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListVariantsContext) KeyListWithExpression() IKeyListWithExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListWithExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListWithExpressionContext)
}

func (s *KeyListVariantsContext) KeyList() IKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListContext)
}

func (s *KeyListVariantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListVariantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListVariantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterKeyListVariants(s)
	}
}

func (s *KeyListVariantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitKeyListVariants(s)
	}
}

func (s *KeyListVariantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitKeyListVariants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) KeyListVariants() (localctx IKeyListVariantsContext) {
	localctx = NewKeyListVariantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, MySQLParserRULE_keyListVariants)
	p.SetState(7151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 917, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7147)

		if !(serverVersion >= 80013) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80013", ""))
			goto errorExit
		}
		{
			p.SetState(7148)
			p.KeyListWithExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7149)

		if !(serverVersion < 80013) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80013", ""))
			goto errorExit
		}
		{
			p.SetState(7150)
			p.KeyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgorithm returns the algorithm token.
	GetAlgorithm() antlr.Token

	// SetAlgorithm sets the algorithm token.
	SetAlgorithm(antlr.Token)

	// Getter signatures
	BTREE_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	algorithm antlr.Token
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) GetAlgorithm() antlr.Token { return s.algorithm }

func (s *IndexTypeContext) SetAlgorithm(v antlr.Token) { s.algorithm = v }

func (s *IndexTypeContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBTREE_SYMBOL, 0)
}

func (s *IndexTypeContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRTREE_SYMBOL, 0)
}

func (s *IndexTypeContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHASH_SYMBOL, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, MySQLParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7153)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexTypeContext).algorithm = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserBTREE_SYMBOL || _la == MySQLParserHASH_SYMBOL || _la == MySQLParserRTREE_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexTypeContext).algorithm = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext
	IndexTypeClause() IIndexTypeClauseContext

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *IndexOptionContext) IndexTypeClause() IIndexTypeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeClauseContext)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, MySQLParserRULE_indexOption)
	p.SetState(7157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 918, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7155)
			p.CommonIndexOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7156)
			p.IndexTypeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonIndexOptionContext is an interface to support dynamic dispatch.
type ICommonIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	EQUAL_OPERATOR() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	Visibility() IVisibilityContext

	// IsCommonIndexOptionContext differentiates from other interfaces.
	IsCommonIndexOptionContext()
}

type CommonIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonIndexOptionContext() *CommonIndexOptionContext {
	var p = new(CommonIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_commonIndexOption
	return p
}

func InitEmptyCommonIndexOptionContext(p *CommonIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_commonIndexOption
}

func (*CommonIndexOptionContext) IsCommonIndexOptionContext() {}

func NewCommonIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonIndexOptionContext {
	var p = new(CommonIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_commonIndexOption

	return p
}

func (s *CommonIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonIndexOptionContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *CommonIndexOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CommonIndexOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *CommonIndexOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *CommonIndexOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *CommonIndexOptionContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *CommonIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCommonIndexOption(s)
	}
}

func (s *CommonIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCommonIndexOption(s)
	}
}

func (s *CommonIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCommonIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CommonIndexOption() (localctx ICommonIndexOptionContext) {
	localctx = NewCommonIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, MySQLParserRULE_commonIndexOption)
	var _la int

	p.SetState(7168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 920, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7159)
			p.Match(MySQLParserKEY_BLOCK_SIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7160)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7163)
			p.Ulong_number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7164)
			p.Match(MySQLParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7165)
			p.TextLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7166)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(7167)
			p.Visibility()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VISIBLE_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode

	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_visibility
	return p
}

func InitEmptyVisibilityContext(p *VisibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_visibility
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVISIBLE_SYMBOL, 0)
}

func (s *VisibilityContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVISIBLE_SYMBOL, 0)
}

func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (s *VisibilityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVisibility(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Visibility() (localctx IVisibilityContext) {
	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, MySQLParserRULE_visibility)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7170)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserINVISIBLE_SYMBOL || _la == MySQLParserVISIBLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeClauseContext is an interface to support dynamic dispatch.
type IIndexTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexType() IIndexTypeContext
	USING_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode

	// IsIndexTypeClauseContext differentiates from other interfaces.
	IsIndexTypeClauseContext()
}

type IndexTypeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeClauseContext() *IndexTypeClauseContext {
	var p = new(IndexTypeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexTypeClause
	return p
}

func InitEmptyIndexTypeClauseContext(p *IndexTypeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexTypeClause
}

func (*IndexTypeClauseContext) IsIndexTypeClauseContext() {}

func NewIndexTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeClauseContext {
	var p = new(IndexTypeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexTypeClause

	return p
}

func (s *IndexTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexTypeClauseContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSING_SYMBOL, 0)
}

func (s *IndexTypeClauseContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPE_SYMBOL, 0)
}

func (s *IndexTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexTypeClause(s)
	}
}

func (s *IndexTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexTypeClause(s)
	}
}

func (s *IndexTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexTypeClause() (localctx IIndexTypeClauseContext) {
	localctx = NewIndexTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, MySQLParserRULE_indexTypeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7172)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserTYPE_SYMBOL || _la == MySQLParserUSING_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7173)
		p.IndexType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFulltextIndexOptionContext is an interface to support dynamic dispatch.
type IFulltextIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext
	WITH_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFulltextIndexOptionContext differentiates from other interfaces.
	IsFulltextIndexOptionContext()
}

type FulltextIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFulltextIndexOptionContext() *FulltextIndexOptionContext {
	var p = new(FulltextIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fulltextIndexOption
	return p
}

func InitEmptyFulltextIndexOptionContext(p *FulltextIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fulltextIndexOption
}

func (*FulltextIndexOptionContext) IsFulltextIndexOptionContext() {}

func NewFulltextIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FulltextIndexOptionContext {
	var p = new(FulltextIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fulltextIndexOption

	return p
}

func (s *FulltextIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FulltextIndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *FulltextIndexOptionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *FulltextIndexOptionContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARSER_SYMBOL, 0)
}

func (s *FulltextIndexOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FulltextIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FulltextIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FulltextIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFulltextIndexOption(s)
	}
}

func (s *FulltextIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFulltextIndexOption(s)
	}
}

func (s *FulltextIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFulltextIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FulltextIndexOption() (localctx IFulltextIndexOptionContext) {
	localctx = NewFulltextIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, MySQLParserRULE_fulltextIndexOption)
	p.SetState(7179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 921, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7175)
			p.CommonIndexOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7176)
			p.Match(MySQLParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7177)
			p.Match(MySQLParserPARSER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7178)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpatialIndexOptionContext is an interface to support dynamic dispatch.
type ISpatialIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext

	// IsSpatialIndexOptionContext differentiates from other interfaces.
	IsSpatialIndexOptionContext()
}

type SpatialIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpatialIndexOptionContext() *SpatialIndexOptionContext {
	var p = new(SpatialIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spatialIndexOption
	return p
}

func InitEmptySpatialIndexOptionContext(p *SpatialIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_spatialIndexOption
}

func (*SpatialIndexOptionContext) IsSpatialIndexOptionContext() {}

func NewSpatialIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpatialIndexOptionContext {
	var p = new(SpatialIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_spatialIndexOption

	return p
}

func (s *SpatialIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpatialIndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *SpatialIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpatialIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSpatialIndexOption(s)
	}
}

func (s *SpatialIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSpatialIndexOption(s)
	}
}

func (s *SpatialIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSpatialIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SpatialIndexOption() (localctx ISpatialIndexOptionContext) {
	localctx = NewSpatialIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, MySQLParserRULE_spatialIndexOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7181)
		p.CommonIndexOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeDefinitionContext is an interface to support dynamic dispatch.
type IDataTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	EOF() antlr.TerminalNode

	// IsDataTypeDefinitionContext differentiates from other interfaces.
	IsDataTypeDefinitionContext()
}

type DataTypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefinitionContext() *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataTypeDefinition
	return p
}

func InitEmptyDataTypeDefinitionContext(p *DataTypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataTypeDefinition
}

func (*DataTypeDefinitionContext) IsDataTypeDefinitionContext() {}

func NewDataTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dataTypeDefinition

	return p
}

func (s *DataTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeDefinitionContext) EOF() antlr.TerminalNode {
	return s.GetToken(MySQLParserEOF, 0)
}

func (s *DataTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDataTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DataTypeDefinition() (localctx IDataTypeDefinitionContext) {
	localctx = NewDataTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, MySQLParserRULE_dataTypeDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7183)
		p.DataType()
	}
	{
		p.SetState(7184)
		p.Match(MySQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	INT_SYMBOL() antlr.TerminalNode
	TINYINT_SYMBOL() antlr.TerminalNode
	SMALLINT_SYMBOL() antlr.TerminalNode
	MEDIUMINT_SYMBOL() antlr.TerminalNode
	BIGINT_SYMBOL() antlr.TerminalNode
	FieldLength() IFieldLengthContext
	FieldOptions() IFieldOptionsContext
	REAL_SYMBOL() antlr.TerminalNode
	DOUBLE_SYMBOL() antlr.TerminalNode
	Precision() IPrecisionContext
	PRECISION_SYMBOL() antlr.TerminalNode
	FLOAT_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	NUMERIC_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	FloatOptions() IFloatOptionsContext
	BIT_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	CharsetWithOptBinary() ICharsetWithOptBinaryContext
	Nchar() INcharContext
	BINARY_SYMBOL() antlr.TerminalNode
	VARYING_SYMBOL() antlr.TerminalNode
	VARCHAR_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	VARBINARY_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TypeDatetimePrecision() ITypeDatetimePrecisionContext
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	TINYBLOB_SYMBOL() antlr.TerminalNode
	BLOB_SYMBOL() antlr.TerminalNode
	MEDIUMBLOB_SYMBOL() antlr.TerminalNode
	LONGBLOB_SYMBOL() antlr.TerminalNode
	LONG_SYMBOL() antlr.TerminalNode
	TINYTEXT_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	MEDIUMTEXT_SYMBOL() antlr.TerminalNode
	LONGTEXT_SYMBOL() antlr.TerminalNode
	StringList() IStringListContext
	ENUM_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *DataTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *DataTypeContext) INT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_SYMBOL, 0)
}

func (s *DataTypeContext) TINYINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTINYINT_SYMBOL, 0)
}

func (s *DataTypeContext) SMALLINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSMALLINT_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUMINT_SYMBOL, 0)
}

func (s *DataTypeContext) BIGINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIGINT_SYMBOL, 0)
}

func (s *DataTypeContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *DataTypeContext) FieldOptions() IFieldOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOptionsContext)
}

func (s *DataTypeContext) REAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAL_SYMBOL, 0)
}

func (s *DataTypeContext) DOUBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOUBLE_SYMBOL, 0)
}

func (s *DataTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *DataTypeContext) PRECISION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECISION_SYMBOL, 0)
}

func (s *DataTypeContext) FLOAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLOAT_SYMBOL, 0)
}

func (s *DataTypeContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_SYMBOL, 0)
}

func (s *DataTypeContext) NUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNUMERIC_SYMBOL, 0)
}

func (s *DataTypeContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIXED_SYMBOL, 0)
}

func (s *DataTypeContext) FloatOptions() IFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatOptionsContext)
}

func (s *DataTypeContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_SYMBOL, 0)
}

func (s *DataTypeContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOL_SYMBOL, 0)
}

func (s *DataTypeContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOLEAN_SYMBOL, 0)
}

func (s *DataTypeContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) CharsetWithOptBinary() ICharsetWithOptBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetWithOptBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetWithOptBinaryContext)
}

func (s *DataTypeContext) Nchar() INcharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INcharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INcharContext)
}

func (s *DataTypeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *DataTypeContext) VARYING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARYING_SYMBOL, 0)
}

func (s *DataTypeContext) VARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATIONAL_SYMBOL, 0)
}

func (s *DataTypeContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNVARCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) VARBINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARBINARY_SYMBOL, 0)
}

func (s *DataTypeContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_SYMBOL, 0)
}

func (s *DataTypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *DataTypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *DataTypeContext) TypeDatetimePrecision() ITypeDatetimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDatetimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDatetimePrecisionContext)
}

func (s *DataTypeContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *DataTypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATETIME_SYMBOL, 0)
}

func (s *DataTypeContext) TINYBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTINYBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) BLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUMBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) LONGBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONGBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) LONG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_SYMBOL, 0)
}

func (s *DataTypeContext) TINYTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTINYTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUMTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) LONGTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONGTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataTypeContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENUM_SYMBOL, 0)
}

func (s *DataTypeContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSET_SYMBOL, 0)
}

func (s *DataTypeContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIAL_SYMBOL, 0)
}

func (s *DataTypeContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_SYMBOL, 0)
}

func (s *DataTypeContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRY_SYMBOL, 0)
}

func (s *DataTypeContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *DataTypeContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOINT_SYMBOL, 0)
}

func (s *DataTypeContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOINT_SYMBOL, 0)
}

func (s *DataTypeContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINESTRING_SYMBOL, 0)
}

func (s *DataTypeContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTILINESTRING_SYMBOL, 0)
}

func (s *DataTypeContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOLYGON_SYMBOL, 0)
}

func (s *DataTypeContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, MySQLParserRULE_dataType)
	var _la int

	p.SetState(7333)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 955, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7186)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBIGINT_SYMBOL || _la == MySQLParserINT_SYMBOL || _la == MySQLParserMEDIUMINT_SYMBOL || _la == MySQLParserSMALLINT_SYMBOL || _la == MySQLParserTINYINT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7188)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 922, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7187)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7191)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 923, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7190)
				p.FieldOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserREAL_SYMBOL:
			{
				p.SetState(7193)

				var _m = p.Match(MySQLParserREAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySQLParserDOUBLE_SYMBOL:
			{
				p.SetState(7194)

				var _m = p.Match(MySQLParserDOUBLE_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7196)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 924, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7195)
					p.Match(MySQLParserPRECISION_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(7201)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 926, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7200)
				p.Precision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7204)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 927, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7203)
				p.FieldOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7206)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDECIMAL_SYMBOL || _la == MySQLParserFIXED_SYMBOL || _la == MySQLParserFLOAT_SYMBOL || _la == MySQLParserNUMERIC_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7208)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 928, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7207)
				p.FloatOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7211)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 929, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7210)
				p.FieldOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7213)

			var _m = p.Match(MySQLParserBIT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 930, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7214)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7217)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserBOOLEAN_SYMBOL || _la == MySQLParserBOOL_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7218)

			var _m = p.Match(MySQLParserCHAR_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7220)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 931, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7219)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 932, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7222)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7225)
			p.Nchar()
		}
		p.SetState(7227)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 933, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7226)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7230)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 934, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7229)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7232)

			var _m = p.Match(MySQLParserBINARY_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7234)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 935, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7233)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(7239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserCHAR_SYMBOL:
			{
				p.SetState(7236)

				var _m = p.Match(MySQLParserCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7237)
				p.Match(MySQLParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySQLParserVARCHAR_SYMBOL:
			{
				p.SetState(7238)

				var _m = p.Match(MySQLParserVARCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(7241)
			p.FieldLength()
		}
		p.SetState(7243)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 937, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7242)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(7255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 938, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7245)

				var _m = p.Match(MySQLParserNATIONAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7246)
				p.Match(MySQLParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(7247)

				var _m = p.Match(MySQLParserNVARCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(7248)

				var _m = p.Match(MySQLParserNCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7249)
				p.Match(MySQLParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(7250)

				var _m = p.Match(MySQLParserNATIONAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7251)
				p.Match(MySQLParserCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7252)
				p.Match(MySQLParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(7253)

				var _m = p.Match(MySQLParserNCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7254)
				p.Match(MySQLParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7257)
			p.FieldLength()
		}
		p.SetState(7259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 939, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7258)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7261)

			var _m = p.Match(MySQLParserVARBINARY_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7262)
			p.FieldLength()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7263)

			var _m = p.Match(MySQLParserYEAR_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7265)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 940, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7264)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7268)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 941, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7267)
				p.FieldOptions()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7270)

			var _m = p.Match(MySQLParserDATE_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7271)

			var _m = p.Match(MySQLParserTIME_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7273)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 942, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7272)
				p.TypeDatetimePrecision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7275)

			var _m = p.Match(MySQLParserTIMESTAMP_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7277)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 943, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7276)
				p.TypeDatetimePrecision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7279)

			var _m = p.Match(MySQLParserDATETIME_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7281)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 944, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7280)
				p.TypeDatetimePrecision()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7283)

			var _m = p.Match(MySQLParserTINYBLOB_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7284)

			var _m = p.Match(MySQLParserBLOB_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7286)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 945, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7285)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7288)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLONGBLOB_SYMBOL || _la == MySQLParserMEDIUMBLOB_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7289)

			var _m = p.Match(MySQLParserLONG_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.Match(MySQLParserVARBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7291)

			var _m = p.Match(MySQLParserLONG_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7295)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 946, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7292)
				p.Match(MySQLParserCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7293)
				p.Match(MySQLParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 946, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7294)
				p.Match(MySQLParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7298)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 947, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7297)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7300)

			var _m = p.Match(MySQLParserTINYTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7302)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 948, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7301)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7304)

			var _m = p.Match(MySQLParserTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7306)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 949, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7305)
				p.FieldLength()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7309)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 950, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7308)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(7311)

			var _m = p.Match(MySQLParserMEDIUMTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7313)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 951, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7312)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(7315)

			var _m = p.Match(MySQLParserLONGTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7317)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7316)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(7319)

			var _m = p.Match(MySQLParserENUM_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7320)
			p.StringList()
		}
		p.SetState(7322)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 953, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7321)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(7324)

			var _m = p.Match(MySQLParserSET_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7325)
			p.StringList()
		}
		p.SetState(7327)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 954, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7326)
				p.CharsetWithOptBinary()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(7329)

			var _m = p.Match(MySQLParserSERIAL_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		p.SetState(7330)

		if !(serverVersion >= 50708) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50708", ""))
			goto errorExit
		}
		{
			p.SetState(7331)

			var _m = p.Match(MySQLParserJSON_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(7332)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserGEOMETRYCOLLECTION_SYMBOL || _la == MySQLParserGEOMETRY_SYMBOL || _la == MySQLParserLINESTRING_SYMBOL || ((int64((_la-351)) & ^0x3f) == 0 && ((int64(1)<<(_la-351))&3458764513820540935) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INcharContext is an interface to support dynamic dispatch.
type INcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	NCHAR_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode

	// IsNcharContext differentiates from other interfaces.
	IsNcharContext()
}

type NcharContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyNcharContext() *NcharContext {
	var p = new(NcharContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nchar
	return p
}

func InitEmptyNcharContext(p *NcharContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nchar
}

func (*NcharContext) IsNcharContext() {}

func NewNcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NcharContext {
	var p = new(NcharContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_nchar

	return p
}

func (s *NcharContext) GetParser() antlr.Parser { return s.parser }

func (s *NcharContext) GetType_() antlr.Token { return s.type_ }

func (s *NcharContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *NcharContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNCHAR_SYMBOL, 0)
}

func (s *NcharContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAR_SYMBOL, 0)
}

func (s *NcharContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATIONAL_SYMBOL, 0)
}

func (s *NcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNchar(s)
	}
}

func (s *NcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNchar(s)
	}
}

func (s *NcharContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNchar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Nchar() (localctx INcharContext) {
	localctx = NewNcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, MySQLParserRULE_nchar)
	p.SetState(7338)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserNCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7335)

			var _m = p.Match(MySQLParserNCHAR_SYMBOL)

			localctx.(*NcharContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserNATIONAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7336)

			var _m = p.Match(MySQLParserNATIONAL_SYMBOL)

			localctx.(*NcharContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7337)
			p.Match(MySQLParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRealTypeContext is an interface to support dynamic dispatch.
type IRealTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	REAL_SYMBOL() antlr.TerminalNode
	DOUBLE_SYMBOL() antlr.TerminalNode
	PRECISION_SYMBOL() antlr.TerminalNode

	// IsRealTypeContext differentiates from other interfaces.
	IsRealTypeContext()
}

type RealTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyRealTypeContext() *RealTypeContext {
	var p = new(RealTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_realType
	return p
}

func InitEmptyRealTypeContext(p *RealTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_realType
}

func (*RealTypeContext) IsRealTypeContext() {}

func NewRealTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealTypeContext {
	var p = new(RealTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_realType

	return p
}

func (s *RealTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RealTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *RealTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *RealTypeContext) REAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAL_SYMBOL, 0)
}

func (s *RealTypeContext) DOUBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOUBLE_SYMBOL, 0)
}

func (s *RealTypeContext) PRECISION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECISION_SYMBOL, 0)
}

func (s *RealTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRealType(s)
	}
}

func (s *RealTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRealType(s)
	}
}

func (s *RealTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRealType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RealType() (localctx IRealTypeContext) {
	localctx = NewRealTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, MySQLParserRULE_realType)
	p.SetState(7345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserREAL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7340)

			var _m = p.Match(MySQLParserREAL_SYMBOL)

			localctx.(*RealTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserDOUBLE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7341)

			var _m = p.Match(MySQLParserDOUBLE_SYMBOL)

			localctx.(*RealTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7343)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 957, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7342)
				p.Match(MySQLParserPRECISION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldLengthContext is an interface to support dynamic dispatch.
type IFieldLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	DECIMAL_NUMBER() antlr.TerminalNode

	// IsFieldLengthContext differentiates from other interfaces.
	IsFieldLengthContext()
}

type FieldLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldLengthContext() *FieldLengthContext {
	var p = new(FieldLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldLength
	return p
}

func InitEmptyFieldLengthContext(p *FieldLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldLength
}

func (*FieldLengthContext) IsFieldLengthContext() {}

func NewFieldLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldLengthContext {
	var p = new(FieldLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldLength

	return p
}

func (s *FieldLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldLengthContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *FieldLengthContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FieldLengthContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *FieldLengthContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_NUMBER, 0)
}

func (s *FieldLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldLength(s)
	}
}

func (s *FieldLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldLength(s)
	}
}

func (s *FieldLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldLength() (localctx IFieldLengthContext) {
	localctx = NewFieldLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, MySQLParserRULE_fieldLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7347)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7348)
			p.Real_ulonglong_number()
		}

	case 2:
		{
			p.SetState(7349)
			p.Match(MySQLParserDECIMAL_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(7352)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOptionsContext is an interface to support dynamic dispatch.
type IFieldOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSIGNED_SYMBOL() []antlr.TerminalNode
	SIGNED_SYMBOL(i int) antlr.TerminalNode
	AllUNSIGNED_SYMBOL() []antlr.TerminalNode
	UNSIGNED_SYMBOL(i int) antlr.TerminalNode
	AllZEROFILL_SYMBOL() []antlr.TerminalNode
	ZEROFILL_SYMBOL(i int) antlr.TerminalNode

	// IsFieldOptionsContext differentiates from other interfaces.
	IsFieldOptionsContext()
}

type FieldOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOptionsContext() *FieldOptionsContext {
	var p = new(FieldOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldOptions
	return p
}

func InitEmptyFieldOptionsContext(p *FieldOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldOptions
}

func (*FieldOptionsContext) IsFieldOptionsContext() {}

func NewFieldOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOptionsContext {
	var p = new(FieldOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldOptions

	return p
}

func (s *FieldOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOptionsContext) AllSIGNED_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserSIGNED_SYMBOL)
}

func (s *FieldOptionsContext) SIGNED_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserSIGNED_SYMBOL, i)
}

func (s *FieldOptionsContext) AllUNSIGNED_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserUNSIGNED_SYMBOL)
}

func (s *FieldOptionsContext) UNSIGNED_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserUNSIGNED_SYMBOL, i)
}

func (s *FieldOptionsContext) AllZEROFILL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserZEROFILL_SYMBOL)
}

func (s *FieldOptionsContext) ZEROFILL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserZEROFILL_SYMBOL, i)
}

func (s *FieldOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldOptions(s)
	}
}

func (s *FieldOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldOptions(s)
	}
}

func (s *FieldOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldOptions() (localctx IFieldOptionsContext) {
	localctx = NewFieldOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, MySQLParserRULE_fieldOptions)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(7354)
				_la = p.GetTokenStream().LA(1)

				if !(_la == MySQLParserSIGNED_SYMBOL || _la == MySQLParserUNSIGNED_SYMBOL || _la == MySQLParserZEROFILL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(7357)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 960, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetWithOptBinaryContext is an interface to support dynamic dispatch.
type ICharsetWithOptBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ascii() IAsciiContext
	Unicode() IUnicodeContext
	BYTE_SYMBOL() antlr.TerminalNode
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext
	BINARY_SYMBOL() antlr.TerminalNode

	// IsCharsetWithOptBinaryContext differentiates from other interfaces.
	IsCharsetWithOptBinaryContext()
}

type CharsetWithOptBinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetWithOptBinaryContext() *CharsetWithOptBinaryContext {
	var p = new(CharsetWithOptBinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetWithOptBinary
	return p
}

func InitEmptyCharsetWithOptBinaryContext(p *CharsetWithOptBinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetWithOptBinary
}

func (*CharsetWithOptBinaryContext) IsCharsetWithOptBinaryContext() {}

func NewCharsetWithOptBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetWithOptBinaryContext {
	var p = new(CharsetWithOptBinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_charsetWithOptBinary

	return p
}

func (s *CharsetWithOptBinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetWithOptBinaryContext) Ascii() IAsciiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsciiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsciiContext)
}

func (s *CharsetWithOptBinaryContext) Unicode() IUnicodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnicodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnicodeContext)
}

func (s *CharsetWithOptBinaryContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBYTE_SYMBOL, 0)
}

func (s *CharsetWithOptBinaryContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *CharsetWithOptBinaryContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharsetWithOptBinaryContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *CharsetWithOptBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetWithOptBinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetWithOptBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCharsetWithOptBinary(s)
	}
}

func (s *CharsetWithOptBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCharsetWithOptBinary(s)
	}
}

func (s *CharsetWithOptBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCharsetWithOptBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CharsetWithOptBinary() (localctx ICharsetWithOptBinaryContext) {
	localctx = NewCharsetWithOptBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, MySQLParserRULE_charsetWithOptBinary)
	p.SetState(7373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 963, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7359)
			p.Ascii()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7360)
			p.Unicode()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7361)
			p.Match(MySQLParserBYTE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7362)
			p.Charset()
		}
		{
			p.SetState(7363)
			p.CharsetName()
		}
		p.SetState(7365)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 961, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7364)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7367)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7371)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 962, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7368)
				p.Charset()
			}
			{
				p.SetState(7369)
				p.CharsetName()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsciiContext is an interface to support dynamic dispatch.
type IAsciiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASCII_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsAsciiContext differentiates from other interfaces.
	IsAsciiContext()
}

type AsciiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsciiContext() *AsciiContext {
	var p = new(AsciiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ascii
	return p
}

func InitEmptyAsciiContext(p *AsciiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ascii
}

func (*AsciiContext) IsAsciiContext() {}

func NewAsciiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsciiContext {
	var p = new(AsciiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ascii

	return p
}

func (s *AsciiContext) GetParser() antlr.Parser { return s.parser }

func (s *AsciiContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASCII_SYMBOL, 0)
}

func (s *AsciiContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *AsciiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsciiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsciiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAscii(s)
	}
}

func (s *AsciiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAscii(s)
	}
}

func (s *AsciiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAscii(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Ascii() (localctx IAsciiContext) {
	localctx = NewAsciiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, MySQLParserRULE_ascii)
	p.SetState(7381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserASCII_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7375)
			p.Match(MySQLParserASCII_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7377)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 964, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7376)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7379)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7380)
			p.Match(MySQLParserASCII_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnicodeContext is an interface to support dynamic dispatch.
type IUnicodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNICODE_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsUnicodeContext differentiates from other interfaces.
	IsUnicodeContext()
}

type UnicodeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnicodeContext() *UnicodeContext {
	var p = new(UnicodeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unicode
	return p
}

func InitEmptyUnicodeContext(p *UnicodeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_unicode
}

func (*UnicodeContext) IsUnicodeContext() {}

func NewUnicodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnicodeContext {
	var p = new(UnicodeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_unicode

	return p
}

func (s *UnicodeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnicodeContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNICODE_SYMBOL, 0)
}

func (s *UnicodeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *UnicodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnicodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUnicode(s)
	}
}

func (s *UnicodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUnicode(s)
	}
}

func (s *UnicodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUnicode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Unicode() (localctx IUnicodeContext) {
	localctx = NewUnicodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, MySQLParserRULE_unicode)
	p.SetState(7389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserUNICODE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7383)
			p.Match(MySQLParserUNICODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7385)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 966, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7384)
				p.Match(MySQLParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case MySQLParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7387)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7388)
			p.Match(MySQLParserUNICODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWsNumCodepointsContext is an interface to support dynamic dispatch.
type IWsNumCodepointsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsWsNumCodepointsContext differentiates from other interfaces.
	IsWsNumCodepointsContext()
}

type WsNumCodepointsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWsNumCodepointsContext() *WsNumCodepointsContext {
	var p = new(WsNumCodepointsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_wsNumCodepoints
	return p
}

func InitEmptyWsNumCodepointsContext(p *WsNumCodepointsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_wsNumCodepoints
}

func (*WsNumCodepointsContext) IsWsNumCodepointsContext() {}

func NewWsNumCodepointsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WsNumCodepointsContext {
	var p = new(WsNumCodepointsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_wsNumCodepoints

	return p
}

func (s *WsNumCodepointsContext) GetParser() antlr.Parser { return s.parser }

func (s *WsNumCodepointsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *WsNumCodepointsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WsNumCodepointsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WsNumCodepointsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WsNumCodepointsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WsNumCodepointsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWsNumCodepoints(s)
	}
}

func (s *WsNumCodepointsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWsNumCodepoints(s)
	}
}

func (s *WsNumCodepointsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWsNumCodepoints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WsNumCodepoints() (localctx IWsNumCodepointsContext) {
	localctx = NewWsNumCodepointsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, MySQLParserRULE_wsNumCodepoints)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7391)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7392)
		p.Real_ulong_number()
	}
	{
		p.SetState(7393)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDatetimePrecisionContext is an interface to support dynamic dispatch.
type ITypeDatetimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsTypeDatetimePrecisionContext differentiates from other interfaces.
	IsTypeDatetimePrecisionContext()
}

type TypeDatetimePrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDatetimePrecisionContext() *TypeDatetimePrecisionContext {
	var p = new(TypeDatetimePrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_typeDatetimePrecision
	return p
}

func InitEmptyTypeDatetimePrecisionContext(p *TypeDatetimePrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_typeDatetimePrecision
}

func (*TypeDatetimePrecisionContext) IsTypeDatetimePrecisionContext() {}

func NewTypeDatetimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDatetimePrecisionContext {
	var p = new(TypeDatetimePrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_typeDatetimePrecision

	return p
}

func (s *TypeDatetimePrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDatetimePrecisionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *TypeDatetimePrecisionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *TypeDatetimePrecisionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TypeDatetimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDatetimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDatetimePrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTypeDatetimePrecision(s)
	}
}

func (s *TypeDatetimePrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTypeDatetimePrecision(s)
	}
}

func (s *TypeDatetimePrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTypeDatetimePrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TypeDatetimePrecision() (localctx ITypeDatetimePrecisionContext) {
	localctx = NewTypeDatetimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, MySQLParserRULE_typeDatetimePrecision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7395)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7396)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7397)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext
	BINARY_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CharsetNameContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *CharsetNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, MySQLParserRULE_charsetName)
	p.SetState(7403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 968, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7399)
			p.TextOrIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7400)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7401)

		if !(serverVersion < 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
			goto errorExit
		}
		{
			p.SetState(7402)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CollationNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *CollationNameContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINARY_SYMBOL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, MySQLParserRULE_collationName)
	p.SetState(7410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 969, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7405)
			p.TextOrIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7406)

		if !(serverVersion < 80011) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
			goto errorExit
		}
		{
			p.SetState(7407)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7408)

		if !(serverVersion >= 80018) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80018", ""))
			goto errorExit
		}
		{
			p.SetState(7409)
			p.Match(MySQLParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionsContext is an interface to support dynamic dispatch.
type ICreateTableOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateTableOption() []ICreateTableOptionContext
	CreateTableOption(i int) ICreateTableOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateTableOptionsContext differentiates from other interfaces.
	IsCreateTableOptionsContext()
}

type CreateTableOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableOptionsContext() *CreateTableOptionsContext {
	var p = new(CreateTableOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOptions
	return p
}

func InitEmptyCreateTableOptionsContext(p *CreateTableOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOptions
}

func (*CreateTableOptionsContext) IsCreateTableOptionsContext() {}

func NewCreateTableOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionsContext {
	var p = new(CreateTableOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTableOptions

	return p
}

func (s *CreateTableOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionsContext) AllCreateTableOption() []ICreateTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableOptionContext); ok {
			tst[i] = t.(ICreateTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableOptionsContext) CreateTableOption(i int) ICreateTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionContext)
}

func (s *CreateTableOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *CreateTableOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *CreateTableOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTableOptions(s)
	}
}

func (s *CreateTableOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTableOptions(s)
	}
}

func (s *CreateTableOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTableOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTableOptions() (localctx ICreateTableOptionsContext) {
	localctx = NewCreateTableOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, MySQLParserRULE_createTableOptions)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7412)
		p.CreateTableOption()
	}
	p.SetState(7419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 971, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(7414)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 970, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7413)
					p.Match(MySQLParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(7416)
				p.CreateTableOption()
			}

		}
		p.SetState(7421)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 971, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionsSpaceSeparatedContext is an interface to support dynamic dispatch.
type ICreateTableOptionsSpaceSeparatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateTableOption() []ICreateTableOptionContext
	CreateTableOption(i int) ICreateTableOptionContext

	// IsCreateTableOptionsSpaceSeparatedContext differentiates from other interfaces.
	IsCreateTableOptionsSpaceSeparatedContext()
}

type CreateTableOptionsSpaceSeparatedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableOptionsSpaceSeparatedContext() *CreateTableOptionsSpaceSeparatedContext {
	var p = new(CreateTableOptionsSpaceSeparatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOptionsSpaceSeparated
	return p
}

func InitEmptyCreateTableOptionsSpaceSeparatedContext(p *CreateTableOptionsSpaceSeparatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOptionsSpaceSeparated
}

func (*CreateTableOptionsSpaceSeparatedContext) IsCreateTableOptionsSpaceSeparatedContext() {}

func NewCreateTableOptionsSpaceSeparatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionsSpaceSeparatedContext {
	var p = new(CreateTableOptionsSpaceSeparatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTableOptionsSpaceSeparated

	return p
}

func (s *CreateTableOptionsSpaceSeparatedContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionsSpaceSeparatedContext) AllCreateTableOption() []ICreateTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableOptionContext); ok {
			tst[i] = t.(ICreateTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableOptionsSpaceSeparatedContext) CreateTableOption(i int) ICreateTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionContext)
}

func (s *CreateTableOptionsSpaceSeparatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionsSpaceSeparatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionsSpaceSeparatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTableOptionsSpaceSeparated(s)
	}
}

func (s *CreateTableOptionsSpaceSeparatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTableOptionsSpaceSeparated(s)
	}
}

func (s *CreateTableOptionsSpaceSeparatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTableOptionsSpaceSeparated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTableOptionsSpaceSeparated() (localctx ICreateTableOptionsSpaceSeparatedContext) {
	localctx = NewCreateTableOptionsSpaceSeparatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, MySQLParserRULE_createTableOptionsSpaceSeparated)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(7422)
				p.CreateTableOption()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(7425)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 972, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionContext is an interface to support dynamic dispatch.
type ICreateTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// GetFormat returns the format token.
	GetFormat() antlr.Token

	// GetMethod returns the method token.
	GetMethod() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// SetFormat sets the format token.
	SetFormat(antlr.Token)

	// SetMethod sets the method token.
	SetMethod(antlr.Token)

	// Getter signatures
	EngineRef() IEngineRefContext
	ENGINE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	NULL_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	Equal() IEqualContext
	Ulonglong_number() IUlonglong_numberContext
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	PASSWORD_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	COMPRESSION_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	TernaryOption() ITernaryOptionContext
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	TableRefList() ITableRefListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	UNION_SYMBOL() antlr.TerminalNode
	DefaultCharset() IDefaultCharsetContext
	DefaultCollation() IDefaultCollationContext
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLESPACE_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode

	// IsCreateTableOptionContext differentiates from other interfaces.
	IsCreateTableOptionContext()
}

type CreateTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
	format antlr.Token
	method antlr.Token
}

func NewEmptyCreateTableOptionContext() *CreateTableOptionContext {
	var p = new(CreateTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOption
	return p
}

func InitEmptyCreateTableOptionContext(p *CreateTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createTableOption
}

func (*CreateTableOptionContext) IsCreateTableOptionContext() {}

func NewCreateTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionContext {
	var p = new(CreateTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createTableOption

	return p
}

func (s *CreateTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionContext) GetOption() antlr.Token { return s.option }

func (s *CreateTableOptionContext) GetFormat() antlr.Token { return s.format }

func (s *CreateTableOptionContext) GetMethod() antlr.Token { return s.method }

func (s *CreateTableOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *CreateTableOptionContext) SetFormat(v antlr.Token) { s.format = v }

func (s *CreateTableOptionContext) SetMethod(v antlr.Token) { s.method = v }

func (s *CreateTableOptionContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *CreateTableOptionContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *CreateTableOptionContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CreateTableOptionContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CreateTableOptionContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *CreateTableOptionContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_ROWS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIN_ROWS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CreateTableOptionContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *CreateTableOptionContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *CreateTableOptionContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCRYPTION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TernaryOption() ITernaryOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryOptionContext)
}

func (s *CreateTableOptionContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPACK_KEYS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *CreateTableOptionContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECKSUM_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_FORMAT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDYNAMIC_SYMBOL, 0)
}

func (s *CreateTableOptionContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIXED_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSED_SYMBOL, 0)
}

func (s *CreateTableOptionContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDUNDANT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPACT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TableRefList() ITableRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefListContext)
}

func (s *CreateTableOptionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CreateTableOptionContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DefaultCharset() IDefaultCharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCharsetContext)
}

func (s *CreateTableOptionContext) DefaultCollation() IDefaultCollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCollationContext)
}

func (s *CreateTableOptionContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_METHOD_SYMBOL, 0)
}

func (s *CreateTableOptionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *CreateTableOptionContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *CreateTableOptionContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *CreateTableOptionContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *CreateTableOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableOptionContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISK_SYMBOL, 0)
}

func (s *CreateTableOptionContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMORY_SYMBOL, 0)
}

func (s *CreateTableOptionContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONNECTION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateTableOption(s)
	}
}

func (s *CreateTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateTableOption(s)
	}
}

func (s *CreateTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateTableOption() (localctx ICreateTableOptionContext) {
	localctx = NewCreateTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, MySQLParserRULE_createTableOption)
	var _la int

	p.SetState(7556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 997, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7427)

			var _m = p.Match(MySQLParserENGINE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7429)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 973, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7428)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7431)
			p.EngineRef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7432)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(7433)

			var _m = p.Match(MySQLParserSECONDARY_ENGINE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7435)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 974, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7434)
				p.Equal()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(7439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 975, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7437)
				p.Match(MySQLParserNULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(7438)
				p.TextOrIdentifier()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7441)

			var _m = p.Match(MySQLParserMAX_ROWS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7442)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7445)
			p.Ulonglong_number()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7446)

			var _m = p.Match(MySQLParserMIN_ROWS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7448)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7447)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7450)
			p.Ulonglong_number()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7451)

			var _m = p.Match(MySQLParserAVG_ROW_LENGTH_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7453)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7452)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7455)
			p.Ulong_number()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7456)

			var _m = p.Match(MySQLParserPASSWORD_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7458)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 979, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7457)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7460)
			p.TextStringLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7461)

			var _m = p.Match(MySQLParserCOMMENT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7463)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 980, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7462)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7465)
			p.TextStringLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		p.SetState(7466)

		if !(serverVersion >= 50708) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50708", ""))
			goto errorExit
		}
		{
			p.SetState(7467)

			var _m = p.Match(MySQLParserCOMPRESSION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7469)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 981, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7468)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7471)
			p.TextString()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(7472)

		if !(serverVersion >= 50711) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50711", ""))
			goto errorExit
		}
		{
			p.SetState(7473)

			var _m = p.Match(MySQLParserENCRYPTION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7475)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 982, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7474)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7477)
			p.TextString()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7478)

			var _m = p.Match(MySQLParserAUTO_INCREMENT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7479)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7482)
			p.Ulonglong_number()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7483)

			var _m = p.Match(MySQLParserPACK_KEYS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7484)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7487)
			p.TernaryOption()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7488)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-544)) & ^0x3f) == 0 && ((int64(1)<<(_la-544))&7) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7490)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7489)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7492)
			p.TernaryOption()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7493)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCHECKSUM_SYMBOL || _la == MySQLParserTABLE_CHECKSUM_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7495)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7494)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7497)
			p.Ulong_number()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7498)

			var _m = p.Match(MySQLParserDELAY_KEY_WRITE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7499)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7502)
			p.Ulong_number()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7503)

			var _m = p.Match(MySQLParserROW_FORMAT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7505)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7504)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7507)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).format = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1125899906842629) != 0) || _la == MySQLParserDYNAMIC_SYMBOL || _la == MySQLParserFIXED_SYMBOL || _la == MySQLParserREDUNDANT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).format = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7508)

			var _m = p.Match(MySQLParserUNION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7510)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7509)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7512)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7513)
			p.TableRefList()
		}
		{
			p.SetState(7514)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7516)
			p.DefaultCharset()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7517)
			p.DefaultCollation()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7518)

			var _m = p.Match(MySQLParserINSERT_METHOD_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7520)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7519)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7522)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).method = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserFIRST_SYMBOL || _la == MySQLParserLAST_SYMBOL || _la == MySQLParserNO_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).method = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7523)

			var _m = p.Match(MySQLParserDATA_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7524)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7526)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 991, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7525)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7528)
			p.TextString()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7529)

			var _m = p.Match(MySQLParserINDEX_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7530)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7532)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 992, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7531)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7534)
			p.TextString()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(7535)

			var _m = p.Match(MySQLParserTABLESPACE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 994, p.GetParserRuleContext()) {
		case 1:
			p.SetState(7536)

			if !(serverVersion >= 50707) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50707", ""))
				goto errorExit
			}
			p.SetState(7538)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 993, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7537)
					p.Match(MySQLParserEQUAL_OPERATOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 2:

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(7543)
			p.Identifier()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(7544)

			var _m = p.Match(MySQLParserSTORAGE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7545)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDISK_SYMBOL || _la == MySQLParserMEMORY_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(7546)

			var _m = p.Match(MySQLParserCONNECTION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7548)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 995, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7547)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7550)
			p.TextString()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(7551)

			var _m = p.Match(MySQLParserKEY_BLOCK_SIZE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7552)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7555)
			p.Ulong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryOptionContext is an interface to support dynamic dispatch.
type ITernaryOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ulong_number() IUlong_numberContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsTernaryOptionContext differentiates from other interfaces.
	IsTernaryOptionContext()
}

type TernaryOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTernaryOptionContext() *TernaryOptionContext {
	var p = new(TernaryOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ternaryOption
	return p
}

func InitEmptyTernaryOptionContext(p *TernaryOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ternaryOption
}

func (*TernaryOptionContext) IsTernaryOptionContext() {}

func NewTernaryOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryOptionContext {
	var p = new(TernaryOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ternaryOption

	return p
}

func (s *TernaryOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *TernaryOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *TernaryOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTernaryOption(s)
	}
}

func (s *TernaryOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTernaryOption(s)
	}
}

func (s *TernaryOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTernaryOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TernaryOption() (localctx ITernaryOptionContext) {
	localctx = NewTernaryOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, MySQLParserRULE_ternaryOption)
	p.SetState(7560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserINT_NUMBER, MySQLParserLONG_NUMBER, MySQLParserULONGLONG_NUMBER, MySQLParserHEX_NUMBER, MySQLParserDECIMAL_NUMBER, MySQLParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7558)
			p.Ulong_number()
		}

	case MySQLParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7559)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultCollationContext is an interface to support dynamic dispatch.
type IDefaultCollationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE_SYMBOL() antlr.TerminalNode
	CollationName() ICollationNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultCollationContext differentiates from other interfaces.
	IsDefaultCollationContext()
}

type DefaultCollationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCollationContext() *DefaultCollationContext {
	var p = new(DefaultCollationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultCollation
	return p
}

func InitEmptyDefaultCollationContext(p *DefaultCollationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultCollation
}

func (*DefaultCollationContext) IsDefaultCollationContext() {}

func NewDefaultCollationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCollationContext {
	var p = new(DefaultCollationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_defaultCollation

	return p
}

func (s *DefaultCollationContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCollationContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATE_SYMBOL, 0)
}

func (s *DefaultCollationContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *DefaultCollationContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultCollationContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *DefaultCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCollationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDefaultCollation(s)
	}
}

func (s *DefaultCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDefaultCollation(s)
	}
}

func (s *DefaultCollationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDefaultCollation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DefaultCollation() (localctx IDefaultCollationContext) {
	localctx = NewDefaultCollationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, MySQLParserRULE_defaultCollation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFAULT_SYMBOL {
		{
			p.SetState(7562)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7565)
		p.Match(MySQLParserCOLLATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7567)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1000, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7566)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7569)
		p.CollationName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultEncryptionContext is an interface to support dynamic dispatch.
type IDefaultEncryptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultEncryptionContext differentiates from other interfaces.
	IsDefaultEncryptionContext()
}

type DefaultEncryptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultEncryptionContext() *DefaultEncryptionContext {
	var p = new(DefaultEncryptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultEncryption
	return p
}

func InitEmptyDefaultEncryptionContext(p *DefaultEncryptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultEncryption
}

func (*DefaultEncryptionContext) IsDefaultEncryptionContext() {}

func NewDefaultEncryptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultEncryptionContext {
	var p = new(DefaultEncryptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_defaultEncryption

	return p
}

func (s *DefaultEncryptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultEncryptionContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCRYPTION_SYMBOL, 0)
}

func (s *DefaultEncryptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *DefaultEncryptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultEncryptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *DefaultEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultEncryptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDefaultEncryption(s)
	}
}

func (s *DefaultEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDefaultEncryption(s)
	}
}

func (s *DefaultEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDefaultEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DefaultEncryption() (localctx IDefaultEncryptionContext) {
	localctx = NewDefaultEncryptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, MySQLParserRULE_defaultEncryption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFAULT_SYMBOL {
		{
			p.SetState(7571)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7574)
		p.Match(MySQLParserENCRYPTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7576)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1002, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7575)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7578)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultCharsetContext is an interface to support dynamic dispatch.
type IDefaultCharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultCharsetContext differentiates from other interfaces.
	IsDefaultCharsetContext()
}

type DefaultCharsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCharsetContext() *DefaultCharsetContext {
	var p = new(DefaultCharsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultCharset
	return p
}

func InitEmptyDefaultCharsetContext(p *DefaultCharsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_defaultCharset
}

func (*DefaultCharsetContext) IsDefaultCharsetContext() {}

func NewDefaultCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCharsetContext {
	var p = new(DefaultCharsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_defaultCharset

	return p
}

func (s *DefaultCharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCharsetContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *DefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DefaultCharsetContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultCharsetContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *DefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDefaultCharset(s)
	}
}

func (s *DefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDefaultCharset(s)
	}
}

func (s *DefaultCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDefaultCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DefaultCharset() (localctx IDefaultCharsetContext) {
	localctx = NewDefaultCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, MySQLParserRULE_defaultCharset)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserDEFAULT_SYMBOL {
		{
			p.SetState(7580)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7583)
		p.Charset()
	}
	p.SetState(7585)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1004, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7584)
			p.Match(MySQLParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7587)
		p.CharsetName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	PartitionTypeDef() IPartitionTypeDefContext
	PARTITIONS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	SubPartitions() ISubPartitionsContext
	PartitionDefinitions() IPartitionDefinitionsContext

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *PartitionClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *PartitionClauseContext) PartitionTypeDef() IPartitionTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTypeDefContext)
}

func (s *PartitionClauseContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONS_SYMBOL, 0)
}

func (s *PartitionClauseContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionClauseContext) SubPartitions() ISubPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubPartitionsContext)
}

func (s *PartitionClauseContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, MySQLParserRULE_partitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7589)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7590)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7591)
		p.PartitionTypeDef()
	}
	p.SetState(7594)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1005, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7592)
			p.Match(MySQLParserPARTITIONS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7593)
			p.Real_ulong_number()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(7597)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1006, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7596)
			p.SubPartitions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(7600)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1007, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7599)
			p.PartitionDefinitions()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTypeDefContext is an interface to support dynamic dispatch.
type IPartitionTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionTypeDefContext differentiates from other interfaces.
	IsPartitionTypeDefContext()
}

type PartitionTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionTypeDefContext() *PartitionTypeDefContext {
	var p = new(PartitionTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionTypeDef
	return p
}

func InitEmptyPartitionTypeDefContext(p *PartitionTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionTypeDef
}

func (*PartitionTypeDefContext) IsPartitionTypeDefContext() {}

func NewPartitionTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTypeDefContext {
	var p = new(PartitionTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionTypeDef

	return p
}

func (s *PartitionTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTypeDefContext) CopyAll(ctx *PartitionTypeDefContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionDefRangeListContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefRangeListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefRangeListContext {
	var p = new(PartitionDefRangeListContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefRangeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefRangeListContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANGE_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIST_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionDefRangeListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDefRangeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDefRangeList(s)
	}
}

func (s *PartitionDefRangeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDefRangeList(s)
	}
}

func (s *PartitionDefRangeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDefRangeList(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionDefKeyContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefKeyContext {
	var p = new(PartitionDefKeyContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefKeyContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINEAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyAlgorithmContext)
}

func (s *PartitionDefKeyContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDefKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDefKey(s)
	}
}

func (s *PartitionDefKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDefKey(s)
	}
}

func (s *PartitionDefKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDefKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionDefHashContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefHashContext {
	var p = new(PartitionDefHashContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefHashContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHASH_SYMBOL, 0)
}

func (s *PartitionDefHashContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionDefHashContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINEAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDefHash(s)
	}
}

func (s *PartitionDefHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDefHash(s)
	}
}

func (s *PartitionDefHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDefHash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionTypeDef() (localctx IPartitionTypeDefContext) {
	localctx = NewPartitionTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, MySQLParserRULE_partitionTypeDef)
	var _la int

	p.SetState(7635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1014, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionDefKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLINEAR_SYMBOL {
			{
				p.SetState(7602)
				p.Match(MySQLParserLINEAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7605)
			p.Match(MySQLParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7607)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1009, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7606)
				p.PartitionKeyAlgorithm()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7609)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7611)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1010, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7610)
				p.IdentifierList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7613)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPartitionDefHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserLINEAR_SYMBOL {
			{
				p.SetState(7614)
				p.Match(MySQLParserLINEAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7617)
			p.Match(MySQLParserHASH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7618)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7619)
			p.bitExpr(0)
		}
		{
			p.SetState(7620)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPartitionDefRangeListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7622)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserLIST_SYMBOL || _la == MySQLParserRANGE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserOPEN_PAR_SYMBOL:
			{
				p.SetState(7623)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7624)
				p.bitExpr(0)
			}
			{
				p.SetState(7625)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case MySQLParserCOLUMNS_SYMBOL:
			{
				p.SetState(7627)
				p.Match(MySQLParserCOLUMNS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7628)
				p.Match(MySQLParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7630)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1012, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7629)
					p.IdentifierList()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(7632)
				p.Match(MySQLParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubPartitionsContext is an interface to support dynamic dispatch.
type ISubPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	BitExpr() IBitExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	LINEAR_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext

	// IsSubPartitionsContext differentiates from other interfaces.
	IsSubPartitionsContext()
}

type SubPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubPartitionsContext() *SubPartitionsContext {
	var p = new(SubPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subPartitions
	return p
}

func InitEmptySubPartitionsContext(p *SubPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subPartitions
}

func (*SubPartitionsContext) IsSubPartitionsContext() {}

func NewSubPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubPartitionsContext {
	var p = new(SubPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_subPartitions

	return p
}

func (s *SubPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubPartitionsContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITION_SYMBOL, 0)
}

func (s *SubPartitionsContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *SubPartitionsContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHASH_SYMBOL, 0)
}

func (s *SubPartitionsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *SubPartitionsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_SYMBOL, 0)
}

func (s *SubPartitionsContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *SubPartitionsContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINEAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *SubPartitionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *SubPartitionsContext) PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyAlgorithmContext)
}

func (s *SubPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSubPartitions(s)
	}
}

func (s *SubPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSubPartitions(s)
	}
}

func (s *SubPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSubPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SubPartitions() (localctx ISubPartitionsContext) {
	localctx = NewSubPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, MySQLParserRULE_subPartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7637)
		p.Match(MySQLParserSUBPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7638)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserLINEAR_SYMBOL {
		{
			p.SetState(7639)
			p.Match(MySQLParserLINEAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(7652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserHASH_SYMBOL:
		{
			p.SetState(7642)
			p.Match(MySQLParserHASH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7643)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7644)
			p.bitExpr(0)
		}
		{
			p.SetState(7645)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserKEY_SYMBOL:
		{
			p.SetState(7647)
			p.Match(MySQLParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7649)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1016, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7648)
				p.PartitionKeyAlgorithm()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7651)
			p.IdentifierListWithParentheses()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(7656)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1018, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7654)
			p.Match(MySQLParserSUBPARTITIONS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7655)
			p.Real_ulong_number()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyAlgorithmContext is an interface to support dynamic dispatch.
type IPartitionKeyAlgorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALGORITHM_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext

	// IsPartitionKeyAlgorithmContext differentiates from other interfaces.
	IsPartitionKeyAlgorithmContext()
}

type PartitionKeyAlgorithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyAlgorithmContext() *PartitionKeyAlgorithmContext {
	var p = new(PartitionKeyAlgorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionKeyAlgorithm
	return p
}

func InitEmptyPartitionKeyAlgorithmContext(p *PartitionKeyAlgorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionKeyAlgorithm
}

func (*PartitionKeyAlgorithmContext) IsPartitionKeyAlgorithmContext() {}

func NewPartitionKeyAlgorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyAlgorithmContext {
	var p = new(PartitionKeyAlgorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionKeyAlgorithm

	return p
}

func (s *PartitionKeyAlgorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyAlgorithmContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALGORITHM_SYMBOL, 0)
}

func (s *PartitionKeyAlgorithmContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *PartitionKeyAlgorithmContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionKeyAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyAlgorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionKeyAlgorithm(s)
	}
}

func (s *PartitionKeyAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionKeyAlgorithm(s)
	}
}

func (s *PartitionKeyAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionKeyAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionKeyAlgorithm() (localctx IPartitionKeyAlgorithmContext) {
	localctx = NewPartitionKeyAlgorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, MySQLParserRULE_partitionKeyAlgorithm)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(7658)

	if !(serverVersion >= 50700) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50700", ""))
		goto errorExit
	}
	{
		p.SetState(7659)
		p.Match(MySQLParserALGORITHM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7660)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7661)
		p.Real_ulong_number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *PartitionDefinitionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, MySQLParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7663)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7664)
		p.PartitionDefinition()
	}
	p.SetState(7669)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(7665)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7666)
			p.PartitionDefinition()
		}

		p.SetState(7671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7672)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	PartitionValuesIn() IPartitionValuesInContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllSubpartitionDefinition() []ISubpartitionDefinitionContext
	SubpartitionDefinition(i int) ISubpartitionDefinitionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	PartitionValueItemListParen() IPartitionValueItemListParenContext
	MAXVALUE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionDefinitionContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUES_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHAN_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) PartitionValuesIn() IPartitionValuesInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValuesInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValuesInContext)
}

func (s *PartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionDefinitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionDefinitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) PartitionValueItemListParen() IPartitionValueItemListParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemListParenContext)
}

func (s *PartitionDefinitionContext) MAXVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAXVALUE_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *PartitionDefinitionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionDefinition(s)
	}
}

func (s *PartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionDefinition(s)
	}
}

func (s *PartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, MySQLParserRULE_partitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7674)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7675)
		p.Identifier()
	}
	p.SetState(7686)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7676)
			p.Match(MySQLParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7677)
			p.Match(MySQLParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7678)
			p.Match(MySQLParserTHAN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7681)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case MySQLParserOPEN_PAR_SYMBOL:
			{
				p.SetState(7679)
				p.PartitionValueItemListParen()
			}

		case MySQLParserMAXVALUE_SYMBOL:
			{
				p.SetState(7680)
				p.Match(MySQLParserMAXVALUE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1021, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7683)
			p.Match(MySQLParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7684)
			p.Match(MySQLParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7685)
			p.PartitionValuesIn()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(7691)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMENT_SYMBOL || _la == MySQLParserDATA_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINDEX_SYMBOL || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&35184374185985) != 0) || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserTABLESPACE_SYMBOL {
		{
			p.SetState(7688)
			p.PartitionOption()
		}

		p.SetState(7693)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(7705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == MySQLParserOPEN_PAR_SYMBOL {
		{
			p.SetState(7694)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7695)
			p.SubpartitionDefinition()
		}
		p.SetState(7700)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(7696)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7697)
				p.SubpartitionDefinition()
			}

			p.SetState(7702)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7703)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValuesInContext is an interface to support dynamic dispatch.
type IPartitionValuesInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValueItemListParen() []IPartitionValueItemListParenContext
	PartitionValueItemListParen(i int) IPartitionValueItemListParenContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionValuesInContext differentiates from other interfaces.
	IsPartitionValuesInContext()
}

type PartitionValuesInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValuesInContext() *PartitionValuesInContext {
	var p = new(PartitionValuesInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValuesIn
	return p
}

func InitEmptyPartitionValuesInContext(p *PartitionValuesInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValuesIn
}

func (*PartitionValuesInContext) IsPartitionValuesInContext() {}

func NewPartitionValuesInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValuesInContext {
	var p = new(PartitionValuesInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionValuesIn

	return p
}

func (s *PartitionValuesInContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValuesInContext) AllPartitionValueItemListParen() []IPartitionValueItemListParenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueItemListParenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueItemListParenContext); ok {
			tst[i] = t.(IPartitionValueItemListParenContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValuesInContext) PartitionValueItemListParen(i int) IPartitionValueItemListParenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemListParenContext)
}

func (s *PartitionValuesInContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionValuesInContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionValuesInContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *PartitionValuesInContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *PartitionValuesInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValuesInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValuesInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionValuesIn(s)
	}
}

func (s *PartitionValuesInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionValuesIn(s)
	}
}

func (s *PartitionValuesInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionValuesIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionValuesIn() (localctx IPartitionValuesInContext) {
	localctx = NewPartitionValuesInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, MySQLParserRULE_partitionValuesIn)
	var _la int

	p.SetState(7719)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1026, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7707)
			p.PartitionValueItemListParen()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7708)
			p.Match(MySQLParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7709)
			p.PartitionValueItemListParen()
		}
		p.SetState(7714)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == MySQLParserCOMMA_SYMBOL {
			{
				p.SetState(7710)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7711)
				p.PartitionValueItemListParen()
			}

			p.SetState(7716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(7717)
			p.Match(MySQLParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	TABLESPACE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	EngineRef() IEngineRefContext
	ENGINE_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	NODEGROUP_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	DATA_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode

	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) GetOption() antlr.Token { return s.option }

func (s *PartitionOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *PartitionOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionOptionContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *PartitionOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *PartitionOptionContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *PartitionOptionContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *PartitionOptionContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *PartitionOptionContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionOptionContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNODEGROUP_SYMBOL, 0)
}

func (s *PartitionOptionContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_ROWS_SYMBOL, 0)
}

func (s *PartitionOptionContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIN_ROWS_SYMBOL, 0)
}

func (s *PartitionOptionContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *PartitionOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *PartitionOptionContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *PartitionOptionContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEX_SYMBOL, 0)
}

func (s *PartitionOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionOption(s)
	}
}

func (s *PartitionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionOption(s)
	}
}

func (s *PartitionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, MySQLParserRULE_partitionOption)
	var _la int

	p.SetState(7755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserTABLESPACE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7721)

			var _m = p.Match(MySQLParserTABLESPACE_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7723)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1027, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7722)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7725)
			p.Identifier()
		}

	case MySQLParserENGINE_SYMBOL, MySQLParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserSTORAGE_SYMBOL {
			{
				p.SetState(7726)
				p.Match(MySQLParserSTORAGE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7729)

			var _m = p.Match(MySQLParserENGINE_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7731)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1029, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7730)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7733)
			p.EngineRef()
		}

	case MySQLParserNODEGROUP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7734)

			var _m = p.Match(MySQLParserNODEGROUP_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7735)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7738)
			p.Real_ulong_number()
		}

	case MySQLParserMAX_ROWS_SYMBOL, MySQLParserMIN_ROWS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7739)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PartitionOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserMAX_ROWS_SYMBOL || _la == MySQLParserMIN_ROWS_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PartitionOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(7741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserEQUAL_OPERATOR {
			{
				p.SetState(7740)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7743)
			p.Real_ulong_number()
		}

	case MySQLParserDATA_SYMBOL, MySQLParserINDEX_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7744)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PartitionOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserDATA_SYMBOL || _la == MySQLParserINDEX_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PartitionOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(7745)
			p.Match(MySQLParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7747)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1032, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7746)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7749)
			p.TextLiteral()
		}

	case MySQLParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7750)

			var _m = p.Match(MySQLParserCOMMENT_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7752)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1033, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7751)
				p.Match(MySQLParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(7754)
			p.TextLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITION_SYMBOL, 0)
}

func (s *SubpartitionDefinitionContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSubpartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, MySQLParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7757)
		p.Match(MySQLParserSUBPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7758)
		p.TextOrIdentifier()
	}
	p.SetState(7762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMENT_SYMBOL || _la == MySQLParserDATA_SYMBOL || _la == MySQLParserENGINE_SYMBOL || _la == MySQLParserINDEX_SYMBOL || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&35184374185985) != 0) || _la == MySQLParserSTORAGE_SYMBOL || _la == MySQLParserTABLESPACE_SYMBOL {
		{
			p.SetState(7759)
			p.PartitionOption()
		}

		p.SetState(7764)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueItemListParenContext is an interface to support dynamic dispatch.
type IPartitionValueItemListParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllPartitionValueItem() []IPartitionValueItemContext
	PartitionValueItem(i int) IPartitionValueItemContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionValueItemListParenContext differentiates from other interfaces.
	IsPartitionValueItemListParenContext()
}

type PartitionValueItemListParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueItemListParenContext() *PartitionValueItemListParenContext {
	var p = new(PartitionValueItemListParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValueItemListParen
	return p
}

func InitEmptyPartitionValueItemListParenContext(p *PartitionValueItemListParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValueItemListParen
}

func (*PartitionValueItemListParenContext) IsPartitionValueItemListParenContext() {}

func NewPartitionValueItemListParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueItemListParenContext {
	var p = new(PartitionValueItemListParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionValueItemListParen

	return p
}

func (s *PartitionValueItemListParenContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueItemListParenContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionValueItemListParenContext) AllPartitionValueItem() []IPartitionValueItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueItemContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueItemContext); ok {
			tst[i] = t.(IPartitionValueItemContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueItemListParenContext) PartitionValueItem(i int) IPartitionValueItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemContext)
}

func (s *PartitionValueItemListParenContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionValueItemListParenContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *PartitionValueItemListParenContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *PartitionValueItemListParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueItemListParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueItemListParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionValueItemListParen(s)
	}
}

func (s *PartitionValueItemListParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionValueItemListParen(s)
	}
}

func (s *PartitionValueItemListParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionValueItemListParen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionValueItemListParen() (localctx IPartitionValueItemListParenContext) {
	localctx = NewPartitionValueItemListParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, MySQLParserRULE_partitionValueItemListParen)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7765)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7766)
		p.PartitionValueItem()
	}
	p.SetState(7771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(7767)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7768)
			p.PartitionValueItem()
		}

		p.SetState(7773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7774)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueItemContext is an interface to support dynamic dispatch.
type IPartitionValueItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BitExpr() IBitExprContext
	MAXVALUE_SYMBOL() antlr.TerminalNode

	// IsPartitionValueItemContext differentiates from other interfaces.
	IsPartitionValueItemContext()
}

type PartitionValueItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueItemContext() *PartitionValueItemContext {
	var p = new(PartitionValueItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValueItem
	return p
}

func InitEmptyPartitionValueItemContext(p *PartitionValueItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_partitionValueItem
}

func (*PartitionValueItemContext) IsPartitionValueItemContext() {}

func NewPartitionValueItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueItemContext {
	var p = new(PartitionValueItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_partitionValueItem

	return p
}

func (s *PartitionValueItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueItemContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionValueItemContext) MAXVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAXVALUE_SYMBOL, 0)
}

func (s *PartitionValueItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPartitionValueItem(s)
	}
}

func (s *PartitionValueItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPartitionValueItem(s)
	}
}

func (s *PartitionValueItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPartitionValueItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PartitionValueItem() (localctx IPartitionValueItemContext) {
	localctx = NewPartitionValueItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, MySQLParserRULE_partitionValueItem)
	p.SetState(7778)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1037, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7776)
			p.bitExpr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7777)
			p.Match(MySQLParserMAXVALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinerClauseContext is an interface to support dynamic dispatch.
type IDefinerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	User() IUserContext

	// IsDefinerClauseContext differentiates from other interfaces.
	IsDefinerClauseContext()
}

type DefinerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinerClauseContext() *DefinerClauseContext {
	var p = new(DefinerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_definerClause
	return p
}

func InitEmptyDefinerClauseContext(p *DefinerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_definerClause
}

func (*DefinerClauseContext) IsDefinerClauseContext() {}

func NewDefinerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinerClauseContext {
	var p = new(DefinerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_definerClause

	return p
}

func (s *DefinerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinerClauseContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINER_SYMBOL, 0)
}

func (s *DefinerClauseContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *DefinerClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DefinerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDefinerClause(s)
	}
}

func (s *DefinerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDefinerClause(s)
	}
}

func (s *DefinerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDefinerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DefinerClause() (localctx IDefinerClauseContext) {
	localctx = NewDefinerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, MySQLParserRULE_definerClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7780)
		p.Match(MySQLParserDEFINER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7781)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7782)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF_SYMBOL() antlr.TerminalNode
	EXISTS_SYMBOL() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIF_SYMBOL, 0)
}

func (s *IfExistsContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXISTS_SYMBOL, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, MySQLParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7784)
		p.Match(MySQLParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7785)
		p.Match(MySQLParserEXISTS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	EXISTS_SYMBOL() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIF_SYMBOL, 0)
}

func (s *IfNotExistsContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *IfNotExistsContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXISTS_SYMBOL, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, MySQLParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7787)
		p.Match(MySQLParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7788)
		p.NotRule()
	}
	{
		p.SetState(7789)
		p.Match(MySQLParserEXISTS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	FunctionParameter() IFunctionParameterContext
	IN_SYMBOL() antlr.TerminalNode
	OUT_SYMBOL() antlr.TerminalNode
	INOUT_SYMBOL() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureParameter
	return p
}

func InitEmptyProcedureParameterContext(p *ProcedureParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureParameter
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetType_() antlr.Token { return s.type_ }

func (s *ProcedureParameterContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ProcedureParameterContext) FunctionParameter() IFunctionParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *ProcedureParameterContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIN_SYMBOL, 0)
}

func (s *ProcedureParameterContext) OUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOUT_SYMBOL, 0)
}

func (s *ProcedureParameterContext) INOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINOUT_SYMBOL, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitProcedureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, MySQLParserRULE_procedureParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(7792)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1038, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7791)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserINOUT_SYMBOL || _la == MySQLParserIN_SYMBOL || _la == MySQLParserOUT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7794)
		p.FunctionParameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterName() IParameterNameContext
	TypeWithOptCollate() ITypeWithOptCollateContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) ParameterName() IParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterNameContext)
}

func (s *FunctionParameterContext) TypeWithOptCollate() ITypeWithOptCollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithOptCollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithOptCollateContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, MySQLParserRULE_functionParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7796)
		p.ParameterName()
	}
	{
		p.SetState(7797)
		p.TypeWithOptCollate()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateContext is an interface to support dynamic dispatch.
type ICollateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE_SYMBOL() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsCollateContext differentiates from other interfaces.
	IsCollateContext()
}

type CollateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateContext() *CollateContext {
	var p = new(CollateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_collate
	return p
}

func InitEmptyCollateContext(p *CollateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_collate
}

func (*CollateContext) IsCollateContext() {}

func NewCollateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateContext {
	var p = new(CollateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_collate

	return p
}

func (s *CollateContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATE_SYMBOL, 0)
}

func (s *CollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Collate() (localctx ICollateContext) {
	localctx = NewCollateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, MySQLParserRULE_collate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7799)
		p.Match(MySQLParserCOLLATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7800)
		p.CollationName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithOptCollateContext is an interface to support dynamic dispatch.
type ITypeWithOptCollateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	Collate() ICollateContext

	// IsTypeWithOptCollateContext differentiates from other interfaces.
	IsTypeWithOptCollateContext()
}

type TypeWithOptCollateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithOptCollateContext() *TypeWithOptCollateContext {
	var p = new(TypeWithOptCollateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_typeWithOptCollate
	return p
}

func InitEmptyTypeWithOptCollateContext(p *TypeWithOptCollateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_typeWithOptCollate
}

func (*TypeWithOptCollateContext) IsTypeWithOptCollateContext() {}

func NewTypeWithOptCollateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithOptCollateContext {
	var p = new(TypeWithOptCollateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_typeWithOptCollate

	return p
}

func (s *TypeWithOptCollateContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithOptCollateContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeWithOptCollateContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *TypeWithOptCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithOptCollateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithOptCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTypeWithOptCollate(s)
	}
}

func (s *TypeWithOptCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTypeWithOptCollate(s)
	}
}

func (s *TypeWithOptCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTypeWithOptCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TypeWithOptCollate() (localctx ITypeWithOptCollateContext) {
	localctx = NewTypeWithOptCollateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, MySQLParserRULE_typeWithOptCollate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7802)
		p.DataType()
	}
	p.SetState(7804)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1039, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7803)
			p.Collate()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaIdentifierPairContext is an interface to support dynamic dispatch.
type ISchemaIdentifierPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllSchemaRef() []ISchemaRefContext
	SchemaRef(i int) ISchemaRefContext
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsSchemaIdentifierPairContext differentiates from other interfaces.
	IsSchemaIdentifierPairContext()
}

type SchemaIdentifierPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaIdentifierPairContext() *SchemaIdentifierPairContext {
	var p = new(SchemaIdentifierPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaIdentifierPair
	return p
}

func InitEmptySchemaIdentifierPairContext(p *SchemaIdentifierPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaIdentifierPair
}

func (*SchemaIdentifierPairContext) IsSchemaIdentifierPairContext() {}

func NewSchemaIdentifierPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaIdentifierPairContext {
	var p = new(SchemaIdentifierPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_schemaIdentifierPair

	return p
}

func (s *SchemaIdentifierPairContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaIdentifierPairContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) AllSchemaRef() []ISchemaRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaRefContext); ok {
			len++
		}
	}

	tst := make([]ISchemaRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaRefContext); ok {
			tst[i] = t.(ISchemaRefContext)
			i++
		}
	}

	return tst
}

func (s *SchemaIdentifierPairContext) SchemaRef(i int) ISchemaRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *SchemaIdentifierPairContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaIdentifierPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaIdentifierPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSchemaIdentifierPair(s)
	}
}

func (s *SchemaIdentifierPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSchemaIdentifierPair(s)
	}
}

func (s *SchemaIdentifierPairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSchemaIdentifierPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SchemaIdentifierPair() (localctx ISchemaIdentifierPairContext) {
	localctx = NewSchemaIdentifierPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, MySQLParserRULE_schemaIdentifierPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7806)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7807)
		p.SchemaRef()
	}
	{
		p.SetState(7808)
		p.Match(MySQLParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7809)
		p.SchemaRef()
	}
	{
		p.SetState(7810)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewRefListContext is an interface to support dynamic dispatch.
type IViewRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllViewRef() []IViewRefContext
	ViewRef(i int) IViewRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsViewRefListContext differentiates from other interfaces.
	IsViewRefListContext()
}

type ViewRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewRefListContext() *ViewRefListContext {
	var p = new(ViewRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewRefList
	return p
}

func InitEmptyViewRefListContext(p *ViewRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewRefList
}

func (*ViewRefListContext) IsViewRefListContext() {}

func NewViewRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewRefListContext {
	var p = new(ViewRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewRefList

	return p
}

func (s *ViewRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewRefListContext) AllViewRef() []IViewRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IViewRefContext); ok {
			len++
		}
	}

	tst := make([]IViewRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IViewRefContext); ok {
			tst[i] = t.(IViewRefContext)
			i++
		}
	}

	return tst
}

func (s *ViewRefListContext) ViewRef(i int) IViewRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefContext)
}

func (s *ViewRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ViewRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ViewRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewRefList(s)
	}
}

func (s *ViewRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewRefList(s)
	}
}

func (s *ViewRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewRefList() (localctx IViewRefListContext) {
	localctx = NewViewRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, MySQLParserRULE_viewRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7812)
		p.ViewRef()
	}
	p.SetState(7817)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(7813)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7814)
			p.ViewRef()
		}

		p.SetState(7819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateListContext is an interface to support dynamic dispatch.
type IUpdateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUpdateElement() []IUpdateElementContext
	UpdateElement(i int) IUpdateElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUpdateListContext differentiates from other interfaces.
	IsUpdateListContext()
}

type UpdateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateListContext() *UpdateListContext {
	var p = new(UpdateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateList
	return p
}

func InitEmptyUpdateListContext(p *UpdateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateList
}

func (*UpdateListContext) IsUpdateListContext() {}

func NewUpdateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateListContext {
	var p = new(UpdateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_updateList

	return p
}

func (s *UpdateListContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateListContext) AllUpdateElement() []IUpdateElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdateElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateElementContext); ok {
			tst[i] = t.(IUpdateElementContext)
			i++
		}
	}

	return tst
}

func (s *UpdateListContext) UpdateElement(i int) IUpdateElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateElementContext)
}

func (s *UpdateListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *UpdateListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *UpdateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUpdateList(s)
	}
}

func (s *UpdateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUpdateList(s)
	}
}

func (s *UpdateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUpdateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UpdateList() (localctx IUpdateListContext) {
	localctx = NewUpdateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, MySQLParserRULE_updateList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7820)
		p.UpdateElement()
	}
	p.SetState(7825)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1041, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7821)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7822)
				p.UpdateElement()
			}

		}
		p.SetState(7827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1041, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateElementContext is an interface to support dynamic dispatch.
type IUpdateElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	EQUAL_OPERATOR() antlr.TerminalNode
	Expr() IExprContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsUpdateElementContext differentiates from other interfaces.
	IsUpdateElementContext()
}

type UpdateElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateElementContext() *UpdateElementContext {
	var p = new(UpdateElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateElement
	return p
}

func InitEmptyUpdateElementContext(p *UpdateElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_updateElement
}

func (*UpdateElementContext) IsUpdateElementContext() {}

func NewUpdateElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateElementContext {
	var p = new(UpdateElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_updateElement

	return p
}

func (s *UpdateElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateElementContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *UpdateElementContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *UpdateElementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UpdateElementContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_SYMBOL, 0)
}

func (s *UpdateElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUpdateElement(s)
	}
}

func (s *UpdateElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUpdateElement(s)
	}
}

func (s *UpdateElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUpdateElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UpdateElement() (localctx IUpdateElementContext) {
	localctx = NewUpdateElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, MySQLParserRULE_updateElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7828)
		p.ColumnRef()
	}
	{
		p.SetState(7829)
		p.Match(MySQLParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1042, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7830)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(7831)
			p.Match(MySQLParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetClauseContext is an interface to support dynamic dispatch.
type ICharsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext

	// IsCharsetClauseContext differentiates from other interfaces.
	IsCharsetClauseContext()
}

type CharsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetClauseContext() *CharsetClauseContext {
	var p = new(CharsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetClause
	return p
}

func InitEmptyCharsetClauseContext(p *CharsetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_charsetClause
}

func (*CharsetClauseContext) IsCharsetClauseContext() {}

func NewCharsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetClauseContext {
	var p = new(CharsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_charsetClause

	return p
}

func (s *CharsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetClauseContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *CharsetClauseContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCharsetClause(s)
	}
}

func (s *CharsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCharsetClause(s)
	}
}

func (s *CharsetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCharsetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CharsetClause() (localctx ICharsetClauseContext) {
	localctx = NewCharsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, MySQLParserRULE_charsetClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7834)
		p.Charset()
	}
	{
		p.SetState(7835)
		p.CharsetName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldsClauseContext is an interface to support dynamic dispatch.
type IFieldsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS_SYMBOL() antlr.TerminalNode
	AllFieldTerm() []IFieldTermContext
	FieldTerm(i int) IFieldTermContext

	// IsFieldsClauseContext differentiates from other interfaces.
	IsFieldsClauseContext()
}

type FieldsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsClauseContext() *FieldsClauseContext {
	var p = new(FieldsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldsClause
	return p
}

func InitEmptyFieldsClauseContext(p *FieldsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldsClause
}

func (*FieldsClauseContext) IsFieldsClauseContext() {}

func NewFieldsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsClauseContext {
	var p = new(FieldsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldsClause

	return p
}

func (s *FieldsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsClauseContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *FieldsClauseContext) AllFieldTerm() []IFieldTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldTermContext); ok {
			len++
		}
	}

	tst := make([]IFieldTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldTermContext); ok {
			tst[i] = t.(IFieldTermContext)
			i++
		}
	}

	return tst
}

func (s *FieldsClauseContext) FieldTerm(i int) IFieldTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTermContext)
}

func (s *FieldsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldsClause(s)
	}
}

func (s *FieldsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldsClause(s)
	}
}

func (s *FieldsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldsClause() (localctx IFieldsClauseContext) {
	localctx = NewFieldsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, MySQLParserRULE_fieldsClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7837)
		p.Match(MySQLParserCOLUMNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(7838)
				p.FieldTerm()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(7841)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1043, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldTermContext is an interface to support dynamic dispatch.
type IFieldTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TERMINATED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	ENCLOSED_SYMBOL() antlr.TerminalNode
	OPTIONALLY_SYMBOL() antlr.TerminalNode
	ESCAPED_SYMBOL() antlr.TerminalNode

	// IsFieldTermContext differentiates from other interfaces.
	IsFieldTermContext()
}

type FieldTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTermContext() *FieldTermContext {
	var p = new(FieldTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldTerm
	return p
}

func InitEmptyFieldTermContext(p *FieldTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldTerm
}

func (*FieldTermContext) IsFieldTermContext() {}

func NewFieldTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTermContext {
	var p = new(FieldTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldTerm

	return p
}

func (s *FieldTermContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTermContext) TERMINATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTERMINATED_SYMBOL, 0)
}

func (s *FieldTermContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *FieldTermContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *FieldTermContext) ENCLOSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCLOSED_SYMBOL, 0)
}

func (s *FieldTermContext) OPTIONALLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONALLY_SYMBOL, 0)
}

func (s *FieldTermContext) ESCAPED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserESCAPED_SYMBOL, 0)
}

func (s *FieldTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldTerm(s)
	}
}

func (s *FieldTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldTerm(s)
	}
}

func (s *FieldTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldTerm() (localctx IFieldTermContext) {
	localctx = NewFieldTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, MySQLParserRULE_fieldTerm)
	var _la int

	p.SetState(7855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserTERMINATED_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7843)
			p.Match(MySQLParserTERMINATED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7844)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7845)
			p.TextString()
		}

	case MySQLParserENCLOSED_SYMBOL, MySQLParserOPTIONALLY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7847)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserOPTIONALLY_SYMBOL {
			{
				p.SetState(7846)
				p.Match(MySQLParserOPTIONALLY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7849)
			p.Match(MySQLParserENCLOSED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7850)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7851)
			p.TextString()
		}

	case MySQLParserESCAPED_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7852)
			p.Match(MySQLParserESCAPED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7853)
			p.Match(MySQLParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7854)
			p.TextString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinesClauseContext is an interface to support dynamic dispatch.
type ILinesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LINES_SYMBOL() antlr.TerminalNode
	AllLineTerm() []ILineTermContext
	LineTerm(i int) ILineTermContext

	// IsLinesClauseContext differentiates from other interfaces.
	IsLinesClauseContext()
}

type LinesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinesClauseContext() *LinesClauseContext {
	var p = new(LinesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_linesClause
	return p
}

func InitEmptyLinesClauseContext(p *LinesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_linesClause
}

func (*LinesClauseContext) IsLinesClauseContext() {}

func NewLinesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinesClauseContext {
	var p = new(LinesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_linesClause

	return p
}

func (s *LinesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LinesClauseContext) LINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINES_SYMBOL, 0)
}

func (s *LinesClauseContext) AllLineTerm() []ILineTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineTermContext); ok {
			len++
		}
	}

	tst := make([]ILineTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineTermContext); ok {
			tst[i] = t.(ILineTermContext)
			i++
		}
	}

	return tst
}

func (s *LinesClauseContext) LineTerm(i int) ILineTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineTermContext)
}

func (s *LinesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLinesClause(s)
	}
}

func (s *LinesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLinesClause(s)
	}
}

func (s *LinesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLinesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LinesClause() (localctx ILinesClauseContext) {
	localctx = NewLinesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, MySQLParserRULE_linesClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7857)
		p.Match(MySQLParserLINES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(7858)
				p.LineTerm()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(7861)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1046, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineTermContext is an interface to support dynamic dispatch.
type ILineTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	TERMINATED_SYMBOL() antlr.TerminalNode
	STARTING_SYMBOL() antlr.TerminalNode

	// IsLineTermContext differentiates from other interfaces.
	IsLineTermContext()
}

type LineTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineTermContext() *LineTermContext {
	var p = new(LineTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lineTerm
	return p
}

func InitEmptyLineTermContext(p *LineTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lineTerm
}

func (*LineTermContext) IsLineTermContext() {}

func NewLineTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineTermContext {
	var p = new(LineTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lineTerm

	return p
}

func (s *LineTermContext) GetParser() antlr.Parser { return s.parser }

func (s *LineTermContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *LineTermContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *LineTermContext) TERMINATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTERMINATED_SYMBOL, 0)
}

func (s *LineTermContext) STARTING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTARTING_SYMBOL, 0)
}

func (s *LineTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLineTerm(s)
	}
}

func (s *LineTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLineTerm(s)
	}
}

func (s *LineTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLineTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LineTerm() (localctx ILineTermContext) {
	localctx = NewLineTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, MySQLParserRULE_lineTerm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7863)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserSTARTING_SYMBOL || _la == MySQLParserTERMINATED_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(7864)
		p.Match(MySQLParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7865)
		p.TextString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserListContext is an interface to support dynamic dispatch.
type IUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUser() []IUserContext
	User(i int) IUserContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUserListContext differentiates from other interfaces.
	IsUserListContext()
}

type UserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserListContext() *UserListContext {
	var p = new(UserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userList
	return p
}

func InitEmptyUserListContext(p *UserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userList
}

func (*UserListContext) IsUserListContext() {}

func NewUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserListContext {
	var p = new(UserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_userList

	return p
}

func (s *UserListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserListContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *UserListContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *UserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *UserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *UserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUserList(s)
	}
}

func (s *UserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUserList(s)
	}
}

func (s *UserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UserList() (localctx IUserListContext) {
	localctx = NewUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, MySQLParserRULE_userList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7867)
		p.User()
	}
	p.SetState(7872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1047, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7868)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7869)
				p.User()
			}

		}
		p.SetState(7874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1047, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserListContext is an interface to support dynamic dispatch.
type ICreateUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateUserEntry() []ICreateUserEntryContext
	CreateUserEntry(i int) ICreateUserEntryContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateUserListContext differentiates from other interfaces.
	IsCreateUserListContext()
}

type CreateUserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserListContext() *CreateUserListContext {
	var p = new(CreateUserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserList
	return p
}

func InitEmptyCreateUserListContext(p *CreateUserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserList
}

func (*CreateUserListContext) IsCreateUserListContext() {}

func NewCreateUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserListContext {
	var p = new(CreateUserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUserList

	return p
}

func (s *CreateUserListContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserListContext) AllCreateUserEntry() []ICreateUserEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateUserEntryContext); ok {
			len++
		}
	}

	tst := make([]ICreateUserEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateUserEntryContext); ok {
			tst[i] = t.(ICreateUserEntryContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserListContext) CreateUserEntry(i int) ICreateUserEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserEntryContext)
}

func (s *CreateUserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *CreateUserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *CreateUserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUserList(s)
	}
}

func (s *CreateUserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUserList(s)
	}
}

func (s *CreateUserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUserList() (localctx ICreateUserListContext) {
	localctx = NewCreateUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, MySQLParserRULE_createUserList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7875)
		p.CreateUserEntry()
	}
	p.SetState(7880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1048, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7876)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7877)
				p.CreateUserEntry()
			}

		}
		p.SetState(7882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1048, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserListContext is an interface to support dynamic dispatch.
type IAlterUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterUserEntry() []IAlterUserEntryContext
	AlterUserEntry(i int) IAlterUserEntryContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterUserListContext differentiates from other interfaces.
	IsAlterUserListContext()
}

type AlterUserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserListContext() *AlterUserListContext {
	var p = new(AlterUserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserList
	return p
}

func InitEmptyAlterUserListContext(p *AlterUserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserList
}

func (*AlterUserListContext) IsAlterUserListContext() {}

func NewAlterUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserListContext {
	var p = new(AlterUserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterUserList

	return p
}

func (s *AlterUserListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserListContext) AllAlterUserEntry() []IAlterUserEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterUserEntryContext); ok {
			len++
		}
	}

	tst := make([]IAlterUserEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterUserEntryContext); ok {
			tst[i] = t.(IAlterUserEntryContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserListContext) AlterUserEntry(i int) IAlterUserEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserEntryContext)
}

func (s *AlterUserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *AlterUserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *AlterUserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterUserList(s)
	}
}

func (s *AlterUserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterUserList(s)
	}
}

func (s *AlterUserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterUserList() (localctx IAlterUserListContext) {
	localctx = NewAlterUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, MySQLParserRULE_alterUserList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7883)
		p.AlterUserEntry()
	}
	p.SetState(7888)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1049, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(7884)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7885)
				p.AlterUserEntry()
			}

		}
		p.SetState(7890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1049, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserEntryContext is an interface to support dynamic dispatch.
type ICreateUserEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	RANDOM_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	TextStringHash() ITextStringHashContext

	// IsCreateUserEntryContext differentiates from other interfaces.
	IsCreateUserEntryContext()
}

type CreateUserEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserEntryContext() *CreateUserEntryContext {
	var p = new(CreateUserEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserEntry
	return p
}

func InitEmptyCreateUserEntryContext(p *CreateUserEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_createUserEntry
}

func (*CreateUserEntryContext) IsCreateUserEntryContext() {}

func NewCreateUserEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserEntryContext {
	var p = new(CreateUserEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_createUserEntry

	return p
}

func (s *CreateUserEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserEntryContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserEntryContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *CreateUserEntryContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *CreateUserEntryContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CreateUserEntryContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANDOM_SYMBOL, 0)
}

func (s *CreateUserEntryContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *CreateUserEntryContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextStringHash() ITextStringHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringHashContext)
}

func (s *CreateUserEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterCreateUserEntry(s)
	}
}

func (s *CreateUserEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitCreateUserEntry(s)
	}
}

func (s *CreateUserEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitCreateUserEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) CreateUserEntry() (localctx ICreateUserEntryContext) {
	localctx = NewCreateUserEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, MySQLParserRULE_createUserEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7891)
		p.User()
	}
	p.SetState(7918)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1054, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7892)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1053, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(7893)
				p.Match(MySQLParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7896)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1050, p.GetParserRuleContext()) == 1 {
				p.SetState(7894)

				if !(serverVersion < 80011) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80011", ""))
					goto errorExit
				}
				{
					p.SetState(7895)
					p.Match(MySQLParserPASSWORD_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(7898)
				p.TextString()
			}

		case 2:
			{
				p.SetState(7899)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7900)
				p.TextOrIdentifier()
			}
			p.SetState(7906)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1051, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7901)
					p.Match(MySQLParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7902)
					p.TextStringHash()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1051, p.GetParserRuleContext()) == 2 {
				p.SetState(7903)

				if !(serverVersion >= 50706) {
					p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50706", ""))
					goto errorExit
				}
				{
					p.SetState(7904)
					p.Match(MySQLParserBY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7905)
					p.TextString()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 3:
			p.SetState(7908)

			if !(serverVersion >= 80018) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80018", ""))
				goto errorExit
			}
			p.SetState(7911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserWITH_SYMBOL {
				{
					p.SetState(7909)
					p.Match(MySQLParserWITH_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7910)
					p.TextOrIdentifier()
				}

			}
			{
				p.SetState(7913)
				p.Match(MySQLParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7914)
				p.Match(MySQLParserRANDOM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7915)
				p.Match(MySQLParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserEntryContext is an interface to support dynamic dispatch.
type IAlterUserEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	DiscardOldPassword() IDiscardOldPasswordContext
	REPLACE_SYMBOL() antlr.TerminalNode
	RetainCurrentPassword() IRetainCurrentPasswordContext
	AS_SYMBOL() antlr.TerminalNode
	TextStringHash() ITextStringHashContext

	// IsAlterUserEntryContext differentiates from other interfaces.
	IsAlterUserEntryContext()
}

type AlterUserEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserEntryContext() *AlterUserEntryContext {
	var p = new(AlterUserEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserEntry
	return p
}

func InitEmptyAlterUserEntryContext(p *AlterUserEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_alterUserEntry
}

func (*AlterUserEntryContext) IsAlterUserEntryContext() {}

func NewAlterUserEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserEntryContext {
	var p = new(AlterUserEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_alterUserEntry

	return p
}

func (s *AlterUserEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserEntryContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserEntryContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *AlterUserEntryContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBY_SYMBOL, 0)
}

func (s *AlterUserEntryContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserEntryContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *AlterUserEntryContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITH_SYMBOL, 0)
}

func (s *AlterUserEntryContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *AlterUserEntryContext) DiscardOldPassword() IDiscardOldPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiscardOldPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiscardOldPasswordContext)
}

func (s *AlterUserEntryContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *AlterUserEntryContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *AlterUserEntryContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAS_SYMBOL, 0)
}

func (s *AlterUserEntryContext) TextStringHash() ITextStringHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringHashContext)
}

func (s *AlterUserEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterAlterUserEntry(s)
	}
}

func (s *AlterUserEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitAlterUserEntry(s)
	}
}

func (s *AlterUserEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitAlterUserEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) AlterUserEntry() (localctx IAlterUserEntryContext) {
	localctx = NewAlterUserEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, MySQLParserRULE_alterUserEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7920)
		p.User()
	}
	p.SetState(7949)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1062, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7921)
			p.Match(MySQLParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7944)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1060, p.GetParserRuleContext()) == 1 {
			p.SetState(7924)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserWITH_SYMBOL {
				{
					p.SetState(7922)
					p.Match(MySQLParserWITH_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7923)
					p.TextOrIdentifier()
				}

			}
			{
				p.SetState(7926)
				p.Match(MySQLParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7927)
				p.TextString()
			}
			p.SetState(7930)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1056, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7928)
					p.Match(MySQLParserREPLACE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7929)
					p.TextString()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			p.SetState(7933)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1057, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7932)
					p.RetainCurrentPassword()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1060, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(7935)
				p.Match(MySQLParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7936)
				p.TextOrIdentifier()
			}
			p.SetState(7942)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1059, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(7937)
					p.Match(MySQLParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7938)
					p.TextStringHash()
				}
				p.SetState(7940)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1058, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(7939)
						p.RetainCurrentPassword()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.SetState(7947)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1061, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7946)
				p.DiscardOldPassword()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetainCurrentPasswordContext is an interface to support dynamic dispatch.
type IRetainCurrentPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode

	// IsRetainCurrentPasswordContext differentiates from other interfaces.
	IsRetainCurrentPasswordContext()
}

type RetainCurrentPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetainCurrentPasswordContext() *RetainCurrentPasswordContext {
	var p = new(RetainCurrentPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_retainCurrentPassword
	return p
}

func InitEmptyRetainCurrentPasswordContext(p *RetainCurrentPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_retainCurrentPassword
}

func (*RetainCurrentPasswordContext) IsRetainCurrentPasswordContext() {}

func NewRetainCurrentPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetainCurrentPasswordContext {
	var p = new(RetainCurrentPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_retainCurrentPassword

	return p
}

func (s *RetainCurrentPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *RetainCurrentPasswordContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETAIN_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetainCurrentPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetainCurrentPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRetainCurrentPassword(s)
	}
}

func (s *RetainCurrentPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRetainCurrentPassword(s)
	}
}

func (s *RetainCurrentPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRetainCurrentPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RetainCurrentPassword() (localctx IRetainCurrentPasswordContext) {
	localctx = NewRetainCurrentPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, MySQLParserRULE_retainCurrentPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7951)
		p.Match(MySQLParserRETAIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7952)
		p.Match(MySQLParserCURRENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7953)
		p.Match(MySQLParserPASSWORD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiscardOldPasswordContext is an interface to support dynamic dispatch.
type IDiscardOldPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISCARD_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode

	// IsDiscardOldPasswordContext differentiates from other interfaces.
	IsDiscardOldPasswordContext()
}

type DiscardOldPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiscardOldPasswordContext() *DiscardOldPasswordContext {
	var p = new(DiscardOldPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_discardOldPassword
	return p
}

func InitEmptyDiscardOldPasswordContext(p *DiscardOldPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_discardOldPassword
}

func (*DiscardOldPasswordContext) IsDiscardOldPasswordContext() {}

func NewDiscardOldPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiscardOldPasswordContext {
	var p = new(DiscardOldPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_discardOldPassword

	return p
}

func (s *DiscardOldPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *DiscardOldPasswordContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISCARD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiscardOldPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiscardOldPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDiscardOldPassword(s)
	}
}

func (s *DiscardOldPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDiscardOldPassword(s)
	}
}

func (s *DiscardOldPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDiscardOldPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DiscardOldPassword() (localctx IDiscardOldPasswordContext) {
	localctx = NewDiscardOldPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, MySQLParserRULE_discardOldPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7955)
		p.Match(MySQLParserDISCARD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7956)
		p.Match(MySQLParserOLD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7957)
		p.Match(MySQLParserPASSWORD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePasswordContext is an interface to support dynamic dispatch.
type IReplacePasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext

	// IsReplacePasswordContext differentiates from other interfaces.
	IsReplacePasswordContext()
}

type ReplacePasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacePasswordContext() *ReplacePasswordContext {
	var p = new(ReplacePasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replacePassword
	return p
}

func InitEmptyReplacePasswordContext(p *ReplacePasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_replacePassword
}

func (*ReplacePasswordContext) IsReplacePasswordContext() {}

func NewReplacePasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePasswordContext {
	var p = new(ReplacePasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_replacePassword

	return p
}

func (s *ReplacePasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePasswordContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLACE_SYMBOL, 0)
}

func (s *ReplacePasswordContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *ReplacePasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReplacePassword(s)
	}
}

func (s *ReplacePasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReplacePassword(s)
	}
}

func (s *ReplacePasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReplacePassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ReplacePassword() (localctx IReplacePasswordContext) {
	localctx = NewReplacePasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, MySQLParserRULE_replacePassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7959)
		p.Match(MySQLParserREPLACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7960)
		p.TextString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifierOrTextContext is an interface to support dynamic dispatch.
type IUserIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextOrIdentifier() []ITextOrIdentifierContext
	TextOrIdentifier(i int) ITextOrIdentifierContext
	AT_SIGN_SYMBOL() antlr.TerminalNode
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsUserIdentifierOrTextContext differentiates from other interfaces.
	IsUserIdentifierOrTextContext()
}

type UserIdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserIdentifierOrTextContext() *UserIdentifierOrTextContext {
	var p = new(UserIdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userIdentifierOrText
	return p
}

func InitEmptyUserIdentifierOrTextContext(p *UserIdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_userIdentifierOrText
}

func (*UserIdentifierOrTextContext) IsUserIdentifierOrTextContext() {}

func NewUserIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifierOrTextContext {
	var p = new(UserIdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_userIdentifierOrText

	return p
}

func (s *UserIdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifierOrTextContext) AllTextOrIdentifier() []ITextOrIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITextOrIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextOrIdentifierContext); ok {
			tst[i] = t.(ITextOrIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifierOrTextContext) TextOrIdentifier(i int) ITextOrIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *UserIdentifierOrTextContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SIGN_SYMBOL, 0)
}

func (s *UserIdentifierOrTextContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_TEXT_SUFFIX, 0)
}

func (s *UserIdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUserIdentifierOrText(s)
	}
}

func (s *UserIdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUserIdentifierOrText(s)
	}
}

func (s *UserIdentifierOrTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUserIdentifierOrText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UserIdentifierOrText() (localctx IUserIdentifierOrTextContext) {
	localctx = NewUserIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, MySQLParserRULE_userIdentifierOrText)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7962)
		p.TextOrIdentifier()
	}
	p.SetState(7966)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1063, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7963)
			p.Match(MySQLParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7964)
			p.TextOrIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1063, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(7965)
			p.Match(MySQLParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentifierOrText() IUserIdentifierOrTextContext
	CURRENT_USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) UserIdentifierOrText() IUserIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifierOrTextContext)
}

func (s *UserContext) CURRENT_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_USER_SYMBOL, 0)
}

func (s *UserContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUser(s)
	}
}

func (s *UserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, MySQLParserRULE_user)
	p.SetState(7973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1065, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7968)
			p.UserIdentifierOrText()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7969)
			p.Match(MySQLParserCURRENT_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7971)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1064, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7970)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIKE_SYMBOL, 0)
}

func (s *LikeClauseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, MySQLParserRULE_likeClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7975)
		p.Match(MySQLParserLIKE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7976)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeOrWhereContext is an interface to support dynamic dispatch.
type ILikeOrWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LikeClause() ILikeClauseContext
	WhereClause() IWhereClauseContext

	// IsLikeOrWhereContext differentiates from other interfaces.
	IsLikeOrWhereContext()
}

type LikeOrWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeOrWhereContext() *LikeOrWhereContext {
	var p = new(LikeOrWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_likeOrWhere
	return p
}

func InitEmptyLikeOrWhereContext(p *LikeOrWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_likeOrWhere
}

func (*LikeOrWhereContext) IsLikeOrWhereContext() {}

func NewLikeOrWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeOrWhereContext {
	var p = new(LikeOrWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_likeOrWhere

	return p
}

func (s *LikeOrWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeOrWhereContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *LikeOrWhereContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *LikeOrWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeOrWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeOrWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLikeOrWhere(s)
	}
}

func (s *LikeOrWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLikeOrWhere(s)
	}
}

func (s *LikeOrWhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLikeOrWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LikeOrWhere() (localctx ILikeOrWhereContext) {
	localctx = NewLikeOrWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, MySQLParserRULE_likeOrWhere)
	p.SetState(7980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserLIKE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7978)
			p.LikeClause()
		}

	case MySQLParserWHERE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7979)
			p.WhereClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnlineOptionContext is an interface to support dynamic dispatch.
type IOnlineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONLINE_SYMBOL() antlr.TerminalNode
	OFFLINE_SYMBOL() antlr.TerminalNode

	// IsOnlineOptionContext differentiates from other interfaces.
	IsOnlineOptionContext()
}

type OnlineOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnlineOptionContext() *OnlineOptionContext {
	var p = new(OnlineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onlineOption
	return p
}

func InitEmptyOnlineOptionContext(p *OnlineOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_onlineOption
}

func (*OnlineOptionContext) IsOnlineOptionContext() {}

func NewOnlineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnlineOptionContext {
	var p = new(OnlineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_onlineOption

	return p
}

func (s *OnlineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OnlineOptionContext) ONLINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONLINE_SYMBOL, 0)
}

func (s *OnlineOptionContext) OFFLINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFFLINE_SYMBOL, 0)
}

func (s *OnlineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnlineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnlineOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOnlineOption(s)
	}
}

func (s *OnlineOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOnlineOption(s)
	}
}

func (s *OnlineOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOnlineOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OnlineOption() (localctx IOnlineOptionContext) {
	localctx = NewOnlineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, MySQLParserRULE_onlineOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7982)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserOFFLINE_SYMBOL || _la == MySQLParserONLINE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoWriteToBinLogContext is an interface to support dynamic dispatch.
type INoWriteToBinLogContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_SYMBOL() antlr.TerminalNode
	NO_WRITE_TO_BINLOG_SYMBOL() antlr.TerminalNode

	// IsNoWriteToBinLogContext differentiates from other interfaces.
	IsNoWriteToBinLogContext()
}

type NoWriteToBinLogContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoWriteToBinLogContext() *NoWriteToBinLogContext {
	var p = new(NoWriteToBinLogContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_noWriteToBinLog
	return p
}

func InitEmptyNoWriteToBinLogContext(p *NoWriteToBinLogContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_noWriteToBinLog
}

func (*NoWriteToBinLogContext) IsNoWriteToBinLogContext() {}

func NewNoWriteToBinLogContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoWriteToBinLogContext {
	var p = new(NoWriteToBinLogContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_noWriteToBinLog

	return p
}

func (s *NoWriteToBinLogContext) GetParser() antlr.Parser { return s.parser }

func (s *NoWriteToBinLogContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *NoWriteToBinLogContext) NO_WRITE_TO_BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_WRITE_TO_BINLOG_SYMBOL, 0)
}

func (s *NoWriteToBinLogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoWriteToBinLogContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoWriteToBinLogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNoWriteToBinLog(s)
	}
}

func (s *NoWriteToBinLogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNoWriteToBinLog(s)
	}
}

func (s *NoWriteToBinLogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNoWriteToBinLog(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NoWriteToBinLog() (localctx INoWriteToBinLogContext) {
	localctx = NewNoWriteToBinLogContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, MySQLParserRULE_noWriteToBinLog)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7984)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserNO_WRITE_TO_BINLOG_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsePartitionContext is an interface to support dynamic dispatch.
type IUsePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext

	// IsUsePartitionContext differentiates from other interfaces.
	IsUsePartitionContext()
}

type UsePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsePartitionContext() *UsePartitionContext {
	var p = new(UsePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_usePartition
	return p
}

func InitEmptyUsePartitionContext(p *UsePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_usePartition
}

func (*UsePartitionContext) IsUsePartitionContext() {}

func NewUsePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsePartitionContext {
	var p = new(UsePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_usePartition

	return p
}

func (s *UsePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UsePartitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *UsePartitionContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *UsePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUsePartition(s)
	}
}

func (s *UsePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUsePartition(s)
	}
}

func (s *UsePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUsePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UsePartition() (localctx IUsePartitionContext) {
	localctx = NewUsePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, MySQLParserRULE_usePartition)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(7986)

	if !(serverVersion >= 50602) {
		p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50602", ""))
		goto errorExit
	}
	{
		p.SetState(7987)
		p.Match(MySQLParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7988)
		p.IdentifierListWithParentheses()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldIdentifierContext is an interface to support dynamic dispatch.
type IFieldIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DotIdentifier() IDotIdentifierContext
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFieldIdentifierContext differentiates from other interfaces.
	IsFieldIdentifierContext()
}

type FieldIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldIdentifierContext() *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldIdentifier
	return p
}

func InitEmptyFieldIdentifierContext(p *FieldIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_fieldIdentifier
}

func (*FieldIdentifierContext) IsFieldIdentifierContext() {}

func NewFieldIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_fieldIdentifier

	return p
}

func (s *FieldIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldIdentifierContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *FieldIdentifierContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FieldIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFieldIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FieldIdentifier() (localctx IFieldIdentifierContext) {
	localctx = NewFieldIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, MySQLParserRULE_fieldIdentifier)
	p.SetState(7995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1068, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7990)
			p.DotIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7991)
			p.QualifiedIdentifier()
		}
		p.SetState(7993)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1067, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7992)
				p.DotIdentifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FieldIdentifier() IFieldIdentifierContext

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnName
	return p
}

func InitEmptyColumnNameContext(p *ColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnName
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnName() (localctx IColumnNameContext) {
	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, MySQLParserRULE_columnName)
	p.SetState(8001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1069, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(7997)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(7998)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7999)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(8000)
			p.FieldIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnInternalRefContext is an interface to support dynamic dispatch.
type IColumnInternalRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnInternalRefContext differentiates from other interfaces.
	IsColumnInternalRefContext()
}

type ColumnInternalRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnInternalRefContext() *ColumnInternalRefContext {
	var p = new(ColumnInternalRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnInternalRef
	return p
}

func InitEmptyColumnInternalRefContext(p *ColumnInternalRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnInternalRef
}

func (*ColumnInternalRefContext) IsColumnInternalRefContext() {}

func NewColumnInternalRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnInternalRefContext {
	var p = new(ColumnInternalRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnInternalRef

	return p
}

func (s *ColumnInternalRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnInternalRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnInternalRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnInternalRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnInternalRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnInternalRef(s)
	}
}

func (s *ColumnInternalRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnInternalRef(s)
	}
}

func (s *ColumnInternalRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnInternalRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnInternalRef() (localctx IColumnInternalRefContext) {
	localctx = NewColumnInternalRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, MySQLParserRULE_columnInternalRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8003)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnInternalRefListContext is an interface to support dynamic dispatch.
type IColumnInternalRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllColumnInternalRef() []IColumnInternalRefContext
	ColumnInternalRef(i int) IColumnInternalRefContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumnInternalRefListContext differentiates from other interfaces.
	IsColumnInternalRefListContext()
}

type ColumnInternalRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnInternalRefListContext() *ColumnInternalRefListContext {
	var p = new(ColumnInternalRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnInternalRefList
	return p
}

func InitEmptyColumnInternalRefListContext(p *ColumnInternalRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnInternalRefList
}

func (*ColumnInternalRefListContext) IsColumnInternalRefListContext() {}

func NewColumnInternalRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnInternalRefListContext {
	var p = new(ColumnInternalRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnInternalRefList

	return p
}

func (s *ColumnInternalRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnInternalRefListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ColumnInternalRefListContext) AllColumnInternalRef() []IColumnInternalRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnInternalRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnInternalRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnInternalRefContext); ok {
			tst[i] = t.(IColumnInternalRefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnInternalRefListContext) ColumnInternalRef(i int) IColumnInternalRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefContext)
}

func (s *ColumnInternalRefListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ColumnInternalRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *ColumnInternalRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *ColumnInternalRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnInternalRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnInternalRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnInternalRefList(s)
	}
}

func (s *ColumnInternalRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnInternalRefList(s)
	}
}

func (s *ColumnInternalRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnInternalRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnInternalRefList() (localctx IColumnInternalRefListContext) {
	localctx = NewColumnInternalRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, MySQLParserRULE_columnInternalRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8005)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8006)
		p.ColumnInternalRef()
	}
	p.SetState(8011)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(8007)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8008)
			p.ColumnInternalRef()
		}

		p.SetState(8013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8014)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRefContext is an interface to support dynamic dispatch.
type IColumnRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext

	// IsColumnRefContext differentiates from other interfaces.
	IsColumnRefContext()
}

type ColumnRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefContext() *ColumnRefContext {
	var p = new(ColumnRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnRef
	return p
}

func InitEmptyColumnRefContext(p *ColumnRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_columnRef
}

func (*ColumnRefContext) IsColumnRefContext() {}

func NewColumnRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefContext {
	var p = new(ColumnRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_columnRef

	return p
}

func (s *ColumnRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ColumnRef() (localctx IColumnRefContext) {
	localctx = NewColumnRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, MySQLParserRULE_columnRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8016)
		p.FieldIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertIdentifierContext is an interface to support dynamic dispatch.
type IInsertIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	TableWild() ITableWildContext

	// IsInsertIdentifierContext differentiates from other interfaces.
	IsInsertIdentifierContext()
}

type InsertIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertIdentifierContext() *InsertIdentifierContext {
	var p = new(InsertIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertIdentifier
	return p
}

func InitEmptyInsertIdentifierContext(p *InsertIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_insertIdentifier
}

func (*InsertIdentifierContext) IsInsertIdentifierContext() {}

func NewInsertIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertIdentifierContext {
	var p = new(InsertIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_insertIdentifier

	return p
}

func (s *InsertIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertIdentifierContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *InsertIdentifierContext) TableWild() ITableWildContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableWildContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableWildContext)
}

func (s *InsertIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterInsertIdentifier(s)
	}
}

func (s *InsertIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitInsertIdentifier(s)
	}
}

func (s *InsertIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitInsertIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) InsertIdentifier() (localctx IInsertIdentifierContext) {
	localctx = NewInsertIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, MySQLParserRULE_insertIdentifier)
	p.SetState(8020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1071, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8018)
			p.ColumnRef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8019)
			p.TableWild()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, MySQLParserRULE_indexName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8022)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexRefContext is an interface to support dynamic dispatch.
type IIndexRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext

	// IsIndexRefContext differentiates from other interfaces.
	IsIndexRefContext()
}

type IndexRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexRefContext() *IndexRefContext {
	var p = new(IndexRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexRef
	return p
}

func InitEmptyIndexRefContext(p *IndexRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_indexRef
}

func (*IndexRefContext) IsIndexRefContext() {}

func NewIndexRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexRefContext {
	var p = new(IndexRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_indexRef

	return p
}

func (s *IndexRefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexRefContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *IndexRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIndexRef(s)
	}
}

func (s *IndexRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIndexRef(s)
	}
}

func (s *IndexRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIndexRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IndexRef() (localctx IIndexRefContext) {
	localctx = NewIndexRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, MySQLParserRULE_indexRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8024)
		p.FieldIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableWildContext is an interface to support dynamic dispatch.
type ITableWildContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_SYMBOL() []antlr.TerminalNode
	DOT_SYMBOL(i int) antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode

	// IsTableWildContext differentiates from other interfaces.
	IsTableWildContext()
}

type TableWildContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableWildContext() *TableWildContext {
	var p = new(TableWildContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableWild
	return p
}

func InitEmptyTableWildContext(p *TableWildContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableWild
}

func (*TableWildContext) IsTableWildContext() {}

func NewTableWildContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableWildContext {
	var p = new(TableWildContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableWild

	return p
}

func (s *TableWildContext) GetParser() antlr.Parser { return s.parser }

func (s *TableWildContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TableWildContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableWildContext) AllDOT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserDOT_SYMBOL)
}

func (s *TableWildContext) DOT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, i)
}

func (s *TableWildContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *TableWildContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableWildContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableWildContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableWild(s)
	}
}

func (s *TableWildContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableWild(s)
	}
}

func (s *TableWildContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableWild(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableWild() (localctx ITableWildContext) {
	localctx = NewTableWildContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, MySQLParserRULE_tableWild)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8026)
		p.Identifier()
	}
	{
		p.SetState(8027)
		p.Match(MySQLParserDOT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(8031)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1072, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(8028)
			p.Identifier()
		}
		{
			p.SetState(8029)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(8033)
		p.Match(MySQLParserMULT_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaName
	return p
}

func InitEmptySchemaNameContext(p *SchemaNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaName
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (s *SchemaNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSchemaName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SchemaName() (localctx ISchemaNameContext) {
	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, MySQLParserRULE_schemaName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8035)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaRefContext is an interface to support dynamic dispatch.
type ISchemaRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSchemaRefContext differentiates from other interfaces.
	IsSchemaRefContext()
}

type SchemaRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaRefContext() *SchemaRefContext {
	var p = new(SchemaRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaRef
	return p
}

func InitEmptySchemaRefContext(p *SchemaRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_schemaRef
}

func (*SchemaRefContext) IsSchemaRefContext() {}

func NewSchemaRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaRefContext {
	var p = new(SchemaRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_schemaRef

	return p
}

func (s *SchemaRefContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSchemaRef(s)
	}
}

func (s *SchemaRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSchemaRef(s)
	}
}

func (s *SchemaRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSchemaRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SchemaRef() (localctx ISchemaRefContext) {
	localctx = NewSchemaRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, MySQLParserRULE_schemaRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8037)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureName
	return p
}

func InitEmptyProcedureNameContext(p *ProcedureNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureName
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, MySQLParserRULE_procedureName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8039)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureRefContext is an interface to support dynamic dispatch.
type IProcedureRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsProcedureRefContext differentiates from other interfaces.
	IsProcedureRefContext()
}

type ProcedureRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureRefContext() *ProcedureRefContext {
	var p = new(ProcedureRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureRef
	return p
}

func InitEmptyProcedureRefContext(p *ProcedureRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_procedureRef
}

func (*ProcedureRefContext) IsProcedureRefContext() {}

func NewProcedureRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureRefContext {
	var p = new(ProcedureRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_procedureRef

	return p
}

func (s *ProcedureRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ProcedureRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterProcedureRef(s)
	}
}

func (s *ProcedureRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitProcedureRef(s)
	}
}

func (s *ProcedureRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitProcedureRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ProcedureRef() (localctx IProcedureRefContext) {
	localctx = NewProcedureRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, MySQLParserRULE_procedureRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8041)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, MySQLParserRULE_functionName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8043)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionRefContext is an interface to support dynamic dispatch.
type IFunctionRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFunctionRefContext differentiates from other interfaces.
	IsFunctionRefContext()
}

type FunctionRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionRefContext() *FunctionRefContext {
	var p = new(FunctionRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionRef
	return p
}

func InitEmptyFunctionRefContext(p *FunctionRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_functionRef
}

func (*FunctionRefContext) IsFunctionRefContext() {}

func NewFunctionRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionRefContext {
	var p = new(FunctionRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_functionRef

	return p
}

func (s *FunctionRefContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFunctionRef(s)
	}
}

func (s *FunctionRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFunctionRef(s)
	}
}

func (s *FunctionRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFunctionRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FunctionRef() (localctx IFunctionRefContext) {
	localctx = NewFunctionRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, MySQLParserRULE_functionRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8045)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerNameContext is an interface to support dynamic dispatch.
type ITriggerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsTriggerNameContext differentiates from other interfaces.
	IsTriggerNameContext()
}

type TriggerNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerNameContext() *TriggerNameContext {
	var p = new(TriggerNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerName
	return p
}

func InitEmptyTriggerNameContext(p *TriggerNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerName
}

func (*TriggerNameContext) IsTriggerNameContext() {}

func NewTriggerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerNameContext {
	var p = new(TriggerNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_triggerName

	return p
}

func (s *TriggerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TriggerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTriggerName(s)
	}
}

func (s *TriggerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTriggerName(s)
	}
}

func (s *TriggerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTriggerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TriggerName() (localctx ITriggerNameContext) {
	localctx = NewTriggerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, MySQLParserRULE_triggerName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8047)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerRefContext is an interface to support dynamic dispatch.
type ITriggerRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsTriggerRefContext differentiates from other interfaces.
	IsTriggerRefContext()
}

type TriggerRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerRefContext() *TriggerRefContext {
	var p = new(TriggerRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerRef
	return p
}

func InitEmptyTriggerRefContext(p *TriggerRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_triggerRef
}

func (*TriggerRefContext) IsTriggerRefContext() {}

func NewTriggerRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerRefContext {
	var p = new(TriggerRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_triggerRef

	return p
}

func (s *TriggerRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TriggerRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTriggerRef(s)
	}
}

func (s *TriggerRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTriggerRef(s)
	}
}

func (s *TriggerRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTriggerRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TriggerRef() (localctx ITriggerRefContext) {
	localctx = NewTriggerRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, MySQLParserRULE_triggerRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8049)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewNameContext is an interface to support dynamic dispatch.
type IViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsViewNameContext differentiates from other interfaces.
	IsViewNameContext()
}

type ViewNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewNameContext() *ViewNameContext {
	var p = new(ViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewName
	return p
}

func InitEmptyViewNameContext(p *ViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewName
}

func (*ViewNameContext) IsViewNameContext() {}

func NewViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewNameContext {
	var p = new(ViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewName

	return p
}

func (s *ViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ViewNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *ViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewName(s)
	}
}

func (s *ViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewName(s)
	}
}

func (s *ViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewName() (localctx IViewNameContext) {
	localctx = NewViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, MySQLParserRULE_viewName)
	p.SetState(8053)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1073, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8051)
			p.QualifiedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8052)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewRefContext is an interface to support dynamic dispatch.
type IViewRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsViewRefContext differentiates from other interfaces.
	IsViewRefContext()
}

type ViewRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewRefContext() *ViewRefContext {
	var p = new(ViewRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewRef
	return p
}

func InitEmptyViewRefContext(p *ViewRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_viewRef
}

func (*ViewRefContext) IsViewRefContext() {}

func NewViewRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewRefContext {
	var p = new(ViewRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_viewRef

	return p
}

func (s *ViewRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ViewRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *ViewRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterViewRef(s)
	}
}

func (s *ViewRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitViewRef(s)
	}
}

func (s *ViewRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitViewRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ViewRef() (localctx IViewRefContext) {
	localctx = NewViewRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, MySQLParserRULE_viewRef)
	p.SetState(8057)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1074, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8055)
			p.QualifiedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8056)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceNameContext is an interface to support dynamic dispatch.
type ITablespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsTablespaceNameContext differentiates from other interfaces.
	IsTablespaceNameContext()
}

type TablespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceNameContext() *TablespaceNameContext {
	var p = new(TablespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceName
	return p
}

func InitEmptyTablespaceNameContext(p *TablespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceName
}

func (*TablespaceNameContext) IsTablespaceNameContext() {}

func NewTablespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceNameContext {
	var p = new(TablespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tablespaceName

	return p
}

func (s *TablespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTablespaceName(s)
	}
}

func (s *TablespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTablespaceName(s)
	}
}

func (s *TablespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTablespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TablespaceName() (localctx ITablespaceNameContext) {
	localctx = NewTablespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, MySQLParserRULE_tablespaceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8059)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceRefContext is an interface to support dynamic dispatch.
type ITablespaceRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsTablespaceRefContext differentiates from other interfaces.
	IsTablespaceRefContext()
}

type TablespaceRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceRefContext() *TablespaceRefContext {
	var p = new(TablespaceRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceRef
	return p
}

func InitEmptyTablespaceRefContext(p *TablespaceRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tablespaceRef
}

func (*TablespaceRefContext) IsTablespaceRefContext() {}

func NewTablespaceRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceRefContext {
	var p = new(TablespaceRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tablespaceRef

	return p
}

func (s *TablespaceRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablespaceRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTablespaceRef(s)
	}
}

func (s *TablespaceRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTablespaceRef(s)
	}
}

func (s *TablespaceRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTablespaceRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TablespaceRef() (localctx ITablespaceRefContext) {
	localctx = NewTablespaceRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, MySQLParserRULE_tablespaceRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8061)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupNameContext is an interface to support dynamic dispatch.
type ILogfileGroupNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLogfileGroupNameContext differentiates from other interfaces.
	IsLogfileGroupNameContext()
}

type LogfileGroupNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupNameContext() *LogfileGroupNameContext {
	var p = new(LogfileGroupNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupName
	return p
}

func InitEmptyLogfileGroupNameContext(p *LogfileGroupNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupName
}

func (*LogfileGroupNameContext) IsLogfileGroupNameContext() {}

func NewLogfileGroupNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupNameContext {
	var p = new(LogfileGroupNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_logfileGroupName

	return p
}

func (s *LogfileGroupNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LogfileGroupNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLogfileGroupName(s)
	}
}

func (s *LogfileGroupNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLogfileGroupName(s)
	}
}

func (s *LogfileGroupNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLogfileGroupName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LogfileGroupName() (localctx ILogfileGroupNameContext) {
	localctx = NewLogfileGroupNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, MySQLParserRULE_logfileGroupName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8063)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupRefContext is an interface to support dynamic dispatch.
type ILogfileGroupRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLogfileGroupRefContext differentiates from other interfaces.
	IsLogfileGroupRefContext()
}

type LogfileGroupRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupRefContext() *LogfileGroupRefContext {
	var p = new(LogfileGroupRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupRef
	return p
}

func InitEmptyLogfileGroupRefContext(p *LogfileGroupRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_logfileGroupRef
}

func (*LogfileGroupRefContext) IsLogfileGroupRefContext() {}

func NewLogfileGroupRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupRefContext {
	var p = new(LogfileGroupRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_logfileGroupRef

	return p
}

func (s *LogfileGroupRefContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LogfileGroupRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLogfileGroupRef(s)
	}
}

func (s *LogfileGroupRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLogfileGroupRef(s)
	}
}

func (s *LogfileGroupRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLogfileGroupRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LogfileGroupRef() (localctx ILogfileGroupRefContext) {
	localctx = NewLogfileGroupRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, MySQLParserRULE_logfileGroupRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8065)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventNameContext is an interface to support dynamic dispatch.
type IEventNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsEventNameContext differentiates from other interfaces.
	IsEventNameContext()
}

type EventNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventNameContext() *EventNameContext {
	var p = new(EventNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_eventName
	return p
}

func InitEmptyEventNameContext(p *EventNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_eventName
}

func (*EventNameContext) IsEventNameContext() {}

func NewEventNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventNameContext {
	var p = new(EventNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_eventName

	return p
}

func (s *EventNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EventNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *EventNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterEventName(s)
	}
}

func (s *EventNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitEventName(s)
	}
}

func (s *EventNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitEventName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) EventName() (localctx IEventNameContext) {
	localctx = NewEventNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, MySQLParserRULE_eventName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8067)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventRefContext is an interface to support dynamic dispatch.
type IEventRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsEventRefContext differentiates from other interfaces.
	IsEventRefContext()
}

type EventRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventRefContext() *EventRefContext {
	var p = new(EventRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_eventRef
	return p
}

func InitEmptyEventRefContext(p *EventRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_eventRef
}

func (*EventRefContext) IsEventRefContext() {}

func NewEventRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventRefContext {
	var p = new(EventRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_eventRef

	return p
}

func (s *EventRefContext) GetParser() antlr.Parser { return s.parser }

func (s *EventRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *EventRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterEventRef(s)
	}
}

func (s *EventRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitEventRef(s)
	}
}

func (s *EventRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitEventRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) EventRef() (localctx IEventRefContext) {
	localctx = NewEventRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, MySQLParserRULE_eventRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8069)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfNameContext is an interface to support dynamic dispatch.
type IUdfNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsUdfNameContext differentiates from other interfaces.
	IsUdfNameContext()
}

type UdfNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfNameContext() *UdfNameContext {
	var p = new(UdfNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfName
	return p
}

func InitEmptyUdfNameContext(p *UdfNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_udfName
}

func (*UdfNameContext) IsUdfNameContext() {}

func NewUdfNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfNameContext {
	var p = new(UdfNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_udfName

	return p
}

func (s *UdfNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UdfNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUdfName(s)
	}
}

func (s *UdfNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUdfName(s)
	}
}

func (s *UdfNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUdfName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) UdfName() (localctx IUdfNameContext) {
	localctx = NewUdfNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, MySQLParserRULE_udfName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8071)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerNameContext is an interface to support dynamic dispatch.
type IServerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsServerNameContext differentiates from other interfaces.
	IsServerNameContext()
}

type ServerNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerNameContext() *ServerNameContext {
	var p = new(ServerNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverName
	return p
}

func InitEmptyServerNameContext(p *ServerNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverName
}

func (*ServerNameContext) IsServerNameContext() {}

func NewServerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerNameContext {
	var p = new(ServerNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_serverName

	return p
}

func (s *ServerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *ServerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterServerName(s)
	}
}

func (s *ServerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitServerName(s)
	}
}

func (s *ServerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitServerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ServerName() (localctx IServerNameContext) {
	localctx = NewServerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, MySQLParserRULE_serverName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8073)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerRefContext is an interface to support dynamic dispatch.
type IServerRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsServerRefContext differentiates from other interfaces.
	IsServerRefContext()
}

type ServerRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerRefContext() *ServerRefContext {
	var p = new(ServerRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverRef
	return p
}

func InitEmptyServerRefContext(p *ServerRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_serverRef
}

func (*ServerRefContext) IsServerRefContext() {}

func NewServerRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerRefContext {
	var p = new(ServerRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_serverRef

	return p
}

func (s *ServerRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerRefContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *ServerRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterServerRef(s)
	}
}

func (s *ServerRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitServerRef(s)
	}
}

func (s *ServerRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitServerRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ServerRef() (localctx IServerRefContext) {
	localctx = NewServerRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, MySQLParserRULE_serverRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8075)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineRefContext is an interface to support dynamic dispatch.
type IEngineRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsEngineRefContext differentiates from other interfaces.
	IsEngineRefContext()
}

type EngineRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineRefContext() *EngineRefContext {
	var p = new(EngineRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_engineRef
	return p
}

func InitEmptyEngineRefContext(p *EngineRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_engineRef
}

func (*EngineRefContext) IsEngineRefContext() {}

func NewEngineRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineRefContext {
	var p = new(EngineRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_engineRef

	return p
}

func (s *EngineRefContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineRefContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *EngineRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterEngineRef(s)
	}
}

func (s *EngineRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitEngineRef(s)
	}
}

func (s *EngineRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitEngineRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) EngineRef() (localctx IEngineRefContext) {
	localctx = NewEngineRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, MySQLParserRULE_engineRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8077)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TableNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, MySQLParserRULE_tableName)
	p.SetState(8081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1075, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8079)
			p.QualifiedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8080)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterTableRefContext is an interface to support dynamic dispatch.
type IFilterTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SchemaRef() ISchemaRefContext
	DotIdentifier() IDotIdentifierContext

	// IsFilterTableRefContext differentiates from other interfaces.
	IsFilterTableRefContext()
}

type FilterTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterTableRefContext() *FilterTableRefContext {
	var p = new(FilterTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterTableRef
	return p
}

func InitEmptyFilterTableRefContext(p *FilterTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_filterTableRef
}

func (*FilterTableRefContext) IsFilterTableRefContext() {}

func NewFilterTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterTableRefContext {
	var p = new(FilterTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_filterTableRef

	return p
}

func (s *FilterTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterTableRefContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *FilterTableRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *FilterTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterTableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFilterTableRef(s)
	}
}

func (s *FilterTableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFilterTableRef(s)
	}
}

func (s *FilterTableRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFilterTableRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FilterTableRef() (localctx IFilterTableRefContext) {
	localctx = NewFilterTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, MySQLParserRULE_filterTableRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8083)
		p.SchemaRef()
	}
	{
		p.SetState(8084)
		p.DotIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefWithWildcardContext is an interface to support dynamic dispatch.
type ITableRefWithWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT_SYMBOL() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	DotIdentifier() IDotIdentifierContext

	// IsTableRefWithWildcardContext differentiates from other interfaces.
	IsTableRefWithWildcardContext()
}

type TableRefWithWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefWithWildcardContext() *TableRefWithWildcardContext {
	var p = new(TableRefWithWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRefWithWildcard
	return p
}

func InitEmptyTableRefWithWildcardContext(p *TableRefWithWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRefWithWildcard
}

func (*TableRefWithWildcardContext) IsTableRefWithWildcardContext() {}

func NewTableRefWithWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefWithWildcardContext {
	var p = new(TableRefWithWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableRefWithWildcard

	return p
}

func (s *TableRefWithWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefWithWildcardContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRefWithWildcardContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, 0)
}

func (s *TableRefWithWildcardContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULT_OPERATOR, 0)
}

func (s *TableRefWithWildcardContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableRefWithWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefWithWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefWithWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableRefWithWildcard(s)
	}
}

func (s *TableRefWithWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableRefWithWildcard(s)
	}
}

func (s *TableRefWithWildcardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableRefWithWildcard(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableRefWithWildcard() (localctx ITableRefWithWildcardContext) {
	localctx = NewTableRefWithWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, MySQLParserRULE_tableRefWithWildcard)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8086)
		p.Identifier()
	}
	p.SetState(8094)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1077, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(8087)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8088)
			p.Match(MySQLParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1077, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(8089)
			p.DotIdentifier()
		}
		p.SetState(8092)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1076, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(8090)
				p.Match(MySQLParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8091)
				p.Match(MySQLParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefContext is an interface to support dynamic dispatch.
type ITableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsTableRefContext differentiates from other interfaces.
	IsTableRefContext()
}

type TableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefContext() *TableRefContext {
	var p = new(TableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRef
	return p
}

func InitEmptyTableRefContext(p *TableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRef
}

func (*TableRefContext) IsTableRefContext() {}

func NewTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefContext {
	var p = new(TableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableRef

	return p
}

func (s *TableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TableRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableRef(s)
	}
}

func (s *TableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableRef(s)
	}
}

func (s *TableRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableRef() (localctx ITableRefContext) {
	localctx = NewTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, MySQLParserRULE_tableRef)
	p.SetState(8098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1078, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8096)
			p.QualifiedIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8097)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefListContext is an interface to support dynamic dispatch.
type ITableRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableRef() []ITableRefContext
	TableRef(i int) ITableRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableRefListContext differentiates from other interfaces.
	IsTableRefListContext()
}

type TableRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefListContext() *TableRefListContext {
	var p = new(TableRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRefList
	return p
}

func InitEmptyTableRefListContext(p *TableRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableRefList
}

func (*TableRefListContext) IsTableRefListContext() {}

func NewTableRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefListContext {
	var p = new(TableRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableRefList

	return p
}

func (s *TableRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefListContext) AllTableRef() []ITableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRefContext); ok {
			len++
		}
	}

	tst := make([]ITableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRefContext); ok {
			tst[i] = t.(ITableRefContext)
			i++
		}
	}

	return tst
}

func (s *TableRefListContext) TableRef(i int) ITableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *TableRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TableRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TableRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableRefList(s)
	}
}

func (s *TableRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableRefList(s)
	}
}

func (s *TableRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableRefList() (localctx ITableRefListContext) {
	localctx = NewTableRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, MySQLParserRULE_tableRefList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8100)
		p.TableRef()
	}
	p.SetState(8105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1079, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(8101)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8102)
				p.TableRef()
			}

		}
		p.SetState(8107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1079, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasRefListContext is an interface to support dynamic dispatch.
type ITableAliasRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableRefWithWildcard() []ITableRefWithWildcardContext
	TableRefWithWildcard(i int) ITableRefWithWildcardContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableAliasRefListContext differentiates from other interfaces.
	IsTableAliasRefListContext()
}

type TableAliasRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasRefListContext() *TableAliasRefListContext {
	var p = new(TableAliasRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAliasRefList
	return p
}

func InitEmptyTableAliasRefListContext(p *TableAliasRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_tableAliasRefList
}

func (*TableAliasRefListContext) IsTableAliasRefListContext() {}

func NewTableAliasRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasRefListContext {
	var p = new(TableAliasRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_tableAliasRefList

	return p
}

func (s *TableAliasRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasRefListContext) AllTableRefWithWildcard() []ITableRefWithWildcardContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRefWithWildcardContext); ok {
			len++
		}
	}

	tst := make([]ITableRefWithWildcardContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRefWithWildcardContext); ok {
			tst[i] = t.(ITableRefWithWildcardContext)
			i++
		}
	}

	return tst
}

func (s *TableAliasRefListContext) TableRefWithWildcard(i int) ITableRefWithWildcardContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefWithWildcardContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefWithWildcardContext)
}

func (s *TableAliasRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TableAliasRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TableAliasRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTableAliasRefList(s)
	}
}

func (s *TableAliasRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTableAliasRefList(s)
	}
}

func (s *TableAliasRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTableAliasRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TableAliasRefList() (localctx ITableAliasRefListContext) {
	localctx = NewTableAliasRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, MySQLParserRULE_tableAliasRefList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8108)
		p.TableRefWithWildcard()
	}
	p.SetState(8113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1080, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(8109)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8110)
				p.TableRefWithWildcard()
			}

		}
		p.SetState(8115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1080, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterNameContext is an interface to support dynamic dispatch.
type IParameterNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsParameterNameContext differentiates from other interfaces.
	IsParameterNameContext()
}

type ParameterNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterNameContext() *ParameterNameContext {
	var p = new(ParameterNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_parameterName
	return p
}

func InitEmptyParameterNameContext(p *ParameterNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_parameterName
}

func (*ParameterNameContext) IsParameterNameContext() {}

func NewParameterNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterNameContext {
	var p = new(ParameterNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_parameterName

	return p
}

func (s *ParameterNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterParameterName(s)
	}
}

func (s *ParameterNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitParameterName(s)
	}
}

func (s *ParameterNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitParameterName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ParameterName() (localctx IParameterNameContext) {
	localctx = NewParameterNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, MySQLParserRULE_parameterName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8116)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelIdentifierContext is an interface to support dynamic dispatch.
type ILabelIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	LabelKeyword() ILabelKeywordContext

	// IsLabelIdentifierContext differentiates from other interfaces.
	IsLabelIdentifierContext()
}

type LabelIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelIdentifierContext() *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelIdentifier
	return p
}

func InitEmptyLabelIdentifierContext(p *LabelIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelIdentifier
}

func (*LabelIdentifierContext) IsLabelIdentifierContext() {}

func NewLabelIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_labelIdentifier

	return p
}

func (s *LabelIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *LabelIdentifierContext) LabelKeyword() ILabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelKeywordContext)
}

func (s *LabelIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabelIdentifier(s)
	}
}

func (s *LabelIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabelIdentifier(s)
	}
}

func (s *LabelIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabelIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LabelIdentifier() (localctx ILabelIdentifierContext) {
	localctx = NewLabelIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, MySQLParserRULE_labelIdentifier)
	p.SetState(8120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1081, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8118)
			p.PureIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8119)
			p.LabelKeyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelRefContext is an interface to support dynamic dispatch.
type ILabelRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext

	// IsLabelRefContext differentiates from other interfaces.
	IsLabelRefContext()
}

type LabelRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelRefContext() *LabelRefContext {
	var p = new(LabelRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelRef
	return p
}

func InitEmptyLabelRefContext(p *LabelRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelRef
}

func (*LabelRefContext) IsLabelRefContext() {}

func NewLabelRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelRefContext {
	var p = new(LabelRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_labelRef

	return p
}

func (s *LabelRefContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelRefContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *LabelRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabelRef(s)
	}
}

func (s *LabelRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabelRef(s)
	}
}

func (s *LabelRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabelRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LabelRef() (localctx ILabelRefContext) {
	localctx = NewLabelRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, MySQLParserRULE_labelRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8122)
		p.LabelIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleIdentifierContext is an interface to support dynamic dispatch.
type IRoleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	RoleKeyword() IRoleKeywordContext

	// IsRoleIdentifierContext differentiates from other interfaces.
	IsRoleIdentifierContext()
}

type RoleIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleIdentifierContext() *RoleIdentifierContext {
	var p = new(RoleIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleIdentifier
	return p
}

func InitEmptyRoleIdentifierContext(p *RoleIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleIdentifier
}

func (*RoleIdentifierContext) IsRoleIdentifierContext() {}

func NewRoleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleIdentifierContext {
	var p = new(RoleIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleIdentifier

	return p
}

func (s *RoleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *RoleIdentifierContext) RoleKeyword() IRoleKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleKeywordContext)
}

func (s *RoleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleIdentifier(s)
	}
}

func (s *RoleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleIdentifier(s)
	}
}

func (s *RoleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleIdentifier() (localctx IRoleIdentifierContext) {
	localctx = NewRoleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, MySQLParserRULE_roleIdentifier)
	p.SetState(8126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1082, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8124)
			p.PureIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8125)
			p.RoleKeyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleRefContext is an interface to support dynamic dispatch.
type IRoleRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifier() IRoleIdentifierContext

	// IsRoleRefContext differentiates from other interfaces.
	IsRoleRefContext()
}

type RoleRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleRefContext() *RoleRefContext {
	var p = new(RoleRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleRef
	return p
}

func InitEmptyRoleRefContext(p *RoleRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleRef
}

func (*RoleRefContext) IsRoleRefContext() {}

func NewRoleRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleRefContext {
	var p = new(RoleRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleRef

	return p
}

func (s *RoleRefContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleRefContext) RoleIdentifier() IRoleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierContext)
}

func (s *RoleRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleRef(s)
	}
}

func (s *RoleRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleRef(s)
	}
}

func (s *RoleRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleRef() (localctx IRoleRefContext) {
	localctx = NewRoleRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, MySQLParserRULE_roleRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8128)
		p.RoleIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPluginRefContext is an interface to support dynamic dispatch.
type IPluginRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPluginRefContext differentiates from other interfaces.
	IsPluginRefContext()
}

type PluginRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPluginRefContext() *PluginRefContext {
	var p = new(PluginRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_pluginRef
	return p
}

func InitEmptyPluginRefContext(p *PluginRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_pluginRef
}

func (*PluginRefContext) IsPluginRefContext() {}

func NewPluginRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PluginRefContext {
	var p = new(PluginRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_pluginRef

	return p
}

func (s *PluginRefContext) GetParser() antlr.Parser { return s.parser }

func (s *PluginRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PluginRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PluginRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPluginRef(s)
	}
}

func (s *PluginRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPluginRef(s)
	}
}

func (s *PluginRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPluginRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PluginRef() (localctx IPluginRefContext) {
	localctx = NewPluginRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, MySQLParserRULE_pluginRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComponentRefContext is an interface to support dynamic dispatch.
type IComponentRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext

	// IsComponentRefContext differentiates from other interfaces.
	IsComponentRefContext()
}

type ComponentRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentRefContext() *ComponentRefContext {
	var p = new(ComponentRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_componentRef
	return p
}

func InitEmptyComponentRefContext(p *ComponentRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_componentRef
}

func (*ComponentRefContext) IsComponentRefContext() {}

func NewComponentRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentRefContext {
	var p = new(ComponentRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_componentRef

	return p
}

func (s *ComponentRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentRefContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *ComponentRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterComponentRef(s)
	}
}

func (s *ComponentRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitComponentRef(s)
	}
}

func (s *ComponentRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitComponentRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ComponentRef() (localctx IComponentRefContext) {
	localctx = NewComponentRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, MySQLParserRULE_componentRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8132)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupRefContext is an interface to support dynamic dispatch.
type IResourceGroupRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsResourceGroupRefContext differentiates from other interfaces.
	IsResourceGroupRefContext()
}

type ResourceGroupRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupRefContext() *ResourceGroupRefContext {
	var p = new(ResourceGroupRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupRef
	return p
}

func InitEmptyResourceGroupRefContext(p *ResourceGroupRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_resourceGroupRef
}

func (*ResourceGroupRefContext) IsResourceGroupRefContext() {}

func NewResourceGroupRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupRefContext {
	var p = new(ResourceGroupRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_resourceGroupRef

	return p
}

func (s *ResourceGroupRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceGroupRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterResourceGroupRef(s)
	}
}

func (s *ResourceGroupRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitResourceGroupRef(s)
	}
}

func (s *ResourceGroupRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitResourceGroupRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) ResourceGroupRef() (localctx IResourceGroupRefContext) {
	localctx = NewResourceGroupRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, MySQLParserRULE_resourceGroupRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8134)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowName
	return p
}

func InitEmptyWindowNameContext(p *WindowNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_windowName
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (s *WindowNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitWindowName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) WindowName() (localctx IWindowNameContext) {
	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, MySQLParserRULE_windowName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8136)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPureIdentifierContext is an interface to support dynamic dispatch.
type IPureIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	BACK_TICK_QUOTED_ID() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsPureIdentifierContext differentiates from other interfaces.
	IsPureIdentifierContext()
}

type PureIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPureIdentifierContext() *PureIdentifierContext {
	var p = new(PureIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_pureIdentifier
	return p
}

func InitEmptyPureIdentifierContext(p *PureIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_pureIdentifier
}

func (*PureIdentifierContext) IsPureIdentifierContext() {}

func NewPureIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PureIdentifierContext {
	var p = new(PureIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_pureIdentifier

	return p
}

func (s *PureIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PureIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIER, 0)
}

func (s *PureIdentifierContext) BACK_TICK_QUOTED_ID() antlr.TerminalNode {
	return s.GetToken(MySQLParserBACK_TICK_QUOTED_ID, 0)
}

func (s *PureIdentifierContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *PureIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PureIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PureIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPureIdentifier(s)
	}
}

func (s *PureIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPureIdentifier(s)
	}
}

func (s *PureIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPureIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) PureIdentifier() (localctx IPureIdentifierContext) {
	localctx = NewPureIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, MySQLParserRULE_pureIdentifier)
	var _la int

	p.SetState(8141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1083, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8138)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserIDENTIFIER || _la == MySQLParserBACK_TICK_QUOTED_ID) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8139)

		if !(isSqlModeActive(AnsiQuotes)) {
			p.SetError(antlr.NewFailedPredicateException(p, "isSqlModeActive(AnsiQuotes)", ""))
			goto errorExit
		}
		{
			p.SetState(8140)
			p.Match(MySQLParserDOUBLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	IdentifierKeyword() IIdentifierKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *IdentifierContext) IdentifierKeyword() IIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, MySQLParserRULE_identifier)
	p.SetState(8145)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1084, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8143)
			p.PureIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8144)
			p.IdentifierKeyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *IdentifierListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, MySQLParserRULE_identifierList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8147)
		p.Identifier()
	}
	p.SetState(8152)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1085, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(8148)
				p.Match(MySQLParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8149)
				p.Identifier()
			}

		}
		p.SetState(8154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1085, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListWithParenthesesContext is an interface to support dynamic dispatch.
type IIdentifierListWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsIdentifierListWithParenthesesContext differentiates from other interfaces.
	IsIdentifierListWithParenthesesContext()
}

type IdentifierListWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListWithParenthesesContext() *IdentifierListWithParenthesesContext {
	var p = new(IdentifierListWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierListWithParentheses
	return p
}

func InitEmptyIdentifierListWithParenthesesContext(p *IdentifierListWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierListWithParentheses
}

func (*IdentifierListWithParenthesesContext) IsIdentifierListWithParenthesesContext() {}

func NewIdentifierListWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListWithParenthesesContext {
	var p = new(IdentifierListWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierListWithParentheses

	return p
}

func (s *IdentifierListWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *IdentifierListWithParenthesesContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IdentifierListWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IdentifierListWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierListWithParentheses(s)
	}
}

func (s *IdentifierListWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierListWithParentheses(s)
	}
}

func (s *IdentifierListWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierListWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierListWithParentheses() (localctx IIdentifierListWithParenthesesContext) {
	localctx = NewIdentifierListWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, MySQLParserRULE_identifierListWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8155)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8156)
		p.IdentifierList()
	}
	{
		p.SetState(8157)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdentifierContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsQualifiedIdentifierContext differentiates from other interfaces.
	IsQualifiedIdentifierContext()
}

type QualifiedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierContext() *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_qualifiedIdentifier
	return p
}

func InitEmptyQualifiedIdentifierContext(p *QualifiedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_qualifiedIdentifier
}

func (*QualifiedIdentifierContext) IsQualifiedIdentifierContext() {}

func NewQualifiedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_qualifiedIdentifier

	return p
}

func (s *QualifiedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedIdentifierContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *QualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterQualifiedIdentifier(s)
	}
}

func (s *QualifiedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitQualifiedIdentifier(s)
	}
}

func (s *QualifiedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitQualifiedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) QualifiedIdentifier() (localctx IQualifiedIdentifierContext) {
	localctx = NewQualifiedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, MySQLParserRULE_qualifiedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8159)
		p.Identifier()
	}
	p.SetState(8161)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1086, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(8160)
			p.DotIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllDotIdentifier() []IDotIdentifierContext
	DotIdentifier(i int) IDotIdentifierContext

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleIdentifier
	return p
}

func InitEmptySimpleIdentifierContext(p *SimpleIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_simpleIdentifier
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleIdentifierContext) AllDotIdentifier() []IDotIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IDotIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDotIdentifierContext); ok {
			tst[i] = t.(IDotIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIdentifierContext) DotIdentifier(i int) IDotIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSimpleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, MySQLParserRULE_simpleIdentifier)
	var _la int

	p.SetState(8174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1089, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8163)
			p.Identifier()
		}
		p.SetState(8168)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserDOT_SYMBOL {
			{
				p.SetState(8164)
				p.DotIdentifier()
			}
			p.SetState(8166)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == MySQLParserDOT_SYMBOL {
				{
					p.SetState(8165)
					p.DotIdentifier()
				}

			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8170)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(8171)
			p.DotIdentifier()
		}
		{
			p.SetState(8172)
			p.DotIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotIdentifierContext is an interface to support dynamic dispatch.
type IDotIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDotIdentifierContext differentiates from other interfaces.
	IsDotIdentifierContext()
}

type DotIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotIdentifierContext() *DotIdentifierContext {
	var p = new(DotIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dotIdentifier
	return p
}

func InitEmptyDotIdentifierContext(p *DotIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_dotIdentifier
}

func (*DotIdentifierContext) IsDotIdentifierContext() {}

func NewDotIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotIdentifierContext {
	var p = new(DotIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_dotIdentifier

	return p
}

func (s *DotIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DotIdentifierContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, 0)
}

func (s *DotIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DotIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterDotIdentifier(s)
	}
}

func (s *DotIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitDotIdentifier(s)
	}
}

func (s *DotIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitDotIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) DotIdentifier() (localctx IDotIdentifierContext) {
	localctx = NewDotIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, MySQLParserRULE_dotIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8176)
		p.Match(MySQLParserDOT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8177)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUlong_numberContext is an interface to support dynamic dispatch.
type IUlong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsUlong_numberContext differentiates from other interfaces.
	IsUlong_numberContext()
}

type Ulong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUlong_numberContext() *Ulong_numberContext {
	var p = new(Ulong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ulong_number
	return p
}

func InitEmptyUlong_numberContext(p *Ulong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ulong_number
}

func (*Ulong_numberContext) IsUlong_numberContext() {}

func NewUlong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ulong_numberContext {
	var p = new(Ulong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ulong_number

	return p
}

func (s *Ulong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Ulong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *Ulong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *Ulong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *Ulong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *Ulong_numberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_NUMBER, 0)
}

func (s *Ulong_numberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLOAT_NUMBER, 0)
}

func (s *Ulong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ulong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ulong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUlong_number(s)
	}
}

func (s *Ulong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUlong_number(s)
	}
}

func (s *Ulong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUlong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Ulong_number() (localctx IUlong_numberContext) {
	localctx = NewUlong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, MySQLParserRULE_ulong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8179)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&28587302322183) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReal_ulong_numberContext is an interface to support dynamic dispatch.
type IReal_ulong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode

	// IsReal_ulong_numberContext differentiates from other interfaces.
	IsReal_ulong_numberContext()
}

type Real_ulong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_ulong_numberContext() *Real_ulong_numberContext {
	var p = new(Real_ulong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_real_ulong_number
	return p
}

func InitEmptyReal_ulong_numberContext(p *Real_ulong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_real_ulong_number
}

func (*Real_ulong_numberContext) IsReal_ulong_numberContext() {}

func NewReal_ulong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_ulong_numberContext {
	var p = new(Real_ulong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_real_ulong_number

	return p
}

func (s *Real_ulong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_ulong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *Real_ulong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *Real_ulong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *Real_ulong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *Real_ulong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_ulong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_ulong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReal_ulong_number(s)
	}
}

func (s *Real_ulong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReal_ulong_number(s)
	}
}

func (s *Real_ulong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReal_ulong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Real_ulong_number() (localctx IReal_ulong_numberContext) {
	localctx = NewReal_ulong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, MySQLParserRULE_real_ulong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8181)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&2199023255559) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUlonglong_numberContext is an interface to support dynamic dispatch.
type IUlonglong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsUlonglong_numberContext differentiates from other interfaces.
	IsUlonglong_numberContext()
}

type Ulonglong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUlonglong_numberContext() *Ulonglong_numberContext {
	var p = new(Ulonglong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ulonglong_number
	return p
}

func InitEmptyUlonglong_numberContext(p *Ulonglong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_ulonglong_number
}

func (*Ulonglong_numberContext) IsUlonglong_numberContext() {}

func NewUlonglong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ulonglong_numberContext {
	var p = new(Ulonglong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_ulonglong_number

	return p
}

func (s *Ulonglong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Ulonglong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *Ulonglong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *Ulonglong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *Ulonglong_numberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_NUMBER, 0)
}

func (s *Ulonglong_numberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLOAT_NUMBER, 0)
}

func (s *Ulonglong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ulonglong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ulonglong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterUlonglong_number(s)
	}
}

func (s *Ulonglong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitUlonglong_number(s)
	}
}

func (s *Ulonglong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitUlonglong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Ulonglong_number() (localctx IUlonglong_numberContext) {
	localctx = NewUlonglong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, MySQLParserRULE_ulonglong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8183)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&26388279066631) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReal_ulonglong_numberContext is an interface to support dynamic dispatch.
type IReal_ulonglong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode

	// IsReal_ulonglong_numberContext differentiates from other interfaces.
	IsReal_ulonglong_numberContext()
}

type Real_ulonglong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_ulonglong_numberContext() *Real_ulonglong_numberContext {
	var p = new(Real_ulonglong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_real_ulonglong_number
	return p
}

func InitEmptyReal_ulonglong_numberContext(p *Real_ulonglong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_real_ulonglong_number
}

func (*Real_ulonglong_numberContext) IsReal_ulonglong_numberContext() {}

func NewReal_ulonglong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_ulonglong_numberContext {
	var p = new(Real_ulonglong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_real_ulonglong_number

	return p
}

func (s *Real_ulonglong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_ulonglong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_ulonglong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_ulonglong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterReal_ulonglong_number(s)
	}
}

func (s *Real_ulonglong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitReal_ulonglong_number(s)
	}
}

func (s *Real_ulonglong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitReal_ulonglong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Real_ulonglong_number() (localctx IReal_ulonglong_numberContext) {
	localctx = NewReal_ulonglong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, MySQLParserRULE_real_ulonglong_number)
	p.SetState(8190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1090, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8185)
			p.Match(MySQLParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8186)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(8187)
			p.Match(MySQLParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8188)
			p.Match(MySQLParserULONGLONG_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8189)
			p.Match(MySQLParserLONG_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextLiteral() ITextLiteralContext
	NumLiteral() INumLiteralContext
	TemporalLiteral() ITemporalLiteralContext
	NullLiteral() INullLiteralContext
	BoolLiteral() IBoolLiteralContext
	HEX_NUMBER() antlr.TerminalNode
	BIN_NUMBER() antlr.TerminalNode
	UNDERSCORE_CHARSET() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *LiteralContext) NumLiteral() INumLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumLiteralContext)
}

func (s *LiteralContext) TemporalLiteral() ITemporalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalLiteralContext)
}

func (s *LiteralContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *LiteralContext) BoolLiteral() IBoolLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolLiteralContext)
}

func (s *LiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *LiteralContext) BIN_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIN_NUMBER, 0)
}

func (s *LiteralContext) UNDERSCORE_CHARSET() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDERSCORE_CHARSET, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, MySQLParserRULE_literal)
	var _la int

	p.SetState(8201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1092, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8192)
			p.TextLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8193)
			p.NumLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8194)
			p.TemporalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8195)
			p.NullLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8196)
			p.BoolLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(8198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == MySQLParserUNDERSCORE_CHARSET {
			{
				p.SetState(8197)
				p.Match(MySQLParserUNDERSCORE_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8200)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserHEX_NUMBER || _la == MySQLParserBIN_NUMBER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedLiteralContext is an interface to support dynamic dispatch.
type ISignedLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	PLUS_OPERATOR() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MINUS_OPERATOR() antlr.TerminalNode

	// IsSignedLiteralContext differentiates from other interfaces.
	IsSignedLiteralContext()
}

type SignedLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedLiteralContext() *SignedLiteralContext {
	var p = new(SignedLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signedLiteral
	return p
}

func InitEmptySignedLiteralContext(p *SignedLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_signedLiteral
}

func (*SignedLiteralContext) IsSignedLiteralContext() {}

func NewSignedLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedLiteralContext {
	var p = new(SignedLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_signedLiteral

	return p
}

func (s *SignedLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SignedLiteralContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUS_OPERATOR, 0)
}

func (s *SignedLiteralContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *SignedLiteralContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUS_OPERATOR, 0)
}

func (s *SignedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSignedLiteral(s)
	}
}

func (s *SignedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSignedLiteral(s)
	}
}

func (s *SignedLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSignedLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SignedLiteral() (localctx ISignedLiteralContext) {
	localctx = NewSignedLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, MySQLParserRULE_signedLiteral)
	p.SetState(8208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1093, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8203)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8204)
			p.Match(MySQLParserPLUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8205)
			p.Ulong_number()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8206)
			p.Match(MySQLParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8207)
			p.Ulong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *StringListContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *StringListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *StringListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *StringListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (s *StringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, MySQLParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8210)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8211)
		p.TextString()
	}
	p.SetState(8216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(8212)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8213)
			p.TextString()
		}

		p.SetState(8218)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8219)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringLiteralContext is an interface to support dynamic dispatch.
type ITextStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsTextStringLiteralContext differentiates from other interfaces.
	IsTextStringLiteralContext()
}

type TextStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
}

func NewEmptyTextStringLiteralContext() *TextStringLiteralContext {
	var p = new(TextStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringLiteral
	return p
}

func InitEmptyTextStringLiteralContext(p *TextStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringLiteral
}

func (*TextStringLiteralContext) IsTextStringLiteralContext() {}

func NewTextStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringLiteralContext {
	var p = new(TextStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textStringLiteral

	return p
}

func (s *TextStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringLiteralContext) GetValue() antlr.Token { return s.value }

func (s *TextStringLiteralContext) SetValue(v antlr.Token) { s.value = v }

func (s *TextStringLiteralContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(MySQLParserSINGLE_QUOTED_TEXT, 0)
}

func (s *TextStringLiteralContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *TextStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextStringLiteral(s)
	}
}

func (s *TextStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextStringLiteral(s)
	}
}

func (s *TextStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextStringLiteral() (localctx ITextStringLiteralContext) {
	localctx = NewTextStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, MySQLParserRULE_textStringLiteral)
	p.SetState(8224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1095, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8221)

			var _m = p.Match(MySQLParserSINGLE_QUOTED_TEXT)

			localctx.(*TextStringLiteralContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8222)

		if !(!isSqlModeActive(AnsiQuotes)) {
			p.SetError(antlr.NewFailedPredicateException(p, "!isSqlModeActive(AnsiQuotes)", ""))
			goto errorExit
		}
		{
			p.SetState(8223)

			var _m = p.Match(MySQLParserDOUBLE_QUOTED_TEXT)

			localctx.(*TextStringLiteralContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringContext is an interface to support dynamic dispatch.
type ITextStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext
	HEX_NUMBER() antlr.TerminalNode
	BIN_NUMBER() antlr.TerminalNode

	// IsTextStringContext differentiates from other interfaces.
	IsTextStringContext()
}

type TextStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringContext() *TextStringContext {
	var p = new(TextStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textString
	return p
}

func InitEmptyTextStringContext(p *TextStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textString
}

func (*TextStringContext) IsTextStringContext() {}

func NewTextStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringContext {
	var p = new(TextStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textString

	return p
}

func (s *TextStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *TextStringContext) BIN_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIN_NUMBER, 0)
}

func (s *TextStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextString(s)
	}
}

func (s *TextStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextString(s)
	}
}

func (s *TextStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextString() (localctx ITextStringContext) {
	localctx = NewTextStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, MySQLParserRULE_textString)
	p.SetState(8229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1096, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8226)
			p.TextStringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8227)
			p.Match(MySQLParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8228)
			p.Match(MySQLParserBIN_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringHashContext is an interface to support dynamic dispatch.
type ITextStringHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext
	HEX_NUMBER() antlr.TerminalNode

	// IsTextStringHashContext differentiates from other interfaces.
	IsTextStringHashContext()
}

type TextStringHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringHashContext() *TextStringHashContext {
	var p = new(TextStringHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringHash
	return p
}

func InitEmptyTextStringHashContext(p *TextStringHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringHash
}

func (*TextStringHashContext) IsTextStringHashContext() {}

func NewTextStringHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringHashContext {
	var p = new(TextStringHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textStringHash

	return p
}

func (s *TextStringHashContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringHashContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringHashContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserHEX_NUMBER, 0)
}

func (s *TextStringHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextStringHash(s)
	}
}

func (s *TextStringHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextStringHash(s)
	}
}

func (s *TextStringHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextStringHash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextStringHash() (localctx ITextStringHashContext) {
	localctx = NewTextStringHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, MySQLParserRULE_textStringHash)
	p.SetState(8234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1097, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8231)
			p.TextStringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8232)

		if !(serverVersion >= 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80017", ""))
			goto errorExit
		}
		{
			p.SetState(8233)
			p.Match(MySQLParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextLiteralContext is an interface to support dynamic dispatch.
type ITextLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextStringLiteral() []ITextStringLiteralContext
	TextStringLiteral(i int) ITextStringLiteralContext
	NCHAR_TEXT() antlr.TerminalNode
	UNDERSCORE_CHARSET() antlr.TerminalNode

	// IsTextLiteralContext differentiates from other interfaces.
	IsTextLiteralContext()
}

type TextLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLiteralContext() *TextLiteralContext {
	var p = new(TextLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textLiteral
	return p
}

func InitEmptyTextLiteralContext(p *TextLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textLiteral
}

func (*TextLiteralContext) IsTextLiteralContext() {}

func NewTextLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLiteralContext {
	var p = new(TextLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textLiteral

	return p
}

func (s *TextLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLiteralContext) AllTextStringLiteral() []ITextStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]ITextStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringLiteralContext); ok {
			tst[i] = t.(ITextStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TextLiteralContext) TextStringLiteral(i int) ITextStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextLiteralContext) NCHAR_TEXT() antlr.TerminalNode {
	return s.GetToken(MySQLParserNCHAR_TEXT, 0)
}

func (s *TextLiteralContext) UNDERSCORE_CHARSET() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDERSCORE_CHARSET, 0)
}

func (s *TextLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextLiteral(s)
	}
}

func (s *TextLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextLiteral(s)
	}
}

func (s *TextLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextLiteral() (localctx ITextLiteralContext) {
	localctx = NewTextLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, MySQLParserRULE_textLiteral)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1099, p.GetParserRuleContext()) {
	case 1:
		p.SetState(8237)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1098, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(8236)
				p.Match(MySQLParserUNDERSCORE_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(8239)
			p.TextStringLiteral()
		}

	case 2:
		{
			p.SetState(8240)
			p.Match(MySQLParserNCHAR_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(8246)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1100, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(8243)
				p.TextStringLiteral()
			}

		}
		p.SetState(8248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1100, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringNoLinebreakContext is an interface to support dynamic dispatch.
type ITextStringNoLinebreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext

	// IsTextStringNoLinebreakContext differentiates from other interfaces.
	IsTextStringNoLinebreakContext()
}

type TextStringNoLinebreakContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringNoLinebreakContext() *TextStringNoLinebreakContext {
	var p = new(TextStringNoLinebreakContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringNoLinebreak
	return p
}

func InitEmptyTextStringNoLinebreakContext(p *TextStringNoLinebreakContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringNoLinebreak
}

func (*TextStringNoLinebreakContext) IsTextStringNoLinebreakContext() {}

func NewTextStringNoLinebreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringNoLinebreakContext {
	var p = new(TextStringNoLinebreakContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textStringNoLinebreak

	return p
}

func (s *TextStringNoLinebreakContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringNoLinebreakContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringNoLinebreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringNoLinebreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringNoLinebreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextStringNoLinebreak(s)
	}
}

func (s *TextStringNoLinebreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextStringNoLinebreak(s)
	}
}

func (s *TextStringNoLinebreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextStringNoLinebreak(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextStringNoLinebreak() (localctx ITextStringNoLinebreakContext) {
	localctx = NewTextStringNoLinebreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, MySQLParserRULE_textStringNoLinebreak)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8249)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringLiteralListContext is an interface to support dynamic dispatch.
type ITextStringLiteralListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextStringLiteral() []ITextStringLiteralContext
	TextStringLiteral(i int) ITextStringLiteralContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTextStringLiteralListContext differentiates from other interfaces.
	IsTextStringLiteralListContext()
}

type TextStringLiteralListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringLiteralListContext() *TextStringLiteralListContext {
	var p = new(TextStringLiteralListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringLiteralList
	return p
}

func InitEmptyTextStringLiteralListContext(p *TextStringLiteralListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textStringLiteralList
}

func (*TextStringLiteralListContext) IsTextStringLiteralListContext() {}

func NewTextStringLiteralListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringLiteralListContext {
	var p = new(TextStringLiteralListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textStringLiteralList

	return p
}

func (s *TextStringLiteralListContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringLiteralListContext) AllTextStringLiteral() []ITextStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]ITextStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringLiteralContext); ok {
			tst[i] = t.(ITextStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TextStringLiteralListContext) TextStringLiteral(i int) ITextStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringLiteralListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserCOMMA_SYMBOL)
}

func (s *TextStringLiteralListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, i)
}

func (s *TextStringLiteralListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringLiteralListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringLiteralListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextStringLiteralList(s)
	}
}

func (s *TextStringLiteralListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextStringLiteralList(s)
	}
}

func (s *TextStringLiteralListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextStringLiteralList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextStringLiteralList() (localctx ITextStringLiteralListContext) {
	localctx = NewTextStringLiteralListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, MySQLParserRULE_textStringLiteralList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8251)
		p.TextStringLiteral()
	}
	p.SetState(8256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == MySQLParserCOMMA_SYMBOL {
		{
			p.SetState(8252)
			p.Match(MySQLParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8253)
			p.TextStringLiteral()
		}

		p.SetState(8258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumLiteralContext is an interface to support dynamic dispatch.
type INumLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsNumLiteralContext differentiates from other interfaces.
	IsNumLiteralContext()
}

type NumLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumLiteralContext() *NumLiteralContext {
	var p = new(NumLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_numLiteral
	return p
}

func InitEmptyNumLiteralContext(p *NumLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_numLiteral
}

func (*NumLiteralContext) IsNumLiteralContext() {}

func NewNumLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumLiteralContext {
	var p = new(NumLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_numLiteral

	return p
}

func (s *NumLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumLiteralContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, 0)
}

func (s *NumLiteralContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserLONG_NUMBER, 0)
}

func (s *NumLiteralContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserULONGLONG_NUMBER, 0)
}

func (s *NumLiteralContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserDECIMAL_NUMBER, 0)
}

func (s *NumLiteralContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLOAT_NUMBER, 0)
}

func (s *NumLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNumLiteral(s)
	}
}

func (s *NumLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNumLiteral(s)
	}
}

func (s *NumLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNumLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NumLiteral() (localctx INumLiteralContext) {
	localctx = NewNumLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, MySQLParserRULE_numLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8259)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&26388279066631) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolLiteralContext is an interface to support dynamic dispatch.
type IBoolLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE_SYMBOL() antlr.TerminalNode
	FALSE_SYMBOL() antlr.TerminalNode

	// IsBoolLiteralContext differentiates from other interfaces.
	IsBoolLiteralContext()
}

type BoolLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolLiteralContext() *BoolLiteralContext {
	var p = new(BoolLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_boolLiteral
	return p
}

func InitEmptyBoolLiteralContext(p *BoolLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_boolLiteral
}

func (*BoolLiteralContext) IsBoolLiteralContext() {}

func NewBoolLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolLiteralContext {
	var p = new(BoolLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_boolLiteral

	return p
}

func (s *BoolLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolLiteralContext) TRUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUE_SYMBOL, 0)
}

func (s *BoolLiteralContext) FALSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFALSE_SYMBOL, 0)
}

func (s *BoolLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterBoolLiteral(s)
	}
}

func (s *BoolLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitBoolLiteral(s)
	}
}

func (s *BoolLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitBoolLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) BoolLiteral() (localctx IBoolLiteralContext) {
	localctx = NewBoolLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, MySQLParserRULE_boolLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8261)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserFALSE_SYMBOL || _la == MySQLParserTRUE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_SYMBOL() antlr.TerminalNode
	NULL2_SYMBOL() antlr.TerminalNode

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nullLiteral
	return p
}

func InitEmptyNullLiteralContext(p *NullLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_nullLiteral
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NullLiteralContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL_SYMBOL, 0)
}

func (s *NullLiteralContext) NULL2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULL2_SYMBOL, 0)
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) NullLiteral() (localctx INullLiteralContext) {
	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, MySQLParserRULE_nullLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8263)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserNULL_SYMBOL || _la == MySQLParserNULL2_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalLiteralContext is an interface to support dynamic dispatch.
type ITemporalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE_SYMBOL() antlr.TerminalNode
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode

	// IsTemporalLiteralContext differentiates from other interfaces.
	IsTemporalLiteralContext()
}

type TemporalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalLiteralContext() *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_temporalLiteral
	return p
}

func InitEmptyTemporalLiteralContext(p *TemporalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_temporalLiteral
}

func (*TemporalLiteralContext) IsTemporalLiteralContext() {}

func NewTemporalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_temporalLiteral

	return p
}

func (s *TemporalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalLiteralContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *TemporalLiteralContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(MySQLParserSINGLE_QUOTED_TEXT, 0)
}

func (s *TemporalLiteralContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *TemporalLiteralContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *TemporalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTemporalLiteral(s)
	}
}

func (s *TemporalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTemporalLiteral(s)
	}
}

func (s *TemporalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTemporalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TemporalLiteral() (localctx ITemporalLiteralContext) {
	localctx = NewTemporalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, MySQLParserRULE_temporalLiteral)
	p.SetState(8271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8265)
			p.Match(MySQLParserDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8266)
			p.Match(MySQLParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserTIME_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8267)
			p.Match(MySQLParserTIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8268)
			p.Match(MySQLParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserTIMESTAMP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8269)
			p.Match(MySQLParserTIMESTAMP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8270)
			p.Match(MySQLParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatOptionsContext is an interface to support dynamic dispatch.
type IFloatOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldLength() IFieldLengthContext
	Precision() IPrecisionContext

	// IsFloatOptionsContext differentiates from other interfaces.
	IsFloatOptionsContext()
}

type FloatOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatOptionsContext() *FloatOptionsContext {
	var p = new(FloatOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_floatOptions
	return p
}

func InitEmptyFloatOptionsContext(p *FloatOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_floatOptions
}

func (*FloatOptionsContext) IsFloatOptionsContext() {}

func NewFloatOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatOptionsContext {
	var p = new(FloatOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_floatOptions

	return p
}

func (s *FloatOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatOptionsContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *FloatOptionsContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *FloatOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterFloatOptions(s)
	}
}

func (s *FloatOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitFloatOptions(s)
	}
}

func (s *FloatOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitFloatOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) FloatOptions() (localctx IFloatOptionsContext) {
	localctx = NewFloatOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, MySQLParserRULE_floatOptions)
	p.SetState(8275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8273)
			p.FieldLength()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8274)
			p.Precision()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardFloatOptionsContext is an interface to support dynamic dispatch.
type IStandardFloatOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Precision() IPrecisionContext

	// IsStandardFloatOptionsContext differentiates from other interfaces.
	IsStandardFloatOptionsContext()
}

type StandardFloatOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardFloatOptionsContext() *StandardFloatOptionsContext {
	var p = new(StandardFloatOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_standardFloatOptions
	return p
}

func InitEmptyStandardFloatOptionsContext(p *StandardFloatOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_standardFloatOptions
}

func (*StandardFloatOptionsContext) IsStandardFloatOptionsContext() {}

func NewStandardFloatOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardFloatOptionsContext {
	var p = new(StandardFloatOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_standardFloatOptions

	return p
}

func (s *StandardFloatOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardFloatOptionsContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *StandardFloatOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardFloatOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardFloatOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterStandardFloatOptions(s)
	}
}

func (s *StandardFloatOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitStandardFloatOptions(s)
	}
}

func (s *StandardFloatOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitStandardFloatOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) StandardFloatOptions() (localctx IStandardFloatOptionsContext) {
	localctx = NewStandardFloatOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, MySQLParserRULE_standardFloatOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8277)
		p.Precision()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrecisionContext is an interface to support dynamic dispatch.
type IPrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsPrecisionContext differentiates from other interfaces.
	IsPrecisionContext()
}

type PrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecisionContext() *PrecisionContext {
	var p = new(PrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_precision
	return p
}

func InitEmptyPrecisionContext(p *PrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_precision
}

func (*PrecisionContext) IsPrecisionContext() {}

func NewPrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecisionContext {
	var p = new(PrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_precision

	return p
}

func (s *PrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecisionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *PrecisionContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(MySQLParserINT_NUMBER)
}

func (s *PrecisionContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(MySQLParserINT_NUMBER, i)
}

func (s *PrecisionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMA_SYMBOL, 0)
}

func (s *PrecisionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterPrecision(s)
	}
}

func (s *PrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitPrecision(s)
	}
}

func (s *PrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitPrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Precision() (localctx IPrecisionContext) {
	localctx = NewPrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1178, MySQLParserRULE_precision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8279)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8280)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8281)
		p.Match(MySQLParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8282)
		p.Match(MySQLParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8283)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextOrIdentifierContext is an interface to support dynamic dispatch.
type ITextOrIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	TextStringLiteral() ITextStringLiteralContext

	// IsTextOrIdentifierContext differentiates from other interfaces.
	IsTextOrIdentifierContext()
}

type TextOrIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextOrIdentifierContext() *TextOrIdentifierContext {
	var p = new(TextOrIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textOrIdentifier
	return p
}

func InitEmptyTextOrIdentifierContext(p *TextOrIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_textOrIdentifier
}

func (*TextOrIdentifierContext) IsTextOrIdentifierContext() {}

func NewTextOrIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextOrIdentifierContext {
	var p = new(TextOrIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_textOrIdentifier

	return p
}

func (s *TextOrIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TextOrIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TextOrIdentifierContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextOrIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextOrIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextOrIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterTextOrIdentifier(s)
	}
}

func (s *TextOrIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitTextOrIdentifier(s)
	}
}

func (s *TextOrIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitTextOrIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) TextOrIdentifier() (localctx ITextOrIdentifierContext) {
	localctx = NewTextOrIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1180, MySQLParserRULE_textOrIdentifier)
	p.SetState(8287)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8285)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8286)
			p.TextStringLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILValueIdentifierContext is an interface to support dynamic dispatch.
type ILValueIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	LValueKeyword() ILValueKeywordContext

	// IsLValueIdentifierContext differentiates from other interfaces.
	IsLValueIdentifierContext()
}

type LValueIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLValueIdentifierContext() *LValueIdentifierContext {
	var p = new(LValueIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lValueIdentifier
	return p
}

func InitEmptyLValueIdentifierContext(p *LValueIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lValueIdentifier
}

func (*LValueIdentifierContext) IsLValueIdentifierContext() {}

func NewLValueIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LValueIdentifierContext {
	var p = new(LValueIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lValueIdentifier

	return p
}

func (s *LValueIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LValueIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *LValueIdentifierContext) LValueKeyword() ILValueKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILValueKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILValueKeywordContext)
}

func (s *LValueIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LValueIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LValueIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLValueIdentifier(s)
	}
}

func (s *LValueIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLValueIdentifier(s)
	}
}

func (s *LValueIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLValueIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LValueIdentifier() (localctx ILValueIdentifierContext) {
	localctx = NewLValueIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1182, MySQLParserRULE_lValueIdentifier)
	p.SetState(8291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8289)
			p.PureIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8290)
			p.LValueKeyword()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleIdentifierOrTextContext is an interface to support dynamic dispatch.
type IRoleIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifier() IRoleIdentifierContext
	TextStringLiteral() ITextStringLiteralContext

	// IsRoleIdentifierOrTextContext differentiates from other interfaces.
	IsRoleIdentifierOrTextContext()
}

type RoleIdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleIdentifierOrTextContext() *RoleIdentifierOrTextContext {
	var p = new(RoleIdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleIdentifierOrText
	return p
}

func InitEmptyRoleIdentifierOrTextContext(p *RoleIdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleIdentifierOrText
}

func (*RoleIdentifierOrTextContext) IsRoleIdentifierOrTextContext() {}

func NewRoleIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleIdentifierOrTextContext {
	var p = new(RoleIdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleIdentifierOrText

	return p
}

func (s *RoleIdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleIdentifierOrTextContext) RoleIdentifier() IRoleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierContext)
}

func (s *RoleIdentifierOrTextContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *RoleIdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleIdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleIdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleIdentifierOrText(s)
	}
}

func (s *RoleIdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleIdentifierOrText(s)
	}
}

func (s *RoleIdentifierOrTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleIdentifierOrText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleIdentifierOrText() (localctx IRoleIdentifierOrTextContext) {
	localctx = NewRoleIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1184, MySQLParserRULE_roleIdentifierOrText)
	p.SetState(8295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8293)
			p.RoleIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8294)
			p.TextStringLiteral()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISizeNumberContext is an interface to support dynamic dispatch.
type ISizeNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Real_ulonglong_number() IReal_ulonglong_numberContext
	PureIdentifier() IPureIdentifierContext

	// IsSizeNumberContext differentiates from other interfaces.
	IsSizeNumberContext()
}

type SizeNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeNumberContext() *SizeNumberContext {
	var p = new(SizeNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sizeNumber
	return p
}

func InitEmptySizeNumberContext(p *SizeNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_sizeNumber
}

func (*SizeNumberContext) IsSizeNumberContext() {}

func NewSizeNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeNumberContext {
	var p = new(SizeNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_sizeNumber

	return p
}

func (s *SizeNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeNumberContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *SizeNumberContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *SizeNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSizeNumber(s)
	}
}

func (s *SizeNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSizeNumber(s)
	}
}

func (s *SizeNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSizeNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SizeNumber() (localctx ISizeNumberContext) {
	localctx = NewSizeNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1186, MySQLParserRULE_sizeNumber)
	p.SetState(8299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8297)
			p.Real_ulonglong_number()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8298)
			p.PureIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesesContext is an interface to support dynamic dispatch.
type IParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsParenthesesContext differentiates from other interfaces.
	IsParenthesesContext()
}

type ParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesesContext() *ParenthesesContext {
	var p = new(ParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_parentheses
	return p
}

func InitEmptyParenthesesContext(p *ParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_parentheses
}

func (*ParenthesesContext) IsParenthesesContext() {}

func NewParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesesContext {
	var p = new(ParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_parentheses

	return p
}

func (s *ParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_PAR_SYMBOL, 0)
}

func (s *ParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterParentheses(s)
	}
}

func (s *ParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitParentheses(s)
	}
}

func (s *ParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Parentheses() (localctx IParenthesesContext) {
	localctx = NewParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1188, MySQLParserRULE_parentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8301)
		p.Match(MySQLParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8302)
		p.Match(MySQLParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualContext is an interface to support dynamic dispatch.
type IEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	ASSIGN_OPERATOR() antlr.TerminalNode

	// IsEqualContext differentiates from other interfaces.
	IsEqualContext()
}

type EqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualContext() *EqualContext {
	var p = new(EqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_equal
	return p
}

func InitEmptyEqualContext(p *EqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_equal
}

func (*EqualContext) IsEqualContext() {}

func NewEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualContext {
	var p = new(EqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_equal

	return p
}

func (s *EqualContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserEQUAL_OPERATOR, 0)
}

func (s *EqualContext) ASSIGN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(MySQLParserASSIGN_OPERATOR, 0)
}

func (s *EqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterEqual(s)
	}
}

func (s *EqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitEqual(s)
	}
}

func (s *EqualContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitEqual(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) Equal() (localctx IEqualContext) {
	localctx = NewEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1190, MySQLParserRULE_equal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8304)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserEQUAL_OPERATOR || _la == MySQLParserASSIGN_OPERATOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionTypeContext is an interface to support dynamic dispatch.
type IOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERSIST_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsOptionTypeContext differentiates from other interfaces.
	IsOptionTypeContext()
}

type OptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionTypeContext() *OptionTypeContext {
	var p = new(OptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionType
	return p
}

func InitEmptyOptionTypeContext(p *OptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_optionType
}

func (*OptionTypeContext) IsOptionTypeContext() {}

func NewOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionTypeContext {
	var p = new(OptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_optionType

	return p
}

func (s *OptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionTypeContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_SYMBOL, 0)
}

func (s *OptionTypeContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *OptionTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGLOBAL_SYMBOL, 0)
}

func (s *OptionTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *OptionTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSESSION_SYMBOL, 0)
}

func (s *OptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterOptionType(s)
	}
}

func (s *OptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitOptionType(s)
	}
}

func (s *OptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) OptionType() (localctx IOptionTypeContext) {
	localctx = NewOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1192, MySQLParserRULE_optionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8306)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserGLOBAL_SYMBOL || _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserSESSION_SYMBOL || _la == MySQLParserPERSIST_SYMBOL || _la == MySQLParserPERSIST_ONLY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarIdentTypeContext is an interface to support dynamic dispatch.
type IVarIdentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsVarIdentTypeContext differentiates from other interfaces.
	IsVarIdentTypeContext()
}

type VarIdentTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarIdentTypeContext() *VarIdentTypeContext {
	var p = new(VarIdentTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_varIdentType
	return p
}

func InitEmptyVarIdentTypeContext(p *VarIdentTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_varIdentType
}

func (*VarIdentTypeContext) IsVarIdentTypeContext() {}

func NewVarIdentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarIdentTypeContext {
	var p = new(VarIdentTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_varIdentType

	return p
}

func (s *VarIdentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarIdentTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGLOBAL_SYMBOL, 0)
}

func (s *VarIdentTypeContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, 0)
}

func (s *VarIdentTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *VarIdentTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSESSION_SYMBOL, 0)
}

func (s *VarIdentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarIdentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarIdentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterVarIdentType(s)
	}
}

func (s *VarIdentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitVarIdentType(s)
	}
}

func (s *VarIdentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitVarIdentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) VarIdentType() (localctx IVarIdentTypeContext) {
	localctx = NewVarIdentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1194, MySQLParserRULE_varIdentType)
	p.SetState(8314)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserGLOBAL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8308)
			p.Match(MySQLParserGLOBAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8309)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserLOCAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8310)
			p.Match(MySQLParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8311)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserSESSION_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8312)
			p.Match(MySQLParserSESSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8313)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarIdentTypeContext is an interface to support dynamic dispatch.
type ISetVarIdentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERSIST_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsSetVarIdentTypeContext differentiates from other interfaces.
	IsSetVarIdentTypeContext()
}

type SetVarIdentTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarIdentTypeContext() *SetVarIdentTypeContext {
	var p = new(SetVarIdentTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setVarIdentType
	return p
}

func InitEmptySetVarIdentTypeContext(p *SetVarIdentTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_setVarIdentType
}

func (*SetVarIdentTypeContext) IsSetVarIdentTypeContext() {}

func NewSetVarIdentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarIdentTypeContext {
	var p = new(SetVarIdentTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_setVarIdentType

	return p
}

func (s *SetVarIdentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarIdentTypeContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDOT_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGLOBAL_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSESSION_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarIdentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetVarIdentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterSetVarIdentType(s)
	}
}

func (s *SetVarIdentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitSetVarIdentType(s)
	}
}

func (s *SetVarIdentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitSetVarIdentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) SetVarIdentType() (localctx ISetVarIdentTypeContext) {
	localctx = NewSetVarIdentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1196, MySQLParserRULE_setVarIdentType)
	p.SetState(8326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case MySQLParserPERSIST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8316)
			p.Match(MySQLParserPERSIST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8317)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserPERSIST_ONLY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8318)
			p.Match(MySQLParserPERSIST_ONLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8319)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserGLOBAL_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8320)
			p.Match(MySQLParserGLOBAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8321)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserLOCAL_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8322)
			p.Match(MySQLParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8323)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case MySQLParserSESSION_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8324)
			p.Match(MySQLParserSESSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8325)
			p.Match(MySQLParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordContext is an interface to support dynamic dispatch.
type IIdentifierKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelKeyword() ILabelKeywordContext
	RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext
	EXECUTE_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	RESTART_SYMBOL() antlr.TerminalNode
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext

	// IsIdentifierKeywordContext differentiates from other interfaces.
	IsIdentifierKeywordContext()
}

type IdentifierKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordContext() *IdentifierKeywordContext {
	var p = new(IdentifierKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeyword
	return p
}

func InitEmptyIdentifierKeywordContext(p *IdentifierKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeyword
}

func (*IdentifierKeywordContext) IsIdentifierKeywordContext() {}

func NewIdentifierKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordContext {
	var p = new(IdentifierKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeyword

	return p
}

func (s *IdentifierKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordContext) LabelKeyword() ILabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelKeywordContext)
}

func (s *IdentifierKeywordContext) RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrIdentifierKeywordContext)
}

func (s *IdentifierKeywordContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXECUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) RESTART_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTART_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *IdentifierKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeyword(s)
	}
}

func (s *IdentifierKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeyword(s)
	}
}

func (s *IdentifierKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeyword() (localctx IIdentifierKeywordContext) {
	localctx = NewIdentifierKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1198, MySQLParserRULE_identifierKeyword)
	p.SetState(8345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(8328)

		if !(serverVersion < 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
			goto errorExit
		}
		p.SetState(8336)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1110, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8329)
				p.LabelKeyword()
			}

		case 2:
			{
				p.SetState(8330)
				p.RoleOrIdentifierKeyword()
			}

		case 3:
			{
				p.SetState(8331)
				p.Match(MySQLParserEXECUTE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			p.SetState(8332)

			if !(serverVersion >= 50709) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50709", ""))
				goto errorExit
			}
			{
				p.SetState(8333)
				p.Match(MySQLParserSHUTDOWN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			p.SetState(8334)

			if !(serverVersion >= 80011) {
				p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80011", ""))
				goto errorExit
			}
			{
				p.SetState(8335)
				p.Match(MySQLParserRESTART_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8343)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1111, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8338)
				p.IdentifierKeywordsUnambiguous()
			}

		case 2:
			{
				p.SetState(8339)
				p.IdentifierKeywordsAmbiguous1RolesAndLabels()
			}

		case 3:
			{
				p.SetState(8340)
				p.IdentifierKeywordsAmbiguous2Labels()
			}

		case 4:
			{
				p.SetState(8341)
				p.IdentifierKeywordsAmbiguous3Roles()
			}

		case 5:
			{
				p.SetState(8342)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous1RolesAndLabelsContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous1RolesAndLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE_SYMBOL() antlr.TerminalNode
	RESTART_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext()
}

type IdentifierKeywordsAmbiguous1RolesAndLabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous1RolesAndLabelsContext() *IdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var p = new(IdentifierKeywordsAmbiguous1RolesAndLabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous1RolesAndLabels
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous1RolesAndLabelsContext(p *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous1RolesAndLabels
}

func (*IdentifierKeywordsAmbiguous1RolesAndLabelsContext) IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext() {
}

func NewIdentifierKeywordsAmbiguous1RolesAndLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var p = new(IdentifierKeywordsAmbiguous1RolesAndLabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous1RolesAndLabels

	return p
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXECUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) RESTART_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTART_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous1RolesAndLabels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous1RolesAndLabels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous1RolesAndLabels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeywordsAmbiguous1RolesAndLabels() (localctx IIdentifierKeywordsAmbiguous1RolesAndLabelsContext) {
	localctx = NewIdentifierKeywordsAmbiguous1RolesAndLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1200, MySQLParserRULE_identifierKeywordsAmbiguous1RolesAndLabels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8347)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserEXECUTE_SYMBOL || _la == MySQLParserSHUTDOWN_SYMBOL || _la == MySQLParserRESTART_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous2LabelsContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous2LabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASCII_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	BYTE_SYMBOL() antlr.TerminalNode
	CACHE_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	CLONE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DO_SYMBOL() antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	FLUSH_SYMBOL() antlr.TerminalNode
	FOLLOWS_SYMBOL() antlr.TerminalNode
	HANDLER_SYMBOL() antlr.TerminalNode
	HELP_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	INSTALL_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	PRECEDES_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	RESET_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	SIGNED_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	UNICODE_SYMBOL() antlr.TerminalNode
	UNINSTALL_SYMBOL() antlr.TerminalNode
	XA_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous2LabelsContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous2LabelsContext()
}

type IdentifierKeywordsAmbiguous2LabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous2LabelsContext() *IdentifierKeywordsAmbiguous2LabelsContext {
	var p = new(IdentifierKeywordsAmbiguous2LabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous2Labels
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous2LabelsContext(p *IdentifierKeywordsAmbiguous2LabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous2Labels
}

func (*IdentifierKeywordsAmbiguous2LabelsContext) IsIdentifierKeywordsAmbiguous2LabelsContext() {}

func NewIdentifierKeywordsAmbiguous2LabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous2LabelsContext {
	var p = new(IdentifierKeywordsAmbiguous2LabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous2Labels

	return p
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASCII_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBYTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCACHE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHARSET_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECKSUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTAINS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEALLOCATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) FLUSH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLUSH_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) FOLLOWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHANDLER_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) HELP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHELP_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTALL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLANGUAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) PRECEDES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDES_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREPARE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPAIR_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESET_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLBACK_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSAVEPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIGNED_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTOP_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUNCATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNICODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNINSTALL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXA_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous2Labels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous2Labels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous2Labels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeywordsAmbiguous2Labels() (localctx IIdentifierKeywordsAmbiguous2LabelsContext) {
	localctx = NewIdentifierKeywordsAmbiguous2LabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1202, MySQLParserRULE_identifierKeywordsAmbiguous2Labels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8349)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2594284492135333888) != 0) || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&281474976743429) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&1688849860268033) != 0) || ((int64((_la-219)) & ^0x3f) == 0 && ((int64(1)<<(_la-219))&281475043852297) != 0) || ((int64((_la-373)) & ^0x3f) == 0 && ((int64(1)<<(_la-373))&21990232555521) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&720575957592711169) != 0) || ((int64((_la-543)) & ^0x3f) == 0 && ((int64(1)<<(_la-543))&-9205357638345293311) != 0) || _la == MySQLParserUNINSTALL_SYMBOL || _la == MySQLParserXA_SYMBOL || _la == MySQLParserCLONE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelKeywordContext is an interface to support dynamic dispatch.
type ILabelKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleOrLabelKeyword() IRoleOrLabelKeywordContext
	EVENT_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext

	// IsLabelKeywordContext differentiates from other interfaces.
	IsLabelKeywordContext()
}

type LabelKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelKeywordContext() *LabelKeywordContext {
	var p = new(LabelKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelKeyword
	return p
}

func InitEmptyLabelKeywordContext(p *LabelKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_labelKeyword
}

func (*LabelKeywordContext) IsLabelKeywordContext() {}

func NewLabelKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelKeywordContext {
	var p = new(LabelKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_labelKeyword

	return p
}

func (s *LabelKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelKeywordContext) RoleOrLabelKeyword() IRoleOrLabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrLabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrLabelKeywordContext)
}

func (s *LabelKeywordContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *LabelKeywordContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_SYMBOL, 0)
}

func (s *LabelKeywordContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *LabelKeywordContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESS_SYMBOL, 0)
}

func (s *LabelKeywordContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROXY_SYMBOL, 0)
}

func (s *LabelKeywordContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELOAD_SYMBOL, 0)
}

func (s *LabelKeywordContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATION_SYMBOL, 0)
}

func (s *LabelKeywordContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *LabelKeywordContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUPER_SYMBOL, 0)
}

func (s *LabelKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *LabelKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *LabelKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *LabelKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLabelKeyword(s)
	}
}

func (s *LabelKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLabelKeyword(s)
	}
}

func (s *LabelKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLabelKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LabelKeyword() (localctx ILabelKeywordContext) {
	localctx = NewLabelKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1204, MySQLParserRULE_labelKeyword)
	p.SetState(8369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1115, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(8351)

		if !(serverVersion < 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
			goto errorExit
		}
		p.SetState(8362)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1113, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8352)
				p.RoleOrLabelKeyword()
			}

		case 2:
			{
				p.SetState(8353)
				p.Match(MySQLParserEVENT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(8354)
				p.Match(MySQLParserFILE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(8355)
				p.Match(MySQLParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(8356)
				p.Match(MySQLParserPROCESS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(8357)
				p.Match(MySQLParserPROXY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(8358)
				p.Match(MySQLParserRELOAD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(8359)
				p.Match(MySQLParserREPLICATION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(8360)
				p.Match(MySQLParserRESOURCE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(8361)
				p.Match(MySQLParserSUPER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1114, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8364)
				p.IdentifierKeywordsUnambiguous()
			}

		case 2:
			{
				p.SetState(8365)
				p.IdentifierKeywordsAmbiguous3Roles()
			}

		case 3:
			{
				p.SetState(8366)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous3RolesContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous3RolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENT_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous3RolesContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous3RolesContext()
}

type IdentifierKeywordsAmbiguous3RolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous3RolesContext() *IdentifierKeywordsAmbiguous3RolesContext {
	var p = new(IdentifierKeywordsAmbiguous3RolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous3Roles
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous3RolesContext(p *IdentifierKeywordsAmbiguous3RolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous3Roles
}

func (*IdentifierKeywordsAmbiguous3RolesContext) IsIdentifierKeywordsAmbiguous3RolesContext() {}

func NewIdentifierKeywordsAmbiguous3RolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous3RolesContext {
	var p = new(IdentifierKeywordsAmbiguous3RolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous3Roles

	return p
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous3RolesContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROXY_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESOURCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUPER_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous3Roles(s)
	}
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous3Roles(s)
	}
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous3Roles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeywordsAmbiguous3Roles() (localctx IIdentifierKeywordsAmbiguous3RolesContext) {
	localctx = NewIdentifierKeywordsAmbiguous3RolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1206, MySQLParserRULE_identifierKeywordsAmbiguous3Roles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8371)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserEVENT_SYMBOL || _la == MySQLParserFILE_SYMBOL || ((int64((_la-369)) & ^0x3f) == 0 && ((int64(1)<<(_la-369))&306244774661193729) != 0) || _la == MySQLParserRELOAD_SYMBOL || _la == MySQLParserREPLICATION_SYMBOL || _la == MySQLParserSUPER_SYMBOL || _la == MySQLParserRESOURCE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsUnambiguousContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsUnambiguousContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTION_SYMBOL() antlr.TerminalNode
	ACCOUNT_SYMBOL() antlr.TerminalNode
	ACTIVE_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode
	AFTER_SYMBOL() antlr.TerminalNode
	AGAINST_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode
	ALGORITHM_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	ANY_SYMBOL() antlr.TerminalNode
	AT_SYMBOL() antlr.TerminalNode
	AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	BINLOG_SYMBOL() antlr.TerminalNode
	BIT_SYMBOL() antlr.TerminalNode
	BLOCK_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BTREE_SYMBOL() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	CASCADED_SYMBOL() antlr.TerminalNode
	CATALOG_NAME_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	CIPHER_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	CLOSE_SYMBOL() antlr.TerminalNode
	COALESCE_SYMBOL() antlr.TerminalNode
	CODE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	COLUMN_NAME_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	COMPLETION_SYMBOL() antlr.TerminalNode
	COMPONENT_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	COMPRESSION_SYMBOL() antlr.TerminalNode
	CONCURRENT_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode
	CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	CURSOR_NAME_SYMBOL() antlr.TerminalNode
	DATAFILE_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	DEFINITION_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	DESCRIPTION_SYMBOL() antlr.TerminalNode
	DIAGNOSTICS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	DISCARD_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	DUMPFILE_SYMBOL() antlr.TerminalNode
	DUPLICATE_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	ENDS_SYMBOL() antlr.TerminalNode
	ENFORCED_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	ENUM_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	ESCAPE_SYMBOL() antlr.TerminalNode
	EVENTS_SYMBOL() antlr.TerminalNode
	EVERY_SYMBOL() antlr.TerminalNode
	EXCHANGE_SYMBOL() antlr.TerminalNode
	EXCLUDE_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	EXTENT_SIZE_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	FOUND_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	GENERAL_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	HOST_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	INACTIVE_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	ISOLATION_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	LIST_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	LOCKS_SYMBOL() antlr.TerminalNode
	LOGFILE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MAX_SIZE_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	MERGE_SYMBOL() antlr.TerminalNode
	MESSAGE_TEXT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	MODIFY_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	MYSQL_ERRNO_SYMBOL() antlr.TerminalNode
	NAMES_SYMBOL() antlr.TerminalNode
	NAME_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	NDBCLUSTER_SYMBOL() antlr.TerminalNode
	NESTED_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	NEW_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode
	NODEGROUP_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode
	NO_WAIT_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	NUMBER_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	OJ_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	ORGANIZATION_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode
	OWNER_SYMBOL() antlr.TerminalNode
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	PATH_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	PORT_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	PREV_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	READ_ONLY_SYMBOL() antlr.TerminalNode
	REBUILD_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	REFERENCE_SYMBOL() antlr.TerminalNode
	RELAY_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	REMOVE_SYMBOL() antlr.TerminalNode
	REORGANIZE_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	USER_RESOURCES_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	RESTORE_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	RETAIN_SYMBOL() antlr.TerminalNode
	RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	ROTATE_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	SCHEMA_NAME_SYMBOL() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	SECONDARY_LOAD_SYMBOL() antlr.TerminalNode
	SECONDARY_SYMBOL() antlr.TerminalNode
	SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	SERVER_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode
	SKIP_SYMBOL() antlr.TerminalNode
	SLOW_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	SOCKET_SYMBOL() antlr.TerminalNode
	SONAME_SYMBOL() antlr.TerminalNode
	SOUNDS_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode
	SRID_SYMBOL() antlr.TerminalNode
	STACKED_SYMBOL() antlr.TerminalNode
	STARTS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	STRING_SYMBOL() antlr.TerminalNode
	SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLE_NAME_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TEMPTABLE_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TYPES_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode
	UNDEFINED_SYMBOL() antlr.TerminalNode
	UNDOFILE_SYMBOL() antlr.TerminalNode
	UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	UNKNOWN_SYMBOL() antlr.TerminalNode
	UNTIL_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode
	VALIDATION_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	VCPU_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	VISIBLE_SYMBOL() antlr.TerminalNode
	WAIT_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	WITHOUT_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	WRAPPER_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode
	XML_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	ARRAY_SYMBOL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode
	MEMBER_SYMBOL() antlr.TerminalNode
	OFF_SYMBOL() antlr.TerminalNode
	PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode
	RANDOM_SYMBOL() antlr.TerminalNode
	REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode
	REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode
	STREAM_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsUnambiguousContext differentiates from other interfaces.
	IsIdentifierKeywordsUnambiguousContext()
}

type IdentifierKeywordsUnambiguousContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsUnambiguousContext() *IdentifierKeywordsUnambiguousContext {
	var p = new(IdentifierKeywordsUnambiguousContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsUnambiguous
	return p
}

func InitEmptyIdentifierKeywordsUnambiguousContext(p *IdentifierKeywordsUnambiguousContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsUnambiguous
}

func (*IdentifierKeywordsUnambiguousContext) IsIdentifierKeywordsUnambiguousContext() {}

func NewIdentifierKeywordsUnambiguousContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsUnambiguousContext {
	var p = new(IdentifierKeywordsUnambiguousContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeywordsUnambiguous

	return p
}

func (s *IdentifierKeywordsUnambiguousContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsUnambiguousContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACCOUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTIVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADDDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADMIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAFTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGAINST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGGREGATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALGORITHM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALWAYS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTOEXTEND_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBACKUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINLOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBLOCK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOLEAN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBTREE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBUCKETS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CASCADED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CATALOG_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCATALOG_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANNEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCIPHER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLASS_ORIGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLIENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOALESCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMN_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMITTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPACT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPLETION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPONENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONCURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONCURRENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONNECTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSISTENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_CATALOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_SCHEMA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCPU_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CURSOR_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURSOR_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATAFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATETIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFINITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DESCRIPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESCRIPTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DIAGNOSTICS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIAGNOSTICS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISCARD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUMPFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DUPLICATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUPLICATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDYNAMIC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCRYPTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENFORCED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENFORCED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERRORS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERROR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserESCAPE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EVERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVERY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXCHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCHANGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCLUDE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPANSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPIRE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXTENT_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENT_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAULTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_BLOCK_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIXED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FOUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOUND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GENERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGENERAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_MASTER_PUBLIC_KEY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHASH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTOGRAM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOSTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINACTIVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEXES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_METHOD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTANCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVISIBLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVOKER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIO_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIPC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISOLATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISSUER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAVES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEVEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINESTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCKED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOCKS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCKS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_DELAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HOST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNETWORK_NAMESPACE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SERVER_ID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_TLS_CIPHERSUITES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_USER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_ROWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MERGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMERGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MESSAGE_TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMESSAGE_TEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMICROSECOND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIGRATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIN_ROWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MODIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODIFY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMONTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTILINESTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMUTEX_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MYSQL_ERRNO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMYSQL_ERRNO_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAMES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATIONAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNCHAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NDBCLUSTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNDBCLUSTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNESTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNODEGROUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOWAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NO_WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_WAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULLS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNUMBER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNVARCHAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFFSET_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OJ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOJ_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDINALITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ORGANIZATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORGANIZATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOTHERS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OWNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOWNER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPACK_KEYS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARSER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTIAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPHASE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGINS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOLYGON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRESERVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PREV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREV_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGE_CHECKS_USER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESSLIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUARTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) READ_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_ONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REBUILD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREBUILD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRECOVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDUNDANT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REFERENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREFERENCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAYLOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_THREAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREMOVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REORGANIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREORGANIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPEATABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USER_RESOURCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_RESOURCES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESPECT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESTORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTORE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESUME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETAIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNED_SQLSTATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREUSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREVERSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROTATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROUTINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_COUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRTREE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEDULE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SCHEMA_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEMA_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_LOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_UNLOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECOND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECURITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIALIZABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHARE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIMPLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSKIP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SLOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLOW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSNAPSHOT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOCKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOCKET_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSONAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOUNDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOURCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_THREAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SRID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSRID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STACKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTACKED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STARTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTARTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATUS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBCLASS_ORIGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBJECT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUSPEND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWAPS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWITCHES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLE_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPORARY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEMPTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPTABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHAN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRANSACTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGERS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TYPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNCOMMITTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDEFINED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDEFINED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDOFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNKNOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNTIL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPGRADE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_FRM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VALIDATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALIDATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARIABLES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVCPU_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVISIBLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWARNINGS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEEK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WITHOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITHOUT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWORK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WRAPPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRAPPER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserX509_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) XML_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXML_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserARRAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAILED_LOGIN_ATTEMPTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMBER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFF_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_LOCK_TIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRANDOM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_ROW_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STREAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTREAM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsUnambiguousContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsUnambiguousContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeywordsUnambiguous(s)
	}
}

func (s *IdentifierKeywordsUnambiguousContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeywordsUnambiguous(s)
	}
}

func (s *IdentifierKeywordsUnambiguousContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeywordsUnambiguous(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeywordsUnambiguous() (localctx IIdentifierKeywordsUnambiguousContext) {
	localctx = NewIdentifierKeywordsUnambiguousContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1208, MySQLParserRULE_identifierKeywordsUnambiguous)
	var _la int

	p.SetState(8376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1116, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8373)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8979026322011384852) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&293728076221109983) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-1036516489208775157) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&-6430563964047286645) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&1868853107068508261) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&173760286417661087) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-4228991016542077057) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2209089036834331935) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082145862309015) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&3874169395838459587) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-315315032541044359) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&497599) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8374)

		if !(serverVersion >= 80019) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80019", ""))
			goto errorExit
		}
		{
			p.SetState(8375)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserTIMESTAMP_SYMBOL || _la == MySQLParserTIME_SYMBOL || ((int64((_la-731)) & ^0x3f) == 0 && ((int64(1)<<(_la-731))&16381) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleKeywordContext is an interface to support dynamic dispatch.
type IRoleKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleOrLabelKeyword() IRoleOrLabelKeywordContext
	RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext

	// IsRoleKeywordContext differentiates from other interfaces.
	IsRoleKeywordContext()
}

type RoleKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleKeywordContext() *RoleKeywordContext {
	var p = new(RoleKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleKeyword
	return p
}

func InitEmptyRoleKeywordContext(p *RoleKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleKeyword
}

func (*RoleKeywordContext) IsRoleKeywordContext() {}

func NewRoleKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleKeywordContext {
	var p = new(RoleKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleKeyword

	return p
}

func (s *RoleKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleKeywordContext) RoleOrLabelKeyword() IRoleOrLabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrLabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrLabelKeywordContext)
}

func (s *RoleKeywordContext) RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrIdentifierKeywordContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *RoleKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleKeyword(s)
	}
}

func (s *RoleKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleKeyword(s)
	}
}

func (s *RoleKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleKeyword() (localctx IRoleKeywordContext) {
	localctx = NewRoleKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1210, MySQLParserRULE_roleKeyword)
	p.SetState(8388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(8378)

		if !(serverVersion < 80017) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80017", ""))
			goto errorExit
		}
		p.SetState(8381)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1117, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8379)
				p.RoleOrLabelKeyword()
			}

		case 2:
			{
				p.SetState(8380)
				p.RoleOrIdentifierKeyword()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1118, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(8383)
				p.IdentifierKeywordsUnambiguous()
			}

		case 2:
			{
				p.SetState(8384)
				p.IdentifierKeywordsAmbiguous2Labels()
			}

		case 3:
			{
				p.SetState(8385)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILValueKeywordContext is an interface to support dynamic dispatch.
type ILValueKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext

	// IsLValueKeywordContext differentiates from other interfaces.
	IsLValueKeywordContext()
}

type LValueKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLValueKeywordContext() *LValueKeywordContext {
	var p = new(LValueKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lValueKeyword
	return p
}

func InitEmptyLValueKeywordContext(p *LValueKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_lValueKeyword
}

func (*LValueKeywordContext) IsLValueKeywordContext() {}

func NewLValueKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LValueKeywordContext {
	var p = new(LValueKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_lValueKeyword

	return p
}

func (s *LValueKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LValueKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *LValueKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LValueKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LValueKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterLValueKeyword(s)
	}
}

func (s *LValueKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitLValueKeyword(s)
	}
}

func (s *LValueKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitLValueKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) LValueKeyword() (localctx ILValueKeywordContext) {
	localctx = NewLValueKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1212, MySQLParserRULE_lValueKeyword)
	p.SetState(8394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8390)
			p.IdentifierKeywordsUnambiguous()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8391)
			p.IdentifierKeywordsAmbiguous1RolesAndLabels()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8392)
			p.IdentifierKeywordsAmbiguous2Labels()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8393)
			p.IdentifierKeywordsAmbiguous3Roles()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous4SystemVariablesContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous4SystemVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	PERSIST_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous4SystemVariablesContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous4SystemVariablesContext()
}

type IdentifierKeywordsAmbiguous4SystemVariablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous4SystemVariablesContext() *IdentifierKeywordsAmbiguous4SystemVariablesContext {
	var p = new(IdentifierKeywordsAmbiguous4SystemVariablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous4SystemVariables
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous4SystemVariablesContext(p *IdentifierKeywordsAmbiguous4SystemVariablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous4SystemVariables
}

func (*IdentifierKeywordsAmbiguous4SystemVariablesContext) IsIdentifierKeywordsAmbiguous4SystemVariablesContext() {
}

func NewIdentifierKeywordsAmbiguous4SystemVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous4SystemVariablesContext {
	var p = new(IdentifierKeywordsAmbiguous4SystemVariablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_identifierKeywordsAmbiguous4SystemVariables

	return p
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGLOBAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSESSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous4SystemVariables(s)
	}
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous4SystemVariables(s)
	}
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous4SystemVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) IdentifierKeywordsAmbiguous4SystemVariables() (localctx IIdentifierKeywordsAmbiguous4SystemVariablesContext) {
	localctx = NewIdentifierKeywordsAmbiguous4SystemVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1214, MySQLParserRULE_identifierKeywordsAmbiguous4SystemVariables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8396)
		_la = p.GetTokenStream().LA(1)

		if !(_la == MySQLParserGLOBAL_SYMBOL || _la == MySQLParserLOCAL_SYMBOL || _la == MySQLParserSESSION_SYMBOL || _la == MySQLParserPERSIST_SYMBOL || _la == MySQLParserPERSIST_ONLY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrIdentifierKeywordContext is an interface to support dynamic dispatch.
type IRoleOrIdentifierKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT_SYMBOL() antlr.TerminalNode
	ASCII_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	BYTE_SYMBOL() antlr.TerminalNode
	CACHE_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	CLONE_SYMBOL() antlr.TerminalNode
	CLOSE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DO_SYMBOL() antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	FLUSH_SYMBOL() antlr.TerminalNode
	FOLLOWS_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	HANDLER_SYMBOL() antlr.TerminalNode
	HELP_SYMBOL() antlr.TerminalNode
	HOST_SYMBOL() antlr.TerminalNode
	INSTALL_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	OWNER_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	PARTITION_SYMBOL() antlr.TerminalNode
	PORT_SYMBOL() antlr.TerminalNode
	PRECEDES_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	REMOVE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	RESET_SYMBOL() antlr.TerminalNode
	RESTORE_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	SECONDARY_SYMBOL() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	SECONDARY_LOAD_SYMBOL() antlr.TerminalNode
	SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	SERVER_SYMBOL() antlr.TerminalNode
	SIGNED_SYMBOL() antlr.TerminalNode
	SOCKET_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	SONAME_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	UNICODE_SYMBOL() antlr.TerminalNode
	UNINSTALL_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	VISIBLE_SYMBOL() antlr.TerminalNode
	WRAPPER_SYMBOL() antlr.TerminalNode
	XA_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode

	// IsRoleOrIdentifierKeywordContext differentiates from other interfaces.
	IsRoleOrIdentifierKeywordContext()
}

type RoleOrIdentifierKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrIdentifierKeywordContext() *RoleOrIdentifierKeywordContext {
	var p = new(RoleOrIdentifierKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrIdentifierKeyword
	return p
}

func InitEmptyRoleOrIdentifierKeywordContext(p *RoleOrIdentifierKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrIdentifierKeyword
}

func (*RoleOrIdentifierKeywordContext) IsRoleOrIdentifierKeywordContext() {}

func NewRoleOrIdentifierKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrIdentifierKeywordContext {
	var p = new(RoleOrIdentifierKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleOrIdentifierKeyword

	return p
}

func (s *RoleOrIdentifierKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrIdentifierKeywordContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACCOUNT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserASCII_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALWAYS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBACKUP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBEGIN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBYTE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCACHE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHARSET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHECKSUM_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLONE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLOSE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMENT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMIT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTAINS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEALLOCATE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDO_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEND_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FLUSH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFLUSH_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FOLLOWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFORMAT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHANDLER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HELP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHELP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOST_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTALL_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVISIBLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLANGUAGE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPEN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OWNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOWNER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARSER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITION_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPORT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PRECEDES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDES_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREPARE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREMOVE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPAIR_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) RESTORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESTORE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLBACK_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSAVEPOINT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_LOAD_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECONDARY_UNLOAD_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECURITY_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERVER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIGNED_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SOCKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOCKET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLAVE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSONAME_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTART_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTOP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRUNCATE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNICODE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNINSTALL_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUPGRADE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVISIBLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) WRAPPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWRAPPER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXA_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrIdentifierKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrIdentifierKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleOrIdentifierKeyword(s)
	}
}

func (s *RoleOrIdentifierKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleOrIdentifierKeyword(s)
	}
}

func (s *RoleOrIdentifierKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleOrIdentifierKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleOrIdentifierKeyword() (localctx IRoleOrIdentifierKeywordContext) {
	localctx = NewRoleOrIdentifierKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1216, MySQLParserRULE_roleOrIdentifierKeyword)
	var _la int

	p.SetState(8403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8398)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2594284492269555716) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&144115188092635649) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&-9203668788485025791) != 0) || ((int64((_la-219)) & ^0x3f) == 0 && ((int64(1)<<(_la-219))&281475043819561) != 0) || ((int64((_la-373)) & ^0x3f) == 0 && ((int64(1)<<(_la-373))&23094341287937) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&5766877052741681161) != 0) || ((int64((_la-519)) & ^0x3f) == 0 && ((int64(1)<<(_la-519))&8606711811) != 0) || ((int64((_la-597)) & ^0x3f) == 0 && ((int64(1)<<(_la-597))&4631952216750818817) != 0) || ((int64((_la-661)) & ^0x3f) == 0 && ((int64(1)<<(_la-661))&8646911284551417859) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8399)

		if !(serverVersion >= 50709) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 50709", ""))
			goto errorExit
		}
		{
			p.SetState(8400)
			p.Match(MySQLParserSHUTDOWN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(8401)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(8402)
			p.Match(MySQLParserIMPORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrLabelKeywordContext is an interface to support dynamic dispatch.
type IRoleOrLabelKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTION_SYMBOL() antlr.TerminalNode
	ACTIVE_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	AFTER_SYMBOL() antlr.TerminalNode
	AGAINST_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode
	ALGORITHM_SYMBOL() antlr.TerminalNode
	ANALYSE_SYMBOL() antlr.TerminalNode
	ANY_SYMBOL() antlr.TerminalNode
	AT_SYMBOL() antlr.TerminalNode
	AUTHORS_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	BINLOG_SYMBOL() antlr.TerminalNode
	BIT_SYMBOL() antlr.TerminalNode
	BLOCK_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	BTREE_SYMBOL() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	CASCADED_SYMBOL() antlr.TerminalNode
	CATALOG_NAME_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	CIPHER_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	COALESCE_SYMBOL() antlr.TerminalNode
	CODE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	COLUMN_NAME_SYMBOL() antlr.TerminalNode
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	COMPLETION_SYMBOL() antlr.TerminalNode
	COMPONENT_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	COMPRESSION_SYMBOL() antlr.TerminalNode
	CONCURRENT_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode
	CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	CONTRIBUTORS_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	CURSOR_NAME_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DATAFILE_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	DES_KEY_FILE_SYMBOL() antlr.TerminalNode
	DESCRIPTION_SYMBOL() antlr.TerminalNode
	DIAGNOSTICS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	DISCARD_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	DUMPFILE_SYMBOL() antlr.TerminalNode
	DUPLICATE_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	ENDS_SYMBOL() antlr.TerminalNode
	ENUM_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	ESCAPE_SYMBOL() antlr.TerminalNode
	EVENTS_SYMBOL() antlr.TerminalNode
	EVERY_SYMBOL() antlr.TerminalNode
	EXCLUDE_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	EXTENT_SIZE_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	FOUND_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	GENERAL_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	INACTIVE_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	ISOLATION_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	LIST_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	LOCKS_SYMBOL() antlr.TerminalNode
	LOGFILE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode
	MAX_SIZE_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	MERGE_SYMBOL() antlr.TerminalNode
	MESSAGE_TEXT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	MODIFY_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	MYSQL_ERRNO_SYMBOL() antlr.TerminalNode
	NAME_SYMBOL() antlr.TerminalNode
	NAMES_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	NDBCLUSTER_SYMBOL() antlr.TerminalNode
	NESTED_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode
	NEW_SYMBOL() antlr.TerminalNode
	NO_WAIT_SYMBOL() antlr.TerminalNode
	NODEGROUP_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode
	NUMBER_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	ORGANIZATION_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	PATH_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	PREV_SYMBOL() antlr.TerminalNode
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	READ_ONLY_SYMBOL() antlr.TerminalNode
	REBUILD_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	REDOFILE_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	RELAY_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	REMOTE_SYMBOL() antlr.TerminalNode
	REORGANIZE_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	USER_RESOURCES_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	RETAIN_SYMBOL() antlr.TerminalNode
	RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	ROTATE_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	SCHEMA_NAME_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode
	SKIP_SYMBOL() antlr.TerminalNode
	SLOW_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	SOUNDS_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_CACHE_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode
	SRID_SYMBOL() antlr.TerminalNode
	STACKED_SYMBOL() antlr.TerminalNode
	STARTS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	STRING_SYMBOL() antlr.TerminalNode
	SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	TABLE_NAME_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TEMPTABLE_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TYPES_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode
	UDF_RETURNS_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode
	UNDEFINED_SYMBOL() antlr.TerminalNode
	UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	UNDOFILE_SYMBOL() antlr.TerminalNode
	UNKNOWN_SYMBOL() antlr.TerminalNode
	UNTIL_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	VCPU_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	WAIT_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode
	XML_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	CUBE_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	ROWS_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	EXCHANGE_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode
	VALIDATION_SYMBOL() antlr.TerminalNode
	WITHOUT_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode

	// IsRoleOrLabelKeywordContext differentiates from other interfaces.
	IsRoleOrLabelKeywordContext()
}

type RoleOrLabelKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrLabelKeywordContext() *RoleOrLabelKeywordContext {
	var p = new(RoleOrLabelKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrLabelKeyword
	return p
}

func InitEmptyRoleOrLabelKeywordContext(p *RoleOrLabelKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = MySQLParserRULE_roleOrLabelKeyword
}

func (*RoleOrLabelKeywordContext) IsRoleOrLabelKeywordContext() {}

func NewRoleOrLabelKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrLabelKeywordContext {
	var p = new(RoleOrLabelKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = MySQLParserRULE_roleOrLabelKeyword

	return p
}

func (s *RoleOrLabelKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrLabelKeywordContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserACTIVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADDDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAFTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGAINST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAGGREGATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserALGORITHM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ANALYSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANALYSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserANY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTHORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTHORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAUTOEXTEND_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserAVG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBINLOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBLOCK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBOOLEAN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBTREE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserBUCKETS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CASCADED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCASCADED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CATALOG_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCATALOG_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHAIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANGED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCHANNEL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCIPHER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLIENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCLASS_ORIGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOALESCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCODE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLLATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMN_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOLUMNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMMITTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPACT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPLETION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPONENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCOMPRESSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONCURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONCURRENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONNECTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSISTENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_CATALOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_SCHEMA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONSTRAINT_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONTRIBUTORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCONTRIBUTORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCPU_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURRENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CURSOR_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCURSOR_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATAFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATETIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDEFINER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DES_KEY_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDES_KEY_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DESCRIPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDESCRIPTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DIAGNOSTICS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIAGNOSTICS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDIRECTORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISCARD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDISK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUMPFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DUPLICATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDUPLICATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserDYNAMIC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENCRYPTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENGINES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERROR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserERRORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserESCAPE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVENTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EVERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEVERY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCLUDE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPANSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENDED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXTENT_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXTENT_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAULTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFAST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOLLOWING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FOUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFOUND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserENABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFULL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILE_BLOCK_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFILTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIRST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFIXED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GENERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGENERAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGET_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGRANTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserGLOBAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHASH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTOGRAM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHISTORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOSTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserHOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIDENTIFIED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINVOKER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINDEXES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSTANCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINACTIVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIO_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIPC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISOLATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserISSUER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserINSERT_METHOD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserJSON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLAST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEAVES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLESS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLEVEL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLINESTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLIST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCKED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCKS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOCKS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserLOGS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_ROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_HOST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_USER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SERVER_ID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_DELAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_STATEMENT_TIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEDIUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMEMORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MERGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMERGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MESSAGE_TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMESSAGE_TEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMICROSECOND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIGRATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMINUTE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMIN_ROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MODIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODIFY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMODE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMONTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTILINESTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOINT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMUTEX_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MYSQL_ERRNO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserMYSQL_ERRNO_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNAMES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNATIONAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNCHAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NDBCLUSTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNDBCLUSTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNESTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEVER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNEW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NO_WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNO_WAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNODEGROUP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNULLS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNOWAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNUMBER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserNVARCHAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOFFSET_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOPTIONAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORDINALITY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ORGANIZATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserORGANIZATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserOTHERS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPACK_KEYS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPAGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTIAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPARTITIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPHASE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPLUGINS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOINT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPOLYGON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRECEDING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRESERVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PREV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPREV_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPRIVILEGES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROCESSLIST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserPROFILES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUARTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUERY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserQUICK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) READ_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREAD_ONLY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REBUILD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREBUILD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRECOVER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDOFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREDUNDANT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAYLOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRELAY_THREAD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REMOTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREMOTE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REORGANIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREORGANIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPEATABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USER_RESOURCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_RESOURCES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESPECT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRESUME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETAIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNED_SQLSTATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRETURNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREUSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserREVERSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROLLUP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROTATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROUTINE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_COUNT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserRTREE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEDULE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SCHEMA_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSCHEMA_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSECOND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSERIALIZABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSESSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHARE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSIMPLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSKIP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SLOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSLOW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSNAPSHOT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOUNDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSOURCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_CACHE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSQL_THREAD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SRID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSRID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STACKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTACKED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STARTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTARTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTATUS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTORAGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBCLASS_ORIGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBJECT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUPER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSUSPEND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWAPS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSWITCHES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLE_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTABLESPACE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPORARY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEMPTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEMPTABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTHAN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRANSACTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTRIGGERS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TYPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserTYPE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UDF_RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUDF_RETURNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNBOUNDED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNCOMMITTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDEFINED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDEFINED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNDOFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNKNOWN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUNTIL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserUSE_FRM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVARIABLES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVCPU_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVIEW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALUE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWARNINGS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEEK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWORK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserX509_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) XML_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserXML_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserYEAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CUBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserCUBE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserIMPORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserFUNCTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserROW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXCHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXCHANGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserEXPIRE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserONLY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VALIDATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserVALIDATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WITHOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserWITHOUT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(MySQLParserADMIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrLabelKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrLabelKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.EnterRoleOrLabelKeyword(s)
	}
}

func (s *RoleOrLabelKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(MySQLParserListener); ok {
		listenerT.ExitRoleOrLabelKeyword(s)
	}
}

func (s *RoleOrLabelKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case MySQLParserVisitor:
		return t.VisitRoleOrLabelKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *MySQLParser) RoleOrLabelKeyword() (localctx IRoleOrLabelKeywordContext) {
	localctx = NewRoleOrLabelKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1218, MySQLParserRULE_roleOrLabelKeyword)
	var _la int

	p.SetState(8414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1122, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8405)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8979026322141404184) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&293728076757980891) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-1036806760278507893) != 0) || ((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&6008090054826942021) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&2012968295144429669) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&3186450531003551) != 0) || ((int64((_la-399)) & ^0x3f) == 0 && ((int64(1)<<(_la-399))&-2123500508502540357) != 0) || ((int64((_la-463)) & ^0x3f) == 0 && ((int64(1)<<(_la-463))&888371177957633551) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283301262519) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&3784097394692726723) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-5647576991346663167) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&27) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(8406)

		if !(serverVersion < 50709) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 50709", ""))
			goto errorExit
		}
		{
			p.SetState(8407)
			p.Match(MySQLParserSHUTDOWN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(8408)

		if !(serverVersion < 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion < 80000", ""))
			goto errorExit
		}
		{
			p.SetState(8409)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserCUBE_SYMBOL || _la == MySQLParserFUNCTION_SYMBOL || _la == MySQLParserIMPORT_SYMBOL || _la == MySQLParserROWS_SYMBOL || _la == MySQLParserROW_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(8410)

		if !(serverVersion >= 80000) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80000", ""))
			goto errorExit
		}
		{
			p.SetState(8411)
			_la = p.GetTokenStream().LA(1)

			if !(_la == MySQLParserEXCHANGE_SYMBOL || _la == MySQLParserEXPIRE_SYMBOL || _la == MySQLParserONLY_SYMBOL || _la == MySQLParserSUPER_SYMBOL || _la == MySQLParserVALIDATION_SYMBOL || _la == MySQLParserWITHOUT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(8412)

		if !(serverVersion >= 80014) {
			p.SetError(antlr.NewFailedPredicateException(p, "serverVersion >= 80014", ""))
			goto errorExit
		}
		{
			p.SetState(8413)
			p.Match(MySQLParserADMIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *MySQLParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *SimpleStatementContext = nil
		if localctx != nil {
			t = localctx.(*SimpleStatementContext)
		}
		return p.SimpleStatement_Sempred(t, predIndex)

	case 2:
		var t *AlterStatementContext = nil
		if localctx != nil {
			t = localctx.(*AlterStatementContext)
		}
		return p.AlterStatement_Sempred(t, predIndex)

	case 3:
		var t *AlterDatabaseContext = nil
		if localctx != nil {
			t = localctx.(*AlterDatabaseContext)
		}
		return p.AlterDatabase_Sempred(t, predIndex)

	case 9:
		var t *AlterTableContext = nil
		if localctx != nil {
			t = localctx.(*AlterTableContext)
		}
		return p.AlterTable_Sempred(t, predIndex)

	case 13:
		var t *StandaloneAlterCommandsContext = nil
		if localctx != nil {
			t = localctx.(*StandaloneAlterCommandsContext)
		}
		return p.StandaloneAlterCommands_Sempred(t, predIndex)

	case 14:
		var t *AlterPartitionContext = nil
		if localctx != nil {
			t = localctx.(*AlterPartitionContext)
		}
		return p.AlterPartition_Sempred(t, predIndex)

	case 17:
		var t *AlterListItemContext = nil
		if localctx != nil {
			t = localctx.(*AlterListItemContext)
		}
		return p.AlterListItem_Sempred(t, predIndex)

	case 24:
		var t *WithValidationContext = nil
		if localctx != nil {
			t = localctx.(*WithValidationContext)
		}
		return p.WithValidation_Sempred(t, predIndex)

	case 27:
		var t *AlterTablespaceContext = nil
		if localctx != nil {
			t = localctx.(*AlterTablespaceContext)
		}
		return p.AlterTablespace_Sempred(t, predIndex)

	case 38:
		var t *CreateStatementContext = nil
		if localctx != nil {
			t = localctx.(*CreateStatementContext)
		}
		return p.CreateStatement_Sempred(t, predIndex)

	case 40:
		var t *CreateDatabaseOptionContext = nil
		if localctx != nil {
			t = localctx.(*CreateDatabaseOptionContext)
		}
		return p.CreateDatabaseOption_Sempred(t, predIndex)

	case 53:
		var t *CreateIndexContext = nil
		if localctx != nil {
			t = localctx.(*CreateIndexContext)
		}
		return p.CreateIndex_Sempred(t, predIndex)

	case 64:
		var t *TsDataFileNameContext = nil
		if localctx != nil {
			t = localctx.(*TsDataFileNameContext)
		}
		return p.TsDataFileName_Sempred(t, predIndex)

	case 67:
		var t *TablespaceOptionContext = nil
		if localctx != nil {
			t = localctx.(*TablespaceOptionContext)
		}
		return p.TablespaceOption_Sempred(t, predIndex)

	case 84:
		var t *TriggerFollowsPrecedesClauseContext = nil
		if localctx != nil {
			t = localctx.(*TriggerFollowsPrecedesClauseContext)
		}
		return p.TriggerFollowsPrecedesClause_Sempred(t, predIndex)

	case 89:
		var t *DropStatementContext = nil
		if localctx != nil {
			t = localctx.(*DropStatementContext)
		}
		return p.DropStatement_Sempred(t, predIndex)

	case 110:
		var t *DeleteStatementContext = nil
		if localctx != nil {
			t = localctx.(*DeleteStatementContext)
		}
		return p.DeleteStatement_Sempred(t, predIndex)

	case 111:
		var t *PartitionDeleteContext = nil
		if localctx != nil {
			t = localctx.(*PartitionDeleteContext)
		}
		return p.PartitionDelete_Sempred(t, predIndex)

	case 113:
		var t *DoStatementContext = nil
		if localctx != nil {
			t = localctx.(*DoStatementContext)
		}
		return p.DoStatement_Sempred(t, predIndex)

	case 116:
		var t *InsertStatementContext = nil
		if localctx != nil {
			t = localctx.(*InsertStatementContext)
		}
		return p.InsertStatement_Sempred(t, predIndex)

	case 135:
		var t *QueryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*QueryExpressionContext)
		}
		return p.QueryExpression_Sempred(t, predIndex)

	case 138:
		var t *QueryPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*QueryPrimaryContext)
		}
		return p.QueryPrimary_Sempred(t, predIndex)

	case 139:
		var t *QuerySpecificationContext = nil
		if localctx != nil {
			t = localctx.(*QuerySpecificationContext)
		}
		return p.QuerySpecification_Sempred(t, predIndex)

	case 163:
		var t *OlapOptionContext = nil
		if localctx != nil {
			t = localctx.(*OlapOptionContext)
		}
		return p.OlapOption_Sempred(t, predIndex)

	case 171:
		var t *SelectOptionContext = nil
		if localctx != nil {
			t = localctx.(*SelectOptionContext)
		}
		return p.SelectOption_Sempred(t, predIndex)

	case 173:
		var t *LockingClauseContext = nil
		if localctx != nil {
			t = localctx.(*LockingClauseContext)
		}
		return p.LockingClause_Sempred(t, predIndex)

	case 174:
		var t *LockStrenghContext = nil
		if localctx != nil {
			t = localctx.(*LockStrenghContext)
		}
		return p.LockStrengh_Sempred(t, predIndex)

	case 180:
		var t *TableReferenceContext = nil
		if localctx != nil {
			t = localctx.(*TableReferenceContext)
		}
		return p.TableReference_Sempred(t, predIndex)

	case 186:
		var t *TableFactorContext = nil
		if localctx != nil {
			t = localctx.(*TableFactorContext)
		}
		return p.TableFactor_Sempred(t, predIndex)

	case 189:
		var t *DerivedTableContext = nil
		if localctx != nil {
			t = localctx.(*DerivedTableContext)
		}
		return p.DerivedTable_Sempred(t, predIndex)

	case 193:
		var t *JtColumnContext = nil
		if localctx != nil {
			t = localctx.(*JtColumnContext)
		}
		return p.JtColumn_Sempred(t, predIndex)

	case 199:
		var t *TableAliasContext = nil
		if localctx != nil {
			t = localctx.(*TableAliasContext)
		}
		return p.TableAlias_Sempred(t, predIndex)

	case 208:
		var t *UpdateStatementContext = nil
		if localctx != nil {
			t = localctx.(*UpdateStatementContext)
		}
		return p.UpdateStatement_Sempred(t, predIndex)

	case 212:
		var t *TransactionCharacteristicContext = nil
		if localctx != nil {
			t = localctx.(*TransactionCharacteristicContext)
		}
		return p.TransactionCharacteristic_Sempred(t, predIndex)

	case 214:
		var t *LockStatementContext = nil
		if localctx != nil {
			t = localctx.(*LockStatementContext)
		}
		return p.LockStatement_Sempred(t, predIndex)

	case 218:
		var t *XaConvertContext = nil
		if localctx != nil {
			t = localctx.(*XaConvertContext)
		}
		return p.XaConvert_Sempred(t, predIndex)

	case 220:
		var t *ReplicationStatementContext = nil
		if localctx != nil {
			t = localctx.(*ReplicationStatementContext)
		}
		return p.ReplicationStatement_Sempred(t, predIndex)

	case 221:
		var t *ResetOptionContext = nil
		if localctx != nil {
			t = localctx.(*ResetOptionContext)
		}
		return p.ResetOption_Sempred(t, predIndex)

	case 222:
		var t *MasterResetOptionsContext = nil
		if localctx != nil {
			t = localctx.(*MasterResetOptionsContext)
		}
		return p.MasterResetOptions_Sempred(t, predIndex)

	case 232:
		var t *ChangeReplicationContext = nil
		if localctx != nil {
			t = localctx.(*ChangeReplicationContext)
		}
		return p.ChangeReplication_Sempred(t, predIndex)

	case 240:
		var t *SlaveUntilOptionsContext = nil
		if localctx != nil {
			t = localctx.(*SlaveUntilOptionsContext)
		}
		return p.SlaveUntilOptions_Sempred(t, predIndex)

	case 241:
		var t *SlaveConnectionOptionsContext = nil
		if localctx != nil {
			t = localctx.(*SlaveConnectionOptionsContext)
		}
		return p.SlaveConnectionOptions_Sempred(t, predIndex)

	case 248:
		var t *CloneStatementContext = nil
		if localctx != nil {
			t = localctx.(*CloneStatementContext)
		}
		return p.CloneStatement_Sempred(t, predIndex)

	case 251:
		var t *AccountManagementStatementContext = nil
		if localctx != nil {
			t = localctx.(*AccountManagementStatementContext)
		}
		return p.AccountManagementStatement_Sempred(t, predIndex)

	case 252:
		var t *AlterUserContext = nil
		if localctx != nil {
			t = localctx.(*AlterUserContext)
		}
		return p.AlterUser_Sempred(t, predIndex)

	case 253:
		var t *AlterUserTailContext = nil
		if localctx != nil {
			t = localctx.(*AlterUserTailContext)
		}
		return p.AlterUserTail_Sempred(t, predIndex)

	case 255:
		var t *CreateUserContext = nil
		if localctx != nil {
			t = localctx.(*CreateUserContext)
		}
		return p.CreateUser_Sempred(t, predIndex)

	case 256:
		var t *CreateUserTailContext = nil
		if localctx != nil {
			t = localctx.(*CreateUserTailContext)
		}
		return p.CreateUserTail_Sempred(t, predIndex)

	case 257:
		var t *DefaultRoleClauseContext = nil
		if localctx != nil {
			t = localctx.(*DefaultRoleClauseContext)
		}
		return p.DefaultRoleClause_Sempred(t, predIndex)

	case 260:
		var t *AccountLockPasswordExpireOptionsContext = nil
		if localctx != nil {
			t = localctx.(*AccountLockPasswordExpireOptionsContext)
		}
		return p.AccountLockPasswordExpireOptions_Sempred(t, predIndex)

	case 261:
		var t *DropUserContext = nil
		if localctx != nil {
			t = localctx.(*DropUserContext)
		}
		return p.DropUser_Sempred(t, predIndex)

	case 262:
		var t *GrantContext = nil
		if localctx != nil {
			t = localctx.(*GrantContext)
		}
		return p.Grant_Sempred(t, predIndex)

	case 263:
		var t *GrantTargetListContext = nil
		if localctx != nil {
			t = localctx.(*GrantTargetListContext)
		}
		return p.GrantTargetList_Sempred(t, predIndex)

	case 264:
		var t *GrantOptionsContext = nil
		if localctx != nil {
			t = localctx.(*GrantOptionsContext)
		}
		return p.GrantOptions_Sempred(t, predIndex)

	case 268:
		var t *VersionedRequireClauseContext = nil
		if localctx != nil {
			t = localctx.(*VersionedRequireClauseContext)
		}
		return p.VersionedRequireClause_Sempred(t, predIndex)

	case 270:
		var t *RevokeContext = nil
		if localctx != nil {
			t = localctx.(*RevokeContext)
		}
		return p.Revoke_Sempred(t, predIndex)

	case 271:
		var t *OnTypeToContext = nil
		if localctx != nil {
			t = localctx.(*OnTypeToContext)
		}
		return p.OnTypeTo_Sempred(t, predIndex)

	case 274:
		var t *RoleOrPrivilegeContext = nil
		if localctx != nil {
			t = localctx.(*RoleOrPrivilegeContext)
		}
		return p.RoleOrPrivilege_Sempred(t, predIndex)

	case 275:
		var t *GrantIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*GrantIdentifierContext)
		}
		return p.GrantIdentifier_Sempred(t, predIndex)

	case 282:
		var t *TableAdministrationStatementContext = nil
		if localctx != nil {
			t = localctx.(*TableAdministrationStatementContext)
		}
		return p.TableAdministrationStatement_Sempred(t, predIndex)

	case 288:
		var t *StartOptionValueListContext = nil
		if localctx != nil {
			t = localctx.(*StartOptionValueListContext)
		}
		return p.StartOptionValueList_Sempred(t, predIndex)

	case 293:
		var t *OptionValueNoOptionTypeContext = nil
		if localctx != nil {
			t = localctx.(*OptionValueNoOptionTypeContext)
		}
		return p.OptionValueNoOptionType_Sempred(t, predIndex)

	case 298:
		var t *SetExprOrDefaultContext = nil
		if localctx != nil {
			t = localctx.(*SetExprOrDefaultContext)
		}
		return p.SetExprOrDefault_Sempred(t, predIndex)

	case 299:
		var t *ShowStatementContext = nil
		if localctx != nil {
			t = localctx.(*ShowStatementContext)
		}
		return p.ShowStatement_Sempred(t, predIndex)

	case 300:
		var t *ShowCommandTypeContext = nil
		if localctx != nil {
			t = localctx.(*ShowCommandTypeContext)
		}
		return p.ShowCommandType_Sempred(t, predIndex)

	case 301:
		var t *NonBlockingContext = nil
		if localctx != nil {
			t = localctx.(*NonBlockingContext)
		}
		return p.NonBlocking_Sempred(t, predIndex)

	case 305:
		var t *OtherAdministrativeStatementContext = nil
		if localctx != nil {
			t = localctx.(*OtherAdministrativeStatementContext)
		}
		return p.OtherAdministrativeStatement_Sempred(t, predIndex)

	case 313:
		var t *FlushOptionContext = nil
		if localctx != nil {
			t = localctx.(*FlushOptionContext)
		}
		return p.FlushOption_Sempred(t, predIndex)

	case 316:
		var t *FlushTablesOptionsContext = nil
		if localctx != nil {
			t = localctx.(*FlushTablesOptionsContext)
		}
		return p.FlushTablesOptions_Sempred(t, predIndex)

	case 331:
		var t *UtilityStatementContext = nil
		if localctx != nil {
			t = localctx.(*UtilityStatementContext)
		}
		return p.UtilityStatement_Sempred(t, predIndex)

	case 333:
		var t *ExplainStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExplainStatementContext)
		}
		return p.ExplainStatement_Sempred(t, predIndex)

	case 334:
		var t *ExplainableStatementContext = nil
		if localctx != nil {
			t = localctx.(*ExplainableStatementContext)
		}
		return p.ExplainableStatement_Sempred(t, predIndex)

	case 338:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 339:
		var t *BoolPriContext = nil
		if localctx != nil {
			t = localctx.(*BoolPriContext)
		}
		return p.BoolPri_Sempred(t, predIndex)

	case 341:
		var t *PredicateContext = nil
		if localctx != nil {
			t = localctx.(*PredicateContext)
		}
		return p.Predicate_Sempred(t, predIndex)

	case 343:
		var t *BitExprContext = nil
		if localctx != nil {
			t = localctx.(*BitExprContext)
		}
		return p.BitExpr_Sempred(t, predIndex)

	case 344:
		var t *SimpleExprContext = nil
		if localctx != nil {
			t = localctx.(*SimpleExprContext)
		}
		return p.SimpleExpr_Sempred(t, predIndex)

	case 345:
		var t *ArrayCastContext = nil
		if localctx != nil {
			t = localctx.(*ArrayCastContext)
		}
		return p.ArrayCast_Sempred(t, predIndex)

	case 346:
		var t *JsonOperatorContext = nil
		if localctx != nil {
			t = localctx.(*JsonOperatorContext)
		}
		return p.JsonOperator_Sempred(t, predIndex)

	case 347:
		var t *SumExprContext = nil
		if localctx != nil {
			t = localctx.(*SumExprContext)
		}
		return p.SumExpr_Sempred(t, predIndex)

	case 358:
		var t *RuntimeFunctionCallContext = nil
		if localctx != nil {
			t = localctx.(*RuntimeFunctionCallContext)
		}
		return p.RuntimeFunctionCall_Sempred(t, predIndex)

	case 359:
		var t *GeometryFunctionContext = nil
		if localctx != nil {
			t = localctx.(*GeometryFunctionContext)
		}
		return p.GeometryFunction_Sempred(t, predIndex)

	case 361:
		var t *FractionalPrecisionContext = nil
		if localctx != nil {
			t = localctx.(*FractionalPrecisionContext)
		}
		return p.FractionalPrecision_Sempred(t, predIndex)

	case 373:
		var t *InternalVariableNameContext = nil
		if localctx != nil {
			t = localctx.(*InternalVariableNameContext)
		}
		return p.InternalVariableName_Sempred(t, predIndex)

	case 377:
		var t *CastTypeContext = nil
		if localctx != nil {
			t = localctx.(*CastTypeContext)
		}
		return p.CastType_Sempred(t, predIndex)

	case 391:
		var t *ChannelContext = nil
		if localctx != nil {
			t = localctx.(*ChannelContext)
		}
		return p.Channel_Sempred(t, predIndex)

	case 420:
		var t *GetDiagnosticsContext = nil
		if localctx != nil {
			t = localctx.(*GetDiagnosticsContext)
		}
		return p.GetDiagnostics_Sempred(t, predIndex)

	case 433:
		var t *CheckOrReferencesContext = nil
		if localctx != nil {
			t = localctx.(*CheckOrReferencesContext)
		}
		return p.CheckOrReferences_Sempred(t, predIndex)

	case 436:
		var t *TableConstraintDefContext = nil
		if localctx != nil {
			t = localctx.(*TableConstraintDefContext)
		}
		return p.TableConstraintDef_Sempred(t, predIndex)

	case 438:
		var t *FieldDefinitionContext = nil
		if localctx != nil {
			t = localctx.(*FieldDefinitionContext)
		}
		return p.FieldDefinition_Sempred(t, predIndex)

	case 439:
		var t *ColumnAttributeContext = nil
		if localctx != nil {
			t = localctx.(*ColumnAttributeContext)
		}
		return p.ColumnAttribute_Sempred(t, predIndex)

	case 449:
		var t *KeyListVariantsContext = nil
		if localctx != nil {
			t = localctx.(*KeyListVariantsContext)
		}
		return p.KeyListVariants_Sempred(t, predIndex)

	case 452:
		var t *CommonIndexOptionContext = nil
		if localctx != nil {
			t = localctx.(*CommonIndexOptionContext)
		}
		return p.CommonIndexOption_Sempred(t, predIndex)

	case 458:
		var t *DataTypeContext = nil
		if localctx != nil {
			t = localctx.(*DataTypeContext)
		}
		return p.DataType_Sempred(t, predIndex)

	case 468:
		var t *CharsetNameContext = nil
		if localctx != nil {
			t = localctx.(*CharsetNameContext)
		}
		return p.CharsetName_Sempred(t, predIndex)

	case 469:
		var t *CollationNameContext = nil
		if localctx != nil {
			t = localctx.(*CollationNameContext)
		}
		return p.CollationName_Sempred(t, predIndex)

	case 472:
		var t *CreateTableOptionContext = nil
		if localctx != nil {
			t = localctx.(*CreateTableOptionContext)
		}
		return p.CreateTableOption_Sempred(t, predIndex)

	case 480:
		var t *PartitionKeyAlgorithmContext = nil
		if localctx != nil {
			t = localctx.(*PartitionKeyAlgorithmContext)
		}
		return p.PartitionKeyAlgorithm_Sempred(t, predIndex)

	case 507:
		var t *CreateUserEntryContext = nil
		if localctx != nil {
			t = localctx.(*CreateUserEntryContext)
		}
		return p.CreateUserEntry_Sempred(t, predIndex)

	case 518:
		var t *UsePartitionContext = nil
		if localctx != nil {
			t = localctx.(*UsePartitionContext)
		}
		return p.UsePartition_Sempred(t, predIndex)

	case 520:
		var t *ColumnNameContext = nil
		if localctx != nil {
			t = localctx.(*ColumnNameContext)
		}
		return p.ColumnName_Sempred(t, predIndex)

	case 563:
		var t *PureIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*PureIdentifierContext)
		}
		return p.PureIdentifier_Sempred(t, predIndex)

	case 568:
		var t *SimpleIdentifierContext = nil
		if localctx != nil {
			t = localctx.(*SimpleIdentifierContext)
		}
		return p.SimpleIdentifier_Sempred(t, predIndex)

	case 573:
		var t *Real_ulonglong_numberContext = nil
		if localctx != nil {
			t = localctx.(*Real_ulonglong_numberContext)
		}
		return p.Real_ulonglong_number_Sempred(t, predIndex)

	case 577:
		var t *TextStringLiteralContext = nil
		if localctx != nil {
			t = localctx.(*TextStringLiteralContext)
		}
		return p.TextStringLiteral_Sempred(t, predIndex)

	case 579:
		var t *TextStringHashContext = nil
		if localctx != nil {
			t = localctx.(*TextStringHashContext)
		}
		return p.TextStringHash_Sempred(t, predIndex)

	case 599:
		var t *IdentifierKeywordContext = nil
		if localctx != nil {
			t = localctx.(*IdentifierKeywordContext)
		}
		return p.IdentifierKeyword_Sempred(t, predIndex)

	case 602:
		var t *LabelKeywordContext = nil
		if localctx != nil {
			t = localctx.(*LabelKeywordContext)
		}
		return p.LabelKeyword_Sempred(t, predIndex)

	case 604:
		var t *IdentifierKeywordsUnambiguousContext = nil
		if localctx != nil {
			t = localctx.(*IdentifierKeywordsUnambiguousContext)
		}
		return p.IdentifierKeywordsUnambiguous_Sempred(t, predIndex)

	case 605:
		var t *RoleKeywordContext = nil
		if localctx != nil {
			t = localctx.(*RoleKeywordContext)
		}
		return p.RoleKeyword_Sempred(t, predIndex)

	case 608:
		var t *RoleOrIdentifierKeywordContext = nil
		if localctx != nil {
			t = localctx.(*RoleOrIdentifierKeywordContext)
		}
		return p.RoleOrIdentifierKeyword_Sempred(t, predIndex)

	case 609:
		var t *RoleOrLabelKeywordContext = nil
		if localctx != nil {
			t = localctx.(*RoleOrLabelKeywordContext)
		}
		return p.RoleOrLabelKeyword_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *MySQLParser) SimpleStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return serverVersion >= 80000

	case 1:
		return serverVersion >= 80000

	case 2:
		return serverVersion >= 80000

	case 3:
		return serverVersion >= 50604

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return serverVersion >= 80014

	case 5:
		return serverVersion >= 50713

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterDatabase_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterTable_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return serverVersion < 50700

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) StandaloneAlterCommands_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterPartition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return serverVersion >= 50704

	case 10:
		return serverVersion >= 50704

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterListItem_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 11:
		return serverVersion >= 50700

	case 12:
		return serverVersion < 50700

	case 13:
		return serverVersion >= 80017

	case 14:
		return serverVersion >= 80019

	case 15:
		return serverVersion >= 80014

	case 16:
		return serverVersion >= 80000

	case 17:
		return serverVersion >= 80017

	case 18:
		return serverVersion >= 80019

	case 19:
		return serverVersion >= 80000

	case 20:
		return serverVersion >= 50700

	case 21:
		return serverVersion >= 80014

	case 22:
		return serverVersion >= 50708 && serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) WithValidation_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 23:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterTablespace_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 24:
		return serverVersion < 80000

	case 25:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 26:
		return serverVersion >= 80000

	case 27:
		return serverVersion >= 80011

	case 28:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateDatabaseOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 29:
		return serverVersion >= 80016

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateIndex_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 30:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TsDataFileName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 31:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TablespaceOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 32:
		return serverVersion >= 50707

	case 33:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TriggerFollowsPrecedesClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 34:
		return serverVersion >= 50700

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DropStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 35:
		return serverVersion >= 80000

	case 36:
		return serverVersion >= 80011

	case 37:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DeleteStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 38:
		return serverVersion >= 80000

	case 39:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) PartitionDelete_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 40:
		return serverVersion >= 50602

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DoStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 41:
		return serverVersion < 50709

	case 42:
		return serverVersion >= 50709

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) InsertStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 43:
		return serverVersion >= 80018

	case 44:
		return serverVersion >= 80018

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) QueryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 45:
		return serverVersion >= 80000

	case 46:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) QueryPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 47:
		return serverVersion >= 80019

	case 48:
		return serverVersion >= 80019

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) QuerySpecification_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 49:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) OlapOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 50:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SelectOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 51:
		return serverVersion < 80000

	case 52:
		return serverVersion >= 50704 && serverVersion < 50708

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) LockingClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 53:
		return serverVersion >= 80000

	case 54:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) LockStrengh_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 55:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TableReference_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 56:
		return serverVersion < 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TableFactor_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 57:
		return serverVersion >= 80004

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DerivedTable_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 58:
		return serverVersion >= 80000

	case 59:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) JtColumn_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 60:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TableAlias_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 61:
		return serverVersion < 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) UpdateStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 62:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TransactionCharacteristic_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 63:
		return serverVersion >= 50605

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) LockStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 64:
		return serverVersion >= 80000

	case 65:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) XaConvert_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 66:
		return serverVersion >= 50704

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ReplicationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 67:
		return serverVersion > 80000

	case 68:
		return serverVersion >= 50700

	case 69:
		return serverVersion > 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ResetOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 70:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) MasterResetOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 71:
		return serverVersion >= 80000

	case 72:
		return serverVersion < 80017

	case 73:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ChangeReplication_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 74:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SlaveUntilOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 75:
		return serverVersion >= 50606

	case 76:
		return serverVersion >= 50606

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SlaveConnectionOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 77:
		return serverVersion >= 50604

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CloneStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 78:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AccountManagementStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 79:
		return serverVersion >= 50606

	case 80:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterUser_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 81:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AlterUserTail_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 82:
		return serverVersion < 80014

	case 83:
		return serverVersion >= 80014

	case 84:
		return serverVersion >= 50706

	case 85:
		return serverVersion >= 80014

	case 86:
		return serverVersion >= 80014

	case 87:
		return serverVersion >= 80014

	case 88:
		return serverVersion >= 80000

	case 89:
		return serverVersion >= 80018

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateUser_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 90:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateUserTail_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 91:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DefaultRoleClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 92:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) AccountLockPasswordExpireOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 93:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DropUser_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 94:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Grant_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 95:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) GrantTargetList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 96:
		return serverVersion < 80011

	case 97:
		return serverVersion >= 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) GrantOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 98:
		return serverVersion < 80011

	case 99:
		return serverVersion >= 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) VersionedRequireClause_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 100:
		return serverVersion < 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Revoke_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 101:
		return serverVersion >= 80000

	case 102:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) OnTypeTo_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 103:
		return serverVersion < 80000

	case 104:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) RoleOrPrivilege_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 105:
		return serverVersion > 80000

	case 106:
		return serverVersion > 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) GrantIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 107:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TableAdministrationStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 108:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) StartOptionValueList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 109:
		return serverVersion < 50706

	case 110:
		return serverVersion < 80014

	case 111:
		return serverVersion >= 80018

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) OptionValueNoOptionType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 112:
		return serverVersion >= 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SetExprOrDefault_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 113:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ShowStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 114:
		return serverVersion < 50700

	case 115:
		return serverVersion >= 80000

	case 116:
		return serverVersion < 50700

	case 117:
		return serverVersion >= 50704

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ShowCommandType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 118:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) NonBlocking_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 119:
		return serverVersion >= 50700 && serverVersion < 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) OtherAdministrativeStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 120:
		return serverVersion >= 50709

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) FlushOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 121:
		return serverVersion < 80000

	case 122:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) FlushTablesOptions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 123:
		return serverVersion >= 50606

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) UtilityStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 124:
		return serverVersion >= 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ExplainStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 125:
		return serverVersion < 80000

	case 126:
		return serverVersion < 80000

	case 127:
		return serverVersion >= 50605

	case 128:
		return serverVersion >= 80018

	case 129:
		return serverVersion >= 80019

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ExplainableStatement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 130:
		return serverVersion >= 50603

	case 131:
		return serverVersion >= 50700

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 132:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 133:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 134:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) BoolPri_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 135:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 136:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 137:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Predicate_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 138:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) BitExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 139:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 140:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 141:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 142:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 143:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 144:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 145:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SimpleExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 146:
		return serverVersion >= 80000

	case 147:
		return serverVersion >= 80000

	case 148:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 149:
		return p.Precpred(p.GetParserRuleContext(), 21)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ArrayCast_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 150:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) JsonOperator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 151:
		return serverVersion >= 50708

	case 152:
		return serverVersion >= 50713

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SumExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 153:
		return serverVersion >= 80000

	case 154:
		return serverVersion >= 80000

	case 155:
		return serverVersion >= 80000

	case 156:
		return serverVersion >= 80000

	case 157:
		return serverVersion >= 80000

	case 158:
		return serverVersion >= 80000

	case 159:
		return serverVersion >= 80000

	case 160:
		return serverVersion >= 80000

	case 161:
		return serverVersion >= 80000

	case 162:
		return serverVersion >= 80000

	case 163:
		return serverVersion >= 80000

	case 164:
		return serverVersion >= 80000

	case 165:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) RuntimeFunctionCall_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 166:
		return serverVersion < 50607

	case 167:
		return serverVersion < 80011

	case 168:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) GeometryFunction_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 169:
		return serverVersion < 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) FractionalPrecision_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 170:
		return serverVersion >= 50604

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) InternalVariableName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 171:
		return serverVersion < 80017

	case 172:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CastType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 173:
		return serverVersion >= 50708

	case 174:
		return serverVersion >= 80017

	case 175:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Channel_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 176:
		return serverVersion >= 50706

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) GetDiagnostics_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 177:
		return serverVersion >= 50700

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CheckOrReferences_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 178:
		return serverVersion < 80016

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TableConstraintDef_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 179:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) FieldDefinition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 180:
		return serverVersion >= 50707

	case 181:
		return serverVersion < 80000

	case 182:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ColumnAttribute_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 183:
		return serverVersion >= 80014

	case 184:
		return serverVersion >= 80013

	case 185:
		return serverVersion >= 80000

	case 186:
		return serverVersion >= 80017

	case 187:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) KeyListVariants_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 188:
		return serverVersion >= 80013

	case 189:
		return serverVersion < 80013

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CommonIndexOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 190:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) DataType_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 191:
		return serverVersion >= 50708

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CharsetName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 192:
		return serverVersion < 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CollationName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 193:
		return serverVersion < 80011

	case 194:
		return serverVersion >= 80018

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateTableOption_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 195:
		return serverVersion >= 80014

	case 196:
		return serverVersion >= 50708

	case 197:
		return serverVersion >= 50711

	case 198:
		return serverVersion >= 50707

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) PartitionKeyAlgorithm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 199:
		return serverVersion >= 50700

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) CreateUserEntry_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 200:
		return serverVersion < 80011

	case 201:
		return serverVersion >= 50706

	case 202:
		return serverVersion >= 80018

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) UsePartition_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 203:
		return serverVersion >= 50602

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) ColumnName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 204:
		return serverVersion >= 80000

	case 205:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) PureIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 206:
		return isSqlModeActive(AnsiQuotes)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) SimpleIdentifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 207:
		return serverVersion < 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) Real_ulonglong_number_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 208:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TextStringLiteral_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 209:
		return !isSqlModeActive(AnsiQuotes)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) TextStringHash_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 210:
		return serverVersion >= 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) IdentifierKeyword_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 211:
		return serverVersion < 80017

	case 212:
		return serverVersion >= 50709

	case 213:
		return serverVersion >= 80011

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) LabelKeyword_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 214:
		return serverVersion < 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) IdentifierKeywordsUnambiguous_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 215:
		return serverVersion >= 80019

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) RoleKeyword_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 216:
		return serverVersion < 80017

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) RoleOrIdentifierKeyword_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 217:
		return serverVersion >= 50709

	case 218:
		return serverVersion >= 80000

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *MySQLParser) RoleOrLabelKeyword_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 219:
		return serverVersion < 50709

	case 220:
		return serverVersion < 80000

	case 221:
		return serverVersion >= 80000

	case 222:
		return serverVersion >= 80014

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
